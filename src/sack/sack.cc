/*CMake Option defined*/
#define NO_AUTO_VECTLIB_NAMES
/*
 BLOCKINDEX BAT[BLOCKS_PER_BAT] // link of next blocks; 0 if free, FFFFFFFF if end of file block
 uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
 // (1+BLOCKS_PER_BAT) * BLOCK_SIZE total...
 BAT[0] = first directory cluster; array of struct directory_entry
 BAT[1] = name space; directory offsets land in a block referenced by this chain
 */
#define SACK_VFS_SOURCE
#if 1
/* Includes the system platform as required or appropriate. If
   under a linux system, include appropriate basic linux type
   headers, if under windows pull "windows.h".
   Includes the MOST stuff here ( a full windows.h parse is many
   many lines of code.)                                          */
/* A macro to build a wide character string of __FILE__ */
#define _WIDE__FILE__(n) WIDE(n)
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
#ifndef STANDARD_HEADERS_INCLUDED
/* multiple inclusion protection symbol */
#define STANDARD_HEADERS_INCLUDED
#include <stdlib.h>
#include <stddef.h>
#include <stdio.h>
#include <stdint.h>
#if _MSC_VER
#  ifdef EXCLUDE_SAFEINT_H
#    define _INTSAFE_H_INCLUDED_
#  endif
 //_MSC_VER
#endif
#ifndef WINVER
#  define WINVER 0x0601
#endif
#if !defined(__LINUX__)
#  ifndef STRICT
#    define STRICT
#  endif
#  define WIN32_LEAN_AND_MEAN
// #define NOGDICAPMASKS             // CC_*, LC_*, PC_*, CP_*, TC_*, RC_
// #define NOVIRTUALKEYCODES         // VK_*
// #define NOWINMESSAGES             // WM_*, EM_*, LB_*, CB_*
// #define NOWINSTYLES               // WS_*, CS_*, ES_*, LBS_*, SBS_*, CBS_*
// #define NOSYSMETRICS              // SM_*
// #define NOMENUS                   // MF_*
// #define NOICONS                   // IDI_*
// #define NOKEYSTATES               // MK_*
// #define NOSYSCOMMANDS             // SC_*
// #define NORASTEROPS               // Binary and Tertiary raster ops
// #define NOSHOWWINDOW              // SW_*
               // OEM Resource values
#  define OEMRESOURCE
// #define NOATOM                    // Atom Manager routines
#  ifndef _INCLUDE_CLIPBOARD
               // Clipboard routines
#    define NOCLIPBOARD
#  endif
// #define NOCOLOR                   // Screen colors
// #define NOCTLMGR                  // Control and Dialog routines
//(spv) #define NODRAWTEXT                // DrawText() and DT_*
// #define NOGDI                     // All GDI defines and routines
// #define NOKERNEL                  // All KERNEL defines and routines
// #define NOUSER                    // All USER defines and routines
#  ifndef _ARM_
#    ifndef _INCLUDE_NLS
                     // All NLS defines and routines
#      define NONLS
#    endif
#  endif
// #define NOMB                      // MB_* and MessageBox()
                  // GMEM_*, LMEM_*, GHND, LHND, associated routines
#  define NOMEMMGR
                // typedef METAFILEPICT
#  define NOMETAFILE
                  // Macros min(a,b) and max(a,b)
#  define NOMINMAX
// #define NOMSG                     // typedef MSG and associated routines
// #define NOOPENFILE                // OpenFile(), OemToAnsi, AnsiToOem, and OF_*
// #define NOSCROLL                  // SB_* and scrolling routines
                 // All Service Controller routines, SERVICE_ equates, etc.
#  define NOSERVICE
//#define NOSOUND                   // Sound driver routines
#  ifndef _INCLUDE_TEXTMETRIC
              // typedef TEXTMETRIC and associated routines
#    define NOTEXTMETRIC
#  endif
// #define NOWH                      // SetWindowsHook and WH_*
// #define NOWINOFFSETS              // GWL_*, GCL_*, associated routines
// #define NOCOMM                    // COMM driver routines
                   // Kanji support stuff.
#  define NOKANJI
                    // Help engine interface.
#  define NOHELP
                // Profiler interface.
#  define NOPROFILER
//#define NODEFERWINDOWPOS          // DeferWindowPos routines
                     // Modem Configuration Extensions
#  define NOMCX
   // no StrCat StrCmp StrCpy etc functions.  (used internally)
#  define NO_SHLWAPI_STRFCNS
  // This also has defines that override StrCmp StrCpy etc... but no override
#  define STRSAFE_NO_DEPRECATE
#  ifdef _MSC_VER
#    ifndef _WIN32_WINDOWS
// needed at least this for what - updatelayeredwindow?
#      define _WIN32_WINDOWS 0x0601
#    endif
#  endif
// INCLUDE WINDOWS.H
#  ifdef __WATCOMC__
#    undef _WINDOWS_
#  endif
#  ifdef UNDER_CE
// just in case windows.h also fails after undef WIN32
// these will be the correct order for primitives we require.
#    include <excpt.h>
#    include <windef.h>
#    include <winnt.h>
#    include <winbase.h>
#    include <wingdi.h>
#    include <wtypes.h>
#    include <winuser.h>
#    undef WIN32
#  endif
#  define _WINSOCKAPI_
#  include <windows.h>
#  undef _WINSOCKAPI_
#  if defined( WIN32 ) && defined( NEED_SHLOBJ )
#    include <shlobj.h>
#  endif
//#  include <windowsx.h>
// we like timeGetTime() instead of GetTickCount()
//#  include <mmsystem.h>
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllimport) DWORD WINAPI timeGetTime(void);
#  if defined( NEED_SHLAPI )
#    include <shlwapi.h>
#    include <shellapi.h>
#  endif
#  ifdef NEED_V4W
#    include <vfw.h>
#  endif
#  if defined( HAVE_ENVIRONMENT )
#    define getenv(name)       OSALOT_GetEnvironmentVariable(name)
#    define setenv(name,val)   SetEnvironmentVariable(name,val)
#  endif
#  define Relinquish()       Sleep(0)
//#pragma pragnoteonly("GetFunctionAddress is lazy and has no library cleanup - needs to be a lib func")
//#define GetFunctionAddress( lib, proc ) GetProcAddress( LoadLibrary( lib ), (proc) )
#  ifdef __cplusplus_cli
#    include <vcclr.h>
 /*lprintf( */
#    define DebugBreak() System::Console::WriteLine(gcnew System::String( WIDE__FILE__ WIDE("(") STRSYM(__LINE__) WIDE(") Would DebugBreak here...") ) );
//typedef unsigned int HANDLE;
//typedef unsigned int HMODULE;
//typedef unsigned int HWND;
//typedef unsigned int HRC;
//typedef unsigned int HMENU;
//typedef unsigned int HICON;
//typedef unsigned int HINSTANCE;
#  endif
 // ifdef unix/linux
#else
#  include <pthread.h>
#  include <sched.h>
#  include <unistd.h>
#  include <sys/time.h>
#  include <errno.h>
#  if defined( __ARM__ )
#    define DebugBreak()
#  else
/* A symbol used to cause a debugger to break at a certain
   point. Sometimes dynamicly loaded plugins can be hard to set
   the breakpoint in the debugger, so it becomes easier to
   recompile with a breakpoint in the right place.
   Example
   <code lang="c++">
   DebugBreak();
	</code>                                                      */
#    ifdef __ANDROID__
#      define DebugBreak()
#    else
#      ifdef __EMSCRIPTEN__
#        define DebugBreak()
#      else
#        define DebugBreak()  asm("int $3\n" )
#      endif
#    endif
#  endif
#  ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
extern __sighandler_t bsd_signal(int, __sighandler_t);
#  endif
// moved into timers - please linnk vs timers to get Sleep...
//#define Sleep(n) (usleep((n)*1000))
#  define Relinquish() sched_yield()
#  define GetLastError() (int32_t)errno
/* return with a THREAD_ID that is a unique, universally
   identifier for the thread for inter process communication. */
#  define GetCurrentProcessId() ((uint32_t)getpid())
#  define GetCurrentThreadId() ((uint32_t)getpid())
  // end if( !__LINUX__ )
#endif
#ifndef NEED_MIN_MAX
#  ifndef NO_MIN_MAX_MACROS
#    define NO_MIN_MAX_MACROS
#  endif
#endif
#ifndef NO_MIN_MAX_MACROS
#  ifdef __cplusplus
#    ifdef __GNUC__
#      ifndef min
#        define min(a,b) ((a)<(b))?(a):(b)
#      endif
#    endif
#  endif
/* Define a min(a,b) macro when the compiler lacks it. */
#  ifndef min
#    define min(a,b) (((a)<(b))?(a):(b))
#  endif
/* Why not add the max macro, also? */
#  ifndef max
#    define max(a,b) (((a)>(b))?(a):(b))
#  endif
#endif
/* please Include sthdrs.h */
/* Define most of the sack core types on which everything else is
   based. Also defines some of the primitive container
   structures. We also handle a lot of platform/compiler
   abstraction here.
   A reFactoring for stdint.h and uint32_t etc would be USEFUL!
   where types don't exist, define them as apprpritate types instead.
But WHO doesn't have stdint?  BTW is sizeof( size_t ) == sizeof( void* )
   This is automatically included with stdhdrs.h; however, when
   including sack_types.h, the minimal headers are pulled. */
#define HAS_STDINT
//#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
	// this has to be a compile option (option from cmake)
   // enables debug dump mem...
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#  define USE_CUSTOM_ALLOCER 1
#else
#  define USE_CUSTOM_ALLOCER 0
#endif
#ifndef __64__
#  if defined( _WIN64 ) || defined( ENVIRONMENT64 ) || defined( __x86_64__ ) || defined( __ia64 ) || defined( __ppc64__ ) || defined( __LP64__ )
#    define __64__ 1
#  endif
#endif
#ifdef _MSC_VER
#  ifndef _WIN32_WINNT
#    define _WIN32_WINNT 0x501
#  endif
#  ifndef WIN32
#    ifdef _WIN32
#      define WIN32 _WIN32
#    endif
#  endif
// force windows on __MSVC
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if !defined( __NO_THREAD_LOCAL__ ) && ( defined( _MSC_VER ) || defined( __WATCOMC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __declspec(thread)
#  define DeclareThreadVar __declspec(thread)
#elif !defined( __NO_THREAD_LOCAL__ ) && ( defined( __GNUC__ ) )
#  define HAS_TLS 1
#  define DeclareThreadLocal static __thread
#  define DeclareThreadVar __thread
#else
#  define DeclareThreadLocal static
#  define DeclareThreadVar
#endif
#ifdef __cplusplus_cli
// these things define a type called 'Byte'
	// which causes confusion... so don't include vcclr for those guys.
#  ifdef SACK_BAG_EXPORTS
// maybe only do this while building sack_bag project itself...
#    if !defined( ZCONF_H )        && !defined( __FT2_BUILD_GENERIC_H__ )        && !defined( ZUTIL_H )        && !defined( SQLITE_PRIVATE )        && !defined( NETSERVICE_SOURCE )        && !defined( LIBRARY_DEF )
//using namespace System;
#    endif
#  endif
#endif
// Defined for building visual studio monolithic build.  These symbols are not relavent with cmakelists.
#ifdef SACK_BAG_EXPORTS
#  define SACK_BAG_CORE_EXPORTS
// exports don't really matter with CLI compilation.
#  ifndef BAG
//#ifndef TARGETNAME
//#  define TARGETNAME "sack_bag.dll"  //$(TargetFileName)
//#endif
#    ifndef __cplusplus_cli
// cli mode, we use this directly, and build the exports in sack_bag.dll directly
#    else
#      define LIBRARY_DEADSTART
#    endif
#define USE_SACK_FILE_IO
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSLOG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define _TYPELIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define HTTP_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TIMER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define IDLE_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CLIENTMSG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FRACTION_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define NETWORK_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONFIGURATION_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILESYSTEM_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTEM_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define FILEMONITOR_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VECTOR_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SHA1_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define CONSTRUCT_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PROCREG_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SQLPROXY_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define TYPELIB_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define JSON_EMITTER_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SERVICE_SOURCE
#  ifndef __NO_SQL__
#    ifndef __NO_OPTIONS__
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.    and not NO_SQL and not NO_OPTIONS   */
#      define SQLGETOPTION_SOURCE
#    endif
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define PSI_SOURCE
#  ifdef _MSC_VER
#    ifndef JPEG_SOURCE
//wouldn't matter... the external things wouldn't need to define this
//#error projects were not generated with CMAKE, and JPEG_SORUCE needs to be defined
#    endif
//#define JPEG_SOURCE
//#define __PNG_LIBRARY_SOURCE__
//#define FT2_BUILD_LIBRARY   // freetype is internal
//#define FREETYPE_SOURCE		// build Dll Export
#  endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define MNG_BUILD_DLL
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define BAGIMAGE_EXPORTS
/* Defined when SACK_BAG_EXPORTS is defined. This was an
 individual library module once upon a time.           */
#ifndef IMAGE_LIBRARY_SOURCE
#  define IMAGE_LIBRARY_SOURCE
#endif
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SYSTRAY_LIBRARAY
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define SOURCE_PSI2
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
#define VIDEO_LIBRARY_SOURCE
/* Defined when SACK_BAG_EXPORTS is defined. This was an
   individual library module once upon a time.           */
	/* define RENDER SOURCE when building monolithic. */
#     ifndef RENDER_LIBRARY_SOURCE
#       define RENDER_LIBRARY_SOURCE
#     endif
// define a type that is a public name struct type...
// good thing that typedef and struct were split
// during the process of port to /clr option.
//#define PUBLIC_TYPE public
#  else
//#define PUBLIC_TYPE
#    ifdef __cplusplus_CLR
//using namespace System;
#    endif
#  endif
#endif
 // wchar for X_16 definition
#include <wchar.h>
#include <sys/types.h>
#include <sys/stat.h>
#ifndef MY_TYPES_INCLUDED
#define MY_TYPES_INCLUDED
// include this before anything else
// thereby allowing us to redefine exit()
 // CHAR_BIT
#include <limits.h>
 // typelib requires this
#include <stdarg.h>
#ifdef _MSC_VER
#ifndef UNDER_CE
 // memlib requires this, and it MUST be included befoer string.h if it is used.
#include <intrin.h>
#endif
#endif
 // typelib requires this
#include <string.h>
#if !defined( WIN32 ) && !defined( _WIN32 ) && !defined( _PNACL )
#include <dlfcn.h>
#endif
#if defined( _MSC_VER )
// disable pointer conversion warnings - wish I could disable this
// according to types...
//#pragma warning( disable:4312; disable:4311 )
// disable deprication warnings of snprintf, et al.
//#pragma warning( disable:4996 )
#define EMPTY_STRUCT struct { char nothing[]; }
#endif
#if defined( __WATCOMC__ )
#define EMPTY_STRUCT char
#endif
#ifdef __cplusplus
/* Could also consider defining 'SACK_NAMESPACE' as 'extern "C"
   ' {' and '..._END' as '}'                                    */
#define SACK_NAMESPACE namespace sack {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define SACK_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE namespace containers {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE namespace list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE namespace data_list {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE namespace sets {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE_END }
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE namespace text {
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE_END  } _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
#else
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define SACK_NAMESPACE
/* Define the sack namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define SACK_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _CONTAINER_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _LINKLIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _DATALIST_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _SETS_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define _TEXT_NAMESPACE_END
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE
/* Define the container namespace (when building with C++, the
   wrappers are namespace{} instead of extern"c"{} )           */
#define TEXT_NAMESPACE_END
#endif
/* declare composite SACK_CONTAINER namespace to declare sack::container in a single line */
#define SACK_CONTAINER_NAMESPACE SACK_NAMESPACE _CONTAINER_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container in a single line */
#define SACK_CONTAINER_NAMESPACE_END _CONTAINER_NAMESPACE_END SACK_NAMESPACE_END
/* declare composite SACK_CONTAINER namespace to declare sack::container::list in a single line */
#define SACK_CONTAINER_LINKLIST_NAMESPACE SACK_CONTAINER_NAMESPACE _LISTLIST_NAMESPACE
/* declare composite SACK_CONTAINER namespace to close sack::container::list in a single line */
#define SACK_CONTAINER_LINKLIST_NAMESPACE_END _LISTLIST_NAMESPACE_END SACK_CONTAINER_NAMESPACE
// this symbols is defined to enforce
// the C Procedure standard - using a stack, and resulting
// in EDX:EAX etc...
#define CPROC
#ifdef SACK_BAG_EXPORTS
# ifdef BUILD_GLUE
// this is used as the export method appropriate for C#?
#  define EXPORT_METHOD [DllImport(LibName)] public
# else
#  ifdef __cplusplus_cli
#   if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#     define EXPORT_METHOD
#     define IMPORT_METHOD extern
#   else
#     define EXPORT_METHOD __declspec(dllexport)
#     define IMPORT_METHOD __declspec(dllimport)
#   endif
#   define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#   define LITERAL_LIB_IMPORT_METHOD extern
//__declspec(dllimport)
#  else
#   if defined( __STATIC__ ) || defined( __LINUX__ ) || defined( __ANDROID__ )
#      define EXPORT_METHOD
#      define IMPORT_METHOD extern
#    else
/* Method to declare functions exported from a DLL. (nothign on
   LINUX or building statically, but __declspec(dllimport) on
   windows )                                                    */
#      define EXPORT_METHOD __declspec(dllexport)
/* method to define a function which will be Imported from a
   library. Under windows, this is probably
   __declspec(dllimport). Under linux this is probably 'extern'. */
#      define IMPORT_METHOD __declspec(dllimport)
#    endif
#      define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#      define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  endif
# endif
#else
# if ( !defined( __STATIC__ ) && defined( WIN32 ) && !defined( __cplusplus_cli) )
#  define EXPORT_METHOD __declspec(dllexport)
#  define IMPORT_METHOD __declspec(dllimport)
#  define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
#  define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
# else
// MRT:  This is needed.  Need to see what may be defined wrong and fix it.
#  if defined( __LINUX__ ) || defined( __STATIC__ )
#    define EXPORT_METHOD
#    define IMPORT_METHOD extern
#    define LITERAL_LIB_EXPORT_METHOD
#    define LITERAL_LIB_IMPORT_METHOD extern
#  else
#    define EXPORT_METHOD __declspec(dllexport)
#    define IMPORT_METHOD __declspec(dllimport)
/* Define how methods in LITERAL_LIBRARIES are exported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#    define LITERAL_LIB_EXPORT_METHOD __declspec(dllexport)
/* Define how methods in LITERAL_LIBRARIES are imported.
   literal_libraries are libraries that are used for plugins,
   and are dynamically loaded by code. They break the rules of
   system prefix and suffix extensions. LITERAL_LIBRARIES are
   always dynamic, and never static.                           */
#    define LITERAL_LIB_IMPORT_METHOD __declspec(dllimport)
#  endif
# endif
#endif
// used when the keword specifying a structure is packed
// needs to prefix the struct keyword.
#define PREFIX_PACKED
// private thing left as a note, and forgotten.  some compilers did not define offsetof
#define my_offsetof( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
SACK_NAMESPACE
#ifdef BCC16
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      type _far _pascal _export name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) type _far _pascal _export name
#define PUBLIC(type,name)       type STDPROC _export name
 /* here would be if dwReason == process_attach */
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, WORD wDataSeg, WORD wHeapSize, LPSTR lpCmdLine )		 { {
 /* end if */
 /*endproc*/
#define LIBEXIT() } }	    int STDPROC WEP(int nSystemExit )  {
#define LIBMAIN_END()  }
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _far _pascal
#endif
#if defined( __LCC__ ) || defined( _MSC_VER ) || defined(__DMC__) || defined( __WATCOMC__ )
#ifdef __WATCOMC__
#undef CPROC
#define CPROC __cdecl
#define STDPROC __cdecl
#ifndef __WATCOMC__
// watcom windef.h headers define this
#define STDCALL _stdcall
#endif
#if __WATCOMC__ >= 1280
// watcom windef.h headers no longer define this.
#define STDCALL __stdcall
#endif
#undef PREFIX_PACKED
#define PREFIX_PACKED _Packed
#else
#undef CPROC
//#error blah
#define CPROC __cdecl
#define STDPROC
#define STDCALL _stdcall
#endif
#define far
#define huge
#define near
#define _far
#define _huge
#define _near
/* portability type for porting legacy 16 bit applications. */
/* portability macro for legacy 16 bit applications. */
#define __far
#ifndef FAR
#define FAR
#endif
//#define HUGE
//#ifndef NEAR
//#define NEAR
//#endif
#define _fastcall
#ifdef __cplusplus
#ifdef __cplusplus_cli
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#else
//#error what the hell!?
// okay Public functions are meant to be loaded with LoadFuncion( "library" , "function name"  );
#define PUBLIC(type,name) extern "C"  LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#else
#define PUBLIC(type,name) LITERAL_LIB_EXPORT_METHOD type CPROC name
#endif
#define MAINPROC(type,name)  type WINAPI name
#define WINPROC(type,name)   type WINAPI name
#define CALLBACKPROC(type,name) type CALLBACK name
#if defined( __WATCOMC__ )
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(_WIDE(TARGETNAME)) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#else
#ifdef TARGETNAME
#define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(_WIDE(TARGETNAME)) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#else
#define LIBMAIN()   TARGETNAME_NOT_DEFINED
#endif
#define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#define LIBMAIN_END() }
#endif
#define PACKED
#endif
#if defined( __GNUC__ )
#  ifndef STDPROC
#    define STDPROC
#  endif
#  ifndef STDCALL
 // for IsBadCodePtr which isn't a linux function...
#    define STDCALL
#  endif
#  ifndef WINAPI
#    ifdef __LINUX__
#       define WINAPI
#    else
#       define WINAPI __stdcall
#    endif
#  endif
#  ifndef PASCAL
//#define PASCAL
#  endif
#  define WINPROC(type,name)   type WINAPI name
#  define CALLBACKPROC( type, name ) type name
#  define PUBLIC(type,name) EXPORT_METHOD type CPROC name
#  define LIBMAIN()   static int __LibMain( HINSTANCE ); PRELOAD( LibraryInitializer ) {	 __LibMain( GetModuleHandle(TARGETNAME) );   }	 static int __LibMain( HINSTANCE hInstance ) {
#  define LIBEXIT() } static int LibExit( void ); ATEXIT( LiraryUninitializer ) { LibExit(); } int LibExit(void) {
#  define LIBMAIN_END()  }
/* Portability Macro for porting legacy code forward. */
#  define FAR
#  define NEAR
//#define HUGE
#  define far
#  define near
#  define huge
#  define PACKED __attribute__((packed))
#endif
#if defined( BCC32 )
#define far
#define huge
/* define obsolete keyword for porting purposes */
/* defined for porting from 16 bit environments */
#define near
/* portability macro for legacy 16 bit applications. */
#define _far
#define _huge
#define _near
/* portability type for porting to compilers that don't inline. */
/* portability macro for legacy 16 bit applications. */
#define __inline__
#define MAINPROC(type,name)     type _pascal name
// winproc is intended for use at libmain/wep/winmain...
#define WINPROC(type,name)      EXPORT_METHOD type _pascal name
// callbackproc is for things like timers, dlgprocs, wndprocs...
#define CALLBACKPROC(type,name) EXPORT_METHOD type _stdcall name
#define STDCALL _stdcall
#define PUBLIC(type,name)        type STDPROC name
#ifdef __STATIC__
			/*Log( WIDE("Library Enter" ) );*/
#define LIBMAIN() static WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#else
			/*Log( WIDE("Library Enter" ) );*/
#define LIBMAIN() WINPROC(int, LibMain)(HINSTANCE hInstance, DWORD dwReason, void *unused )		 { if( dwReason == DLL_PROCESS_ATTACH ) {
 /* end if */
#define LIBEXIT() } if( dwReason == DLL_PROCESS_DETACH ) {
#define LIBMAIN_END()  } return 1; }
#endif
// should use this define for all local defines...
// this will allow one place to modify ALL _pascal or not to _pascal decls.
#define STDPROC _pascal
#define PACKED
#endif
#define TOCHR(n) #n[0]
#define TOSTR(n) WIDE(#n)
#define STRSYM(n) TOSTR(n)
#define _WIDE__FILE__(n) WIDE(n)
#define WIDE__FILE__ _WIDE__FILE__(__FILE__)
/* a constant text string that represents the current source
   filename and line... fourmated as "source.c(11) :"        */
#define FILELINE  TEXT(__FILE__) WIDE("(" ) TEXT(STRSYM(__LINE__))WIDE(" : " ))
#if defined( _MSC_VER ) || defined( __PPCCPP__ )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) message( FILELINE msg )
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) message( msg )
#else
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnote(msg) msg
/* try and define a way to emit comipler messages... but like no compilers support standard ways to do this accross the board.*/
#define pragnoteonly(msg) msg
#endif
/* specify a consistant macro to pass current file and line information.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_SRC         , (CTEXTSTR)_WIDE(__FILE__), __LINE__
/* specify a consistant macro to pass current file and line information, to functions which void param lists.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDSRC     (CTEXTSTR)_WIDE(__FILE__), __LINE__
//#define FILELINE_LEADSRC     (CTEXTSTR)_WIDE(__FILE__), __LINE__,
/* specify a consistant macro to define file and line parameters, to functions with otherwise void param lists.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDPASS    CTEXTSTR pFile, uint32_t nLine
//#define FILELINE_LEADPASS    CTEXTSTR pFile, uint32_t nLine,
/* specify a consistant macro to define file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_PASS        , CTEXTSTR pFile, uint32_t nLine
/* specify a consistant macro to forward file and line parameters.   This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_RELAY       , pFile, nLine
/* specify a consistant macro to forward file and line parameters, to functions which have void parameter lists without this information.  This are appended parameters, and common usage is to only use these with _DEBUG set. */
#define FILELINE_VOIDRELAY   pFile, nLine
/* specify a consistant macro to format file and line information for printf formated strings. */
#define FILELINE_FILELINEFMT WIDE("%s(%") _32f WIDE("): ")
#define FILELINE_FILELINEFMT_MIN WIDE("%s(%") _32f WIDE(")")
#define FILELINE_NULL        , NULL, 0
#define FILELINE_VOIDNULL    NULL, 0
/* define static parameters which are the declaration's current file and line, for stubbing in where debugging is being stripped.
  usage
    FILELINE_VARSRC: // declare pFile and nLine variables.
	*/
#define FILELINE_VARSRC       CTEXTSTR pFile = _WIDE(__FILE__); uint32_t nLine = __LINE__
// this is for passing FILE, LINE information to allocate
// useful during DEBUG phases only...
// drop out these debug relay paramters for managed code...
// we're going to have the full call frame managed and known...
#if !defined( _DEBUG ) && !defined( _DEBUG_INFO )
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to be ignored."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to be ignored"  )
#  endif
#define DBG_AVAILABLE   0
/* in NDEBUG mode, pass nothing */
#define DBG_SRC
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDSRC
/* <combine sack::DBG_PASS>
   \#define DBG_LEADSRC in NDEBUG mode, declare (void) */
/* <combine sack::DBG_PASS>
   \ \                      */
#define DBG_VOIDPASS    void
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_PASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_RELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_VOIDRELAY
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
#define DBG_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing
   Example
   printf( DBG_FILELINEFMT ": extra message" DBG_PASS ); */
#define DBG_VARSRC
#else
	// these DBG_ formats are commented out from duplication in sharemem.h
#  if defined( __LINUX__ ) && !defined( __PPCCPP__ )
//#warning "Setting DBG_PASS and DBG_FORWARD to work."
#  else
//#pragma pragnoteonly("Setting DBG_PASS and DBG_FORWARD to work"  )
#  endif
// used to specify whether debug information is being passed - can be referenced in compiled code
#define DBG_AVAILABLE   1
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_SRC */
#define DBG_SRC         FILELINE_SRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDSRC */
#define DBG_VOIDSRC     FILELINE_VOIDSRC
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDPASS */
#define DBG_VOIDPASS    FILELINE_VOIDPASS
/* <combine sack::DBG_PASS>
   in NDEBUG mode, pass nothing */
/* Example
   This example shows forwarding debug information through a
   chain of routines.
   <code lang="c++">
   void ReportFunction( int sum DBG_PASS )
   {
       printf( "%s(%d):started this whole mess\\n" DBG_RELAY );
   }
   void TrackingFunction( int a, int b DBG_PASS )
   {
       ReportFunction( a+b, DBG_RELAY );
   }
   void CallTrack( void )
   {
       TrackingFunction( 1, 2 DBG_SRC );
   }
   </code>
   In this example, the debug information is passed to the
   logging system. This allows logging to blame the user
   application for allocations, releases, locks, etc...
   <code lang="c++">
   void MyAlloc( int size DBG_PASS )
   {
       _lprintf( DBG_RELAY )( ": alloc %d\\n", size );
   }
   void g( void )
   {
       lprintf( "Will Allocate %d\\n", 32 );
       MyAlloc( 32 DBG_SRC );
   }
   </code>
   This example uses the void argument macros
   <code>
   void SimpleFunction( DBG_VOIDPASS )
   {
       // this function usually has (void) parameters.
   }
   void f( void )
   {
       SimpleFunction( DBG_VOIDSRC );
   }
   </code>
   Description
   in NDEBUG mode, pass nothing.
   This function allows specification of DBG_RELAY or DBG_SRC
   under debug compilation. Otherwise, the simple AddLink macro
   should be used. DBG_RELAY can be used to forward file and
   line information which has been passed via DBG_PASS
   declaration in the function parameters.
   This is a part of a set of macros which allow additional
   logging information to be passed.
   These 3 are the most commonly used.
   DBG_SRC - this passes the current __FILE__, __LINE__
   \parameters.
   DBG_PASS - this is used on a function declaration, is a
   filename and line number from DBG_SRC or DBG_RELAY.
   DBG_RELAY - this passes the file and line passed to this
   function to another function with DBG_PASS defined on it.
   DBG_VOIDPASS - used when the argument list is ( void )
   without debugging information.
   DBG_VOIDSRC - used to call a function who's argument list is
   ( void ) without debugging information.
   DBG_VOIDRELAY - pass file and line information forward to
   another function, who's argument list is ( void ) without
   debugging information.
   Remarks
   The SACK library is highly instrumented with this sort of
   information. Very commonly the only difference between a
   specific function called 'MyFunctionName' and
   'MyFunctionNameEx' is the addition of debug information
   tracking.
   The following code blocks show the evolution added to add
   instrumentation...
   <code lang="c++">
   int MyFunction( int param )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       return MyFunction();
   }
   </code>
   Pretty simple code, a function that takes a parameter, and a
   function that calls it.
   The first thing is to extend the called function.
   <code>
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   </code>
   And provide a macro for everyone else calling the function to
   automatically pass their file and line information
   <code lang="c++">
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   </code>
   Then all-together
   <code>
   \#define MyFunction(param)  MyFunctionEx(param DBG_SRC)
   int MyFunctionEx( int param DBG_PASS )
   {
       // do stuff
   }
   int CallingFunction( void )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 3 );
   }
   </code>
   But then... what if CallingFunction decided wasn't really the
   one at fault, or responsible for the allocation, or other
   issue being tracked, then she could be extended....
   <code>
   int CallingFunctionEx( DBG_VOIDPASS )
   \#define CallingFunction() CallingFunction( DBG_VOIDSRC )
   {
       // and this person calling doesn't matter
       // does require a recompile of source.
       return MyFunction( 1 DBG_RELAY );
   }
   </code>
   Now, calling function will pass it's callers information to
   MyFunction....
   Why?
   Now, when you call CreateList, your code callng the list
   creation method is marked as the one who allocates the space.
   Or on a DeleteList, rather than some internal library code
   being blamed, the actual culprit can be tracked and
   identified, because it's surely not the fault of CreateList
   that the reference to the memory for the list wasn't managed
   correctly.
   Note
   It is important to note, every usage of these macros does not
   have a ',' before them. This allows non-debug code to
   eliminate these extra parameters cleanly. If the ',' was
   outside of the macro, then it would remain on the line, and
   an extra parameter would have be be passed that was unused.
   This is also why DBG_VOIDPASS exists, because in release mode
   this is substituted with 'void'.
   In Release mode, DBG_VOIDRELAY becomes nothing, but when in
   debug mode, DBG_RELAY has a ',' in the macro, so without a
   paramter f( DBG_RELAY ) would fail; on expansion this would
   be f( , pFile, nLine ); (note the extra comma, with no
   parameter would be a syntax error.                            */
#define DBG_PASS        FILELINE_PASS
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_RELAY */
#define DBG_RELAY       FILELINE_RELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VOIDRELAY */
#define DBG_VOIDRELAY   FILELINE_VOIDRELAY
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT */
#define DBG_FILELINEFMT FILELINE_FILELINEFMT
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_FILELINEFMT_MIN */
#define DBG_FILELINEFMT_MIN FILELINE_FILELINEFMT_MIN
/* <combine sack::DBG_PASS>
   in _DEBUG mode, pass FILELINE_VARSRC */
#define DBG_VARSRC      FILELINE_VARSRC
#endif
// cannot declare _0 since that overloads the
// vector library definition for origin (0,0,0,0,...)
//typedef void             _0; // totally unusable to declare 0 size things.
/* the only type other than when used in a function declaration that void is valid is as a pointer to void. no _0 type exists (it does, but it's in vectlib, and is an origin vector)*/
typedef void             *P_0;
/*
 * several compilers are rather picky about the types of data
 * used for bit field declaration, therefore this type
 * should be used instead of uint32_t (DWORD)
 */
typedef unsigned int  BIT_FIELD;
// have to do this on a per structure basis - otherwise
// any included headers with structures to use will get FUCKED
#ifndef PACKED
#define PACKED
#endif
/* An pointer to a volatile unsigned integer type that is 64 bits long. */
//typedef volatile uint64_t  *volatile int64_t*;
/* An pointer to a volatile pointer size type that is as long as a pointer. */
typedef volatile uintptr_t        *PVPTRSZVAL;
/* an unsigned type meant to index arrays.  (By convention, arrays are not indexed negatively.)  An index which is not valid is INVALID_INDEX, which equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
typedef size_t         INDEX;
/* An index which is not valid; equates to 0xFFFFFFFFUL or negative one cast as an INDEX... ((INDEX)-1). */
#define INVALID_INDEX ((INDEX)-1)
#ifdef __CYGWIN__
typedef unsigned short wchar_t;
#endif
// may consider changing this to uint16_t* for unicode...
typedef wchar_t X_16;
/* This is a pointer to wchar_t. A 16 bit value that is
   character data, and is not signed or unsigned.       */
typedef wchar_t *PX_16;
#if defined( UNICODE ) || defined( SACK_COM_OBJECT )
//should also consider revisiting code that was updated for TEXTCHAR to char conversion methods...
#  ifdef _MSC_VER
#    ifdef UNDER_CE
#      define NULTERM
#    else
#      define NULTERM __nullterminated
#    endif
#  else
#    define NULTERM
#  endif
#define WIDE(s)  L##s
#define _WIDE(s)  WIDE(s)
#define cWIDE(s)  s
#define _cWIDE(s)  cWIDE(s)
 // constant text string content
typedef NULTERM          const X_16      *CTEXTSTR;
 // pointer to constant text string content
typedef NULTERM          CTEXTSTR        *PCTEXTSTR;
typedef NULTERM          X_16            *TEXTSTR;
/* a text 16 bit character  */
typedef X_16             TEXTCHAR;
#else
#define WIDE(s)   s
#define _WIDE(s)  s
#define cWIDE(s)   s
/* Modified WIDE wrapper that actually forces non-unicode
   string.                                                */
#define _cWIDE(s)  s
// constant text string content
typedef const char     *CTEXTSTR;
/* A non constant array of TEXTCHAR. A pointer to TEXTCHAR. A
   pointer to non-constant characters. (A non-static string
   probably)                                                  */
typedef char           *TEXTSTR;
#if defined( __LINUX__ ) && defined( __cplusplus )
// pointer to constant text string content
typedef TEXTSTR const  *PCTEXTSTR;
#else
// char const *const *
typedef CTEXTSTR const *PCTEXTSTR;
#endif
/* a text 8 bit character  */
typedef char            TEXTCHAR;
#endif
/* a character rune.  Strings should be interpreted as UTF-8 or 16 depending on UNICODE compile option.
   GetUtfChar() from strings.  */
typedef uint32_t             TEXTRUNE;
/* Used to handle returned values that are invalid runes; past end or beginning of string for instance */
#define INVALID_RUNE  0x80000000
//typedef enum { FALSE, TRUE } LOGICAL; // smallest information
#ifndef FALSE
#define FALSE 0
/* Define TRUE when not previously defined in the platform. TRUE
   is (!FALSE) so anything not 0 is true.                        */
#define TRUE (!FALSE)
#endif
/* Meant to hold boolean and only boolean values. Should be
   implemented per-platform as appropriate for the bool type the
   compiler provides.                                            */
typedef uint32_t LOGICAL;
/* This is a pointer. It is a void*. It is meant to point to a
   single thing, and cannot be used to reference arrays of bytes
   without recasting.                                            */
typedef P_0 POINTER;
/* This is a pointer to constant data. void const *. Compatible
   with things like char const *.                               */
typedef const void *CPOINTER;
SACK_NAMESPACE_END
//------------------------------------------------------
// formatting macro defintions for [vsf]printf output of the above types
#if !defined( _MSC_VER ) || ( _MSC_VER >= 1900 )
#define __STDC_FORMAT_MACROS
#include <inttypes.h>
#endif
SACK_NAMESPACE
/* 16 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16f   WIDE("u" )
/* 16 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fx   WIDE("x" )
/* 16 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _16fX   WIDE("X" )
/* 16 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _16fs   WIDE("d" )
/* 8 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8f   WIDE("u" )
/* 8 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fx   WIDE("x" )
/* 8 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\>                */
#define _8fX   WIDE("X" )
/* 8 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\>               */
#define _8fs   WIDE("d" )
#if defined( __STDC_FORMAT_MACROS )
#  define _32f   _WIDE( PRIu32 )
#  define _32fx   _WIDE( PRIx32 )
#  define _32fX   _WIDE( PRIX32 )
#  define _32fs   _WIDE( PRId32 )
#  define _64f    _WIDE(PRIu64)
#  define _64fx   _WIDE(PRIx64)
#  define _64fX   _WIDE(PRIX64)
#  define _64fs   _WIDE(PRId64)
#  define _64f    _WIDE(PRIu64)
#  define _64fx   _WIDE(PRIx64)
#  define _64fX   _WIDE(PRIX64)
#  define _64fs   _WIDE(PRId64)
// non-unicode strings
#  define c_32f    PRIu32
#  define c_32fx   PRIx32
#  define c_32fX   PRIX32
#  define c_32fs   PRId32
#  define c_64f    PRIu64
#  define c_64fx   PRIx64
#  define c_64fX   PRIX64
#  define c_64fs   PRId64
#else
#  define _32f   WIDE("u" )
#  define _32fx   WIDE("x" )
#  define _32fX   WIDE("X" )
#  define _32fs   WIDE("d" )
#  define c_32f   "u"
#  define c_32fx  "x"
#  define c_32fX  "X"
#  define c_32fs  "d"
#  define c_64f    "llu"
#  define c_64fx   "llx"
#  define c_64fX   "llX"
#  define c_64fs   "lld"
#endif
#if defined( UNICODE )
#  define _cstring_f WIDE("s")
#  define _string_f WIDE("S")
#  define _ustring_f WIDE("S")
#else
#  define _cstring_f WIDE("s")
#  define _string_f WIDE("s")
#  define _ustring_f WIDE("S")
#endif
#if defined( __64__ )
#  if defined( __STDC_FORMAT_MACROS )
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _WIDE( PRIu64 )
#      define _size_fx   _WIDE( PRIx64 )
#      define _size_fX   _WIDE( PRIX64 )
#      define _size_fs   _WIDE( PRId64 )
#      define c_size_f    PRIu64
#      define c_size_fx   PRIx64
#      define c_size_fX   PRIX64
#      define c_size_fs   PRId64
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _64f
#      define _size_fx   _64fx
#      define _size_fX   _64fX
#      define _size_fs   _64fs
#      define c_size_f   c_64f
#      define c_size_fx  c_64fx
#      define c_size_fX  c_64fX
#      define c_size_fs  c_64fs
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#else
#  if defined( __STDC_FORMAT_MACROS )
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _WIDE( PRIu32 )
#      define _size_fx   _WIDE( PRIx32 )
#      define _size_fX   _WIDE( PRIX32 )
#      define _size_fs   _WIDE( PRId32 )
#      define c_size_f    PRIu32
#      define c_size_fx   PRIx32
#      define c_size_fX   PRIX32
#      define c_size_fs   PRId32
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  else
      // this HAS been fixed in UCRT - 2015!  but it'll take 5 years before everyone has that...
#    if !defined( __GNUC__ ) || defined( _WIN32 )
#      define _size_f    _32f
#      define _size_fx   _32fx
#      define _size_fX   _32fX
#      define _size_fs   _32fs
#      define c_size_f    c_32f
#      define c_size_fx   c_32fx
#      define c_size_fX   c_32fX
#      define c_size_fs   c_32fs
#    else
#      define _size_f    WIDE( "zu" )
#      define _size_fx   WIDE( "zx" )
#      define _size_fX   WIDE( "zX" )
#      define _size_fs   WIDE( "zd" )
#      define c_size_f    "zu"
#      define c_size_fx   "zx"
#      define c_size_fX   "zX"
#      define c_size_fs   "zd"
#    endif
#    define _PTRSZVALfs _WIDE( PRIuPTR )
#    define _PTRSZVALfx _WIDE( PRIxPTR )
#    define cPTRSZVALfs PRIuPTR
#    define cPTRSZVALfx PRIxPTR
#  endif
#endif
#define PTRSZVALf WIDE("p" )
#define _PTRSZVALf WIDE("p" )
#if defined( _MSC_VER ) && ( _MSC_VER < 1900 )
/* 64 bit unsigned decimal output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIu64              */
#define _64f    WIDE("llu")
/* 64 bit hex output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fx   WIDE("llx")
/* 64 bit HEX output printf format specifier. This would
   otherwise be defined in \<inttypes.h\> as PRIxFAST64                */
#define _64fX   WIDE("llX")
/* 64 bit signed decimal output printf format specifier. This
   would otherwise be defined in \<inttypes.h\> as PRIdFAST64               */
#define _64fs   WIDE("lld")
#endif
// This should be for several years a
// sufficiently large type to represent
// threads and processes.
typedef uint64_t THREAD_ID;
#define GetMyThreadIDNL GetMyThreadID
#if defined( _WIN32 ) || defined( __CYGWIN__ )
#define _GetMyThreadID()  ( (( ((uint64_t)GetCurrentProcessId()) << 32 ) | ( (uint64_t)GetCurrentThreadId() ) ) )
#define GetMyThreadID()  (GetThisThreadID())
#else
// this is now always the case
// it's a safer solution anyhow...
#ifndef GETPID_RETURNS_PPID
#define GETPID_RETURNS_PPID
#endif
#ifdef GETPID_RETURNS_PPID
#ifdef __ANDROID__
#define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(gettid()) ) )
#else
#define GetMyThreadID()  (( ((uint64_t)getpid()) << 32 ) | ( (uint64_t)(pthread_self()) ) )
#endif
#else
#define GetMyThreadID()  (( ((uint64_t)getppid()) << 32 ) | ( (uint64_t)(getpid()|0x40000000)) )
#endif
#define _GetMyThreadID GetMyThreadID
#endif
//#error blah
// general macros for linking lists using
#define DeclareLink( type )  type *next;type **me
#define RelinkThing( root, node )	   ((( node->me && ( (*node->me)=node->next ) )?	  node->next->me = node->me:0),(node->next = NULL),(node->me = NULL),node),	 ((( node->next = root )?	        (root->me = &node->next):0),	  (node->me = &root),	             (root = node) )
/* Link a new node into the list.
   Example
   struct mynode
   {
   DeclareLink( struct mynode );
   } *node;
   struct mynode *list;
   LinkThing( list_root, node );  */
#define LinkThing( root, node )		     ((( (node)->next = (root) )?	        (((root)->me) = &((node)->next)):0),	  (((node)->me) = &(root)),	             ((root) = (node)) )
/* Link a node to the end of a list. Link thing inserts the new
   node as the new head of the list.                            */
#define LinkLast( root, type, node ) if( node ) do { if( !root )	 { root = node; (node)->me=&root; }	 else { type tmp;	 for( tmp = root; tmp->next; tmp = tmp->next );	 tmp->next = (node);	 (node)->me = &tmp->next;	 } } while (0)
// put 'Thing' after 'node'
#define LinkThingAfter( node, thing )	 ( ( (thing)&&(node))	   ?(((((thing)->next = (node)->next))?((node)->next->me = &(thing)->next):0)	  ,((thing)->me = &(node)->next), ((node)->next = thing))	  :((node)=(thing)) )
//
// put 'Thing' before 'node'... so (*node->me) = thing
#define LinkThingBefore( node, thing )	 {  thing->next = (*node->me);	(*node->me) = thing;    thing->me = node->me;       node->me = &thing->next;     }
/* Remove a node from a list. Requires only the node. */
#define UnlinkThing( node )	                      ((( (node) && (node)->me && ( (*(node)->me)=(node)->next ) )?	  (node)->next->me = (node)->me:0),((node)->next = NULL),((node)->me = NULL),(node))
// this has two expressions duplicated...
// but in being so safe in this expression,
// the self-circular link needs to be duplicated.
// GrabThing is used for nodes which are circularly bound
#define GrabThing( node )	    ((node)?(((node)->me)?(((*(node)->me)=(node)->next)?	 ((node)->next->me=(node)->me),((node)->me=&(node)->next):NULL):((node)->me=&(node)->next)):NULL)
/* Go to the next node with links declared by DeclareLink */
#define NextLink(node) ((node)?(node)->next:NULL)
// everything else is called a thing... should probably migrate to using this...
#define NextThing(node) ((node)?(node)->next:NULL)
//#ifndef FALSE
//#define FALSE 0
//#endif
//#ifndef TRUE
//#define TRUE (!FALSE)
//#endif
/* the default type to use for flag sets - flag sets are arrays of bits which can be toggled on and off by an index. */
#define FLAGSETTYPE uint32_t
/* the number of bits a specific type is.
   Example
   int bit_size_int = FLAGTYPEBITS( int ); */
#define FLAGTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* how many bits to add to make sure we round to the next greater index if even 1 bit overflows */
#define FLAGROUND(t) (FLAGTYPEBITS(t)-1)
/* the index of the FLAGSETTYPE which contains the bit in question */
#define FLAGTYPE_INDEX(t,n)  (((n)+FLAGROUND(t))/FLAGTYPEBITS(t))
/* how big the flag set is in count of FLAGSETTYPEs required in a row ( size of the array of FLAGSETTYPE that contains n bits) */
#define FLAGSETSIZE(t,n) (FLAGTYPE_INDEX(t,n) * sizeof( FLAGSETTYPE ) )
// declare a set of flags...
#define FLAGSET(v,n)   FLAGSETTYPE (v)[((n)+FLAGROUND(FLAGSETTYPE))/FLAGTYPEBITS(FLAGSETTYPE)]
// set a single flag index
#define SETFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] |= 1 << ( (n) & FLAGROUND((v)[0]) ))
// clear a single flag index
#define RESETFLAG(v,n) ( (v)[(n)/FLAGTYPEBITS((v)[0])] &= ~( 1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// test if a flags is set
#define TESTFLAG(v,n)  ( (v)[(n)/FLAGTYPEBITS((v)[0])] & ( 1 << ( (n) & FLAGROUND((v)[0]) ) ) )
// reverse a flag from 1 to 0 and vice versa
#define TOGGLEFLAG(v,n)   ( (v)[(n)/FLAGTYPEBITS((v)[0])] ^= 1 << ( (n) & FLAGROUND((v)[0]) ))
// 32 bits max for range on mask
#define MASK_MAX_LENGTH 32
// gives a 32 bit mask possible from flagset..
#define MASKSET_READTYPE uint32_t
// gives byte index...
#define MASKSETTYPE uint8_t
/* how many bits the type specified can hold
   Parameters
   t :  data type to measure (int, uint32_t, ... ) */
#define MASKTYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* the maximum number of bits storable in a type */
#define MASK_MAX_TYPEBITS(t) (sizeof(t)*CHAR_BIT)
/* round up to the next count of types that fits 1 bit - used as a cieling round factor */
#define MASKROUND(t) (MASKTYPEBITS(t)-1)
/* define MAX_MAX_ROUND factor based on MASKSET_READTYPE - how to read it... */
#define MASK_MAX_ROUND() (MASK_MAX_TYPEBITS(MASKSET_READTYPE)-1)
/* byte index of the start of the mask
   Parameters
   t :  type to measure with
   n :  mask index                     */
#define MASKTYPE_INDEX(t,n)  (((n)+MASKROUND(t))/MASKTYPEBITS(t))
/* The number of bytes the set would be.
   Parameters
   t :  the given type to measure with
   n :  the count of masks to fit.       */
#define MASKSETSIZE(t,n) (MASKTYPE_INDEX(t,(n+1)))
// declare a set of flags...
#define MASK_TOP_MASK_VAL(length,val) ((val)&( (0xFFFFFFFFUL) >> (32-(length)) ))
/* the mask in the dword resulting from shift-right.   (gets a mask of X bits in length) */
#define MASK_TOP_MASK(length) ( (0xFFFFFFFFUL) >> (32-(length)) )
/* the mast in the dword shifted to the left to overlap the field in the word */
#define MASK_MASK(n,length)   (MASK_TOP_MASK(length) << (((n)*(length))&0x7) )
// masks value with the mask size, then applies that mask back to the correct word indexing
#define MASK_MASK_VAL(n,length,val)   (MASK_TOP_MASK_VAL(length,val) << (((n)*(length))&0x7) )
/* declare a mask set. */
#define MASKSET(v,n,r)  MASKSETTYPE  (v)[(((n)*(r))+MASK_MAX_ROUND())/MASKTYPEBITS(MASKSETTYPE)]; const int v##_mask_size = r;
// set a field index to a value
#define SETMASK(v,n,val)    (((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0] =    ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS(uint8_t)))[0]                                  & (~(MASK_MASK(n,v##_mask_size))) )	                                                                           | MASK_MASK_VAL(n,v##_mask_size,val) )
// get the value of a field
#define GETMASK(v,n)  ( ( ((MASKSET_READTYPE*)((v)+((n)*(v##_mask_size))/MASKTYPEBITS((v)[0])))[0]                                  & MASK_MASK(n,v##_mask_size) )	                                                                           >> (((n)*(v##_mask_size))&0x7))
/* This type stores data, it has a self-contained length in
   bytes of the data stored.  Length is in characters       */
_CONTAINER_NAMESPACE
#define DECLDATA(name,length) struct {size_t size; TEXTCHAR data[length];} name
// Hmm - this can be done with MemLib alone...
// although this library is not nessecarily part of that?
// and it's not nessecarily allocated.
typedef struct SimpleDataBlock {
   size_t size;
/* unsigned size; size is sometimes a pointer value... this
                    means bad thing when we change platforms... Defined as
                    uintptr_t now, so it's relative to the size of the platform
                    anyhow.                                                    */
#ifdef _MSC_VER
#pragma warning (disable:4200)
#endif
   uint8_t  data[
#ifndef __cplusplus
   1
#endif
 // beginning of var data - this is created size+sizeof(uint8_t)
   ];
#ifdef _MSC_VER
#pragma warning (default:4200)
#endif
} DATA, *PDATA;
/* This is a slab array of pointers, each pointer may be
   assigned to point to any user data.
   Remarks
   When the list is filled to the capacity of Cnt elements, the
   list is reallocated to be larger.
   Cannot add NULL pointer to list, empty elements in the list
   are represented with NULL, and may be filled by any non-NULL
   value.                                                       */
_LINKLIST_NAMESPACE
/* <combine sack::containers::list::LinkBlock>
   \ \                                         */
typedef struct LinkBlock
{
	/* How many pointers the list can contain now. */
	INDEX     Cnt;
	/* \ \  */
	POINTER pNode[1];
} LIST, *PLIST;
_LINKLIST_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::list;
#endif
_DATALIST_NAMESPACE
/* a list of data structures... a slab array of N members of X size */
typedef struct DataBlock  DATALIST;
/* A typedef of a pointer to a DATALIST struct DataList. */
typedef struct DataBlock *PDATALIST;
/* Data Blocks are like LinkBlocks, and store blocks of data in
   slab format. If the count of elements exceeds available, the
   structure is grown, to always contain a continuous array of
   structures of Size size.
   Remarks
   When blocks are deleted, all subsequent blocks are shifted
   down in the array. So the free blocks are always at the end. */
struct DataBlock
{
	/* How many elements are used. */
	INDEX     Cnt;
	/* How many elements are available in his array. */
	INDEX     Avail;
	/* A simple exchange lock on the data for insert and delete. For
	   thread safety.                                                */
	//volatile uint32_t     Lock;
	/* How big each element of the array is. */
	INDEX     Size;
	/* The physical array. */
	uint8_t      data[1];
};
_DATALIST_NAMESPACE_END
/* This is a stack that contains pointers to user objects.
   Remarks
   This is a stack 'by reference'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct LinkStack
{
	/* This is the index of the next pointer to be pushed or popped.
	   If top == 0, the stack is empty, until a pointer is added and
	   top is incremented.                                           */
	INDEX     Top;
	/* How many pointers the stack can contain. */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	                  thread safety.                                            */
	//volatile uint32_t     Lock;
	/*  a defined maximum capacity of stacked values... values beyond this are lost from the bottom  */
	uint32_t     Max;
	/* Reserved data portion that stores the pointers. */
	POINTER pNode[1];
} LINKSTACK, *PLINKSTACK;
/* A Stack that stores information in an array of structures of
   known size.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataListStack
{
	volatile INDEX     Top;
 /* enable logging the program executable (probably the same for
	                all messages, unless they are network)
	                                                                             */
 // How many elements are on the stack.
	INDEX     Cnt;
	//volatile uint32_t     Lock;  /* thread interlock using InterlockedExchange semaphore. For
	//                  thread safety.                                            */
	INDEX     Size;
	INDEX     Max;
	uint8_t      data[1];
} DATASTACK, *PDATASTACK;
/* A queue which contains pointers to user objects. If the queue
   is filled to capacity and new queue is allocated, and all
   existing pointers are transferred.                            */
typedef struct LinkQueue
{
	/* This is the index of the next pointer to be added to the
	   queue. If Top==Bottom, then the queue is empty, until a
	   pointer is added to the queue, and Top is incremented.   */
	volatile INDEX     Top;
	/* This is the index of the next element to leave the queue. */
	volatile INDEX     Bottom;
	/* This is the current count of pointers that can be stored in
	   the queue.                                                  */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore. For
	   thread safety.                                            */
#if USE_CUSTOM_ALLOCER
	volatile uint32_t     Lock;
#endif
 // need two to have distinct empty/full conditions
	POINTER pNode[2];
} LINKQUEUE, *PLINKQUEUE;
/* A queue of structure elements.
   Remarks
   The size of each element must be known at stack creation
   time. Structures are literally copied to and from this stack.
   This is a stack 'by value'. When extended, the stack will
   occupy different memory, care must be taken to not duplicate
   pointers to this stack.                                       */
typedef struct DataQueue
{
	/* This is the next index to be added to. If Top==Bottom, the
	   queue is empty, until an entry is added at Top, and Top
	   increments.                                                */
	volatile INDEX     Top;
	/* The current bottom index. This is the next one to be
	   returned.                                            */
	volatile INDEX     Bottom;
	/* How many elements the queue can hold. If a queue has more
	   elements added to it than it has count, it will be expanded,
	   and a new queue returned.                                    */
	INDEX     Cnt;
	/* thread interlock using InterlockedExchange semaphore */
	//volatile uint32_t     Lock;
	/* How big each element in the queue is. */
	INDEX     Size;
	/* How many elements to expand the queue by, when its capacity
	   is reached.                                                 */
	INDEX     ExpandBy;
	/* The data area of the queue. */
	uint8_t      data[1];
} DATAQUEUE, *PDATAQUEUE;
/* A mostly obsolete function, but can return the status of
   whether all initially scheduled startups are completed. (Or
   maybe whether we are not complete, and are processing
   startups)                                                   */
_CONTAINER_NAMESPACE_END
SACK_NAMESPACE_END
/* This contains the methods to use the base container types
   defined in sack_types.h.                                  */
#ifndef LINKSTUFF
#define LINKSTUFF
	SACK_NAMESPACE
	_CONTAINER_NAMESPACE
#    define TYPELIB_CALLTYPE
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define TYPELIB_PROC extern
#  elif defined( NO_EXPORTS )
#    if defined( _TYPELIBRARY_SOURCE )
#      define TYPELIB_PROC
#    else
#      define TYPELIB_PROC extern
#    endif
#  elif defined( _TYPELIBRARY_SOURCE )
#    define TYPELIB_PROC EXPORT_METHOD
#  else
#    define TYPELIB_PROC IMPORT_METHOD
#  endif
_LINKLIST_NAMESPACE
//--------------------------------------------------------
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        CreateListEx   ( DBG_VOIDPASS );
/* Destroy a PLIST. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        DeleteListEx   ( PLIST *plist DBG_PASS );
/* See <link AddLink>.
   See <link DBG_PASS>. */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        AddLinkEx      ( PLIST *pList, POINTER p DBG_PASS );
/* Sets the value of a link at the specified index.
   Parameters
   pList :     address of a PLIST
   idx :       index of the element to set
   p :         new link value to be set at the specified index
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PLIST TYPELIB_CALLTYPE        SetLinkEx      ( PLIST *pList, INDEX idx, POINTER p DBG_PASS );
/* Gets the link at the specified index.
   Parameters
   pList :  address of a PLIST pointer.
   idx :    index to get the link from.  */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      GetLink        ( PLIST *pList, INDEX idx );
/* Gets the address of the link node in the PLIST.
   Parameters
   pList :  address of a PLIST to get the node address
   idx :    index of the node to get the adddress of
   Example
   <code lang="c++">
   PLIST list = NULL; // don't have to use CreateList();
   POINTER *a;
   POINTER b;
   POINTER *result;
   a = &amp;b;
   AddLink( &amp;list, a );
   \result = GetLinkAddress( &amp;list, 0 );
    ( (*result) == b )
   </code>                                               */
TYPELIB_PROC  POINTER* TYPELIB_CALLTYPE     GetLinkAddress ( PLIST *pList, INDEX idx );
/* Locate a pointer in a PLIST. Return the index.
   Parameters
   pList :  address of a list pointer to locate link
   value :  link to find in the list
   Return Value List
   INVALID_INDEX :  Not found in the list
   0\-n :           Index of the first occurance of the link in the
                    list.                                           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        FindLink       ( PLIST *pList, POINTER value );
/* return the count of used members in a PLIST
    pList : the list to count
	Return Value
	   number of things in the list.
*/
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetLinkCount   ( PLIST pList );
/* Uses FindLink on the list for the value to delete, and then
   sets the index of the found link to NULL.
   Parameters
   pList :  Address of a PLIST pointer
   value :  the link to find and remove from the list.
   Example
   <code lang="c++">
   PLIST list = NULL;
	POINTER a = &#47;*some address*&#47;;
   </code>
   <code>
   AddLink( &amp;list, a );
   DeleteLink( &amp;list, a );
   </code>                                                     */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DeleteLink     ( PLIST *pList, CPOINTER value );
/* Remove all links from a PLIST. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyList      ( PLIST *pList );
#ifdef __cplusplus
/* This was a basic attempt to make list into a C++ class. I
   gave up doing this sort of thing afterwards after realizing
   the methods of a library and these static methods for a class
   aren't much different.                                        */
typedef class iList
{
public:
	PLIST list;
	INDEX idx;
	inline iList() { list = CreateListEx( DBG_VOIDSRC ); }
	inline ~iList() { DeleteListEx( &list DBG_SRC ); }
	inline iList &operator+=( POINTER &p ){ AddLinkEx( &list, p DBG_SRC ); return *this; }
	inline void add( POINTER p ) { AddLinkEx( &list, p DBG_SRC ); }
	inline void remove( POINTER p ) { DeleteLink( &list, p ); }
	inline POINTER first( void ) { POINTER p; for( idx = 0, p = NULL;list && (idx < list->Cnt) && (( p = GetLink( &list, idx ) )==0); )idx++; return p; }
	inline POINTER next( void ) { POINTER p; for( idx++;list && (( p = GetLink( &list, idx ) )==0) && idx < list->Cnt; )idx++; return p; }
	inline POINTER get(INDEX idx) { return GetLink( &list, idx ); }
} *piList;
#endif
// address of the thing...
typedef uintptr_t (CPROC *ForProc)( uintptr_t user, INDEX idx, POINTER *item );
// if the callback function returns non 0 - then the looping is aborted,
// and the value is returned... the user value is passed to the callback.
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE     ForAllLinks    ( PLIST *pList, ForProc func, uintptr_t user );
/* This is a iterator which can be used to check each member in
   a PLIST.
   Parameters
   list :     List to iterate through
   index :    variable to use to index the list
   type :     type of the elements stored in the list (for C++)
   pointer :  variable used to get the current member of the
              list.
   Example
   <code lang="c++">
   POINTER p;  // the pointer to receive the list member pointer (should be a user type)
   INDEX idx; // indexer
   PLIST pList; // some list.
   LIST_FORALL( pList, idx, POINTER, p )
   {
       // p will never be NULL here.
       // each link stored in the list is set to p here..
       // this is a way to remove this item from the list...
       SetLink( &amp;pList, idx, NULL );
       if( some condition )
          break;
   }
   </code>
   Another example that uses data and searches..
   <code lang="c++">
   PLIST pList = NULL;
   INDEX idx;
   CTEXTSTR string;
   AddLink( &amp;pList, (POINTER)"hello" );
   </code>
   <code>
   AddLink( &amp;pList, (POINTER)"world" );
   LITS_FORALL( pList, idx, CTEXTSTR, string )
   {
       if( strcmp( string, "hello" ) == 0 )
           break;
   }
   // here 'string' will be NULL if not found, else will be what was found
   </code>
   Remarks
   This initializes the parameters passed to the macro so that
   if the list is NULL or empty, then p will be set to NULL. If
   there are no non-nulll members in the list, p will be set to
   NULL. If you break in the loop, like in the case of searching
   the list for something, then p will be non-null at the end of
   the loop.
                                                                                         */
#define LIST_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l))                                                        for( ((i)=0); ((i) < ((l)->Cnt))?                                         (((v)=(t)((l)->pNode[i])),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* This can be used to continue iterating through a list after a
   LIST_FORALL has been interrupted.
   Parameters
   list :     \Description
   index :    index variable for stepping through the list
   type :     type of the members in the list.
   pointer :  variable name to use to store the the current list
              element.
   Example
   <code lang="c++">
   PLIST pList = NULL;
   CTEXTSTR p;
   INDEX idx;
   </code>
   <code>
   AddLink( &amp;pList, "this" );
   AddLink( &amp;pList, "is" );
   AddLink( &amp;pList, "a" );
   AddLink( &amp;pList, "test" );
   LIST_FORALL( pList, idx, CTEXTSTR, p )
   {
       if( strcmp( p, "is" ) == 0 )
           break;
   }
   LIST_NEXTALL( pList, idx, CTEXTSTR, p )
   {
       printf( "remaining element : %s", p );
   }
   </code>
   <code lang="c++">
   j
   </code>                                                       */
#define LIST_NEXTALL( l, i, t, v )  if(l)                for( ++(i),((v)=(t)NULL); ((i) < ((l)->Cnt))?     (((v)=(t)(l)->pNode[i]),1):(((v)=(t)NULL),0); (i)++ )  if( v )
/* <combine sack::containers::list::CreateListEx@DBG_VOIDPASS>
   \ \                                                         */
#define CreateList()       ( CreateListEx( DBG_VOIDSRC ) )
/* <combine sack::containers::list::DeleteListEx@PLIST *plist>
   \ \                                                         */
#ifndef FIX_RELEASE_COM_COLLISION
#  define DeleteList(p)      ( DeleteListEx( (p) DBG_SRC ) )
#endif
/* Adds a pointer to a user object to a list.
   Example
   <code lang="c++">
   // the list can be initialized to NULL,
   // it does not have to be assigned the result of a CreateList().
   // this allows the list to only be allocated if it is used.
   PLIST list = NULL;
   AddLink( &amp;list, (POINTER)user_pointer );
   {
       POINTER p; // this should be USER_DATA_TYPE *p;
       INDEX idx; // just a generic counter.
       LIST_FORALL( list, idx, POINTER, p )
       {
           // for each item in the list, p will be not null.
           if( p-\>something == some_other_thing )
               break;
       }
       // p will be NULL if the list is empty
       // p will be NULL if the LIST_FORALL loop completes to termination.
       // p will be not NULL if the LIST_FORALL loop executed a 'break;'
   }
   </code>                                                                 */
#define AddLink(p,v)       ( AddLinkEx( (p),((POINTER)(v)) DBG_SRC ) )
/* <combine sack::containers::list::SetLinkEx@PLIST *@INDEX@POINTER p>
   \ \                                                                 */
#define SetLink(p,i,v)     ( SetLinkEx( (p),(i),((POINTER)(v)) DBG_SRC ) )
#ifdef __cplusplus
//		namespace list;
	};
#endif
//--------------------------------------------------------
_DATALIST_NAMESPACE
/* Creates a data list which hold data elements of the specified
   size.
                                                                 */
TYPELIB_PROC  PDATALIST TYPELIB_CALLTYPE  CreateDataListEx ( uintptr_t nSize DBG_PASS );
/* <combine sack::containers::data_list::DeleteDataList>
   \ \                                                   */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataListEx ( PDATALIST *ppdl DBG_PASS );
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* Adds an item to a DataList.
   Example
   <code lang="c++">
   PDATALIST datalist = CreateDataList();
   struct my_struct {
       uint32_t my_data;
   }
   struct my_struct my_item;
   my_item.my_data = 0;
   AddDataItem( &amp;datalist, &amp;my_item );
   </code>                                     */
#define AddDataItem(list,data) (((list)&&(*(list)))?SetDataItemEx((list),(*list)->Cnt,data DBG_SRC ):NULL)
/* Sets the item at a specific nodes to the new data.
   Parameters
   ppdl :      address of a PDATALIST.
   idx :       index of element in list to set
   data :      POINTER to data to set element to
   DBG_PASS :  optional debug file/line information
   Example
   <code lang="c++">
      PDATALIST pdl;
      int oldval = 3;
      int newval = 5;
      pdl = CreateDataList( sizeof( int ) ); // store int's as data
      AddDataItem( &amp;pdl, &amp;oldval );
      SetDataItem( &amp;pdl, 0, &amp;newval );
   </code>                                                          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    SetDataItemEx ( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS );
/* \Returns a pointer to the data at a specified index.
   Parameters
   \ \
   ppdl :  address of a PDATALIST
   idx :   index of element to get                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE    GetDataItem ( PDATALIST *ppdl, INDEX idx );
/* Removes a data element from the list (moves all other
   elements down over it since there is no used indicator.
   Parameters
   ppdl :  address of a PDATALIST.
   idx :   index of element to delete                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE       DeleteDataItem ( PDATALIST *ppdl, INDEX idx );
/* Empties a PDATALIST of all content.
   Parameters
   ppdl :  address of a PDATALIST
   Example
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) ); // store int's as data
   EmptyDataList( &amp;pdl );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE       EmptyDataList ( PDATALIST *ppdl );
/* For loop to iterate through all items in a PDATALIST.
   <code lang="c++">
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
      }
   }
   </code>                                               */
#define DATA_FORALL( l, i, t, v )  if(((v)=(t)NULL),(l)&&((l)->Cnt != INVALID_INDEX))	   for( ((i)=0);	                         (((i) < (l)->Cnt)                                             ?(((v)=(t)((l)->data + (uintptr_t)(((l)->Size) * (i)))),1)	         :(((v)=(t)NULL),0))&&(v); (i)++ )
/* <code>
   PDATALIST pdl;
   pdl = CreateDataList( sizeof( int ) );
   {
      INDEX index;
      int *value;
      DATA_FORALL( pdl, index, int, value )
      {
          // abort loop early
      }
      DATA_NEXTALL( pdl, index, int, value )
      {
      }
   }
   </code>                                   */
#define DATA_NEXTALL( l, i, t, v )  if(((v)=(t)NULL),(l))	   for( ((i)++);	                         ((i) < (l)->Cnt)                                             ?((v)=(t)((l)->data + (((l)->Size) * (i))))	         :(((v)=(t)NULL),0); (i)++ )
/* <combine sack::containers::data_list::CreateDataListEx@uintptr_t nSize>
   Creates a DataList specifying just the size. Uses the current
   source and line for debugging parameter.                               */
#define CreateDataList(sz) ( CreateDataListEx( (sz) DBG_SRC ) )
/* Destroy a DataList.
   Example
   <code>
   PDATALIST datalist = CreateDataList( 4 );
   DeleteDataList( &amp;datalist );
   </code>
   Parameters
   ppDataList :  pointer to the PDATALIST.   */
#define DeleteDataList(p)  ( DeleteDataListEx( (p) DBG_SRC ) )
/* <combine sack::containers::data_list::SetDataItemEx@PDATALIST *@INDEX@POINTER data>
   \ \                                                                                 */
#define SetDataItem(p,i,v) ( SetDataItemEx( (p),(i),(v) DBG_SRC ) )
   _DATALIST_NAMESPACE_END
//--------------------------------------------------------
#ifdef __cplusplus
		namespace link_stack {
#endif
/* Creates a new stack for links (POINTERS).
   Parameters
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   CreateLinkStackEx( DBG_VOIDPASS );
/* Creates a new stack for links (POINTERS).  Link stack has a limited number of entries.
    When the stack fills, the oldest item on the stack is removed automatically.
	 Parameters
	 max_entries : maximum depth of the stack.
   DBG_PASS :  Debug file and line information to use for the
               allocation of the stack.
   Returns
   Pointer to a new link stack.                               */
         // creates a link stack with maximum entries - any extra entries are pushed off the bottom into NULL
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE      CreateLinkStackLimitedEx        ( int max_entries  DBG_PASS );
/* <combine sack::containers::link_stack::CreateLinkStackLimitedEx@int max_entries>
   Macro to pass default debug file and line information.                           */
#define CreateLinkStackLimited(n) CreateLinkStackLimitedEx(n DBG_SRC)
/* Destroy a link stack. Sets the pointer to the stack to NULL
   on deletion.
   Parameters
   pls :       address of a link stack pointer
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkStackEx( PLINKSTACK *pls DBG_PASS);
/* Pushes a new link on the stack.
   Parameters
   pls :       address of a link stack pointer
   p :         new pointer to push on the stack
   DBG_PASS :  debug source file and line information.
   Returns
   New link stack pointer if the stack was reallocated to have
   more space. Since the address of the pointer is passed, the
   pointer is already updated, and the return value is
   unimportant.                                                */
TYPELIB_PROC  PLINKSTACK TYPELIB_CALLTYPE   PushLinkEx       ( PLINKSTACK *pls, POINTER p DBG_PASS);
/* Reads the top value of the stack and returns it, removes top
   link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Stack was empty
   not NULL :  Link that was on the top of the stack.           */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLink          ( PLINKSTACK *pls );
/* Look at the top link on the stack.
   Parameters
   pls :  address of a link stack pointer
   Return Value List
   NULL :      Nothing on stack.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLink         ( PLINKSTACK *pls );
/* Look at links in the stack.
   Parameters
	pls :  address of a link stack pointer
	n : index of the element from the top to look at
   Return Value List
   NULL :      Nothing on stack at the position specified.
   not NULL :  link on the top of the stack. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekLinkEx         ( PLINKSTACK *pls, INDEX n );
// thought about adding these, but decided on creating a limited stack instead.
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      StackLength      ( PLINKSTACK *pls );
//TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopLinkEx        ( PLINKSTACK *pls, int position );
/* <combine sack::containers::link_stack::CreateLinkStackEx@DBG_VOIDPASS>
   Macro to pass default file and line information.                       */
#define CreateLinkStack()  CreateLinkStackEx( DBG_VOIDSRC )
/* <combine sack::containers::link_stack::DeleteLinkStackEx@PLINKSTACK *pls>
   Macro to pass default file and line information.                          */
#define DeleteLinkStack(p) DeleteLinkStackEx((p) DBG_SRC)
/* <combine sack::containers::link_stack::PushLinkEx@PLINKSTACK *@POINTER p>
   Macro to pass default debug file and line information.                    */
#define PushLink(p, v)     PushLinkEx((p),(v) DBG_SRC)
#ifdef __cplusplus
//		namespace link_stack {
		};
#endif
//--------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of elements in the stack
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackEx( size_t size DBG_PASS );
/* Creates a data stack for data element of the specified size.
   Parameters
   size :       size of items in the stack
   count :      max items in stack (oldest gets deleted)
   DBG_PASS :  debug file and line information.                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   CreateDataStackLimitedEx( size_t size, INDEX count DBG_PASS );
/* Destroys a data stack.
   Parameters
   pds :       address of a data stack pointer. The pointer will
               be set to NULL when the queue is destroyed.
   DBG_PASS :  Debug file and line information.                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataStackEx( PDATASTACK *pds DBG_PASS);
/* Push a data element onto the stack. The size of the element
   is known at the stack creation time.
   Parameters
   pds :       address of a data stack pointer
   p :         pointer to data to push on stack
   DBG_PASS :  debug file and line information                 */
TYPELIB_PROC  PDATASTACK TYPELIB_CALLTYPE   PushDataEx     ( PDATASTACK *pds, POINTER pdata DBG_PASS );
/* \Returns an allocated buffer containing the data on the
   stack. Removes item from the stack.
   Parameters
   pds :  address of a data stack to get data from         */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PopData        ( PDATASTACK *pds );
/* Clear all data stored in the stack.
   Parameters
   pds :  address of a data stack pointer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataStack ( PDATASTACK *pds );
/* Look at top item in the stack without removing it.
   Parameters
   pds :  address of a data stack to look at          */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekData       ( PDATASTACK *pds );
// Incrementing Item moves progressivly down the stack
// final(invalid) stack, and/or empty stack will return NULL;
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekDataEx     ( PDATASTACK *pds, INDEX Item );
 /* keeps data on stack (can be used)
                                                                                      Parameters
                                                                                      pds :   address of a data stack pointer
                                                                                      Item :  Item to peek at; 0 is the top, 1 is just below it...
                                                                                              (maybe \-1 is last and further up)
                                                                                      Returns
                                                                                      \returns the address of the data item in the data stack.     */
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStack(size) CreateDataStackEx( size DBG_SRC )
/* <combine sack::containers::data_stack::CreateDataStackEx@INDEX size>
   Macro to pass default file and line information.                     */
#define CreateDataStackLimited(size,items) CreateDataStackLimitedEx( size,items DBG_SRC )
/* <combine sack::containers::data_stack::DeleteDataStackEx@PDATASTACK *pds>
   Macro to pass default file and line information.                          */
#define DeleteDataStack(p) DeleteDataStackEx((p) DBG_SRC)
/* <combine sack::containers::data_stack::PushDataEx@PDATASTACK *@POINTER pdata>
   Macro to pass default file and line information.                              */
#define PushData(pds,p) PushDataEx(pds,p DBG_SRC )
#ifdef __cplusplus
 //		namespace data_stack {
		}
#endif
/* Queue container - can enque (at tail) deque (from head) and preque (at head). Can also browse the queue with peekqueue. */
#ifdef __cplusplus
		namespace queue {
#endif
/* Creates a <link sack::containers::PLINKQUEUE, LinkQueue>. In
   debug mode, gets passed the current source and file so it can
   blame the user for the allocation.                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   CreateLinkQueueEx( DBG_VOIDPASS );
/* Delete a link queue. Pass the address of the pointer to the
   queue to delete, this function sets the pointer to NULL if
   the queue is actually deleted.                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS );
/* Enque a link to the queue.  */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   EnqueLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE   EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* EnqueLink adds the new item at the end of the list. PrequeueLink
   puts the new item at the head of the queue (so it's the next
   one to be retrieved).                                            */
TYPELIB_PROC  PLINKQUEUE TYPELIB_CALLTYPE   PrequeLinkEx      ( PLINKQUEUE *pplq, POINTER link DBG_PASS );
/* If the queue is not empty, returns the address of the next
   element in the queue and removes the element from the queue.
                                                                */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      DequeLink        ( PLINKQUEUE *pplq );
TYPELIB_PROC POINTER  TYPELIB_CALLTYPE      DequeLinkNL      ( PLINKQUEUE *pplq );
/* Return TRUE/FALSE if the queue is empty or not. */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsQueueEmpty     ( PLINKQUEUE *pplq );
/* Gets the number of elements current in the queue. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE        GetQueueLength   ( PLINKQUEUE plq );
// get a PLINKQUEUE element at index
//  If idx < 0 then count from the end of the queue, otherwise count from the start of the queue
// start of the queue is the next element to be dequeue, end of the queue is the last element added to the queue.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueueEx    ( PLINKQUEUE plq, int idx );
/* Can be used to look at the next element in the queue without
   removing it from the queue. PeekQueueEx allows you to specify
   an index of an item in the queue to get.                      */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE      PeekQueue    ( PLINKQUEUE plq );
/* <combinewith sack::containers::queue::CreateLinkQueueEx@DBG_VOIDPASS>
   \ \                                                                   */
#define     CreateLinkQueue()     CreateLinkQueueEx( DBG_VOIDSRC )
/* <combine sack::containers::queue::PrequeLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                       */
#define     PrequeLink(pplq,link) PrequeLinkEx( pplq, link DBG_SRC )
/* <combine sack::containers::queue::DeleteLinkQueueEx@PLINKQUEUE *pplq>
   \ \                                                                   */
#define     DeleteLinkQueue(pplq) DeleteLinkQueueEx( pplq DBG_SRC )
/* <combine sack::containers::queue::EnqueLinkEx@PLINKQUEUE *@POINTER link>
   \ \                                                                      */
#define     EnqueLink(pplq, link) EnqueLinkEx( pplq, link DBG_SRC )
#define     EnqueLinkNL(pplq, link) EnqueLinkNLEx( pplq, link DBG_SRC )
#ifdef __cplusplus
//		namespace queue {
		}
#endif
/* Functions related to PDATAQUEUE container. DataQueue stores
   literal data elements in the list instead of just a pointer. (could
   be used for optimized vertex arrays for instance).
   int data = 3;
   int result;
   PDATAQUEUE pdq = CreateDataQueue( sizeof( int ) );
   EnqueData( &amp;pdq, &amp;data );
   DequeData( &amp;pdq, &amp;result );
   DestroyDataQueue( &amp;pdq );                                       */
#ifdef __cplusplus
		namespace data_queue {
#endif
/* Creates a PDATAQUEUE. Can pass DBG_FILELINE information to
   blame other code for the allocation.                       */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateDataQueueEx( INDEX size DBG_PASS );
/* Creates a PDATAQUEUE that has an overridden expand-by amount
   and initial amount of entries in the queue. (expecting
   something like 1000 to start and expand by 500, instead of
   the default 0, and expand by 1.                              */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS );
/* Destroys a data queue. */
TYPELIB_PROC  void TYPELIB_CALLTYPE         DeleteDataQueueEx( PDATAQUEUE *pplq DBG_PASS );
/* Add a data element into the queue. */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   EnqueDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Enque data at the head of the queue instead of the tail. (Normally
   add at tail, take from head).                                      */
TYPELIB_PROC  PDATAQUEUE TYPELIB_CALLTYPE   PrequeDataEx      ( PDATAQUEUE *pplq, POINTER Data DBG_PASS );
/* Removes data from a queue, resulting with the data in the
   specified buffer, and result TRUE if there was an element
   else FALSE, and the buffer is not modified.               */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      DequeData        ( PDATAQUEUE *pplq, POINTER Data );
/* Removes the last element in the queue. (takes from the tail). */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      UnqueData        ( PDATAQUEUE *pplq, POINTER Data );
/* Checks if the queue is empty, result TRUE if nothing in it,
   else FALSE.                                                 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE      IsDataQueueEmpty ( PDATAQUEUE *pplq );
/* Empty a dataqueue of all data. (Sets head=tail). */
TYPELIB_PROC  void TYPELIB_CALLTYPE         EmptyDataQueue ( PDATAQUEUE *pplq );
/*
 * get a PDATAQUEUE element at index
 * result buffer is a pointer to the type of structure expected to be
 * stored within this.  The buffer result is a copy of the data stored in the queue.
 * This enforces that data stored in the list is immutable.
 * Also on the basic DequeData function, after resulting, if the pointer to the
 * data within the queue were returned, it could become invalid immediatly after
 * returning by having another enque happen which overwrites that position in the buffer.
 * One could, in theory, set a flag in the queue that a deque was done, and not update the
 * bottom until that flag is encountered while within DequeData again...
 * the pointer to the data in the queue may also not be returned because the queue may be
 * reallocated and moved.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueueEx    ( PDATAQUEUE *pplq, POINTER ResultBuffer, INDEX idx );
/* <combine sack::containers::data_queue::PeekDataQueueEx@PDATAQUEUE *@POINTER@INDEX>
   \ \                                                                                */
#define PeekDataQueueEx( q, type, result, idx ) PeekDataQueueEx( q, (POINTER)result, idx )
/*
 * Result buffer is filled with the last element, and the result is true, otherwise the return
 * value is FALSE, and the data was not filled in.
 */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  PeekDataQueue    ( PDATAQUEUE *pplq, POINTER ResultBuffer );
/* <combine sack::containers::data_queue::PeekDataQueue@PDATAQUEUE *@POINTER>
   \ \                                                                        */
#define PeekDataQueue( q, type, result ) PeekDataQueue( q, (POINTER)result )
/* <combine sack::containers::data_queue::CreateDataQueueEx@INDEX size>
   \ \                                                                  */
#define     CreateDataQueue(size)     CreateDataQueueEx( size DBG_SRC )
/* <combine sack::containers::data_queue::CreateLargeDataQueueEx@INDEX@INDEX@INDEX expand>
   \ \                                                                                     */
#define     CreateLargeDataQueue(size,entries)     CreateLargeDataQueueEx( size,entries, 0 DBG_SRC )
/* <combine sack::containers::data_queue::DeleteDataQueueEx@PDATAQUEUE *pplq>
   \ \                                                                        */
#define     DeleteDataQueue(pplq) DeleteDataQueueEx( pplq DBG_SRC )
/* <combine sack::containers::data_queue::EnqueDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                           */
#define     EnqueData(pplq, Data) EnqueDataEx( pplq, Data DBG_SRC )
/* <combine sack::containers::data_queue::PrequeDataEx@PDATAQUEUE *@POINTER Data>
   \ \                                                                            */
#define     PrequeData(pplq, Data) PrequeDataEx( pplq, Data DBG_SRC )
#ifdef __cplusplus
//		namespace data_queue {
		}
#endif
//---------------------------------------------------------------------------
#ifdef __cplusplus
namespace message {
#endif
/* handle to a message queue. */
typedef struct MsgDataHandle *PMSGHANDLE;
//typedef struct MsgDataQueue *PMSGQUEUE;
// messages sent - the first dword of them must be
// a message ID.
typedef void (CPROC *MsgQueueReadCallback)( uintptr_t psv, CPOINTER p, uintptr_t sz );
/* Create a named shared memory message queue.
   Parameters
   name :     name of the queue to create
   size :     size of the queue.
   Read :     read callback, called when a message is received on
              the queue.
   psvRead :  user data associated with the queue. Passed to the
              read callback.                                      */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                                      , MsgQueueReadCallback Read
                                                      , uintptr_t psvRead );
/* Open a message queue. Opens if it exists, does not create.
   Parameters
   name :     name of the queue.
   Read :     read callback called when a message is received.
   psvRead :  user data associated with this queue, and passed to
              the read callback.                                  */
TYPELIB_PROC  PMSGHANDLE TYPELIB_CALLTYPE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead );
/* Destroys a message queue.
   Parameters
   ppmh :  address of the message queue handle to close (sets
           pointer to NULL when deleted)                      */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteMsgQueue ( PMSGHANDLE **ppmh );
 // if enque, fail send, return immediate on fail
#define MSGQUE_NOWAIT 0x0001
                             // if deque, fail no msg ready to get...
 // read any msg BUT MsgID
#define MSGQUE_EXCEPT 0x0002
 // enque this message... it is a task ID which is waiting.
#define MSGQUE_WAIT_ID 0x0004
/* Error result if there is no message to read. (GetLastError()
   after peekmsg or readmsg returns -1)                         */
#define MSGQUE_ERROR_NOMSG 1
/* Error result if the message to read is bigger than the buffer
   passed to read the message.                                   */
#define MSGQUE_ERROR_E2BIG 2
/* Error result. Unexpected error (queue head/tail out of
   bounds)                                                */
#define MSGQUE_ERROR_EABORT 5
// result is the size of the message, or 0 if no message.
// -1 if some other error?
TYPELIB_PROC  int TYPELIB_CALLTYPE  DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Receives a message from the message queue.
   Parameters
   Message Queue :  PMSGHANDLE to read from
   Message ID * :   a Pointer to the message ID to read. Updated
                    with the message ID from the queue.
   buffer :         buffer to read message into
   buffer length :  length of the buffer to read
   options :        extra options for the read
   Return Value List
   \-1 :  Error
   0 :    No Message to read
   \>0 :  size of message read.
   Returns
   \ \                                                           */
#define DequeMsg(q,b,s,i,o) DequeMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::PeekMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  PeekMsgEx ( PMSGHANDLE pmh, long MsgID, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Just peek at the next message.
   Parameters
   queue :        The PMSGHANDLE queue to read.
   MsgID :        what message to read. 0 is read any message.
   buffer :       where to read the message data into.
   buffer_size :  the length of the message buffer.
   options :      Options controlling the read
   Returns
   \-1 on error
   0 if no message
   length of the message read                                  */
#define PeekMsg(q,b,s,i,o) PeekMsgEx(q,b,s,i,o DBG_SRC )
/* <combine sack::containers::message::EnqueMsg>
   \ \                                          */
TYPELIB_PROC  int TYPELIB_CALLTYPE  EnqueMsgEx ( PMSGHANDLE pmh, POINTER buffer, size_t msgsize, uint32_t options DBG_PASS );
/* Add a message to the queue.
   Parameters
   Message Queue :  PMSGQUEUE to write to.
   Buffer :         pointer to the message to send. THe MSgID is
                    the first part of the message buffer.
   Buffer Length :  how long the message to send is
   Options :        Extra options for send
   Return Value List
   \-1 :  Error
   \>0 :  bytes of message sent                                  */
#define EnqueMsg(q,b,s,o) EnqueMsgEx(q,b,s,o DBG_SRC )
/* Check if the message queue is empty.
   Parameters
   pmh :  queue to check if it's empty. */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsMsgQueueEmpty ( PMSGHANDLE pmh );
#ifdef __cplusplus
 //namespace message {
};
#endif
/* Routines to deal with SLAB allocated blocks of structures.
   Each slab has multiple elements of a type in it, and the
   blocks are tracked as a linked list. Each block also has a
   bitmask of allocated elements in the set.
   \---------------------------------------------------------------------------
   Set type
   Usage:
   typedef struct name_tag { } \<name\>;
   \#define MAX\<name\>SPERSET
   DeclareSet( \<name\> );
   Should alias GetFromset, DeleteFromSet, CountUsedInSet,
   GetLinearSetArray
   etc so that the type name is reflected there
   another good place where #define defining defines is good.
   \---------------------------------------------------------------------------
                                                                                */
_SETS_NAMESPACE
//---------------------------------------------------------------------------
// Set type
//   Usage:
//      typedef struct name_tag { } <name>;
//      #define MAX<name>SPERSET
//      DeclareSet( <name> );
//    Should alias GetFromset, DeleteFromSet, CountUsedInSet, GetLinearSetArray
//       etc so that the type name is reflected there
//       another good place where #define defining defines is good.
//---------------------------------------------------------------------------
/* Hard coded 32 bit division for getting word index. (x\>\>5) */
#define UNIT_USED_IDX(n)   ((n) >> 5)
/* Hard coded 32 bit division for getting bit index. (x &amp;
   0x1f)                                                      */
#define UNIT_USED_MASK(n)  (1 << ((n) &0x1f))
/* A macro for use by internal code that marks a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to mark used.                                   */
#define SetUsed(set,n)   ((((set)->bUsed[UNIT_USED_IDX(n)]) |= UNIT_USED_MASK(n)), (++(set)->nUsed) )
/* A macro for use by internal code that marks a member of a set
   as available.
   Parameters
   set :    pointer to a genericset
   index :  item to mark available.                              */
#define ClearUsed(set,n) ((((set)->bUsed[UNIT_USED_IDX(n)]) &= ~UNIT_USED_MASK(n)), (--(set)->nUsed) )
/* A macro for use by internal code that tests a whole set of
   bits for used. (32 bits, can check to see if any in 32 is
   free)
   Parameters
   set :    pointer to a genericset
   index :  index of an one in the set of 32 being tested.
   Returns
   0 if not all are used.
   1 if all in this block of bits are used.                   */
#define AllUsed(set,n)   (((set)->bUsed[UNIT_USED_IDX(n)]) == 0xFFFFFFFF )
/* A macro for use by internal code that tests a member of a set
   as used.
   Parameters
   set :    pointer to a genericset
   index :  item to test used.
   Returns
   not zero if is used, otherwise is free.                       */
#define IsUsed(set,n)    (((set)->bUsed[UNIT_USED_IDX(n)]) & UNIT_USED_MASK(n) )
#ifdef __cplusplus
#define CPP_(n)
/* A macro which is used to emit code in C++ mode... */
#else
#define CPP_(n)
#endif
// requires a symbol of MAX<insert name>SPERSET to declare max size...
 //ndef __cplusplus
#if 1
#define SizeOfSet(size,count)  (sizeof(POINTER)*2+sizeof(int)+sizeof( uint32_t[((count)+31)/32] ) + ((size)*(count)))
#define DeclareSet( name )  typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              name p[MAX##name##SPERSET];	                           CPP_(int forall(uintptr_t(CPROC*f)(void*,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(name), MAX##name##SPERSET, f, psv ); else return 0; })	 CPP_(name##set_tag() { next = NULL;prior = NULL;nUsed = 0; nBias = 0; MemSet( bUsed, 0, sizeof( bUsed ) ); MemSet( p, 0, sizeof( p ) );} )	} name##SET, *P##name##SET
#define DeclareClassSet( name ) typedef struct name##set_tag {	   struct name##set_tag *next, *prior;	                      uint32_t nUsed;	                                               uint32_t nBias;	                                               uint32_t bUsed[(MAX##name##SPERSET + 31 ) / 32];	              class name p[MAX##name##SPERSET];	                        CPP_(int forall(uintptr_t(CPROC*)(void*f,uintptr_t),uintptr_t psv) {if( this ) return _ForAllInSet( (struct genericset_tag*)this, sizeof(class name), MAX##name##SPERSET, f, psv ); else return 0; })	 } name##SET, *P##name##SET
#endif
/* This represents the basic generic set structure. Addtional
   data is allocated at the end of this strcture to fit the bit
   array that maps usage of the set, and for the set size of
   elements.
   Remarks
   \ \
   Summary
   Generic sets are good for tracking lots of tiny structures.
   They track slabs of X structures at a time. They allocate a
   slab of X structures with an array of X bits indicating
   whether a node is used or not. The structure overall has how
   many are used, so once full, a block can be quickly checked
   whether there is anything free. Then when checking a block
   that might have room, the availablility is checked 32 bits at
   a time, until a free spot is found.
   Sets of 1024 members of x,y coordinates for example are good
   for this sort of storage. the points are often static, once
   loaded they all exist until none of them do. This storage has
   gross deletion methods too, quickly evaporate all allocated
   chunks. Storing tiny chunks in a slab is more efficient
   because every allocation method has some sort of tracking
   associated with it - an overhead of having it. Plus, when
   operating on sets of data, a single solid slab of exatly the
   structures you are working with is more efficient to cache.
   Example
   <code lang="c++">
   struct treenode_tag {
       uint32_t treenode_data;  // abitrary structure data
   };
   typedef struct treenode_tag TREENODE;
   \#define MAXTREENODESPERSET 256
   DeclareSet( TREENODE );
   </code>
   The important part of the prior code is the last two lines.
   \#define MAX\<your type name\>SPERSET \<how many\>
   This defines how many of your structure are kept per set
   block.
   The DeclareSet( type ) declares a typedefed structure called
   'struct type##set_tag', 'name##SET', and '*P##name##SET'; in
   the above case, it would be 'struct TREENODEset_tag',
   'TREENODESET', and 'PTREENODESET'.
   Then to actually use the set...
   <code lang="c#">
   // declare a set pointer with one of the magic names.
   PTREENODESET nodeset = NULL;
   // get a node from the set.
   TREENODE *node = GetFromSet( TREENODE, nodeset );
   </code>
   Notice there is no CreateSet, getting a set member will
   create the set as required. Many operations may expend the
   set, except for GetUsedSetMember which will only result with
   \members that are definatly in the set. Accesses to the set
   are all prefixed by the type name the set was created with,
   'TREENODE' in this example.
   <code lang="c++">
   DeleteFromSet( TREENODE, nodeset, node );
   node = GetFromSet( TREENODE, nodeset );
   {
      int index = GetMemberIndex( TREENODE, nodeset, node );
   }
   </code>
   The accessor macros take care of expanding several parameters
   that require sizeof structure expansion.                      */
typedef struct genericset_tag {
	// wow might be nice to have some flags...
	// first flag - bSetSet - meaning that this is a set of sets of
	// the type specified...
	struct genericset_tag *next;
	/* This is the pointer that's pointing at the pointer pointing
	   to me. (did you get that?) See <link DeclareLink>.          */
	struct genericset_tag **me;
	/* number of spots in this set block that are used. */
	uint32_t nUsed;
 // hmm if I change this here? we're hozed... so.. we'll do it anyhow :) evil - recompile please
	uint32_t nBias;
 // after this p * unit must be computed
	uint32_t bUsed[1];
} GENERICSET, *PGENERICSET;
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetFromSetEx( GENERICSET **pSet, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \                                                                             */
#define GetFromSeta(ps, ss, us, max) GetFromSetPoolEx( NULL, 0, 0, 0, (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetEx@GENERICSET **@int@int@int maxcnt>
   \ \
   Parameters
   name :  name of type the set contains.
   pSet :  pointer to a set to get an element from.                                */
#define GetFromSet( name, pset ) (name*)GetFromSeta( (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  PGENERICSET  TYPELIB_CALLTYPE GetFromSetPoolEx( GENERICSET **pSetSet
													 , int setsetsize, int setunitsize, int setmaxcnt
													 , GENERICSET **pSet
													 , int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPoola(pl, sss, sus, smax, ps, ss, us, max) GetFromSetPoolEx( (pl), (sss), (sus), (smax), (ps), (ss), (us), (max) DBG_SRC )
/* <combine sack::containers::sets::GetFromSetPoolEx@GENERICSET **@int@int@int@GENERICSET **@int@int@int maxcnt>
   \ \                                                                                                           */
#define GetFromSetPool( name, pool, pset ) (name*)GetFromSetPoola( (GENERICSET**)(pool)	    , sizeof( name##SETSET ), sizeof( name##SET ), MAX##name##SETSPERSET	, (GENERICSET**)(pset), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMembera(ps, member, ss, us, max) (GetSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                     */
#define GetSetMember( name, pset, member ) ((name*)GetSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS );
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMembera(ps, member, ss, us, max) (GetUsedSetMemberEx( (ps), (member), (ss), (us), (max) DBG_SRC ))
/* <combine sack::containers::sets::GetUsedSetMemberEx@GENERICSET **@INDEX@int@int@int maxcnt>
   \ \                                                                                         */
#define GetUsedSetMember( name, pset, member ) ((name*)GetUsedSetMembera( (GENERICSET**)(pset), (member), sizeof( name##SET ), sizeof( name ), MAX##name##SPERSET ))
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetMemberIndex(GENERICSET **set, POINTER unit, int unitsize, int max );
/* Gets the index of a member passed as a pointer.
   Parameters
   set :       pointer to the set the member is in
   unit :      pointer to the member in the set to get the index
               of.
   unitsize :  size of each member in the set
   max :       count of members in each set block.
   Returns
   \Returns the index of the member passed in as a pointer.      */
#define GetMemberIndex(name,set,member) GetMemberIndex( (GENERICSET**)set, member, sizeof( name ), MAX##name##SPERSET )
/* <combine sack::containers::sets::GetMemberIndex>
   \ \                                              */
#define GetIndexFromSet( name, pset ) GetMemberIndex( name, pset, GetFromSet( name, pset ) )
/* \ \
   Parameters
   pSet :      pointer to a generic set
   nMember :   index of the member
   setsize :   number of elements in each block
   unitsize :  set block
   maxcnt :    max elements per set block       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteFromSetExx( GENERICSET *set, POINTER unit, int unitsize, int max DBG_PASS );
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#define DeleteFromSetEx( name, set, member, xx ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
/* <combine sack::containers::sets::DeleteFromSetExx@GENERICSET *@POINTER@int@int max>
   \ \                                                                                 */
#ifdef _DEBUG
#define DeleteFromSet( name, set, member ) do { P##name##SET testset = set; DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC ); } while(0)
#else
#define DeleteFromSet( name, set, member ) DeleteFromSetExx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET DBG_SRC )
#endif
/* Marks a member in a set as usable.
   Parameters
   set :       pointer to a genericset pointer
   iMember :   index of member to delete
   unitsize :  (filled by macro) size of element in set
   max :       (filled by macro) size of a block of elements. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSetMemberEx( GENERICSET *set, INDEX iMember, uintptr_t unitsize, INDEX max );
/* <combine sack::containers::sets::DeleteSetMemberEx@GENERICSET *@INDEX@uintptr_t@INDEX>
   \ \                                                                                   */
#define DeleteSetMember( name, set, member ) DeleteSetMemberEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
/* This function can check to see if a pointer is a valid
   element from a set.
   Parameters
   set :       pointer to a set to check
   unit :      pointer to an element from the set
   unitsize :  size of element structures in the set.
   max :       count of structures per set block
   Returns
   TRUE if unit is in the set, else FALSE.                */
TYPELIB_PROC  int TYPELIB_CALLTYPE  MemberValidInSetEx( GENERICSET *set, POINTER unit, int unitsize, int max );
/* <combine sack::containers::sets::MemberValidInSetEx@GENERICSET *@POINTER@int@int>
   \ \                                                                               */
#define MemberValidInSet( name, set, member ) MemberValidInSetEx( (GENERICSET*)set, member, sizeof( name ), MAX##name##SPERSET )
TYPELIB_PROC  int TYPELIB_CALLTYPE  CountUsedInSetEx( GENERICSET *set, int max );
/* Count number of elements that are allocated in the set.
   Parameters
   set :  The set to check
   max :  max items per set (may be unused, since this is stored
          internally now)
   Returns
   The number of items in the step.                              */
#define CountUsedInSet( name, set ) CountUsedInSetEx( (GENERICSET*)set, MAX##name##SPERSET )
TYPELIB_PROC  POINTER * TYPELIB_CALLTYPE GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max );
/* Converts a set into a copy of the objects in the set
   organized in a flat array.
   Parameters
   pSet :      set to convert to an array
   pCount :    address of an integer to receive the count of
               elements put in the array.
   unitsize :  size of each element in the set
   max :       count of elements per set block
   Returns
   Pointer to an array that are a copy of the objects in the
   set.                                                      */
#define GetLinearSetArray( name, set, pCount ) GetLinearSetArrayEx( (GENERICSET*)set, pCount, sizeof( name ), MAX##name##SPERSET )
/* Returned the index of an item in a linear array returned from
   a set.
   Parameters
   pArray :      pointer to an array which has been returned from
                 the set
   nArraySize :  size fo the array
   unit :        pointer to an element in the array
   Returns
   Index of the unit in the array, INVALID_INDEX if not in the
   array.                                                         */
TYPELIB_PROC  int TYPELIB_CALLTYPE  FindInArray( POINTER *pArray, int nArraySize, POINTER unit );
/* Delete all allocated slabs.
   Parameters
   ppSet :  pointer to a generic set pointer to delete. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteSet( GENERICSET **ppSet );
/* <combine sack::containers::sets::DeleteSet@GENERICSET **>
   \ \                                                       */
#define DeleteSetEx( name, ppset ) { name##SET **delete_me = ppset; DeleteSet( (GENERICSET**)delete_me ); }
/* <combine sack::containers::sets::ForAllInSet>
   ForAllinSet Callback - callback fucntion used with
   ForAllInSet                                        */
typedef uintptr_t (CPROC *FAISCallback)(void*,uintptr_t);
/* \ \
   Parameters
   pSet :      poiner to a set
   unitsize :  size of elements in the array
   max :       count of elements per set block
   f :         user callback function to call for each element in
               the set
   psv :       user data passed to the user callback when it is
               invoked for a member of the set.
   Returns
   If the user callback returns 0, the loop continues. If the
   user callback returns non zero then the looping through the
   set ends, and that result is returned.                         */
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv );
/* <combine sack::containers::sets::ForEachSetMember>
   ForEachSetMember Callback function - for the function '
   ForEachSetMember'                                       */
typedef uintptr_t (CPROC *FESMCallback)(INDEX,uintptr_t);
TYPELIB_PROC  uintptr_t TYPELIB_CALLTYPE  ForEachSetMember ( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv );
 //def __cplusplus
#if 0
#define DeclareSet(name)	                                struct name##set_tag {	               uint32_t set_size;	                             uint32_t element_size;	                         uint32_t element_cnt;	                          PGENERICSET pool;	                        name##set_tag() {	                        element_size = sizeof( name );	             element_cnt = MAX##name##SPERSET;	          set_size = (element_size * element_cnt )+ ((((element_cnt + 31 )/ 32 )- 1 ) * 4) + sizeof( GENERICSET );	 pool = NULL;	                               }	    ~name##set_tag() { DeleteSet( &pool ); }	 name* grab() { return (name*)GetFromSetEx( &pool, set_size, element_size, element_cnt DBG_SRC ); }	 name* grab(INDEX member) { return (name*)GetSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ); }	 name* get(INDEX member) { return (this)?(name*)GetUsedSetMemberEx( &pool, member, set_size, element_size, element_cnt DBG_SRC ):(NULL); }	 void drop( name* member ) { DeleteFromSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 int valid( name* member ) { return MemberValidInSetEx( pool, (POINTER)member, element_size, element_cnt ); }	 uintptr_t forall( FAISCallback f, uintptr_t psv ) { if( this ) return _ForAllInSet( pool, element_size, element_cnt, f, psv ); else return 0; }	 };	       typedef struct name##set_tag *P##name##SET, name##SET;
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
#else
/* <combine sack::containers::sets::_ForAllInSet@GENERICSET *@int@int@FAISCallback@uintptr_t>
   \ \                                                                                       */
#define ForAllInSet(name, pset,f,psv) _ForAllInSet( (GENERICSET*)(pset), sizeof( name ), MAX##name##SPERSET, (f), (psv) )
/* Performs an iteration over each allocated set member. Calls
   the user provided callback routine with each element in the
   set.
   Parameters
   pSet :      pointer to the set to iterate
   unitsize :  size of each element
   max :       max count of elements per set block
   f :         function to call ( uintptr_t (*)(INDEX,uintptr_t) )
   psv :       user data value to pass to function as uintptr_t
   Returns
   uintptr_t - this value is the return of the user function if
   the function does not return 0. A non zero return from the
   user callback stops iteration.                                */
#define ForEachSetMember(name,pset,f,psv) ForEachSetMember( (GENERICSET*)(pset),sizeof(name),MAX##name##SPERSET, (f), (psv) )
#endif
//---------------------------------------------------------------------------
_SETS_NAMESPACE_END
_TEXT_NAMESPACE
// this defines more esoteric formatting notions...
// these data blocks will be zero sized, and ahve the TF_FORMATEX
// bit set.
//#define DEFAULT_COLOR 0xF7
//#define PRIOR_COLOR 0xF6 // this does not change the color....
// these enumerated ops put in the foreground field of a format
// with a flag of TF_FORMATEX will cause the specified operation
// to be carried out on a display (not files) or generated into
// the appropriate sequence (ansi out encode)
// -- correction
//  this is encoded into its own field for the format
// size, due to machine optimization, 16 bits were free
// this was expanded and used for all information
// a segment may contain extended op, color, attributes,
// and text, everything short of a font for it...
//  - not sure how to address that issue... there's
// certainly modifications to current font... italic for
// instance..
	enum FORMAT_OPS {
      /* this segment clears to the end of the line.  Its content is then added to the output */
		FORMAT_OP_CLEAR_END_OF_LINE = 1
        ,FORMAT_OP_CLEAR_START_OF_LINE
                   ,
						  FORMAT_OP_CLEAR_LINE
						 ,
						  FORMAT_OP_CLEAR_END_OF_PAGE
                   ,
						  FORMAT_OP_CLEAR_START_OF_PAGE
						 ,
/* clear the entire vieable page (pushes all content to history)
                    set cursor home ;6*/
						  FORMAT_OP_CLEAR_PAGE
						 ,
						  FORMAT_OP_CONCEAL
                   ,
						  FORMAT_OP_DELETE_CHARS
                   ,
						  FORMAT_OP_SET_SCROLL_REGION
                   ,
						  FORMAT_OP_GET_CURSOR
						 ,
						  FORMAT_OP_SET_CURSOR
						 ,
						  FORMAT_OP_PAGE_BREAK
						 ,
/* break between paragraphs - kinda same as lines...
						  since lines are as long as possible... ;13 */
						 FORMAT_OP_PARAGRAPH_BREAK
						 ,
/* Justify line(s if wrapped) to the right
						   This attribute should be passed through to renderer;14*/
                   FORMAT_OP_JUSTIFY_RIGHT
						 ,
/* Justify line(s if wrapped) to the center
						 This attribute should be passed through to renderer;15*/
                   FORMAT_OP_JUSTIFY_CENTER
};
//typedef struct text_color_tag { uint32_t color: 8; } TEXTCOLOR;
// this was a 32 bit structure, but 8 fore, 8 back
// 8 x, 8 y failed for positioning...
// extended position, added more information
// reduced color, 16 colors is really all that there
// are... 4 bits... added bits for extended formatting
// like blink, bold, wide, high
// foreground/background  values will be
// sufficient... they retain full informaiton
//
typedef struct format_info_tag
{
   /* bit-packed flags indicating the type of format information that is applied to this segment.*/
	struct {
		// extended operation from enumeration above...
		// might shrink if more attributes are desired...
		// if many more are needed, one might consider
      // adding FONT!
     /* this segment uses the prior foreground, not its own. */
		BIT_FIELD prior_foreground : 1;
     /* this segment uses the prior background, not its own. */
		BIT_FIELD prior_background : 1;
     /* this segment uses the default foreground, not its own. */
		BIT_FIELD default_foreground : 1;
      /* this segment uses the default background, not its own. */
		BIT_FIELD default_background : 1;
      /* the foreground color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD foreground : 4;
      /* the background color of this segment (0-16 standard console text [ANSI text]) */
		BIT_FIELD background : 4;
      /* a bit indicating the text should blink if supported */
		BIT_FIELD blink : 1;
      /* a bit indicating the foreground and background color should be reversed */
		BIT_FIELD reverse : 1;
		// usually highly is bolder, perhaps it's
      // a highlighter effect and changes the background
		BIT_FIELD highlight : 1;
		// this is double height modifications to the font...
		BIT_FIELD tall : 1;
      // this is thicker characters...
		BIT_FIELD bold : 1;
      // draw a line under the text...
		BIT_FIELD underline : 1;
		// strike through - if able, draw a line right
		// through the middle of the text... maybe
		// it's a wiggly scribble line?  maybe that
      // could be extended again?
		BIT_FIELD strike : 1;
      // text is drawn wide (printer kinda font?)
		BIT_FIELD wide : 1;
       // this is pretty common......
		BIT_FIELD italic : 1;
		// --
		// these flags are free, but since we already have text segments
		// and I'm bringing in consoles, perhaps we should consider using
		// this to describe captions, but provide the api layer for CTEXTSTR
		// --
		// position data remains constant.
		// text is mounted at the top/left of the
		// first character... (unless center, then
		// the position specifies the middle of the text
		// draw vertical instead of horizontal
		BIT_FIELD bVertical:1;
		// draw opposite/upside down from normal
		// vertical/down, right/left upside down if not centered
		// if centered, the text pivots around position.
		BIT_FIELD bInvert:1;
		// 0 = default alignment 1 = left, 2 = center 3 = right
		// 0 is not set, the flag set in the lower 32 bit flags
		// is not needed any longer.... anything non zero
		// is that operation to apply.
		BIT_FIELD bAlign:2;
      /* format op indicates one of the enum FORMAT_OPS applies to this segment */
		BIT_FIELD format_op : 7;
	} flags;
	// if x,y are valid segment will have TF_POSFORMAT set...
	union {
		/* Coordinate information attached to a text segment. */
		/* Positioning specification of this text segment. with
		   basically 0 format options, position is used.
		   Position represents the distance from this segment to the
		   prior segment in count of tabs and spaces.
		   coords specifies an x,y coordinate location for the segment.
		   Usage of this union is dependant on <link text::format_info_tag::flags@1::format_op, format_op>. */
		struct {
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t x;
         // Signed coordinate of this segment on a text display.  May be relative depending on format_op.
			int16_t y;
		} coords;
		/* Defines the distance from the prior segment in count of tabs
		   and spaces (mostly count of spaces).                         */
		struct {
   // tabs preceed spaces....
			uint16_t tabs;
 // not sure what else to put with this...
			uint16_t spaces;
		} offset;
	} position;
} FORMAT, *PFORMAT;
 // special coordinate which is NO coordinate
#define IGNORE_CURSOR_POS -16384
/* test flag, format has position data */
#define TF_FORMATPOS (TF_FORMATABS|TF_FORMATREL|TF_FORMATEX)
/* these flags are used in PTEXT.flags member
 applications may use these flags to group expressions
 will affect the BuildLine but is not generated by library.
( TF_QUOTE, TF_SQUOTE, TF_BRACKET, TF_BRACE, TF_PAREN, and TF_TAG).
*/
enum TextFlags {
   // declared in program data.... do NOT release
 TF_STATIC    = 0x00000001,
   // double quoted string segment " "
 TF_QUOTE     = 0x00000002,
   // single quoted string ' '
 TF_SQUOTE    = 0x00000004,
   // bracketed expression []
 TF_BRACKET   = 0x00000008,
   // braced expression {}
 TF_BRACE     = 0x00000010,
   // parenthised expression ()
 TF_PAREN     = 0x00000020,
   // HTML tag like expression &lt;&gt;
 TF_TAG       = 0x00000040,
   // foreground is FORMAT_OP
 TF_FORMATEX  = 0x00000080,
   // x,y position used (relative)
 TF_FORMATREL = 0x00000100,
   // size field extually points at PTEXT
 TF_INDIRECT  = 0x00000200,
   // format position is x/y - else space count
 TF_FORMATABS = 0x00000800,
   // set during burst for last segment...
 TF_COMPLETE  = 0x00001000,
   // set for non-text variable
 TF_BINARY    = 0x00002000,
   // on release release indrect also...
 TF_DEEP      = 0x00004000,
   // set on first segment to send to omit lead \r\n
 TF_NORETURN  = 0x00008000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// Low bound of value...
  TF_LOWER     = 0x00010000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
  // Upper bound of a value...
  TF_UPPER     = 0x00020000,
// these values used originally for ODBC query construction....
// these values are flags stored on the indirect following a value
// label...
// boundry may be ON this value...
 TF_EQUAL     = 0x00040000,
   // this segment is not a permanent part (SubstToken)
 TF_TEMP      = 0x00080000,
  // this is something special do not treat as text indirect.
 TF_APPLICATION = 0x00100000,
};
//--------------------------------------------------------------------------
// flag combinatoin which represents actual data is present even with 0 size
// extended format operations (position, ops) are also considered data.
#define IS_DATA_FLAGS (TF_QUOTE|TF_SQUOTE|TF_BRACKET|TF_BRACE|                              TF_PAREN|TF_TAG|TF_FORMATEX|TF_FORMATABS|TF_FORMATREL)
#define DECLTEXTSZTYPE( name, size ) struct {    uint32_t flags;    struct text_segment_tag *Next, *Prior;    FORMAT format;    DECLDATA(data, size); } name
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring static buffers). Has to be cast to
   (PTEXT) is used. Is defined as a size, but no string content.
   Parameters
   name :  name of the variable to create
   size :  size of the static text element. (0 content)          */
#define DECLTEXTSZ( name, size ) DECLTEXTSZTYPE( name,(size) )	 = { TF_STATIC, NULL, NULL, {{1,1}} }
/* Defines an initializer block which can be used to satisfy a
   TEXT elemnt of a structure
   Parameters
   str :  string content of the TEXT
   Example
   <code lang="c++">
   TEXT something = DEFTEXT( "abc" );
   </code>                                                     */
#define DEFTEXT(str) {TF_STATIC,NULL,NULL,{{1,1}},{(sizeof(str)/sizeof(str[0]))-1,str}}
/* A macro to declare a structure which is the same physically
   as a PTEXT, (for declaring constant static strings
   basically). Has to be cast to (PTEXT) is used.
   Parameters
   name :   name of the variable to create
   value :  static string constant to initialize variable to.  */
#define DECLTEXT(name, str) static DECLTEXTSZTYPE( name, (sizeof(str)/sizeof(str[0])) ) = DEFTEXT(str)
/* Description
   A Text segment, it is based on DataBlock that has a length
   and an addtional region at the end of the structure which
   contains the text of the segment. Segments may have
   formatting attributes. Segments may be linked to other
   segments in a NEXTLINE/PRIORLINE. Segments may have indirect
   content, which may represent phrases. Sets of segments may
   represent sentence diagrams. A Pointer to a <link text::TEXT, TEXT>
   type.
   TEXT is a type I created to provide a variety of functions.
   One particular application was a common language processor,
   and I created the TEXT structure to store elements which are
   described by language. Sentences are words, and phases. A
   phrase is a set of words, but sometimes a word is a phrase.
   (sentence) = ( word ) ... (phrase ) ...
   (phrase) = (word)...
   hmm.. how to describe this.
   <code lang="c++">
   PTEXT phrase = NULL;
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   <code>
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   SegAppend( phrase, SegCreateFromText( "Test" ) );
   </code>
   PTEXT segments point at other segments. A list of segments is
   a sentence. Segments can have information encoded on them
   that remove text from them. For instance, \< and \> tags
   might be removed around a phrase and stored as an attribute
   of the segment. A segment with such an attribute could be an
   indirect segment that points at a list of words which are the
   phrases in the tag.
   <code lang="c++">
   a map of two segments, and their content...
       (segment with TF_TAG) -\> (segment with TF_TAG)
             |                        |
             \+ - ("html")             + - (body) -\> (background="#000000")
   would actually expand to
      \<html\>\<body background="#000000"\>
   </code>
   See Also
   SegCreate
   burst
   TextParse
   SegAppend
   SegSubst
   SegSplit
   SegGrab
   SegDelete
   LineRelease
   BuildLine
   and also.....
   PVARTEXT                                                                  */
typedef struct text_segment_tag
{
	// then here I could overlap with pEnt .bshadow, bmacro, btext ?
   uint32_t flags;
	/* This points to the next segment in the sentence or phrase. NULL
	   if at the end of the line.                                      */
		struct text_segment_tag *Next;
	/* This points to the prior segment in the sentence or phrase. (NULL
	   if at the first segment)                                          */
		struct text_segment_tag *Prior;
	/* format is 64 bits.
      it's two 32 bit bitfields (position, expression)
	 valid if TF_FORMAT is set... */
	FORMAT format;
   /* A description of the data stored here.  It is compatible with a DATABLOCk.... */
   struct {
	   /* unsigned size; size is sometimes a pointer value...
                  this means bad thing when we change platforms... Or not, since we went to uintptr_t which is big enough for a pointer. */
		uintptr_t size;
		/* the data of the test segment
		 beginning of var data - this is created size+sizeof(TEXT) */
		   TEXTCHAR  data[1];
	} data;
} TEXT, *PTEXT;
//
// PTEXT DumpText( PTEXT somestring )
//    PTExT (single data segment with full description \r in text)
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  DumpText ( PTEXT text );
//SegCreateFromText( ".." );
// Burst, SegAppend, SegGrab
// segments are ment to be lines, the meaninful tag "TF_NORETURN" means it's part of the prior line.
//--------------------------------------------------------------------------
#define HAS_WHITESPACE(pText) ( pText && ( (pText)->format.position.offset.spaces || (pText)->format.position.offset.tabs ) )
/* A convenient macro to go from one segment in a line of text
   to the next segment.                                        */
#define NEXTLINE(line)   ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Next):(NULL)))
/* A convenient macro to go from one segment in a line of text
   to the prior segment.                                       */
#define PRIORLINE(line)  ((PTEXT)(((PTEXT)line)?(((PTEXT)line)->Prior):(NULL)))
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the prior pointer of 'word' to 'line'.
   <code>
   PTEXT line;
   PTEXT word;
   SETPRIORLINE( word, line );
   </code>                                                       */
#define SETPRIORLINE(line,p) ((line)?(((line)->Prior) = (PTEXT)(p)):0)
/* Link one PTEXT segment to another. Sets one half of the links
   appropriate for usage.
   Example
   This example sets the next pointer of 'line' to 'word'.
   <code lang="c#">
   PTEXT line;
   PTEXT word;
   SETNEXTLINE( line, word );
   </code>                                                       */
#define SETNEXTLINE(line,p)  ((line)?(((line)->Next ) = (PTEXT)(p)):0)
/* Sets a pointer to PTEXT to the first text segment in the
   list.                                                    */
#define SetStart(line)     for(; line && PRIORLINE(line);line=PRIORLINE(line))
/* Sets a PTEXT to the last segment that it points to.
   Parameters
   line :  segment in the line to move to the end of.
   Remarks
   Updates the variable passed to point to the last segment. */
#define SetEnd(line)      for(; line && NEXTLINE(line); line=NEXTLINE(line))
// might also check to see if pseg is an indirect - setting this size would be BAD
#define SetTextSize(pseg, sz ) ((pseg)?((pseg)->data.size = (sz )):0)
/* gets the indect segment content (if any) from a PTEXT
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetIndirect(PTEXT segment );
/* Get the format flags of a PTEXT.
                                    */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetTextFlags( PTEXT segment );
/* Gets the text segment length. */
TYPELIB_PROC  size_t TYPELIB_CALLTYPE  GetTextSize( PTEXT segment );
/* Gets the text of a PTEXT segment. (convert to a CTEXTSTR)
   Parameters
   segment :  segment to get the string content from         */
TYPELIB_PROC  TEXTSTR TYPELIB_CALLTYPE  GetText( PTEXT segment );
// by registering for TF_APPLICTION is set on the segment
// and flags anded with the segment flags match, the
// function is called.... the result is the actual
// segment of this - since a TF_APPLICATION is also
// TF_INDIRECT - using the size to point to some application
// defined structure instead of a PTEXT structure.
TYPELIB_PROC  void TYPELIB_CALLTYPE  RegisterTextExtension ( uint32_t flags, PTEXT(CPROC*)(uintptr_t,POINTER), uintptr_t );
// similar to GetIndirect - but results in the literal pointer
// instead of the text that the application may have registered to result with.
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  GetApplicationPointer ( PTEXT text );
/* Used to set the content of a segment to some application
   defined value. This allows a users application to store
   chunks of data in lists of text. These external chunks are
   handled like other words.
   Parameters
   text :  this is the text segment to set application data on
   p :     this is a pointer to application data               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetApplicationPointer ( PTEXT text, POINTER p);
/* Set segment's indirect data.
   Parameters
   segment :  pointer to a TEXT segment to set the indirect content
              of.
   data :     pointer to a PTEXT to be referenced indirectly.       */
#define SetIndirect(Seg,Where)  ( (Seg)->data.size = ((uintptr_t)(Where)-(uintptr_t)NULL) )
		/* these return 1 for more(l1&gt;l2) -1 for (l1&lt;l2) and 0 for match.
       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  SameText ( PTEXT l1, PTEXT l2 );
/* A test if one PTEXT is similar to another PTEXT.
   Parameters
   l1 :  PTEXT segment one
   l2 :  PTEXT segment two
   Return Value List
   \<0 :  l1 with case insensitive comparison is less then l2
   0 :    Texts compare case insenitive match
   \>0 :  l1 with case insensitive comparison is more than l2 */
TYPELIB_PROC  int TYPELIB_CALLTYPE  LikeText ( PTEXT l1, PTEXT l2 );
/* Compares if text is like a C string. Case Sensitive.
   <b>Returns</b>
   TRUE if they are alike.
   FALSE if they are different.
   <b>Parameters</b>                                    */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextIs  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like).
   Returns
   TRUE if they are alike.
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextLike  ( PTEXT pText, CTEXTSTR text );
/* Compares if text is like a C string. Case insensitive (like). Uses min string length for max match.
   Returns
   TRUE if they are similar (both case insensitive using shorter of the strings for maxlen).
   FALSE if they are different.
   Parameters
   pText :  PTEXT segment to compare
   text :   C string buffer to compare against                   */
TYPELIB_PROC  int TYPELIB_CALLTYPE  TextSimilar  ( PTEXT pText, CTEXTSTR text );
//#define SameText( l1, l2 )  ( strcmp( GetText(l1), GetText(l2) ) )
#define textmin(a,b) ( (((a)>0)&&((b)>0))?(((a)<(b))?(a):(b)):(((a)>0)?(a):((b)>0)?(b):0) )
#ifdef __LINUX__
/* windows went with stricmp() and strnicmp(), whereas linux
 went with strcasecmp() and strncasecmp()                  */
#  ifdef UNICODE
#    ifndef NO_UNICODE_C
#      define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#      define stricmp strcasecmp
#    else
#      define strnicmp wcsncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#      define stricmp wcscasecmp
#    endif
#  else
#    define strnicmp strncasecmp
/* windows went with stricmp() and strnicmp(), whereas linux
   went with strcasecmp() and strncasecmp()                  */
#     define stricmp strcasecmp
#  endif
#endif
/* Copy segment formatting to another segment... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegCopyFormat( PTEXT to_this, PTEXT copy_this );
/* Create a text segment of sepecified size; inclues one more character for NUL terminator */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateEx( size_t nSize DBG_PASS );
/* Create a PTEXT with specified number of character capacity.
   Example
   <code lang="c#">
   PTEXT text = SegCreate( 10 );
   </code>                                                     */
#define SegCreate(s) SegCreateEx(s DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromText> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromTextEx( CTEXTSTR text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromText( WIDE("Around the world in a day.") );
   </code>                                                         */
#define SegCreateFromText(t) SegCreateFromTextEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromCharEx( const char *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromChar( "Around the world in a day." );
   </code>                                                         */
#define SegCreateFromChar(t) SegCreateFromCharEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromChar> */
#define SegCreateFromCharLen(t,len) SegCreateFromCharLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideLenEx( const wchar_t *text, size_t len DBG_PASS );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromWideEx( const wchar_t *text DBG_PASS );
/* Creates a PTEXT segment from a string.
   Example
   <code lang="c++">
   PTEXT line = SegCreateFromWideLen( L"Around the world in a day.", 26 );
   </code>                                                         */
#define SegCreateFromWideLen(t,len) SegCreateFromWideLenEx((t),(len) DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromWide> */
#define SegCreateFromWide(t) SegCreateFromWideEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateIndirect> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateIndirectEx( PTEXT pText DBG_PASS );
/* Creates a text segment that refers to the parameter
   indirectly. The new segment is not really a clone, but a
   reference of the original PTEXT.
   Example
   <code lang="c#">
   PTEXT phrase = SegCreateIndirect( SegAppend( SegCreateFromText( "Hello" )
                                              , SegCreateFromText( "World" ) ) );
   </code>
   The resulting phrase is a single segment with no prior or
   next, but its content is "HelloWorld" if it was passed to
   buildline... it's go the content of the two text segments
   linked together, but not in its buffer. It is actually a 0
   length buffer for a TEXT segment.
                                                                                  */
#define SegCreateIndirect(t) SegCreateIndirectEx(t DBG_SRC)
/* \ \
   See Also
   <link DBG_PASS>
   <link SegDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDuplicateEx( PTEXT pText DBG_PASS);
/* This duplicates a specific segment. It duplicates the first
   segment of a string. If the segment has indirect data, then
   the first segment of the indirect data is duplicated.       */
#define SegDuplicate(pt) SegDuplicateEx( pt DBG_SRC )
/* Duplicates a linked list of segments.
   Duplicates the structure of a line. The resulting line is an
   exact duplicate of the input line. All segments linked in
   exactly the same sorts of ways.
   Parameters
   line :  list of segments to duplicate                        */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  LineDuplicateEx( PTEXT pText DBG_PASS );
/* <combine sack::containers::text::LineDuplicateEx@PTEXT pText>
   \ \                                                           */
#define LineDuplicate(pt) LineDuplicateEx(pt DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link TextDuplicate> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS );
/* Duplicate the whole string of text to another string with
   exactly the same content.                                 */
#define TextDuplicate(pt,s) TextDuplicateEx(pt,s DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromInt> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromIntEx( int value DBG_PASS );
/* Creates a text segment from a 64 bit integer.
   Example
   <code>
   PTEXT number = SegCreateFromInt( 3314 );
   </code>                                       */
#define SegCreateFromInt(v) SegCreateFromIntEx( v DBG_SRC )
/* Converts an integer to a PTEXT segment.
   Parameters
   _64bit_value :  integer value to convert to a PTEXT segment. */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFrom_64Ex( int64_t value DBG_PASS );
/* Create a text segment from a uint64_t bit value. (long long int) */
#define SegCreateFrom_64(v) SegCreateFrom_64Ex( v DBG_SRC )
/* \ \
   See Also
   <link DBG_PASS>
   <link SegCreateFromFloat> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegCreateFromFloatEx( float value DBG_PASS );
/* Creates a text segment from a floating point value. Probably
   uses something like '%g' to format output. Fairly limited.
   Example
   <code lang="c++">
   PTEXT short_PI = SegCreateFromFloat( 3.14 );
   </code>                                                      */
#define SegCreateFromFloat(v) SegCreateFromFloatEx( v DBG_SRC )
/* Appends a list of segments to an existing list of segments. This
   assumes that the additional segment is referncing the head of
   the segment list.
   Parameters
   source :  source list to add to
   other :   additional segments to add to source.                  */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegAppend   ( PTEXT source, PTEXT other );
/* Inserts a segment before another segment.
   Parameters
   what :    what to insert into the list
   before :  insert the segments before this segment
   Returns
   The parameter 'what'.                             */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegInsert   ( PTEXT what, PTEXT before );
/* This expands a segment by a number of characters.
   Parameters
   PTEXT :  the segment to expand
   int :    count of character to expand by
   Returns
   A pointer to a new segment that is bigger, but has the same
   existing content.                                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegExpandEx (PTEXT source, INDEX nSize DBG_PASS );
/* <combine sack::containers::text::SegExpandEx@PTEXT@INDEX nSize>
   \ \                                                             */
#define SegExpand(s,n) SegExpandEx( s,n DBG_SRC )
/* Release a linked list of PTEXT segments.
   Parameters
   segments :  a segment in a list of segments to delete, first
               this routine goes to the start of the segment
               list, and then deletes all segments in the list.
   DBG_PASS :  debug file and line information                  */
TYPELIB_PROC  void TYPELIB_CALLTYPE   LineReleaseEx (PTEXT line DBG_PASS );
/* Release a line of text.
   A line may be a single segment.
   This is the proper way to dispose of PTEXT segments.
   Any segment in the line may be passed, the first segment is
   found, and then all segments in the line are deleted.       */
#define LineRelease(l) LineReleaseEx(l DBG_SRC )
/* \ \
   <b>See Also</b>
   <link DBG_PASS>
   <link SegRelease> */
TYPELIB_PROC  void TYPELIB_CALLTYPE  SegReleaseEx( PTEXT seg DBG_PASS );
/* Release a single segment. UNSAFE. Does not respect that it is
   in a list.
   See Also
   <link LineRelease>                                            */
#define SegRelease(l) SegReleaseEx(l DBG_SRC )
/* Adds a part of input to the segment list of output.
   Parameters
   output\ :   the segment list to append to.
   input\ :    the input buffer to append from
   offset :    starting offset in 'input' to start from
   length :    how much from 'offset' in input to append as a new
               segment to output.
   DBG_PASS :  \file and line debugging information               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegConcatEx   (PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS);
/* <combine sack::containers::text::SegConcatEx@PTEXT@PTEXT@int32_t@size_t length>
   looks like it takes a peice of one segment and appends it to
   another....
   Needs More research to document correctly and exemplify.                     */
#define SegConcat(out,in,ofs,len) SegConcatEx(out,in,ofs,len DBG_SRC)
/* Removes a segment from a list of segments. Links what was
   prior and what was after together. Sets both next and prior
   of the segment unlinked to NULL.
   Example
   <code lang="c++">
   SegUnlink( segment );
   </code>
   Returns
   The segment passed.                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegUnlink   (PTEXT segment);
/* Breaks a list of PTEXT segments at the specified segment and
   \returns a segment that was before the specified.
   Parameters
   segment :  segment to break the chain at
   Returns
   Any existing segment before the segment to break at.
   Example
   <code lang="c++">
   {
      PTEXT segs;
      PTEXT breakat;
      PTEXT leftover;
		&#47;* ... segs gets populated with some segments ... *&#47;
      breakat = NEXTLINE( segs );
   </code>
   <code>
      breakat = NEXTLINE( segs );
      leftover = segbreak( breakat );
      // now breakat begins a new chain of segments
      // leftover is the segment that was just before breakat
      SegStart( leftover );  // leftover would be equal to segs...
   }
   </code>                                                         */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegBreak    (PTEXT segment);
/* Removes a segment from a list. It also releases the segment.
    Example
    <code lang="c#">
    SegDelete( segment );
    </code>
    the result is NULL;                                          */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegDelete   (PTEXT segment);
/* removes segment from any list it might be in, returns
   segment.                                              */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegGrab     (PTEXT segment);
/* Substitute one PTEXT segment for another in a list of PTEXT
   segments.
   Parameters
   _this :  This is the segment to remove
   that :   This is the segment to subustitute with. This may be
            a list of segments, and it is linked in from the
            first segment to the prior to '_this' and the last to
            the next after '_this'
   Returns
   \Returns the '_this' that was substituted.                     */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSubst    ( PTEXT _this, PTEXT that );
/* \ \
   See Also
   <link DBG_PASS>
   <link SegSplit> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  SegSplitEx( PTEXT *pLine, INDEX nPos DBG_PASS);
/* Split a PTEXT segment.
   Example
   \ \
   <code lang="c++">
   PTEXT result = SegSplit( &amp;old_string, 5 );
   </code>
   Returns
   PTEXT new_string;
   Remarks
   the old string segment is split at the position indicated. The
   pointer to the old segment is modified to point to now two
   segments linked dynamically, each part of the segment after
   the split. If the index is beyond the bounds of the segment,
   the segment remains unmodified.                                */
#define SegSplit(line,pos) SegSplitEx( line, pos DBG_SRC )
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Create a highest precision signed integer from a PTEXT. */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromSeg( PTEXT pText );
/* Converts a text to the longest precision signed integer
   value.                                                  */
TYPELIB_PROC  int64_t TYPELIB_CALLTYPE  IntCreateFromText( CTEXTSTR p );
/* Create a high precision floating point value from PTEXT
   segment.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromSeg( PTEXT pText );
/* Create a high precision floating point value from text
   string.                                                */
TYPELIB_PROC  double TYPELIB_CALLTYPE  FloatCreateFromText( CTEXTSTR p, CTEXTSTR *pp );
//
// IsSegAnyNumber returns 0 if no, 1 if is int, 2 if is float
//   if pfNumber or piNumber are available then the text pointer
//   will be updated to the next segment after what was used to resolve
//   the number.
//   bUseAllSegs is for testing pTexts which are indirect, such that
//      only all segments within the indirect segment will result valid.
//   pfNumber and piNumber may be passed as NULL, and the function can still
// be used to determine ifnumber
//   the number resulting in the values pointed to will be filled in
//    with (*pfNumber)=FltCreateFromSeg(p) (or Int as appropriate)
//
//#define IsNumber(p) IsSegAnyNumberEx( &(p), NULL, NULL, NULL, 0 )
#define IsIntNumber(p, pint) IsSegAnyNumberEx( &(p), NULL, pint, NULL, 0 )
/* Tests a PTEXT segment to see if it might be a floating point
   number.                                                      */
#define IsFltNumber(p, pflt) IsSegAnyNumberEx( &(p), pflt, NULL, NULL, 0 )
/* Tests the content of a PTEXT to see if it might be a number.
   Parameters
   ppText :       pointer to PTEXT to check
   pfNumber :     pointer to double to get result of number it's
                  a float
   piNumber :     pointer to a signed 64 bit value to get the
                  \result if it's not a float.
   pbIsInt :      point to a integer \- receives boolean result
                  if the segment was an integer is TRUE else it's
                  a double.
   bUseAllSegs :  if TRUE, use all the segments starting with the
                  first, and update the pointer to the next
                  stgment. If false, use only the first segment. if
                  uses all segments, it must also use ALL
                  segments to get the number.
   Returns
   0 if not a number or fails.
   1 if a valid conversion took place.                              */
TYPELIB_PROC  int TYPELIB_CALLTYPE  IsSegAnyNumberEx ( PTEXT *ppText, double *pfNumber, int64_t *piNumber, int *pbIsInt, int bUseAllSegs );
/* <combine sack::containers::text::IsSegAnyNumberEx@PTEXT *@double *@int64_t *@int *@int>
   \ \                                                                                  */
#define IsSegAnyNumber(pptext, pfNum, piNum, pbIsInt) IsSegAnyNumberEx( pptext, pfNum, piNum, pbIsInt, 0 )
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure from
   nTabSize :  how big tabs are supposed to be
   tabs :      list of tab positions (for arbitrary tab
               positioning\- table column alignment?)           */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpaceEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs);
/* \Returns the amount of space required to store this segment,
   and all indirect statements it contains.
   Parameters
   segment :   segment to measure
   position :  starting position in the segment to measure
               from
   nTabSize :  how big tabs are supposed to be                  */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize );
/* Simlar to getsegment space... */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLengthEx ( PTEXT segment, INDEX position, int nTabs, INDEX *tabs );
/* \Returns the length of a single PTEXT segment.
   Parameters
   segment :   segment to measure
   position :  string position in the string to measure
   nTabSize :  how many characters a tab is supposed to be. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  GetSegmentLength ( PTEXT segment, INDEX position, int nTabSize );
/* Measure the length of a list of segments (combined length of
   all linked segments)                                         */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL );
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  LineLengthExx( PTEXT pt, LOGICAL bSingle,PTEXT pEOL );
/* <combine sack::containers::text::LineLengthExEx@PTEXT@LOGICAL@int@PTEXT>
   \ \                                                                      */
#define LineLengthExx(pt,single,eol) LineLengthExEx( pt,single,8,eol)
/* \ \
   Parameters
   Text segment :  PTEXT line or segment to get the length of
   single :        boolean, if set then only a single segment is
                   measured, otherwise all segments from this to
                   the end are measured.                         */
#define LineLengthEx(pt,single) LineLengthExx( pt,single,NULL)
/* Computes the length of characters in a line, if all segments
   in the line are flattened into a single word.                */
#define LineLength(pt) LineLengthEx( pt, FALSE )
/* Collapses an indirect segment or a while list of segments
   into a single segment with content expanded. When passed to
   things like TextParse and Burst, segments have their
   positioning encoded to counters for tabs and spaces; the
   segment itself contains only text without whitespace. Buildline
   expands these segments into their plain text representation.
   Parameters
   pt :        pointer to a PTEXT segment.
   bSingle :   if TRUE, build only the first segment. If the
               segment is indirect, builds entire content of
               indirect.
   nTabsize :  how wide tabs are. When written into a line, tabs
               are written as spaces. (maybe if 0, tabs are
               emitted directly?)
   pEOL :      the segment to use to represent an end of line. Often
               this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS );
/* Collapses an indirect segment or a while list of segments
into a single segment with content expanded. When passed to
things like TextParse and Burst, segments have their
positioning encoded to counters for tabs and spaces; the
segment itself contains only text without whitespace. Buildline
expands these segments into their plain text representation.
Parameters
pt :        pointer to a PTEXT segment.
bSingle :   if TRUE, build only the first segment. If the
segment is indirect, builds entire content of
indirect.
pEOL :      the segment to use to represent an end of line. Often
this is a SegCreate(0) segment.                       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS );
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
\ \                                                                          */
#define BuildLineExx(from,single,eol) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \                                                                          */
#define BuildLineEx(from,single) BuildLineExEx( from,single,8,NULL DBG_SRC )
/* <combine sack::containers::text::BuildLineExEx@PTEXT@LOGICAL@int@PTEXT pEOL>
   \ \
    Flattens all segments in a line to a single segment result.
*/
#define BuildLine(from) BuildLineExEx( from, FALSE,8,NULL DBG_SRC )
//
// text parse - more generic flavor of burst.
//
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
// filter_to_space WIDE(" \t")
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  TextParse ( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_tospace, int bTabs, int bSpaces  DBG_PASS );
/* normal_punctuation=WIDE("'"\\({[\<\>]}):@%/,;!?=*&amp;$^~#`");
   Process a line of PTEXT into another line of PTEXT, but with
   words parsed as appropriate for common language.
   Parameters
   input\ :  pointer to a list of PTEXT segments to parse.
   Remarks
   Burst is a simple method of breaking a sentence into its word
   and phrase parts. It collapses space and tabs before words
   into the word. Any space representation is space preceeding
   the word. Sentences are also broken on any punctuation.
   "({[\<\>]})'";;.,/?\\!@#$%^&amp;*=" for instances. + and - are
   treated specially if they prefix numbers, otherwise they are
   also punctuation. Also groups of '.' like '...' are kept
   together. if the '.' is in a number, it is stored as part of
   the number. Otherwise a '.' used in an abbreviation like P.S.
   will be a '.' with 0 spaces followed by a segment also with 0
   spaces. (unless it's the lsat one)
   so initials are encoded badly.
   Bugs
   There is an exploit in the parser such that . followed by a
   number will cause fail to break into seperate words. This is
   used by configuration scripts to write binary blocks, and
   read them back in, having the block parsed into a segment
   correctly.
   See Also
   <link sack::containers::text::TextParse@PTEXT@CTEXTSTR@CTEXTSTR@int@int bSpaces, TextParse> */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  burstEx( PTEXT input DBG_PASS);
/* <combine sack::containers::text::burstEx@PTEXT input>
   \ \                                                   */
#define burst( input ) burstEx( (input) DBG_SRC )
/* Compares a couple lists of text segments.
   Parameters
   pt1 :      pointer to a phrase
   single1 :  use only the first word, not the whole phrase
   pt2 :      pointer to a phrase
   single2 :  use only the first segment, not the whole phrase
   bExact :   if FALSE, match case insensitive, otherwise match
              exact case.                                       */
TYPELIB_PROC  int TYPELIB_CALLTYPE  CompareStrings( PTEXT pt1, int single1
                            , PTEXT pt2, int single2
                            , int bExact );
/* This removes indirect segments, replacing them with their
   indirect content.
   Parameters
   pLine :  pointer to a PTEXT segment list to flatten.      */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  FlattenLine ( PTEXT pLine );
/* Steps through a linked list of segments, just a convenient
   for loop wrapper.                                          */
#define FORALLTEXT(start,var)  for(var=start;var; var=NEXTLINE(var))
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8( char *output, TEXTRUNE rune );
/* returns number of characters filled into output.  Output needs to be at maximum 6 chars;  if overlong is set
   characters are deliberatly padded to be overlong */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong );
/* returns number of wchar filled into output.  Output needs to be at maximum 2 wchar. */
TYPELIB_PROC int TYPELIB_CALLTYPE ConvertToUTF16( wchar_t *output, TEXTRUNE rune );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfChar( const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexed( const char *from, size_t *index, size_t length );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfChar( const char *start, const char **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexed( const char *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharW( const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharW( const wchar_t *start, const wchar_t **from );
TYPELIB_PROC TEXTRUNE TYPELIB_CALLTYPE GetPriorUtfCharIndexedW( const wchar_t *from, size_t *index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE GetDisplayableCharacterCount( const char *string, size_t max_bytes );
TYPELIB_PROC CTEXTSTR TYPELIB_CALLTYPE GetDisplayableCharactersAtCount( const char *string, size_t character_index );
TYPELIB_PROC size_t TYPELIB_CALLTYPE  GetDisplayableCharacterBytes( const char *string, size_t character_count );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS );
/* You Must Deallocate the result */
TYPELIB_PROC  char * TYPELIB_CALLTYPE  WcharConvertEx ( const wchar_t *wch DBG_PASS );
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvertLen(s,len) WcharConvertExx(s, len DBG_SRC )
/* <combine sack::containers::text::WcharConvertExx@wchar_t *@size_t len>
   \ \                                                                    */
#define WcharConvert(s) WcharConvertEx(s DBG_SRC )
/* You Must Deallocate the result */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertExx ( const char *wch, size_t len DBG_PASS );
/* Convert wchar_t strings to char strings.
   Parameters
   string :    wchar_t string to convert
   DBG_PASS :  debug file and line information
   Returns
   A char * string. This string must be Release()'ed or
   Deallocate()'ed by the user.                         */
TYPELIB_PROC wchar_t * TYPELIB_CALLTYPE CharWConvertEx ( const char *wch DBG_PASS );
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvertLen(s,len) CharWConvertExx(s,len DBG_SRC )
/* <combine sack::containers::text::CharWConvertExx@char *@size_t len>
   \ \                                                                 */
#define CharWConvert(s) CharWConvertEx(s DBG_SRC )
//--------------------------------------------------------------------------
/* This is a string collector type.  It has an interface to be able to vtprintf( vartext, "format string", ... ); which appends the specified string to the collected text.
  Example
   PVARTEXT pvt = VarTextCreate();
   vtprintf( pvt, "hello world!" );
   {
      PTEXT text = VarTextGet( pvt );
	  printf( "Text is : %s(%d)", GetText( text ), GetTextSize( text ) );
	  LineRelease( text );
   }
   VarTextDestroy( &pvt );
   */
typedef struct vartext_tag *PVARTEXT;
/* Creates a variable text collector. Allows specification of
   initial size and amount to expand by. SQL Command line sample
   utility uses this and allocates like 10,000 initial and sets
   expand as 40,000, because it expects to build very large
   strings, and expansion of 32 at a time is ludicrous; if the
   space required is more than the expansion factor, then it is
   expanded by the amount required plus the expansion factor.
   Parameters
   initial :   amount of initial buffer
   exand_by :  how much to expand the buffer by when more room
               is needed
   DBG_PASS :  debug file and line parameters.                   */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS );
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   \ \                                                                */
#define VarTextCreateExx(i,e) VarTextCreateExEx(i,e DBG_SRC )
/* <combine sack::containers::text::VarTextCreateExEx@uint32_t@uint32_t expand>
   Creates a variable text collector. Default initial size and
   expansion is 0 and 32.
                                                                      */
TYPELIB_PROC  PVARTEXT TYPELIB_CALLTYPE  VarTextCreateEx ( DBG_VOIDPASS );
/* The simplest, most general way to create a PVARTEXT
   collector. The most extended vartext creator allows
   specification of how long the initial buffer is, and how much
   the buffer expands by when required. This was added to
   optimize building HUGE SQL queries, working withing 100k
   buffers that expanded by 50k at a time was a lot less
   operations than expanding 32 bytes or something at a time.    */
#define VarTextCreate() VarTextCreateEx( DBG_VOIDSRC )
/* Empties and destroys all resources associated with the
   variable text collector.
   Parameters
   pvt * :     address of a PVARTEXT reference to destroy. Sets
               the pointer to NULL when it's destroyed.
   DBG_PASS :  debugging file and line parameters
   Example
   <code lang="c++">
   {
      PVARTEXT pvt = VarTextCreate();
      VarTextDestroy( &amp;pvt );
   }
   void Function( int something DBG_PASS )
   {
      pvt = VarTextCreateEx( DBG_RELAY );
      VarTextDestroyEx( &amp;pvt DBG_RELAY );
   }
   </code>
   C++ Syntax
   \ \                                                          */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextDestroyEx ( PVARTEXT* DBG_PASS );
/* Destroy a VarText collector. */
#define VarTextDestroy(pvt) VarTextDestroyEx( pvt DBG_SRC )
/* \Internal function - used to initialize a VARTEXT structure. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextInitEx( PVARTEXT pvt DBG_PASS);
/* Probably should not be exported. Initializes a VARTEXT
   structure to prepare it for subsequent VarText operations. */
#define VarTextInit(pvt) VarTextInitEx( (pvt) DBG_SRC )
/* Empties a PVARTEXT structure.
   Parameters
   pvt :  PVARTEXT to empty.     */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextEmptyEx( PVARTEXT pvt DBG_PASS);
/* <combine sack::containers::text::VarTextEmptyEx@PVARTEXT pvt>
   \ \                                                           */
#define VarTextEmpty(pvt) VarTextEmptyEx( (pvt) DBG_SRC )
/* Add a single character to a vartext collector.
   Note
   \ \
   Parameters
   pvt :       PVARTEXT to add character to
   c :         character to add
   DBG_PASS :  optional debug information         */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS );
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddCharacter( pvt, 'a' );
   </code>                                          */
#define VarTextAddCharacter(pvt,c) VarTextAddCharacterEx( (pvt),(c) DBG_SRC )
/* Adds a single rune to a PVARTEXT collector. (may be multiple characters convert to UTF8)
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddRune( pvt, 'a' );
   </code>                                          */
#define VarTextAddRune(pvt,c) VarTextAddRuneEx( (pvt),(c), FALSE DBG_SRC )
/* Adds a length of data to the vartext. This allows strings
   with nuls included to be added.
   Parameters
   pvt :       PVARTEXT to add data to
   block :     pointer to data to add
   size :      length of data block to add
	DBG_PASS :  optional file and line parameters             */
#define VARTEXT_ADD_DATA_NULTERM ((size_t)0xFF000000)
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS );
/* Adds a single character to a PVARTEXT collector.
   Example
   <code lang="c++">
   PVARTEXT pvt = VarTextCreate();
   VarTextAddData( pvt, "test one", 8 );
   </code>                                          */
#define VarTextAddData(pvt,block,length) VarTextAddDataEx( (pvt),(block),(length) DBG_SRC )
/* Commits the currently collected text to segment, and adds the
   segment to the internal line accumulator.
		 returns true if any data was added...
       move any collected text to commit... */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  VarTextEndEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextEndEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextEnd(pvt) VarTextEndEx( (pvt) DBG_SRC )
/* Gets the length of the current collection in the VARTEXT.
   Parameters
   pvt :  PVARTEXT collector to get the length.              */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  VarTextLength( PVARTEXT pvt );
/* Gets the text segment built in the VarText. The PVARTEXT is
   set to empty. Clears the collector.
   Parameters
   pvt :  PVARTEXT to get text from.                           */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextGetEx( PVARTEXT pvt DBG_PASS );
/* <combine sack::containers::text::VarTextGetEx@PVARTEXT pvt>
   \ \                                                         */
#define VarTextGet(pvt) VarTextGetEx( (pvt) DBG_SRC )
/* Used to look at the vartext collector and get the current
   collection. Does not clear the collector.
   Parameters
   pvt :       PVARTEXT collector to peek at
   DBG_PASS :  debugging file and line parameters
   Return Value List
   NULL :      No data
   not NULL :  text segment which is in the collector.       */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  VarTextPeekEx ( PVARTEXT pvt DBG_PASS );
/* \Returns the PTEXT that is currently in a PVARTEXT. It does
   not alter the contents of the PVARTEXT. Do not LineRelease
   this peeked value.                                          */
#define VarTextPeek(pvt) VarTextPeekEx( (pvt) DBG_SRC )
/* Increases the internal storage size of the variable text
   collector.
   Parameters
   pvt :       the var text collector to expand
   amount :    amount of size to expand the collector
   DBG_PASS :  debugging file and line parameters           */
TYPELIB_PROC  void TYPELIB_CALLTYPE  VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS );
/* Add a specified number of characters to the amount of space
   in the VARTEXT collector.                                   */
#define VarTextExpand(pvt, sz) VarTextExpandEx( (pvt), (sz) DBG_SRC )
//TYPELIB_PROC  int vtprintfEx( PVARTEXT pvt DBG_PASS TYPELIB_CALLTYPE  CTEXTSTR format, ... ;
// note - don't include format - MUST have at least one parameter passed to ...
//#define vtprintf(pvt, ...) vtprintfEx( (pvt) DBG_SRC, __VA_ARGS__ )
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vtprintfEx( PVARTEXT pvt, CTEXTSTR format, ... );
/* <combine sack::containers::text::vtprintfEx@PVARTEXT@CTEXTSTR@...>
   Note                                                               */
#define vtprintf vtprintfEx
/* variable argument VARTEXT printf. Is passed a PVARTEXT to
   collect the formatted output using printf sort of formatting. */
TYPELIB_PROC  INDEX TYPELIB_CALLTYPE  vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args );
/* encode binary buffer into base64 encoding.
   outsize is updated with the length of the buffer.
 */
TYPELIB_PROC  TEXTCHAR * TYPELIB_CALLTYPE  EncodeBase64Ex( uint8_t* buf, size_t length, size_t *outsize, const char *encoding );
/* decode base64 buffer into binary buffer
   outsize is updated with the length of the buffer.
   result should be Release()'d
 */
TYPELIB_PROC  uint8_t * TYPELIB_CALLTYPE  DecodeBase64Ex( char* buf, size_t length, size_t *outsize, const char *encoding );
/* xor a base64 encoded string over a utf8 string, keeping the utf8 characters in the same length...
   although technically this can result in invalid character encoding where upper bits get zeroed
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs );
/* xor two base64 encoded strings, resulting in a base64 string
   result should be Release()'d
*/
TYPELIB_PROC  char * TYPELIB_CALLTYPE  b64xor( const char *a, const char *b );
//--------------------------------------------------------------------------
// extended command entry stuff... handles editing buffers with insert/overwrite/copy/paste/etc...
typedef struct user_input_buffer_tag {
	// -------------------- custom cmd buffer extension
  // position counter for pulling history
	INDEX nHistory;
  // a link queue which contains the prior lines of text entered for commands.
	PLINKQUEUE InputHistory;
 // set to TRUE when nHistory has wrapped...
	int   bRecallBegin;
   /* A exchange-lock variable for controlling access to the
      \history (so things aren't being read from it while it is
      scrolling old data out).                                  */
	uint32_t   CollectionBufferLock;
  // used to store index.. for insert type operations...
	INDEX CollectionIndex;
 // flag for whether we are inserting or overwriting
	int   CollectionInsert;
 // flag for whether we are inserting or overwriting
	int   storeCR;
 // used to store partial from GatherLine
	PTEXT CollectionBuffer;
 // called when a buffer is complete.
	void (CPROC*CollectedEvent)( uintptr_t psv, PTEXT text );
  // passed to the event callback when a line is completed
	uintptr_t psvCollectedEvent;
} USER_INPUT_BUFFER, *PUSER_INPUT_BUFFER;
/* Creates a buffer structure which behaves like the command
   line command recall queue.
                                                             */
TYPELIB_PROC  PUSER_INPUT_BUFFER TYPELIB_CALLTYPE  CreateUserInputBuffer ( void );
/* Destroy a created user input buffer. */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyUserInputBuffer ( PUSER_INPUT_BUFFER *pci );
// negative with SEEK_SET is SEEK_END -nPos
enum CommandPositionOps {
	// defined that the x,y position in the segment should be used for absolute positioning.
   // can also be SEEK_SET
 COMMAND_POS_SET = 0,
 // defined that the x,y position in the segment should be used for relative positioning.
 // can also be SEEK_CUR
 COMMAND_POS_CUR = 1
};
/* Updates the current input position, for things like input,
   etc. Some external process indicates where in the line to set
   the cursor position.                                          */
TYPELIB_PROC  LOGICAL TYPELIB_CALLTYPE  SetUserInputPosition ( PUSER_INPUT_BUFFER pci, int nPos, int whence );
// bInsert < 0 toggle insert.  bInsert == 0 clear isnert(set overwrite) else
// set insert (clear overwrite )
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputInsert ( PUSER_INPUT_BUFFER pci, int bInsert );
TYPELIB_PROC  void TYPELIB_CALLTYPE  SetUserInputSaveCR( PUSER_INPUT_BUFFER pci, int bSaveCR );
/* Get the next command in the queue in the speicifed direction
   Parameters
   pci :  pointer to command input buffer
   bUp :  if TRUE \- get older command; else get the newer
          command.                                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RecallUserInput ( PUSER_INPUT_BUFFER pci, int bUp );
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GetUserInputLine( PUSER_INPUT_BUFFER pOutput );
/* Add a buffer to the history buffer.
                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  EnqueUserInputHistory ( PUSER_INPUT_BUFFER pci, PTEXT pHistory );
/* Arbitrary PTEXT blocks are fed to the user input queue with
   this.
   Parameters
   pci :     pointer to command buffer
   stroke :  the stroke to add to the buffer (may be a whole
             String or linked list of segments). or NULL if
             getting existing input...
   Return Value List
   NULL :      There is no command available \- no text followed
               by a newline.
   not NULL :  A command line collected from the input text. There
               may be multiple commands in a single 'stroke'
               buffer.
   Example
   This may be used something like .... to add the storke to the
   \input buffer, and while there is a result, get the result
   from the buffer.
   <code lang="c++">
   {
       PUSER_INPUT_BUFFER pci = CreateUserInputBuffer();
       PTEXT result;
       for( result = GatherUserInput( pci, new_stroke ); result; result = GatherUserInput( pci, NULL ) )
       {
       }
   }
   </code>                                                                                               */
TYPELIB_PROC  PTEXT TYPELIB_CALLTYPE  GatherUserInput ( PUSER_INPUT_BUFFER pci, PTEXT stroke );
/* delete 1 character at current user input index */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DeleteUserInput( PUSER_INPUT_BUFFER pci );
/* Converts ascii character set to ebcidc. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertAsciiEbdic( TEXTSTR text, INDEX length );
/* Routine to convert from ebcdic character set to ascii. */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE  ConvertEbcdicAscii( TEXTSTR text, INDEX length );
/* Converts ascii 85 to ascii */
TYPELIB_PROC TEXTSTR FtnATA( TEXTSTR buf );
/* Converts ascii character set to ascii 85  */
TYPELIB_PROC TEXTSTR ATFtnA( TEXTSTR buf );
/* Expand characters which are outside of standard ascii to URI
   compatible escapes.
   Parameters
   text :        Text to convert
   length :      max length of text to convert
   skip_slash :  if TRUE, keep slash characters as literal,
                 otherwise they get converted.                  */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash );
/* Converts URI escape characters like %3B to the appropriate
   ascii characters. The resulting string must be released by
   the application.
   Parameters
   text :    TEXTCHAR * string to convert.
   length :  max length of text to convert.
   Example
   <code lang="c++">
   TEXTCHAR *sample = WIDE( "https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=%3B+%5C+%2B+:+";
   TEXTCHAR *result;
   \result = ConvertURIText( sample, StrLen( sample ) );
   \result == https://www.google.com/#hl=en&amp;sugexp=eqn&amp;cp=11&amp;gs_id=1a&amp;xhr=t&amp;q=;+\\+++:+
   </code>                                                                                                                        */
TYPELIB_PROC TEXTSTR TYPELIB_CALLTYPE ConvertURIText( CTEXTSTR text, INDEX length );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE ParseIntVector( CTEXTSTR data, int **pData, int *nData );
#ifdef __cplusplus
 //namespace text {
};
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
	namespace BinaryTree {
#endif
/* This type defines a specific node in the tree. It is entirely
   private, and is a useless definition.                         */
typedef struct treenode_tag *PTREENODE;
/* Defines a Binary Tree.
   See Also
   <link CreateBinaryTree> */
typedef struct treeroot_tag *PTREEROOT;
/* This option may be passed to extended CreateBinaryTree
   methods to disallow adding of duplicates. Otherwise
   duplicates will be added; they will be added to the side of
   the node with the same value that has less children. Trees
   are created by default without this option, allowing the
   addition of duplicates.
   Example
   <code lang="c++">
   PTREEROOT = <link CreateBinaryTreeExtended>( BT_OPT_NODUPLICATES, NULL, NULL DBG_SRC );
   </code>                                                                                 */
#define BT_OPT_NODUPLICATES 1
/* Generic Compare is the type declaration for the callback routine for user custom comparisons.
  This routine should return -1 if new is less than old, it should return 1 if new is more than old, and it
  should return 0 if new and old are the same key. */
typedef int (CPROC *GenericCompare)( uintptr_t oldnode,uintptr_t newnode );
/* Signature for the user callback passed to CreateBinaryTreeEx
   that will be called for each node removed from the binary
   list.                                                        */
typedef void (CPROC *GenericDestroy)( CPOINTER user, uintptr_t key);
/* when adding a node if Compare is NULL the default method of a
   basic unsigned integer compare on the key value is done. if
   Compare is specified the specified key value of the orginal
   node (old) and of the new node (new) is added. Result of
   compare should be ( \<0 (lesser)) ( 0 (equal)) ( \>0
   (greater))
   Example
   <code lang="c++">
   int CPROC MyGenericCompare( uintptr_t oldnode,uintptr_t newnode )
   {
   </code>
   <code>
      if(oldnode\>newnode)
          return 1;
      else if(oldnode\<newnode)
          return -1;
      else return 0;
   </code>
   <code lang="c++">
      return (oldnode\>newnode)? 1
             \:(oldnode\<newnode)? -1
             \:0;
   }
   void CPROC MyGenericDestroy(POINTER user, uintptr_t key)
   {
      // do something custom with your user data and or key value
   }
   PTREEROOT tree = CreateBinaryTreeExtended( 0 // BT_OPT_NODUPLICATES
                                            , MyGenericCompare
                                            , MyGenericDestroy
                                            <link DBG_PASS, DBG_SRC> );
   </code>
   See Also
   <link CreateBinaryTreeExx>
   <link CreateBinaryTreeEx>
   <link CreateBinaryTree>                                               */
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  CreateBinaryTreeExtended( uint32_t flags
															, GenericCompare Compare
															, GenericDestroy Destroy DBG_PASS);
/* This is the simpler case of <link CreateBinaryTreeExtended>,
   which does not make you pass DBG_SRC.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, NULL, NULL );
   </code>                                                                  */
#define CreateBinaryTreeExx(flags,compare,destroy) CreateBinaryTreeExtended(flags,compare,destroy DBG_SRC)
/* Creates a binary tree, allowing specification of comparison
   and destruction routines.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTreeEx( <link CreateBinaryTreeExtended, MyGenericCompare>, <link CreateBinaryTreeExtended, MyGenericDestroy> );
   </code>                                                                                                                                      */
#define CreateBinaryTreeEx(compare,destroy) CreateBinaryTreeExx( 0, compare, destroy )
/* This is the simplest way to create a binary tree.
   The default compare routine treats 'key' as an integer value
   that is compared against other for lesser/greater condition.
   This tree also allows duplicates to be added.
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   </code>                                                      */
#define CreateBinaryTree() CreateBinaryTreeEx( NULL, NULL )
/* \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   DestroyBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DestroyBinaryTree( PTREEROOT root );
/* Drops all the nodes in a tree so it becomes empty...
   \ \
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   ResetBinaryTree( tree );
   tree = NULL;
   </code>                              */
TYPELIB_PROC  void TYPELIB_CALLTYPE  ResetBinaryTree( PTREEROOT root );
/* Balances a binary tree. If data is added to a binary list in
   a linear way (from least to most), the tree can become
   unbalanced, and all be on the left or right side of data. This
   routine can analyze branches and perform rotations so that
   the tree can be discretely rebalanced.
   Example
   <code lang="c++">
   <link PTREEROOT> tree;
   // <link AddBinaryNode>...
   BalanceBinaryTree( tree );
   </code>                                                        */
TYPELIB_PROC  void TYPELIB_CALLTYPE  BalanceBinaryTree( PTREEROOT root );
/* \ \
   See Also
   <link AddBinaryNode>
   <link DBG_PASS>
                        */
TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNodeEx( PTREEROOT root
                                                   , CPOINTER userdata
                                                   , uintptr_t key DBG_PASS );
/* Adds a user pointer identified by key to a binary list.
   See Also
   <link BinaryTree::CreateBinaryTree, CreateBinaryTree>
   Example
   <code lang="c++">
   PTREEROOT tree = CreateBinaryTree();
   uintptr_t key = 1;
   POINTER data = NewArray( TEXTCHAR, 32 );
   AddBinaryNode( tree, data, key );
   </code>
   Parameters
   root :  PTREEROOT binary tree instance.
   data :  POINTER to some user object.
   key :   uintptr_t a integer type which can be used to identify
           the data. (used to compare in the tree).<p /><p />If
           the user has specified a custom comparison routine in
           an extended CreateBinaryTree(), then this value might
           be a pointer to some other data. Often the thing used
           to key into a binary tree is a <link CTEXTSTR>.
   Returns
   The tree may be created with <link BT_OPT_NODUPLICATES>, in
   which case this will result FALSE if the key is found
   duplicated in the list. Otherwise this returns TRUE. if the
   root parameter is NULL, the result is FALSE.                  */
#define AddBinaryNode(r,u,k) AddBinaryNodeEx((r),(u),(k) DBG_SRC )
//TYPELIB_PROC  int TYPELIB_CALLTYPE  AddBinaryNode( PTREEROOT root
//                                    , POINTER userdata
//                                    , uintptr_t key );
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveBinaryNode( PTREEROOT root, POINTER use, uintptr_t key );
/* Search in a binary tree for the specified key.
   Returns
   user data POINTER if found, else NULL.
   Example
   <code lang="c++">
   PTREEROOT tree;
   void f( void )
   {
      CPOINTER mydata = FindInBinaryTree( tree, 5 );
      if( mydata )
      {
          // found '5' as the key in the tree
      }
   }
   </code>                                          */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  FindInBinaryTree( PTREEROOT root, uintptr_t key );
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  LocateInBinaryTree( PTREEROOT root, uintptr_t key
														, int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key ) );
/* During FindInBinaryTree and LocateInBinaryTree, the last
   found result is stored. This function allows deletion of that
   node.
   Example
   <code lang="c++">
   FindInBinaryTree( tree, 5 );
   RemoveLastFoundNode( tree );
   </code>                                                       */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveLastFoundNode(PTREEROOT root );
/* Removes the currently browsed node from the tree.
   See Also
   <link GetChildNode>                               */
TYPELIB_PROC  void TYPELIB_CALLTYPE  RemoveCurrentNode(PTREEROOT root );
/* Basically this is meant to dump to a log, if the print
   function is passed as NULL, then the tree's contents are
   dumped to the log. It dumps a very cryptic log of how all
   nodes in the tree are arranged. But by allowing the user to
   provide a method to log his data and key, the logging is more
   meaningful based on the application. The basic code for
   managing trees and nodes works....
   Example
   <code>
   int ForEachNode( POINTER user, uintptr_t key )
   {
       // return not 1 to dump to log the internal tree structure
       return 0; // probably did own logging here, so don't log tree internal
   }
   <link PTREEROOT> tree;
   void f( void )
   {
       DumpTree( tree, ForEachNode );
   }
   </code>                                                                    */
TYPELIB_PROC  void TYPELIB_CALLTYPE  DumpTree( PTREEROOT root
                          , int (*Dump)( CPOINTER user, uintptr_t key ) );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLeastNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreatestNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetLesserNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetGreaterNode( PTREEROOT root );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNodeEx( PTREEROOT root, POINTER *cursor );
/* \Returns the node that is set as 'current' in the tree. There
   is a cursor within the tree that can be used for browsing.
   See Also
   <link GetChildNode>                                           */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetCurrentNode( PTREEROOT root );
/* This sets the current node cursor to the root of the node.
   See Also
   <link GetChildNode>                                        */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetRootNode( PTREEROOT root );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetParentNode( PTREEROOT root );
/* While browsing the tree after a find operation move to the
   next child node, direction 0 is lesser direction !0 is
   greater.
   Binary Trees have a 'current' cursor. These operations may be
   used to browse the tree.
   Example
   \ \
   <code>
   // this assumes you have a tree, and it's fairly populated, then this demonstrates
   // all steps of browsing.
   POINTER my_data;
   // go to the 'leftmost' least node. (as determined by the compare callback)
   my_data = GetLeastNode( tree );
   // go to the 'rightmost' greatest node. (as determined by the compare callback)
   my_data = GetGreatestNode( tree );
   // move to the node that is less than the current node.  (move to the 'left')
   my_data = GetLesserNode( tree );
   // move to the node that is greater than the current node.  (move to the 'right')
   my_data = GetGreaterNode( tree );
   // follow the tree to the left down from here
   my_data = GetChildNode( tree, 0 );
   // follow the tree to the right down from here
   my_data = GetChildNode( tree, 1 );
   // follow the tree up to the node above the current one.
   //  (the one who's lesser or greater points at this)
   my_data = GetParentNode( tree );
   // this is probably the least useful, but someone clever might find a trick for it
   // Move back to the node we were just at.
   //  (makes the current the prior, and moves to what the prior was,
   //     but then it's just back and forth between the last two; it's not a stack ).
   my_data = GetPriorNode( tree );
   </code>
   A more practical example...
   <code lang="c++">
   POINTER my_data;
   for( my_data = GetLeastNode( tree );
        my_data;
        my_data = GetGreaterNode( tree ) )
   {
        // browse the tree from least to most.
   }
   </code>                                                                            */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNode( PTREEROOT root, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNodeEx( PTREEROOT root, POINTER *cursor );
/* See Also
   <link GetChildNode> */
TYPELIB_PROC  CPOINTER TYPELIB_CALLTYPE  GetPriorNode( PTREEROOT root );
/* \Returns the total number of nodes in the tree.
   Example
   <code lang="c++">
   uint32_t total_nodes = GetNodeCount(tree);
   </code>                                         */
TYPELIB_PROC  uint32_t TYPELIB_CALLTYPE  GetNodeCount ( PTREEROOT root );
 // returns a shadow of the original.
TYPELIB_PROC  PTREEROOT TYPELIB_CALLTYPE  ShadowBinaryTree( PTREEROOT root );
#ifdef __cplusplus
 //namespace BinaryTree {
	};
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
namespace family {
#endif
/* A family tree structure, for tracking elements that have
   multiple children.
                                                            */
typedef struct familyroot_tag *PFAMILYTREE;
typedef struct familynode_tag *PFAMILYNODE;
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYTREE TYPELIB_CALLTYPE  CreateFamilyTree ( int (CPROC *Compare)(uintptr_t key1, uintptr_t key2)
															, void (CPROC *Destroy)(POINTER user, uintptr_t key) );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER TYPELIB_CALLTYPE  FamilyTreeFindChild ( PFAMILYTREE root
														  , uintptr_t psvKey );
/* <unfinished>
   Incomplete, Family tree was never completed. */
TYPELIB_PROC  POINTER  TYPELIB_CALLTYPE FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey );
/* Resets the search cursors in the tree... */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeReset ( PFAMILYTREE *option_tree );
/* Resets the content of the tree (should call destroy methods, at this time it does not) */
TYPELIB_PROC  void TYPELIB_CALLTYPE  FamilyTreeClear ( PFAMILYTREE option_tree );
/* <unfinished>
   Incomplete Work in progress (maybe) */
TYPELIB_PROC  PFAMILYNODE TYPELIB_CALLTYPE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData );
TYPELIB_PROC LOGICAL TYPELIB_CALLTYPE FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData );
#ifdef __cplusplus
 //namespace family {
};
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
//} // extern "c"
 // namespace containers
};
 // namespace sack
};
using namespace sack::containers::link_stack;
using namespace sack::containers::data_stack;
using namespace sack::containers::data_list;
using namespace sack::containers::data_queue;
using namespace sack::containers::queue;
using namespace sack::containers::BinaryTree;
using namespace sack::containers::text;
using namespace sack::containers::message;
using namespace sack::containers::sets;
using namespace sack::containers::family;
using namespace sack::containers;
#else
// should 'class'ify these things....
#endif
#ifndef _TYPELIBRARY_SOURCE
//#undef TYPELIB_PROC // we don't need this symbol after having built the right prototypes
#endif
#endif
// $Log: sack_typelib.h,v $
// Revision 1.99  2005/07/10 23:56:25  d3x0r
// Fix types for C++...
//
//
// Revision 1.39  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
#ifndef IS_DEADSTART
// this is always statically linked with libraries, so they may contact their
// core executable to know when it's done loading everyone else also...
#  ifdef __cplusplus
extern "C"
#  endif
#  if defined( WIN32 ) && !defined( __STATIC__ ) && !defined( __ANDROID__ )
#    ifdef __NO_WIN32API__
// DllImportAttribute ?
#    else
__declspec(dllimport)
#    endif
#  else
#ifndef __cplusplus
extern
#endif
#  endif
/* a function true/false which indicates whether the root
   deadstart has been invoked already. If not, one should call
   InvokeDeadstart and MarkDeadstartComplete.
   <code lang="c++">
   int main( )
   {
       if( !is_deadstart_complete() )
       {
           InvokeDeadstart();
           MarkDeadstartComplete()
       }
       ... your code here ....
       return 0;  // or some other appropriate return.
   }
   </code>
   sack::app::deadstart                                        */
LOGICAL
#  if defined( __WATCOMC__ )
__cdecl
#  endif
is_deadstart_complete( void );
#endif
/* Define a routine to call for exit().  This triggers specific code to handle shutdown event registration */
#ifndef NO_EXPORTS
#  ifdef SACK_BAG_CORE_EXPORTS
EXPORT_METHOD
#  else
IMPORT_METHOD
#  endif
#else
#  ifndef SACK_BAG_CORE_EXPORTS
	extern
#  endif
#endif
		void CPROC BAG_Exit( int code );
#ifndef NO_SACK_EXIT_OVERRIDE
#define exit(n) BAG_Exit(n)
#endif
 // namespace sack {
SACK_NAMESPACE_END
// this should become common to all libraries and programs...
 // pronounced 'kahn-struct'
/* Defines interface for Construct API.
   Description
   This API is for distributed process tracking. A launching
   program will receive notifications to cause certain events to
   happen. Applications built for use by this execution tracking
   program will register that they are loading while they are
   loading, and before the application Main() is invoked. the
   application should then call LoadComplete() once they have
   initialized and are ready to process. This allows a
   quick-wait to wait for the process to register that it is
   loading, and a longer wait for process completion. Certain
   processes may not require others to be completely loaded, but
   maybe just loading. (Two peer processes that have to
   coordinate together to have either one complete
   initialization).                                              */
/* Define the procedure call type for construct API methods. */
#define CONSTRUCT_API CPROC
#ifdef CONSTRUCT_SOURCE
#define CONSTRUCT_PROC EXPORT_METHOD
#else
/* Library linkage specification. */
#define CONSTRUCT_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
/* Defines TASK namespace (unused?) */
#define _TASK_NAMESPACE namespace task {
/* Define Construct namespace. Construct is for distributed
   process tracking project. Applications will register on-load
   that they are loading, and should register load completed
   when they are done loading, or exit.                         */
#define _CONSTRUCT_NAMESPACE namespace construct {
/* Defines TASK namespace ending.(unused?) */
#define _TASK_NAMESPACE_END }
/* Define Construct namespace end. Construct is for distributed
   process tracking project. Applications will register on-load
   that they are loading, and should register load completed
   when they are done loading, or exit.                         */
#define _CONSTRUCT_NAMESPACE_END }
#else
#define _TASK_NAMESPACE
#define _CONSTRUCT_NAMESPACE
#define _TASK_NAMESPACE_END
#define _CONSTRUCT_NAMESPACE_END
#endif
/* Define a symbol to specify full sack::task::construct
   namespace.                                            */
#define CONSTRUCT_NAMESPACE SACK_NAMESPACE _TASK_NAMESPACE _CONSTRUCT_NAMESPACE
/* Define a symbol to specify full sack::task::construct
   namespace ending.                                     */
#define CONSTRUCT_NAMESPACE_END _CONSTRUCT_NAMESPACE_END _TASK_NAMESPACE_END SACK_NAMESPACE_END
	SACK_NAMESPACE
	_TASK_NAMESPACE
	/* Registers with message service, assuming the summoner message service is active.
	 Provides communication methods with a task manager, so the application can notify,
	 start has completed.   The service is ready to work.*/
_CONSTRUCT_NAMESPACE
/* Called to indicate that a process is done initializing and is
   ready to process. Notifies summoner service of Loading
   completed. If enabled, there is also a library component that
   will run at deadstart to just confirm initializing, this
   would actually indicate the service is now ready to serve.    */
CONSTRUCT_PROC void CONSTRUCT_API LoadComplete( void );
CONSTRUCT_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::task::construct;
#endif
/*
 *  Crafted by James Buckeyne
 *  Part of SACK github.com/d3x0r/SACK
 *
 *   (c) Freedom Collective 2000-2006++, 2016++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 */
#ifndef LOGGING_MACROS_DEFINED
#define LOGGING_MACROS_DEFINED
#define SYSLOG_API CPROC
#ifdef SYSLOG_SOURCE
#define SYSLOG_PROC EXPORT_METHOD
#else
#define SYSLOG_PROC IMPORT_METHOD
#endif
#ifdef __cplusplus
#define LOGGING_NAMESPACE namespace sack { namespace logging {
#define LOGGING_NAMESPACE_END }; };
#else
#define LOGGING_NAMESPACE
#define LOGGING_NAMESPACE_END
#endif
#ifdef __cplusplus
	namespace sack {
/* Handles log output. Logs can be directed to UDP directed, or
   broadcast, or localhost, or to a file location, and under
   windows the debugging console log.
   lprintf
   SetSystemLog
   SystemLogTime
   there are options, when options code is enabled, which
   control logging output and format. Log file location can be
   specified generically for instance.... see Options.
	This namespace contains the logging functions. The most basic
   thing you can do to start logging is use 'lprintf'.
   <code lang="c++">
   lprintf( "My printf like format %s %d times", "string", 15 );
   </code>
   This function takes a format string and arguments compatible
   with vsnprintf. Internally strings are truncated to 4k
   length. (that is no single logging message can be more than
   4k in length).
   There are functions to control logging behavior.
   See Also
   SetSystemLog
   SystemLogTime
   SystemLogOptions
   lprintf
   _lprintf
   xlprintf
   _xlprintf
                                                                 */
		namespace logging {
#endif
/* \Parameters for SetSystemLog() to specify where the logging
   should go.                                                  */
enum syslog_types {
 // disable any log output.
SYSLOG_NONE     =   -1
,
SYSLOG_UDP      =    0
,
SYSLOG_FILE     =    1
,
 /* Set logging to output to a file. The file passed is a FILE*. This
   may be a FILE* like stdout, stderr, or some file the
   application opens.                                                */
SYSLOG_FILENAME =    2
,
 /* Set logging to go to a file, pass the string text name of the
   \file to open as the second parameter of SetSystemLog.        */
SYSLOG_SYSTEM   =    3
,
 /* Specify that logging should go to system (this actually means
   Windows system debugging channel. OutputDebugString() ).      */
SYSLOG_UDPBROADCAST= 4
// Allow user to specify a void UserCallback( char * )
// which recieves the formatted output.
,
SYSLOG_CALLBACK    = 5
,
 /* Send Logging to a specified user callback to handle. This
   lets logging go anywhere else that's not already thought of. */
SYSLOG_AUTO_FILE = SYSLOG_FILE + 100
 /* Send logging to a file. If the file is not open, open the
   \file. If no logging happens, no log file is created.     */
,
SYSLOG_SOCKET_SYSLOGD
};
#if !defined( NO_LOGGING )
#define DO_LOGGING
#endif
// this was forced, force no_logging off...
#if defined( DO_LOGGING )
#undef NO_LOGGING
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
SYSLOG_PROC  LOGICAL SYSLOG_API  IsBadReadPtr ( CPOINTER pointer, uintptr_t len );
#endif
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetPackedTime ( void );
//
typedef void (CPROC*UserLoggingCallback)( CTEXTSTR log_string );
SYSLOG_PROC  void SYSLOG_API  SetSystemLog ( enum syslog_types type, const void *data );
SYSLOG_PROC  void SYSLOG_API  ProtectLoggedFilenames ( LOGICAL bEnable );
SYSLOG_PROC  void SYSLOG_API  SystemLogFL ( CTEXTSTR FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLogEx ( CTEXTSTR DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  SystemLog ( CTEXTSTR );
SYSLOG_PROC  void SYSLOG_API  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS );
SYSLOG_PROC  void SYSLOG_API  LogBinary ( const uint8_t* buffer, size_t size );
// logging level defaults to 1000 which is log everything
SYSLOG_PROC  void SYSLOG_API  SetSystemLoggingLevel ( uint32_t nLevel );
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/* Log a binary buffer. Logs lines representing 16 bytes of data
   at a time. The hex of each byte in a buffer followed by the
   text is logged.
   Example
   <code lang="c#">
   char sample[] = "sample string";
   LogBinary( sample, sizeof( sample ) );
   </code>
   Results with the following output in the log...
   <code>
    73 61 6D 70 6C 65 20 73 74 72 69 6E 67 00 sample string.
   </code>
   The '.' at the end of 'sample string' is a non printable
   character. characters 0-31 and 127+ are printed as '.'.       */
#define LogBinary(buf,sz) LogBinaryFL((uint8_t*)(buf),sz DBG_SRC )
#define SystemLog(buf)    SystemLogFL(buf DBG_SRC )
#else
// need to include the typecast... binary logging doesn't really care what sort of pointer it gets.
#define LogBinary(buf,sz) LogBinary((uint8_t*)(buf),sz )
//#define LogBinaryEx(buf,sz,...) LogBinaryFL(buf,sz FILELINE_NULL)
//#define SystemLogEx(buf,...) SystemLogFL(buf FILELINE_NULL )
#endif
// int result is useless... but allows this to be
// within expressions, which with this method should be easy.
typedef INDEX (CPROC*RealVLogFunction)(CTEXTSTR format, va_list args )
//#if defined( __GNUC__ ) && !defined( _UNICODE )
//	__attribute__ ((__format__ (__vprintf__, 1, 2)))
//#endif
	;
typedef INDEX (CPROC*RealLogFunction)(CTEXTSTR format,...)
#if defined( __GNUC__ ) && !defined( _UNICODE )
	__attribute__ ((__format__ (__printf__, 1, 2)))
#endif
	;
SYSLOG_PROC  RealVLogFunction SYSLOG_API  _vxlprintf ( uint32_t level DBG_PASS );
SYSLOG_PROC  RealLogFunction SYSLOG_API  _xlprintf ( uint32_t level DBG_PASS );
// utility function to format a cpu delta into a buffer...
// end-start is always printed... therefore tick_end-0 is
// print absolute time... formats as millisecond.NNN
SYSLOG_PROC  void SYSLOG_API  PrintCPUDelta ( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end );
// return the current CPU tick
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUTick ( void );
// result in nano seconds - thousanths of a millisecond...
SYSLOG_PROC  uint32_t SYSLOG_API  ConvertTickToMicrosecond ( uint64_t tick );
SYSLOG_PROC  uint64_t SYSLOG_API  GetCPUFrequency ( void );
SYSLOG_PROC  CTEXTSTR SYSLOG_API  GetTimeEx ( int bUseDay );
SYSLOG_PROC  void SYSLOG_API  SetSyslogOptions ( FLAGSETTYPE *options );
/* When setting options using SetSyslogOptions() these are the
   defines for the bits passed.
   SYSLOG_OPT_OPENAPPEND - the file, when opened, will be opened
   for append.
   SYSLOG_OPT_OPEN_BACKUP - the file, if it exists, will be
   renamed automatically.
   SYSLOG_OPT_LOG_PROGRAM_NAME - enable logging the program
   executable (probably the same for all messages, unless they
   are network)
   SYSLOG_OPT_LOG_THREAD_ID - enables logging the unique process
   and thread ID.
   SYSLOG_OPT_LOG_SOURCE_FILE - enable logging source file
   information. See <link DBG_PASS>
   SYSLOG_OPT_MAX - used for declaring a flagset to pass to
   setoptions.                                                   */
enum system_logging_option_list {
		/* the file, when opened, will be opened for append.
		 */
		SYSLOG_OPT_OPENAPPEND
										  ,
  /* the file, if it exists, will be renamed automatically.
										  */
										  SYSLOG_OPT_OPEN_BACKUP
                                ,
 /* enable logging the program executable (probably the same for
                                   all messages, unless they are network)
                                                                                                */
                                 SYSLOG_OPT_LOG_PROGRAM_NAME
										  ,
 /* enables logging the unique process and thread ID.
										                                                       */
                                 SYSLOG_OPT_LOG_THREAD_ID
                                ,
 /* enable logging source file information. See <link DBG_PASS>
                                                                                               */
										   SYSLOG_OPT_LOG_SOURCE_FILE
										  ,
										  SYSLOG_OPT_MAX
};
// this solution was developed to provide the same
// functionality for compilers that refuse to implement __VA_ARGS__
// this therefore means that the leader of the function is replace
// and that extra parenthesis exist after this... therefore the remaining
// expression must be ignored... thereofre when defining a NULL function
// this will result in other warnings, about ignored, or meaningless expressions
# if defined( DO_LOGGING )
#  define vlprintf      _vxlprintf(LOG_NOISE DBG_SRC)
#  define lprintf       _xlprintf(LOG_NOISE DBG_SRC)
#  define _lprintf(file_line,...)       _xlprintf(LOG_NOISE file_line,##__VA_ARGS__)
#  define xlprintf(level)       _xlprintf(level DBG_SRC)
#  define vxlprintf(level)       _vxlprintf(level DBG_SRC)
# else
#  ifdef _MSC_VER
#   define vlprintf      (1)?(0):
#   define lprintf       (1)?(0):
#   define _lprintf(DBG_VOIDRELAY)       (1)?(0):
#   define xlprintf(level)       (1)?(0):
#   define vxlprintf(level)      (1)?(0):
#  else
#   define vlprintf(f,...)
/* use printf formating to output to the log. (log printf).
   Parameters
   Format :  Just like printf, the format string to print.
   ... :     extra arguments passed as required for the format.
   Example
   <code lang="c++">
      lprintf( "Test Logging %d %d", 13, __LINE__ );
   </code>                                                      */
#   define lprintf(f,...)
#   define  _lprintf(DBG_VOIDRELAY)       lprintf
#   define xlprintf(level) lprintf
#   define vxlprintf(level) lprintf
#  endif
# endif
#undef LOG_WARNING
#undef LOG_ADVISORIES
#undef LOG_INFO
// Defined Logging Levels
enum {
	  // and you are free to use any numerical value,
	  // this is a rough guideline for wide range
	  // to provide a good scaling for levels of logging
 // unless logging is disabled, this will be logged
	LOG_ALWAYS = 1
 // logging level set to 50 or more will cause this to log
	, LOG_ERRORS = 50
	,
 /* Specify a logging level which only ERROR level logging is
	   logged.                                                   */
 // logging level set to 50 or more will cause this to log
	 LOG_ERROR = LOG_ERRORS
	,
 // .......
	 LOG_WARNINGS = 500
	,
 // .......
	 LOG_WARNING = LOG_WARNINGS
   ,
 /* Use to specify that the log message is a warning level
      message.                                               */
    LOG_ADVISORY = 625
   ,
    LOG_ADVISORIES = LOG_ADVISORY
	,
 /* A symbol to specify to log Adviseries, Warnings and Error
	   level messages only.                                      */
	 LOG_INFO = 750
	  ,
 /* A moderate logging level, which is near maximum verbosity of
	     logging.                                                     */
	   LOG_NOISE = 1000
     ,
 /* Define that the message is just noisy - though verbosly
	  informative, it's level is less critical than even INFO.
	  default iS LOG_NOISE which is 1000, an ddefault for disabling most messages
	  is to set log level to 999.  Have to increase to 2000 to see debug, and this name
     has beviously
	  */
      LOG_LEVEL_DEBUG = 2000
	,
 /* Specify the message is of DEBUG importance, which is far
	   above even NOISY. If debug logging is enabled, all logging,
	   ERROR, WARNING, ADVISORY, INFO, NOISY and DEBUG will be
	   logged.                                                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM = 0x40000000
	,
 /* A bit with LOG_CUSTOM might be enabled, and the lower bits
	   under 0x40000000 (all bits 0x3FFFFFFF ) can be used to
	   indicate a logging type. Then SetLoggingLevel can be passed a
	   mask of bits to filter types of messages.                     */
 // not quite a negative number, but really big
	 LOG_CUSTOM_DISABLE = 0x20000000
	// bits may be user specified or'ed with this value
	// such that ...
	// Example 1:SetSystemLoggingLevel( LOG_CUSTOM | 1 ) will
	// enable custom logging messages which have the '1' bit on... a logical
	// and is used to test the low bits of this value.
	// example 2:SetSystemLogging( LOG_CUSTOM_DISABLE | 1 ) will disable logging
	// of messages with the 1 bit set.
  // mask of bits which may be used to enable and disable custom logging
#define LOG_CUSTOM_BITS 0xFFFFFF
};
 // this is a flag set consisting of 0 or more or'ed symbols
enum SyslogTimeSpecifications {
 // disable time logging
 SYSLOG_TIME_DISABLE = 0,
 // enable is anything not zero.
 SYSLOG_TIME_ENABLE  = 1,
 // specify to log milliseconds
 SYSLOG_TIME_HIGH    = 2,
 // log the year/month/day also
 SYSLOG_TIME_LOG_DAY = 4,
 // log the difference in time instead of the absolute time
 SYSLOG_TIME_DELTA   = 8,
 // logs cpu ticks... implied delta
 SYSLOG_TIME_CPU     =16
};
/* Specify how time is logged. */
SYSLOG_PROC void SYSLOG_API SystemLogTime( uint32_t enable );
#ifndef NO_LOGGING
#define OutputLogString(s) SystemLog(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)                                   SystemLog( s )
#else
#define OutputLogString(s)
/* Depricated. Logs a format string that takes 0 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log(s)
#endif
/* Depricated. Logs a format string that takes 1 parameter.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log1(s,p1)                               lprintf( s, p1 )
/* Depricated. Logs a format string that takes 2 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log2(s,p1,p2)                            lprintf( s, p1, p2 )
/* Depricated. Logs a format string that takes 3 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log3(s,p1,p2,p3)                         lprintf( s, p1, p2, p3 )
/* Depricated. Logs a format string that takes 4 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log4(s,p1,p2,p3,p4)                      lprintf( s, p1, p2, p3,p4)
/* Depricated. Logs a format string that takes 5 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log5(s,p1,p2,p3,p4,p5)                   lprintf( s, p1, p2, p3,p4,p5)
/* Depricated. Logs a format string that takes 6 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log6(s,p1,p2,p3,p4,p5,p6)                lprintf( s, p1, p2, p3,p4,p5,p6)
/* Depricated. Logs a format string that takes 7 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log7(s,p1,p2,p3,p4,p5,p6,p7)             lprintf( s, p1, p2, p3,p4,p5,p6,p7 )
/* Depricated. Logs a format string that takes 8 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log8(s,p1,p2,p3,p4,p5,p6,p7,p8)          lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8 )
/* Depricated. Logs a format string that takes 9 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log9(s,p1,p2,p3,p4,p5,p6,p7,p8,p9)       lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9 )
/* Depricated. Logs a format string that takes 10 parameters.
   See Also
   <link sack::logging::lprintf, lprintf>                    */
#define Log10(s,p1,p2,p3,p4,p5,p6,p7,p8,p9,p10)  lprintf( s, p1, p2, p3,p4,p5,p6,p7,p8,p9,p10 )
LOGGING_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::logging;
#endif
#endif
#if defined( _MSC_VER ) || (1)
// huh, apparently all compiles are messed the hell up.
#  define COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#endif
#ifdef COMPILER_THROWS_SIGNED_UNSIGNED_MISMATCH
#  define SUS_GT(a,at,b,bt)   (((a)<0)?0:(((bt)a)>(b)))
#  define USS_GT(a,at,b,bt)   (((b)<0)?1:((a)>((at)b)))
#  define SUS_LT(a,at,b,bt)   (((a)<0)?1:(((bt)a)<(b)))
#  define USS_LT(a,at,b,bt)   (((b)<0)?0:((a)<((at)b)))
#  define SUS_GTE(a,at,b,bt)  (((a)<0)?0:(((bt)a)>=(b)))
#  define USS_GTE(a,at,b,bt)  (((b)<0)?1:((a)>=((at)b)))
#  define SUS_LTE(a,at,b,bt)  (((a)<0)?1:(((bt)a)<=(b)))
#  define USS_LTE(a,at,b,bt)  (((b)<0)?0:((a)<=((at)b)))
#else
#  define SUS_GT(a,at,b,bt)   ((a)>(b))
#  define USS_GT(a,at,b,bt)   ((a)>(b))
#  define SUS_LT(a,at,b,bt)   ((a)<(b))
#  define USS_LT(a,at,b,bt)   ((a)<(b))
#  define SUS_GTE(a,at,b,bt)  ((a)>=(b))
#  define USS_GTE(a,at,b,bt)  ((a)>=(b))
#  define SUS_LTE(a,at,b,bt)  ((a)<=(b))
#  define USS_LTE(a,at,b,bt)  ((a)<=(b))
#endif
#ifdef __cplusplus
using namespace sack;
using namespace sack::containers;
#endif
#endif
// incldue this first so we avoid a conflict.
// hopefully this comes from sack system?
/*
 *  Created by Jim Buckeyne
 *
 *  Purpose
 *    Generalization of system routines which began in
 *   dekware development.
 *   - Process control (load,start,stop)
 *   - Library runtime link control (load, unload)
 *
 */
#ifndef SYSTEM_LIBRARY_DEFINED
#define SYSTEM_LIBRARY_DEFINED
#ifdef SYSTEM_SOURCE
#define SYSTEM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SYSTEM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __LINUX__
// Hmm I thought that dlopen resulted in an int...
// but this doc says void * (redhat9)
//typedef void *HLIBRARY;
#else
//typedef HMODULE HLIBRARY;
#endif
#ifdef __cplusplus
#define _SYSTEM_NAMESPACE namespace system {
#define _SYSTEM_NAMESPACE_END }
#else
#define _SYSTEM_NAMESPACE
#define _SYSTEM_NAMESPACE_END
#endif
#define SACK_SYSTEM_NAMESPACE SACK_NAMESPACE _SYSTEM_NAMESPACE
#define SACK_SYSTEM_NAMESPACE_END _SYSTEM_NAMESPACE_END SACK_NAMESPACE_END
#ifndef UNDER_CE
#define HAVE_ENVIRONMENT
#endif
SACK_NAMESPACE
	_SYSTEM_NAMESPACE
typedef struct task_info_tag *PTASK_INFO;
typedef void (CPROC*TaskEnd)(uintptr_t, PTASK_INFO task_ended);
typedef void (CPROC*TaskOutput)(uintptr_t, PTASK_INFO task, CTEXTSTR buffer, size_t size );
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
#define LPP_OPTION_DO_NOT_HIDE           1
// for services to launch normal processes (never got it to work; used to work in XP/NT?)
#define LPP_OPTION_IMPERSONATE_EXPLORER  2
#define LPP_OPTION_FIRST_ARG_IS_ARG      4
#define LPP_OPTION_NEW_GROUP             8
#define LPP_OPTION_NEW_CONSOLE          16
#define LPP_OPTION_SUSPEND              32
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                               , int flags
                                               , TaskOutput OutputHandler
                                               , TaskEnd EndNotice
                                               , uintptr_t psv
                                                DBG_PASS
                                               );
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv );
// launch a process, program name (including leading path), a optional path to start in (defaults to
// current process' current working directory.  And a array of character pointers to args
// args should be the NULL.
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR  args );
// abort task, no kill signal, sigabort basically.  Use StopProgram for a more graceful terminate.
// if (!StopProgram(task)) TerminateProgram(task) would be appropriate.
SYSTEM_PROC( uintptr_t, TerminateProgram )( PTASK_INFO task );
SYSTEM_PROC( void, ResumeProgram )( PTASK_INFO task );
// get first address of program startup code(?) Maybe first byte of program code?
SYSTEM_PROC( uintptr_t, GetProgramAddress )( PTASK_INFO task );
// before luanchProgramEx, there was no userdata...
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv );
// attempt to implement a method on windows that allows a service to launch a user process
// current systems don't have such methods
SYSTEM_PROC( void, ImpersonateInteractiveUser )( void );
// after launching a process should revert to a protected state.
SYSTEM_PROC( void, EndImpersonation )( void );
// generate a Ctrl-C to the task.
// maybe also signal systray icon
// maybe also signal process.lock region
// maybe end process?
// maybe then terminate process?
SYSTEM_PROC( LOGICAL, StopProgram )( PTASK_INFO task );
// ctextstr as its own type is a pointer so a
//  PcTextStr is a pointer to strings -
//   char ** - returns a quoted string if args have spaces (and escape quotes in args?)
SYSTEM_PROC( TEXTSTR, GetArgsString )( PCTEXTSTR pArgs );
// after a task has exited, this can return its code.
// undefined if task has not exited (probably 0)
SYSTEM_PROC( uint32_t, GetTaskExitCode )( PTASK_INFO task );
// returns the name of the executable that is this process (without last . extension   .exe for instance)
SYSTEM_PROC( CTEXTSTR, GetProgramName )( void );
// returns the path of the executable that is this process
SYSTEM_PROC( CTEXTSTR, GetProgramPath )( void );
// returns the path that was the working directory when the program started
SYSTEM_PROC( CTEXTSTR, GetStartupPath )( void );
// returns the path of the current sack library.
SYSTEM_PROC( CTEXTSTR, GetLibraryPath )( void );
// on windows, queries an event that indicates the system is rebooting.
SYSTEM_PROC( LOGICAL, IsSystemShuttingDown )( void );
// HandlePeerOutput is called whenever a peer task has generated output on stdout or stderr
//   - someday evolution may require processing stdout and stderr with different event handlers
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
                                              , TaskOutput HandlePeerOutput
                                              , TaskEnd EndNotice
                                              , uintptr_t psv
                                               DBG_PASS
                                              );
#define LaunchPeerProgram(prog,path,args,out,end,psv) LaunchPeerProgramEx(prog,path,args,out,end,psv DBG_SRC)
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
                                   , TaskOutput OutputHandler
                                   , uintptr_t psv
                                   DBG_PASS
                                   );
#define System(command_line,output_handler,user_data) SystemEx( command_line, output_handler, user_data DBG_SRC )
// generate output to a task... read by peer task on standard input pipe
// if a task has been opened with an output handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, pprintf )( PTASK_INFO task, CTEXTSTR format, ... );
// if a task has been opened with an otuput handler, than IO is trapped, and this is a method of
// sending output to a task.
SYSTEM_PROC( int, vpprintf )( PTASK_INFO task, CTEXTSTR format, va_list args );
typedef void (CPROC*generic_function)(void);
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR library, CTEXTSTR function, LOGICAL bPrivate DBG_PASS);
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR library, CTEXTSTR function DBG_PASS);
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname );
/*
  Add a custom loaded library; attach a name to the DLL space; this should allow
  getcustomsybmol to resolve these
  */
SYSTEM_PROC( void, AddMappedLibrary )( CTEXTSTR libname, POINTER image_memory );
SYSTEM_PROC( LOGICAL, IsMappedLibrary )( CTEXTSTR libname );
SYSTEM_PROC( void, DeAttachThreadToLibraries )( LOGICAL attach );
#define LoadFunction(l,f) LoadFunctionEx(l,f DBG_SRC )
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS );
#define LoadPrivateFunction(l,f) LoadPrivateFunctionEx(l,f DBG_SRC )
#define OnLibraryLoad(name)	  __DefineRegistryMethod(WIDE("SACK"),_OnLibraryLoad,WIDE("system/library"),WIDE("load_event"),name WIDE("_LoadEvent"),void,(void), __LINE__)
// the callback passed will be called during LoadLibrary to allow an external
// handler to download or extract the library; the resulting library should also
// be loaded by the callback using the standard 'LoadFunction' methods
SYSTEM_PROC( void, SetExternalLoadLibrary )( LOGICAL (CPROC*f)(const char *) );
// please Release or Deallocate the reutrn value
// the callback should search for the file specified, if required, download or extract it
// and then return with a Release'able utf-8 char *.
SYSTEM_PROC( void, SetExternalFindProgram )( char * (CPROC*f)(const char *) );
// override the default program name.
// Certain program wrappers might use this to change log location, configuration, etc other defaults.
SYSTEM_PROC( void, SetProgramName )( CTEXTSTR filename );
// this is a pointer pointer - being that generic_fucntion is
// a pointer...
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function* DBG_PASS );
#ifdef HAVE_ENVIRONMENT
SYSTEM_PROC( CTEXTSTR, OSALOT_GetEnvironmentVariable )(CTEXTSTR name);
SYSTEM_PROC( void, OSALOT_SetEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_AppendEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
SYSTEM_PROC( void, OSALOT_PrependEnvironmentVariable )(CTEXTSTR name, CTEXTSTR value);
#endif
/* this needs to have 'GetCommandLine()' passed to it.
 * Otherwise, the command line needs to have the program name, and arguments passed in the string
 * the parameter to winmain has the program name skipped
 */
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv );
#define UnloadFunction(p) UnloadFunctionEx(p DBG_SRC )
SACK_SYSTEM_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::system;
#endif
#endif
//----------------------------------------------------------------------
// $Log: system.h,v $
// Revision 1.14  2005/07/06 00:33:55  jim
// Fixes for all sorts of mangilng with the system.h header.
//
//
// Revision 1.2  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.1  2003/10/24 13:22:06  panther
// Initial commit
//
//
#if defined( _MSC_VER )|| defined(__LCC__) || defined( __WATCOMC__ ) || defined( __GNUC__ )
/* Includes networking as appropriate for the target platform. Providing
   compatibility definitions as are lacking between platforms...
   or perhaps appropriate name aliasing to the correct types.            */
#ifndef INCLUDED_SOCKET_LIBRARY
#define INCLUDED_SOCKET_LIBRARY
#if defined( _WIN32 ) || defined( __CYGWIN__ )
//#ifndef __cplusplus_cli
#ifdef UNDER_CE
#define USE_WSA_EVENTS
#endif
#include <winsock2.h>
#include <ws2tcpip.h>
#if defined( MINGW_SUX ) && ( __GNUC__ < 5 )
/* Address information */
typedef struct addrinfoA {
    int             ai_flags;
    int             ai_family;
    int             ai_socktype;
    int             ai_protocol;
    size_t          ai_addrlen;
    char            *ai_canonname;
    struct sockaddr *ai_addr;
    struct addrinfoA *ai_next;
} ADDRINFOA;
typedef ADDRINFOA   *PADDRINFOA;
typedef struct addrinfoW {
    int                 ai_flags;
    int                 ai_family;
    int                 ai_socktype;
    int                 ai_protocol;
    size_t              ai_addrlen;
    PWSTR               ai_canonname;
    struct sockaddr     *ai_addr;
    struct addrinfoW    *ai_next;
} ADDRINFOW;
typedef ADDRINFOW   *PADDRINFOW;
#ifdef UNICODE
typedef ADDRINFOW   ADDRINFOT;
typedef ADDRINFOW   *PADDRINFOT;
#else
typedef ADDRINFOA   ADDRINFOT;
typedef ADDRINFOA   *PADDRINFOT;
#endif
typedef ADDRINFOA   ADDRINFO;
typedef ADDRINFOA   *LPADDRINFO;
#endif
#ifdef __CYGWIN__
// just need this simple symbol
typedef int socklen_t;
#endif
//#endif
#elif defined( __LINUX__ )
#if defined( FBSD )
#endif
 // INADDR_ANY/NONE
#include <netinet/in.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#if !defined( _PNACL )
#  include <net/if.h>
#endif
#define SOCKET int
#define SOCKADDR struct sockaddr
#define SOCKET_ERROR -1
//#define HWND int // unused params...
#define WSAEWOULDBLOCK EAGAIN
#define INVALID_SOCKET -1
#define WSAAsynchSelect( a,b,c,d ) (0)
#define WSAGetLastError()  (errno)
#define closesocket(s) close(s)
typedef struct hostent *PHOSTENT;
#ifndef __LINUX__
#define INADDR_ANY (-1)
#define INADDR_NONE (0)
#endif
struct win_in_addr {
	union {
		struct { uint8_t s_b1,s_b2,s_b3,s_b4; } S_un_b;
		struct { uint16_t s_w1,s_w2; } S_un_w;
		uint32_t S_addr;
	} S_un;
#ifndef __ANDROID__
#define s_addr  S_un.S_addr
/* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
	/* host on imp */
#define s_net   S_un.S_un_b.s_b1
	/* network */
#define s_imp   S_un.S_un_w.s_w2
	/* imp */
#define s_impno S_un.S_un_b.s_b4
	/* imp # */
#define s_lh    S_un.S_un_b.s_b3
	/* logical host */
#endif
};
struct win_sockaddr_in {
#ifdef __MAC__
	uint8_t sa_len;
	uint8_t sin_family;
#else
	short   sin_family;
#endif
	uint16_t sin_port;
	struct  win_in_addr sin_addr;
	char    sin_zero[8];
};
typedef struct win_sockaddr_in SOCKADDR_IN;
#endif
#endif
// $Log: loadsock.h,v $
// Revision 1.7  2005/01/27 08:09:25  panther
// Linux cleaned.
//
// Revision 1.6  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#  if defined( __MAC__ )
#  else
               // _heapmin() included here
#    include <malloc.h>
#  endif
#else
//#include "loadsock.h"
#endif
//#include <stdlib.h>
#ifdef __CYGWIN__
 // provided by -lgcc
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
// lots of things end up including 'setjmp.h' which lacks sigset_t defined here.
#  include <sys/signal.h>
#endif
// GetTickCount() and Sleep(n) Are typically considered to be defined by including stdhdrs...
/*
 *  Crafted by Jim Buckeyne
 *
 *  (c)2001-2006++ Freedom Collective
 *
 *  Provide API interface for timers, critical sections
 *  and other thread things.
 *
 */
#ifndef TIMERS_DEFINED
/* timers.h mutliple inclusion protection symbol. */
#define TIMERS_DEFINED
#if defined( _WIN32 )
// on windows, we add a function that returns HANDLE
#endif
#ifndef SHARED_MEM_DEFINED
/* Multiple inclusion protection symbol. */
#define SHARED_MEM_DEFINED
#if defined (_WIN32)
//#define USE_NATIVE_CRITICAL_SECTION
#endif
#if defined( _SHLWAPI_H ) || defined( _INC_SHLWAPI )
#undef StrChr
#undef StrCpy
#undef StrDup
#undef StrRChr
#undef StrStr
#endif
#ifdef __cplusplus
#define SACK_MEMORY_NAMESPACE SACK_NAMESPACE namespace memory {
#define SACK_MEMORY_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define SACK_MEMORY_NAMESPACE
#define SACK_MEMORY_NAMESPACE_END
#endif
/* A declaration of the call type for memory library routines. */
#define MEM_API CPROC
#    ifdef MEM_LIBRARY_SOURCE
#      define MEM_PROC EXPORT_METHOD
#    else
/* Defines library linkage specification. */
#      define MEM_PROC IMPORT_METHOD
#    endif
#ifndef TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
	TIMER_NAMESPACE
   // enables file/line monitoring of sections and a lot of debuglogging
//#define DEBUG_CRITICAL_SECTIONS
   /* this symbol controls the logging in timers.c... (higher level interface to NoWait primatives)*/
//#define LOG_DEBUG_CRITICAL_SECTIONS
/* A custom implementation of windows CRITICAL_SECTION api.
   Provides same capability for Linux type systems. Can be
   checked as a study in how to implement safe locks.
   See Also
   InitCriticalSec
   EnterCriticalSec
   LeaveCriticalSec
   Example
   <c>For purposes of this example this is declared in global
   memory, known to initialize to all 0.</c>
   <code lang="c++">
   CRITICALSECTION cs_lock_test;
   </code>
   In some bit of code that can be executed by several
   threads...
   <code lang="c++">
   {
      EnterCriticalSec( &amp;cs_lock_test );
      // the code in here will only be run by a single thread
      LeaveCriticalSec( &amp;cs_lock_test );
   }
   </code>
   Remarks
   The __Ex versions of functions passes source file and line
   information in debug mode. This can be used if critical
   section debugging is turned on, or if critical section
   logging is turned on. (See ... ) This allows applications to
   find deadlocks by tracking who is entering critical sections
   and probably failing to leave them.                          */
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	uint32_t dwUpdating;
  // count of locks entered.  (only low 24 bits may count for 16M entries, upper bits indicate internal statuses.
	uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
#ifdef DEBUG_CRITICAL_SECTIONS
#define MAX_SECTION_LOG_QUEUE 16
	uint32_t bCollisions ;
	CTEXTSTR pFile[16];
	uint32_t  nLine[16];
	uint32_t  nLineCS[16];
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadPrior[16];
 // windows upper 16 is process ID, lower is thread ID
	uint8_t isLock[16];
	int nPrior;
#endif
};
#if !defined( _WIN32 )
#undef USE_NATIVE_CRITICAL_SECTION
#endif
/* <combine sack::timers::critical_section_tag>
   \ \                                          */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define CRITICALSECTION CRITICAL_SECTION
#else
typedef struct critical_section_tag CRITICALSECTION;
#endif
/* <combine sack::timers::critical_section_tag>
   defines a pointer to a CRITICALSECTION type  */
#if defined( USE_NATIVE_CRITICAL_SECTION )
#define PCRITICALSECTION LPCRITICAL_SECTION
#else
#define InitializeCriticalSection InitializeCriticalSec
typedef struct critical_section_tag *PCRITICALSECTION;
#endif
/* attempts to enter the critical section, and does not block.
   Returns
   If it enters the return is 1, else the return is 0.
   Parameters
   pcs :    pointer to a critical section
   prior :  if not NULL, prior will be set to the current thread
            ID of the owning thread.                             */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  int32_t MEM_API  EnterCriticalSecNoWaitEx ( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS );
#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( pcs, prior DBG_SRC )
#else
#define EnterCriticalSecNoWait( pcs,prior ) TryEnterCriticalSection( (pcs) )
#endif
/* <combine sack::timers::EnterCriticalSecNoWaitEx@PCRITICALSECTION@THREAD_ID *prior>
   \ \                                                                                */
//#define EnterCriticalSecNoWait( pcs,prior ) EnterCriticalSecNoWaitEx( (pcs),(prior) DBG_SRC )
/* clears all members of a CRITICALSECTION.  Same as memset( pcs, 0, sizeof( CRITICALSECTION ) ); */
#ifndef USE_NATIVE_CRITICAL_SECTION
MEM_PROC  void MEM_API  InitializeCriticalSec ( PCRITICALSECTION pcs );
#else
#define InitializeCriticalSec(pcs)  InitializeCriticalSection(pcs)
#endif
/* Get a count of how many times a critical section is locked */
//MEM_PROC  uint32_t MEM_API  CriticalSecOwners ( PCRITICALSECTION pcs );
/* Namespace of all memory related functions for allocating and
   releasing memory.                                            */
#ifdef __cplusplus
 // namespace timers
};
 // namespace sack
};
using namespace sack::timers;
#endif
#ifdef __cplusplus
namespace sack {
/* Memory namespace contains functions for allocating and
   releasing memory. Also contains methods for accessing shared
   memory (if available on the target platform).
   Allocate
   Release
   Hold
   OpenSpace                                                    */
namespace memory {
#endif
typedef struct memory_block_tag* PMEM;
// what is an abstract name for the memory mapping handle...
// where is a filename for the filebacking of the shared memory
// DigSpace( WIDE(TEXT( "Picture Memory" )), WIDE(TEXT( "Picture.mem" )), 100000 );
/* <combinewith sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                                 */
MEM_PROC  POINTER MEM_API  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize );
/* <unfinished>
   Open a shared memory region. The region may be named with a
   text string (this does not work under linux platforms, and
   the name of the file to back the shared region is the sharing
   point). The region may be backed with a file (and must be if
   it is to be shared on linux.
   If the region exists by name, the region is opened, and a
   pointer to that region is returned.
   If the file exists, the file is opened, and mapped into
   memory, and a pointer to the file backed memory is returned.
   if the file does not exist, and the size parameter passed is
   not 0, then the file is created, and expanded to the size
   requested. The bCreate flag is set to true.
   If NULL is passed for pWhat and pWhere, then a block of
   memory is allocated in system memory, backed by pagefile.
   if dwSize is 0, then the region is specified for open only,
   and will not create.
   Parameters
   pWhat :     String to a named shared memory region. NULL is
               unnamed.
   pWhere :    Filename to back the shared memory with. The file
               name itself may also be used to share the memory.
   address :   A base address to map the memory at. If 0,
               specifies do not care.
   dwSize :    pointer to a uintptr_t that defines the size to
               create. If 0, then the region is only opened. The
               size of the region opened is set back into this
               value after it is opened.
   bCreated :  pointer to a boolean to indicate whether the space
               was created or not.
   Returns
   Pointer to region requested to be opened. NULL on failure.
   Example
   Many examples of this are appropriate.
   1) Open or create a file backed shared space.
   2) Open a file for direct memory access, the file is loaded
   into memory by system paging routines and not any API.         */
MEM_PROC  POINTER MEM_API  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address
	, uintptr_t *dwSize, uint32_t* bCreated );
/* <combine sack::memory::OpenSpaceExx@CTEXTSTR@CTEXTSTR@uintptr_t@uintptr_t *@uint32_t*>
   \ \                                                                             */
#define OpenSpaceEx( what,where,address,psize) OpenSpaceExx( what,where,address,psize,NULL )
/* Closes a shared memory region. Calls CloseSpaceEx() with
   bFinal set TRUE.
   Parameters
   pMem :  pointer to a memory region opened by OpenSpace.  */
MEM_PROC  void MEM_API  CloseSpace ( POINTER pMem );
/* Closes a memory region. Release can also be used to close
   opened spaces.
   Parameters
   pMem :    pointer to a memory region opened with OpenSpace()
   bFinal :  If final is set, the file used for backing the shared
             region is deleted.                                    */
MEM_PROC  void MEM_API  CloseSpaceEx ( POINTER pMem, int bFinal );
/* This can give the size back of a memory space.
   Returns
   The size of the memory block.
   Parameters
   pMem :  pointer to a block of memory that was opened with
           OpenSpace().                                      */
MEM_PROC  uintptr_t MEM_API  GetSpaceSize ( POINTER pMem );
/* even if pMem is just a POINTER returned from OpenSpace this
   will create a valid heap pointer.
   will result TRUE if a valid heap is present will result FALSE
   if heap is not able to init (has content)
   Parameters
   pMem :    pointer to a memory space to setup as a heap.
   dwSize :  size of the memory space pointed at by pMem.        */
MEM_PROC  int MEM_API  InitHeap( PMEM pMem, uintptr_t dwSize );
/* Dumps all blocks into the log.
   Parameters
   pHeap :     Heap to dump. If NULL or unspecified, dump the
               default heap.
   bVerbose :  Specify to dump each block's information,
               otherwise only summary information is generated. */
MEM_PROC  void MEM_API  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose );
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   Logs all of the blocks tracked in a specific heap.
   Parameters
   Heap :  Heap to dump the memory blocks of.              */
#define DebugDumpHeapMem(h)     DebugDumpMemEx( (h), TRUE )
/* <combine sack::memory::DebugDumpHeapMemEx@PMEM@LOGICAL>
   \ \                                                     */
MEM_PROC  void MEM_API  DebugDumpMemEx ( LOGICAL bVerbose );
/* Dumps all tracked heaps.
   Parameters
   None.                    */
#define DebugDumpMem()     DebugDumpMemEx( TRUE )
/* Dumps a heap to a specific file.
   Parameters
   pHeap :      Heap. If NULL or unspecified, dumps default heap.
   pFilename :  name of the file to write output to.              */
MEM_PROC  void MEM_API  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename );
/* <combine sack::memory::DebugDumpHeapMemFile@PMEM@CTEXTSTR>
   \ \                                                        */
MEM_PROC  void MEM_API  DebugDumpMemFile ( CTEXTSTR pFilename );
#ifdef __GNUC__
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx ( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS ) __attribute__( (malloc) );
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS ) __attribute__((malloc));
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS ) __attribute__((malloc));
#else
/* \ \
   Parameters
   pHeap :  pointer to a heap which was initialized with
            InitHeap()
   Size :   Size of block to allocate                    */
MEM_PROC  POINTER MEM_API  HeapAllocateEx ( PMEM pHeap, uintptr_t nSize DBG_PASS );
/* \ Parameters
pHeap :  pointer to a heap which was initialized with
InitHeap()
Size :   Size of block to allocate
Alignment : count of bytes to return block on (1,2,4,8,16,32)  */
MEM_PROC  POINTER MEM_API  HeapAllocateAlignedEx( PMEM pHeap, uintptr_t nSize, uint16_t alignment DBG_PASS );
/* Allocates a block of memory of specific size. Debugging
   information if passed is recorded on the block.
   Parameters
   size :  size of the memory block to create              */
MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
#endif
/* A simple macro to allocate a new single unit of a structure. Adds
   a typecast automatically to be (type*) so C++ compilation is
   clean. Does not burden the user with extra typecasts. This,
   being in definition use means that all other things that are
   typecast are potentially error prone. Memory is considered
   uninitialized.
   Parameters
   type :  type to allocate
   Example
   <code lang="c++">
   int *p_int = New( int );
   </code>                                                           */
#define New(type) ((type*)HeapAllocate(0,sizeof(type)))
/* Reallocates an array of type.
   Parameters
   type :  type to use for sizeof(type) * sz for resulting size.
   p :     pointer to realloc
   sz :    count of elements in the array                        */
#define Renew(type,p,sz) ((type*)HeapReallocate(0,p, sizeof(type)*sz))
/* an advantage of C, can define extra space at end of structure
   which is allowed to carry extra data, which is unknown by
   other code room for exploits rock.
   Parameters
   type :   passed to sizeof()
   extra :  Number of additional bytes to allocate beyond the
            sizeof( type )
   Example
   Create a text segment plus 18 characters of data. (This
   should not be done, use SegCreate instead)
   <code lang="c#">
   PTEXT text = NewPlus( TEXT, 18 );
   </code>                                                       */
#define NewPlus(type,extra) ((type*)HeapAllocate(0,sizeof(type)+(extra)))
/* Allocate a new array of type.
   Parameters
   type :   type to determine size of array element to allocate.
   count :  count of elements to allocate in the array.
   Returns
   A pointer to type. (this is important, since in C++ it's cast
   correctly to the destination type).                           */
#define NewArray(type,count) ((type*)HeapAllocate(0,sizeof(type)*(count)))
/* Allocate sizeof(type). Will invoke some sort of registered
   initializer
   Parameters
   type :  type to allocate for. Passes the name of the type so
           the allocator can do a registered procedure lookup and
           invok an initializer for the type.                     */
//#define NewObject(type) ((type*)FancyAllocate(sizeof(type),#type DBG_SRC))
#ifdef __cplusplus
/* A 'safe' release macro. casts the block to the type to
   release. Makes sure the pointer being released is the type
   specified.
   Parameters
   type :   type of the variable
   thing :  the thing to actually release.                    */
#  ifdef _DEBUG
#    define Deallocate(type,thing) for(type _zzqz_tmp=thing;ReleaseEx((POINTER)(_zzqz_tmp)DBG_SRC),0;)
#  else
#    define Deallocate(type,thing) ReleaseEx((POINTER)(thing)DBG_SRC)
#  endif
#else
#  define Deallocate(type,thing) (ReleaseEx((POINTER)(thing)DBG_SRC))
#endif
/* <combine sack::memory::HeapAllocateEx@PMEM@uintptr_t nSize>
   \ \                                                        */
#define HeapAllocate(heap, n) HeapAllocateEx( (heap), (n) DBG_SRC )
   /* <combine sack::memory::HeapAllocateAlignedEx@PMEM@uintptr_t@uint32_t>
   \ \                                                        */
#define HeapAllocateAligned(heap, n, m) HeapAllocateAlignedEx( (heap), (n), m DBG_SRC )
   /* <combine sack::memory::AllocateEx@uintptr_t nSize>
   \ \                                               */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Allocate( n ) HeapAllocateEx( (PMEM)0, (n) DBG_SRC )
#endif
//MEM_PROC  POINTER MEM_API  AllocateEx ( uintptr_t nSize DBG_PASS );
//#define Allocate(n) AllocateEx(n DBG_SRC )
MEM_PROC  POINTER MEM_API  GetFirstUsedBlock ( PMEM pHeap );
/* Releases an allocated block. Memory becomes free to allocate
   again. If debugging information is passed, the releasing
   source and line is recorded in the block. (can be used to
   find code deallocating memory it shouldn't).
   This also works with Hold(), and decrements the hold counter.
   If there are no more holds on the block, then the block is
   released.
   Parameters
   p :  pointer to allocated block to release.                   */
MEM_PROC  POINTER MEM_API  ReleaseEx ( POINTER pData DBG_PASS ) ;
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#ifdef FIX_RELEASE_COM_COLLISION
#else
/* <combine sack::memory::ReleaseEx@POINTER pData>
   \ \                                             */
#define Release(p) ReleaseEx( (p) DBG_SRC )
#endif
/* Adds a usage count to a block of memory. For each count
   added, an additional release must be used. This can be used
   to keep a copy of the block, even if some other code
   automatically releases it.
   Parameters
   pointer :  pointer to a block of memory that was Allocate()'d.
   Example
   Allocate a block of memory, and release it properly. But we
   passed it to some function. That function wanted to keep a
   copy of the block, so it can apply a hold. It needs to later
   do a Release again to actually free the memory.
   <code lang="c++">
   POINTER p = Allocate( 32 );
   call_some_function( p );
   Release( p );
   void call_some_function( POINTER p )
   {
      static POINTER my_p_copy;
      my_p_copy = p;
      Hold( p );
   }
   </code>                                                        */
MEM_PROC  POINTER MEM_API  HoldEx ( POINTER pData DBG_PASS  );
/* <combine sack::memory::HoldEx@POINTER pData>
   \ \                                          */
#define Hold(p) HoldEx(p DBG_SRC )
/* This can be used to add additional space after the end of a
   memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the curernt data is copied to the
   beginning of the new block, and the memory after the existing
   content is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
#define HeapReallocateAligned(heap,p,sz,al) HeapReallocateEx( (heap),(p),(sz),(al) DBG_SRC )
#define HeapReallocate(heap,p,sz) HeapReallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapReallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                 */
MEM_PROC  POINTER MEM_API  ReallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::ReallocateEx@POINTER@uintptr_t size>
   \ \                                                        */
#ifdef FIX_RELEASE_COM_COLLISION
#else
#define Reallocate(p,sz) ReallocateEx( (p),(sz) DBG_SRC )
#endif
/* This can be used to add additional space before the beginning
   of a memory block.
   Parameters
   pHeap :   If NULL or not specified, uses the common memory heap.
   source :  pointer to the block to pre\-allocate. If NULL, a new
             memory block will be allocated that is filled with 0.
   size :    the new size of the block.
   Returns
   A pointer to a new block of memory that is the new size.
   Remarks
   If the size specified for the new block is larger than the
   previous size of the block, the content data is copied to the
   end of the new block, and the memory leading up to the block
   is cleared to 0.
   If the size specified for the new block is smaller than the
   previous size, the end of the original block is not copied to
   the new block.
   If NULL is passed as the source block, then a new block
   filled with 0 is created.                                        */
MEM_PROC  POINTER MEM_API  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
#define HeapPreallocate(heap,p,sz) HeapPreallocateEx( (heap),(p),(sz) DBG_SRC )
/* <combine sack::memory::HeapPreallocateEx@PMEM@POINTER@uintptr_t size>
   \ \                                                                  */
MEM_PROC  POINTER MEM_API  PreallocateAlignedEx ( POINTER source, uintptr_t size, uint16_t alignment DBG_PASS );
MEM_PROC  POINTER MEM_API  PreallocateEx ( POINTER source, uintptr_t size DBG_PASS );
/* <combine sack::memory::PreallocateEx@POINTER@uintptr_t size>
   \ \                                                         */
#define PreallocateAligned(p,sz,al) PreallocateAlignedEx( (p),(sz),(al) DBG_SRC )
#define Preallocate(p,sz) PreallocateEx( (p),(sz) DBG_SRC )
/* Moves a block of memory from one heap to another.
   Parameters
   pNewHeap :  heap target to move the block to.
   source :    source block to move \- pointer to the data in the
               block.
   Remarks
   Since each block remembers its own size, it is possible to
   move a block from one heap to another. A heap might be a
   memory mapped file at a specific address for instance.         */
MEM_PROC  POINTER MEM_API  HeapMoveEx ( PMEM pNewHeap, POINTER source DBG_PASS );
/* <combine sack::memory::HeapMoveEx@PMEM@POINTER source>
   \ \                                                    */
#define HeapMove(h,s) HeapMoveEx( (h), (s) DBG_SRC )
/* \returns the size of a memory block which was Allocate()'d.
   Parameters
   pData :  pointer to a allocated memory block.
   Returns
   The size of the block that was specified by the Allocate(). */
MEM_PROC uintptr_t MEM_API  SizeOfMemBlock ( CPOINTER pData );
/* \returns the allocation alignment of a memory block which was Allocate()'d.
Parameters
pData :  pointer to a allocated memory block.
Returns
The alignment of the block that was specified from Allocate(). */
MEM_PROC uint16_t  AlignOfMemBlock( CPOINTER pData );
/* not so much of a fragment as a consolidation. Finds a free
   spot earlier in the heap and attempts to move the block
   there. This can help alleviate heap fragmentation.
   Parameters
   ppMemory :  pointer to a pointer to memory which might move */
MEM_PROC  LOGICAL MEM_API  Defragment ( POINTER *ppMemory );
/* \ \
   Parameters
   pHeap :        pointer to a heap
   pFree :        pointer to a 32 bit value to receive the size
                  of free space
   pUsed :        pointer to a 32 bit value to receive the size
                  of used space
   pChunks :      pointer to a 32 bit value to receive the total
                  count of chunks.
   pFreeChunks :  pointer to a 32 bit value to receive the total
                  count of free chunks.
   Remarks
   It looks like DBG_PASS parameter isn't used... not sure why
   it would here, there is no allocate or delete.
   The count of allocated chunks can be gotten by subtracting
   FreeChunks from Chunks.
   Example
   <code lang="c++">
   uint32_t free;
   uint32_t used;
   uint32_t chunks;
   uint32_t free_chunks;
   GetHeapMemStatsEx( NULL, &amp;free, &amp;used, &amp;chunks, &amp;free_chunks );
   </code>                                                                         */
MEM_PROC  void MEM_API  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS );
/* <combine sack::memory::GetHeapMemStatsEx@PMEM@uint32_t *@uint32_t *@uint32_t *@uint32_t *pFreeChunks>
   \ \                                                                               */
#define GetHeapMemStats(h,f,u,c,fc) GetHeapMemStatsEx( h,f,u,c,fc DBG_SRC )
//MEM_PROC  void MEM_API  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
MEM_PROC  void MEM_API  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks );
/* Sets whether to log allocations or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, allocation logging is turned on. Enables
                 logging when each block is Allocated, Released,
                 or Held.                                          */
MEM_PROC  int MEM_API  SetAllocateLogging ( LOGICAL bTrueFalse );
/* disables storing file/line, also disables auto GetMemStats
   checking
   Parameters
   bDisable :  set to TRUE to disable allocate debug logging. */
MEM_PROC  int MEM_API  SetAllocateDebug ( LOGICAL bDisable );
/* disables auto GemMemStats on every allocate/release/Hold
   GetMemStats will evaluate each and every block allocated in
   memory and inspect it for corruption.
   Parameters
   bDisable :  set to TRUE to disable auto mem check.          */
MEM_PROC  int MEM_API  SetManualAllocateCheck ( LOGICAL bDisable );
/* Sets whether to log critical sections or not.
   \returns the prior state of logging...
   Parameters
   bTrueFalse :  if TRUE, critical section logging is turned on. Logs
                 when each thread enters or leaves a
                 CRITICIALSECTION.                                    */
MEM_PROC  int MEM_API  SetCriticalLogging ( LOGICAL bTrueFalse );
/* Sets the minimum size to allocate. If a block size less than
   this is allocated, then this much is actually allocated.
   Parameters
   nSize :  Specify the minimum allocation size                 */
MEM_PROC  void MEM_API  SetMinAllocate ( size_t nSize );
/* Sets how much a heap is expanded by when it is out of space. Default
   is like 512k.
   Parameters
   dwSize :  the new size to expand heaps by.
   Remarks
   Probably internally, this is rounded up to the next 4k
   boundary.                                                            */
MEM_PROC  void MEM_API  SetHeapUnit ( size_t dwSize );
/* Multi-processor safe exchange operation. Returns the prior
   value at the pointer.
   Parameters
   p :    pointer to a volatile 64 bit value.
   val :  a new 64 bit value to put at (*p)
   Example
   <code lang="c#">
   uint64_t value = 13;
   uint64_t oldvalue = LockedExchange64( &amp;value, 15 );
   // old value will be 13
   // value will be 15
   </code>                                                    */
MEM_PROC  uint64_t MEM_API  LockedExchange64 ( volatile uint64_t* p, uint64_t val );
/* A multi-processor safe increment of a variable.
   Parameters
   p :  pointer to a 32 bit value to increment.    */
MEM_PROC  uint32_t MEM_API  LockedIncrement ( uint32_t* p );
/* Does a multi-processor safe decrement on a variable.
   Parameters
   p :  pointer to a 32 bit value to decrement.         */
MEM_PROC  uint32_t MEM_API  LockedDecrement ( uint32_t* p );
#ifdef __cplusplus
// like also __if_assembly__
//extern "C" {
#endif
#ifdef __64__
#define LockedExchangePtrSzVal(a,b) LockedExchange64((volatile uint64_t*)(a),b)
#else
#define LockedExchangePtrSzVal(a,b) LockedExchange((volatile uint32_t*)(a),b)
#endif
/* Multiprocessor safe swap of the contents of a variable with a
   new value, and result with the old variable.
   Parameters
   p :    pointer to a 32 bit value to exchange
   val :  value to set into the variable
   Returns
   The prior value in p.
   Example
   <code>
   uint32_t variable = 0;
   uint32_t oldvalue = LockedExchange( &amp;variable, 1 );
   </code>                                                       */
MEM_PROC  uint32_t MEM_API  LockedExchange ( volatile uint32_t* p, uint32_t val );
/* Sets a 32 bit value into memory. If the length to set is not
   a whole number of 32 bit words, the last bytes may contain
   the low 16 bits of the value and the low 8 bits.
   Parameters
   p :   pointer to memory to set
   n :   32 bit value to set memory with
   sz :  length to set
   Remarks
   Writes as many 32 it values as will fit in sz.
   If (sz &amp; 2), the low 16 bits of n are written at the end.
   then if ( sz &amp; 1 ) the low 8 bits of n are written at the
   end.                                                          */
MEM_PROC  void MEM_API  MemSet ( POINTER p, uintptr_t n, size_t sz );
//#define _memset_ MemSet
/* memory copy operation. not safe when buffers overlap. Performs
   platform-native memory stream operation to copy from one
   place in memory to another. (32 or 64 bit operations as
   possible).
   Parameters
   pTo :    Memory to copy to
   pFrom :  memory to copy from
   sz :     size of block of memory to copy                       */
MEM_PROC  void MEM_API  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz );
//#define _memcpy_ MemCpy
/* Binary byte comparison of one block of memory to another. Results
   \-1 if less, 1 if more and 0 if equal.
   Parameters
   pOne :  pointer to memory one
   pTwo :  pointer to some other memory
   sz :    count of bytes to compare
   Returns
   0 if equal
   \-1 if the first different byte in pOne is less than pTwo.
   1 if the first different byte in pOne is more than pTwo.          */
MEM_PROC  int MEM_API  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz );
	/* nothing.
   does nothing, returns nothing. */
//#define memnop(mem,sz,comment)
#ifdef __cplusplus
//};
#endif
/* Compares two strings. Must match exactly.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
	if s1 and s2 are NULL return is 0.              */
#ifdef StrCmp
#undef StrCmp
 // StrCmp
#endif
MEM_PROC  int MEM_API  StrCmp ( CTEXTSTR pOne, CTEXTSTR pTwo );
/* Compares two strings, case insensitively.
   Parameters
   s1 :  string to compare
   s2 :  string to compare
   Returns
   0 if equal.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.              */
MEM_PROC  int MEM_API  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 );
/* String insensitive case comparison with maximum length
   specified.
   Parameters
   s1 :      string to compare
   s2 :      string to compare
   maxlen :  maximum character required to match
   Returns
   0 if equal up to the number of characters.
   1 if (s1 \>s2)
   \-1 if (s1 \< s2)
   if s1 is NULL and s2 is not NULL, return is -1.
   if s2 is NULL and s1 is not NULL, return is 1.
   if s1 and s2 are NULL return is 0.                     */
MEM_PROC  int MEM_API  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen );
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This flavor is the only one on C where operator overloading
   cannot switch between CTEXTSTR and TEXTSTR parameters, to
   \result with the correct type. If a CTEXTSTR is passed to
   this it should result with a CTEXTSTR, but if that's the only
   choice, then the result of this is never modifiable, even if
	it is a pointer to a non-const TEXTSTR.                       */
MEM_PROC  CTEXTSTR MEM_API  StrChr ( CTEXTSTR s1, TEXTCHAR c );
/* copy S2 to S1, with a maximum of N characters.
   The last byte of S1 will always be a 'nul'. If S2 was longer
   than S1, then it will be truncated to fit within S1. Perferred
   method over this is SaveText or StrDup.
   Parameters
   s1 :      desitnation TEXTCHAR buffer
   s2 :      source string
   length :  the maximum number of characters that S1 can hold. (this
             is not a size, but is a character count)                 */
MEM_PROC  TEXTSTR MEM_API  StrCpyEx ( TEXTSTR s1, CTEXTSTR s2, size_t n );
/* copy S2 to S1. This is 'unsafe', since neither paramter's
   size is known. Prefer StrCpyEx which passes the maximum
   length for S1.
   Parameters
   s1 :  desitnation TEXTCHAR buffer
   s2 :  source string                                       */
MEM_PROC  TEXTSTR MEM_API  StrCpy ( TEXTSTR s1, CTEXTSTR s2 );
/* \Returns the count of characters in a string.
   Parameters
   s :  string to measure
   Returns
   length of string.                             */
MEM_PROC  size_t MEM_API  StrLen ( CTEXTSTR s );
/* Get the length of a string in C chars.
   Parameters
   s :  char * to count.
   Returns
   the length of s. If s is NULL, return 0. */
MEM_PROC  size_t MEM_API  CStrLen ( char const*s );
/* Finds the last instance of a character in a string.
   Parameters
   s1 :  String to search in
   c :   character to find
   Returns
   NULL if character is not in the string.
   a pointer to the last character in s1 that matches c. */
MEM_PROC  CTEXTSTR MEM_API  StrRChr ( CTEXTSTR s1, TEXTCHAR c );
#ifdef __cplusplus
/* This searches a string for the first character that matches
   some specified character.
   A custom strchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrChr ( TEXTSTR s1, TEXTCHAR c );
/* This searches a string for the last character that matches
   some specified character.
   A custom strrchr function, since microsoft is saying this is
   an unsafe function. This Compiles to compare native strings,
   if UNICODE uses unicode, otherwise uses 8 bit characters.
   Parameters
   s1 :  String to search
   c :   Character to find
   Returns
   pointer in string to search that is the first character that
   matches. NULL if no character matches.
   Note
   This second flavor is only available on C++ where operator
   overloading will switch between CTEXTSTR and TEXTSTR
   \parameters, to result with the correct type. If a CTEXTSTR
   is passed to this it should result with a CTEXTSTR, but if
   that's the only choice, then the result of this is never
   modifiable, even if it is a pointer to a non-const TEXTSTR.  */
MEM_PROC  TEXTSTR MEM_API  StrRChr ( TEXTSTR s1, TEXTCHAR c );
/* <combine sack::memory::StrCmp@CTEXTSTR@CTEXTSTR>
   \ \                                              */
MEM_PROC  int MEM_API  StrCmp ( const char * s1, CTEXTSTR s2 );
#endif
/* <combine sack::memory::StrCmp@char *@CTEXTSTR>
   \ \                                            */
MEM_PROC  int MEM_API  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen );
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code lang="c++">
   TEXTCHAR const *found = StrStr( WIDE( "look in this string" ), WIDE( "in" ) );
                                               ^returns a pointer to here.
   </code>                                                                        */
MEM_PROC  CTEXTSTR MEM_API  StrStr ( CTEXTSTR s1, CTEXTSTR s2 );
#ifdef __cplusplus
/* Finds an instance of a string in another string.
   Custom implementation because strstr is declared unsafe, and
   to handle switching between unicode and char.
   Parameters
   s1 :  the string to search in
   s2 :  the string to locate
   Returns
   NULL if s2 is not in s1.
   The beginning of the string in s1 that matches s2.
   Example
   <code>
   TEXTCHAR *writable_string = StrDup( WIDE( "look in this string" ) );
   TEXTCHAR *found = StrStr( writable_string, WIDE( "in" ) );
   // returns a pointer to 'in' in the writable string, which can then be modified.
   </code>                                                                          */
MEM_PROC  TEXTSTR MEM_API  StrStr ( TEXTSTR s1, CTEXTSTR s2 );
#endif
/* Searches for one string in another. Compares case
   insensitively.
   Parameters
   s1 :  string to search in
   s2 :  string to locate
   See Also
   <link sack::memory::StrStr@CTEXTSTR@CTEXTSTR, StrStr> */
MEM_PROC  CTEXTSTR MEM_API  StrCaseStr ( CTEXTSTR s1, CTEXTSTR s2 );
/* This duplicates a block of memory.
   Parameters
   p :  pointer to a block of memory that was allocated.
   Returns
   a pointer to a new block of memory that has the same content
   as the original.                                             */
MEM_PROC  POINTER MEM_API  MemDupEx ( CPOINTER thing DBG_PASS );
/* <combine sack::memory::MemDupEx@CPOINTER thing>
   \ \                                             */
#define MemDup(thing) MemDupEx(thing DBG_SRC )
/* Duplicates a string, and returns a pointer to the copy.
   Parameters
   original :  string to duplicate                         */
MEM_PROC  TEXTSTR MEM_API  StrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a char string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *  MEM_API  CStrDupEx ( CTEXTSTR original DBG_PASS );
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  wchar_t *  MEM_API  DupTextToWideEx( CTEXTSTR original DBG_PASS );
#define DupTextToWide(s) DupTextToWideEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC  char *     MEM_API  DupTextToCharEx( CTEXTSTR original DBG_PASS );
#define DupTextToChar(s) DupTextToCharEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupWideToTextEx( const wchar_t *original DBG_PASS );
#define DupWideToText(s) DupWideToTextEx( s DBG_SRC )
/* Translates from a TEXTCHAR string to a wchar_t string. Probably
   only for UNICODE to non wide translation points.
   Parameters
   original :  string to duplicate                              */
MEM_PROC TEXTSTR     MEM_API  DupCharToTextEx( const char *original DBG_PASS );
#define DupCharToText(s) DupCharToTextEx( s DBG_SRC )
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
   UNICODE compiled)
   Parameters
   original :  original string of C char.
   Returns
   a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrEx ( const char * original DBG_PASS );
/* Converts from 8 bit char to 16 bit wchar (or no-op if not
UNICODE compiled)
Parameters
original :  original string of C char.
Returns
a pointer to a wide character string.                     */
MEM_PROC  TEXTSTR MEM_API  DupCStrLenEx( const char * original, size_t chars DBG_PASS );
/* <combine sack::memory::StrDupEx@CTEXTSTR original>
   \ \                                                */
#define StrDup(o) StrDupEx( (o) DBG_SRC )
/* <combine sack::memory::CStrDupEx@CTEXTSTR original>
   \ \                                                 */
#define CStrDup(o) CStrDupEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrEx@char * original>
   \ \                                               */
#define DupCStr(o) DupCStrEx( (o) DBG_SRC )
/* <combine sack::memory::DupCStrLenEx@char * original@size_t chars>
   \ \                                               */
#define DupCStrLen(o,l) DupCStrLenEx( (o),(l) DBG_SRC )
//------------------------------------------------------------------------
#if 0
// this code was going to provide network oriented shared memory.
#ifndef TRANSPORT_STRUCTURE_DEFINED
typedef uintptr_t PTRANSPORT_QUEUE;
struct transport_queue_tag { uint8_t private_data_here; };
#endif
MEM_PROC  struct transport_queue_tag * MEM_API  CreateQueue ( int size );
MEM_PROC  int MEM_API  EnqueMessage ( struct transport_queue_tag *queue, POINTER msg, int size );
MEM_PROC  int MEM_API  DequeMessage ( struct transport_queue_tag *queue, POINTER msg, int *size );
MEM_PROC  int MEM_API  PequeMessage ( struct transport_queue_tag *queue, POINTER *msg, int *size );
#endif
//------------------------------------------------------------------------
#ifdef __cplusplus
 // namespace memory
};
 // namespace sack
};
using namespace sack::memory;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
/*
inline void operator delete( void * p )
{ Release( p ); }
#ifdef DELETE_HANDLES_OPTIONAL_ARGS
inline void operator delete (void * p DBG_PASS )
{ ReleaseEx( p DBG_RELAY ); }
#define delete delete( DBG_VOIDSRC )
#endif
//#define deleteEx(file,line) delete(file,line)
#ifdef USE_SACK_ALLOCER
inline void * operator new( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
static void * operator new[]( size_t size DBG_PASS )
{ return AllocateEx( (uintptr_t)size DBG_RELAY ); }
#define new new( DBG_VOIDSRC )
#define newEx(file,line) new(file,line)
#endif
*/
// common names - sometimes in conflict when declaring
// other functions... AND - release is a common
// component of iComObject
//#undef Allocate
//#undef Release
// Hmm wonder where this conflicted....
//#undef LineDuplicate
#else
#ifdef USE_SACK_ALLOCER
inline void * operator new(size_t size)
{ return AllocateEx( size ); }
inline void operator delete (void * p)
{ ReleaseEx( p ); }
#endif
#endif
#endif
#endif
#ifndef _TIMER_NAMESPACE
#ifdef __cplusplus
#define _TIMER_NAMESPACE namespace timers {
/* define a timer library namespace in C++. */
#define TIMER_NAMESPACE SACK_NAMESPACE namespace timers {
/* define a timer library namespace in C++ end. */
#define TIMER_NAMESPACE_END } SACK_NAMESPACE_END
#else
#define _TIMER_NAMESPACE
#define TIMER_NAMESPACE
#define TIMER_NAMESPACE_END
#endif
#endif
// this is a method replacement to use PIPEs instead of SEMAPHORES
// replacement code only affects linux.
#if defined( __QNX__ ) || defined( __MAC__) || defined( __LINUX__ ) || defined( __ANDROID__ )
#  define USE_PIPE_SEMS
// no semtimedop; no semctl, etc
//#include <sys/sem.h>
#endif
#ifdef USE_PIPE_SEMS
#  define _NO_SEMTIMEDOP_
#endif
SACK_NAMESPACE
/* This namespace contains methods for working with timers and
   threads. Since timers are implemented in an asynchronous
   thread, the thread creation and control can be exposed here
   also.
   ThreadTo
   WakeThread
   WakeableSleep [Example]
   AddTimer
   RemoveTimer
   RescheduleTimer
   EnterCriticalSec see Also
 EnterCriticalSecNoWait
   LeaveCriticalSec                                            */
_TIMER_NAMESPACE
#ifdef TIMER_SOURCE
#define TIMER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
/* Defines import export and call method for timers. Looks like
   timers are native calltype by default instead of CPROC.      */
#define TIMER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if defined( __LINUX__ ) || defined( __ANDROID__ )
TIMER_PROC( uint32_t, timeGetTime )( void );
TIMER_PROC( uint32_t, GetTickCount )( void );
TIMER_PROC( void, Sleep )( uint32_t ms );
#endif
/* Function signature for user callbacks passed to AddTimer. */
typedef void (CPROC *TimerCallbackProc)( uintptr_t psv );
/* Adds a new periodic timer. From now, until the timer is
   removed with RemoveTimer, it will call the timer procedure at
   the specified frequency of milliseconds. The delay until the
   first time the timer fires can be specified independant of
   frequency. If it is not specified, the first time the timer
   will get invoked is at +1 frequency from now.
   Parameters
   start :      how long in milliseconds until the timer starts. Can
                be 0 and timer will fire at the next opportunity.
   frequency :  how long the delay is between event invocations,
                in milliseconds.
   callback :   user routine to call when the timer's delay
                expires.
   user :       user data to pass to the callback when it is
                invoked.
   Returns
   a 32 bit ID that identifies the timer for this application.
   Example
   First some setup valid for all timer creations...
   <code lang="c++">
   void CPROC TimerProc( uintptr_t user_data )
   {
       // user_data of the timer is the 'user' parameter passed to AddTimer(Exx)
   }
   </code>
   you might want to save this for something like
   RescheduleTimer
   <code>
   uint32_t timer_id;
   </code>
   Create a simple timer, it will fire at 250 milliseconds from
   now, and again every 250 milliseconds from the time it
   starts.
   <code lang="c++">
   timer_id = AddTimer( 250, TimerProc, 0 );
   </code>
   Create a timer that fires immediately, and 732 milliseconds
   after, passing some value 1234 as user data...
   <code lang="c++">
   timer_id = AddTimerEx( 0, 732, TimerProc, 1234 );
	</code>
	Remarks
	if a timer is dispatched and needs to wait - please link with idlelib, and call Idle.
	this will allow other timers to fire on schedule.  The timer that is waiting is not
	in the list of timers to process.
	*/
TIMER_PROC( uint32_t, AddTimerExx )( uint32_t start, uint32_t frequency
					, TimerCallbackProc callback
					, uintptr_t user DBG_PASS);
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimerEx( s,f,c,u ) AddTimerExx( (s),(f),(c),(u) DBG_SRC )
/* <combine sack::timers::AddTimerExx@uint32_t@uint32_t@TimerCallbackProc@uintptr_t user>
   \ \                                                                         */
#define AddTimer( f, c, u ) AddTimerExx( (f), (f), (c), (u) DBG_SRC)
/* Stops a timer. The next time this timer would run, it will be
   removed. If it is currently dispatched, it is safe to remove
   from within the timer itself.
   Parameters
   timer :  32 bit timer ID from AddTimer.                       */
TIMER_PROC( void, RemoveTimer )( uint32_t timer );
/* Reschedule when a timer can fire. The delay can be 0 to make
   wake the timer.
   Parameters
   timer :  32 bit timer identifier from AddTimer.
   delay :  How long before the timer should run now.<p />If 0,
            will issue timer immediately.<p />If not specified,
            using the macro, the default delay is the timer's
            frequency. (can prevent the timer from firing until
            it's frequency from now.)                           */
TIMER_PROC( void, RescheduleTimerEx )( uint32_t timer, uint32_t delay );
/* <combine sack::timers::RescheduleTimerEx@uint32_t@uint32_t>
   \ \                                               */
TIMER_PROC( void, RescheduleTimer )( uint32_t timer );
/* Changes the frequency of a timer. Reschedule timer only
   changes the next time it fires, this can adjust the
   frequency. The simple ChangeTimer macro is sufficient.
   Parameters
   ID :         32 bit ID of the time created by AddTimer.
   initial :    initial delay of the timer. (Might matter if the
                timer hasn't fired the first time)
   frequency :  new delay between timer callback invokations.    */
TIMER_PROC( void, ChangeTimerEx )( uint32_t ID, uint32_t initial, uint32_t frequency );
/* <combine sack::timers::ChangeTimerEx@uint32_t@uint32_t@uint32_t>
   \ \                                               */
#define ChangeTimer( ID, Freq ) ChangeTimerEx( ID, Freq, Freq )
/* This is the type returned by MakeThread, and passed to
   ThreadTo. This is a private structure, and no definition is
   publicly available, this should be treated like a handle.   */
typedef struct threads_tag *PTHREAD;
/* Function signature for a thread entry point passed to
   ThreadTo.                                             */
typedef uintptr_t (CPROC*ThreadStartProc)( PTHREAD );
/* Function signature for a thread entry point passed to
   ThreadToSimple.                                             */
typedef uintptr_t (*ThreadSimpleStartProc)( POINTER );
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToEx )( ThreadStartProc proc, uintptr_t param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadTo(proc,param) ThreadToEx( proc,param DBG_SRC )
/* Create a separate thread that starts in the routine
   specified. The uintptr_t value (something that might be a
   pointer), is passed in the PTHREAD structure. (See
   GetThreadParam)
   Parameters
   proc :       starting routine for the thread
   user_data :  some value that can be stored in the number of
                bits that a pointer is. This is passed to the
                proc when the thread starts.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( PTHREAD, ThreadToSimpleEx )( ThreadSimpleStartProc proc, POINTER param DBG_PASS );
/* <combine sack::timers::ThreadToEx@ThreadStartProc@uintptr_t param>
   \ \                                                               */
#define ThreadToSimple(proc,param) ThreadToSimpleEx( proc,param DBG_SRC )
/* \Returns a PTHREAD that represents the current thread. This
   can be used to create a PTHREAD identifier for the main
   thread.
   Parameters
   None.
   Returns
   a pointer to a thread structure that identifies the current
   thread. If this thread already has this structure created,
   the same one results on subsequent MakeThread calls.        */
TIMER_PROC( PTHREAD, MakeThread )( void );
/* Releases resources associated with a PTHREAD. For purposes of
   waking a thread, and providing a wakeable point for the
   thread, a system blocking event object is allocated, named
   with the THREAD_ID so it can be referenced by other
   processes. This is only allowed to be done by the thread
   itself.
   Parameters
   Param1 :  \Description
   Param2 :  \Description
   Example
   <code lang="c++">
   int main( void )
   {
       PTHREAD myself = MakeThread();
       // create threads, do stuff...
       UnmakeThread();
       At this point the pointer in 'myself' is invalid, and should be cleared.
       myself = NULL;
   }
   </code>                                                                      */
TIMER_PROC( void, UnmakeThread )( void );
/* This returns the parameter passed as user data to ThreadTo.
   Parameters
   thread :  thread to get the parameter from.
   Example
   See WakeableSleepEx.                                        */
TIMER_PROC( uintptr_t, GetThreadParam )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThreadID )( PTHREAD thread );
/* \returns the numeric THREAD_ID from a PTHREAD.
   Parameters
   thread :  thread to get the system wide unique ID of. */
TIMER_PROC( THREAD_ID, GetThisThreadID )( void );
/* Symbol defined to pass to Wakeable_Sleep to sleep until
   someone calls WakeThread.                               */
#define SLEEP_FOREVER 0xFFFFFFFF
/* Sleeps a number of milliseconds or until the thread is passed
   to WakeThread.
   Parameters
   dwMilliseconds :  How long to sleep. Can be indefinite if
                     value is SLEEP_FOREVER.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   uintptr_t CPROC WakeMeThread( PTHREAD thread )
   {
      // get the value passed to ThreadTo as user_data.
      uintptr_t user_data = GetThreadParam( thread );
      // let the main thread sleep a little wile
       WakeableSleep( 250 );
      // then wake it up
       WakeThread( main_thread );
       return 0;
   }
   int main( void )
   {
       // save my PTHREAD globally.
       main_thread = MakeThread();
       // create a thread that can wake us
       ThreadTo( WakeMeThread, 0 );
       // demonstrate sleeping
       WakableSleep( SLEEP_FOREVER );
       return 0;
   }
   </code>                                                       */
TIMER_PROC( void, WakeableSleepEx )( uint32_t milliseconds DBG_PASS );
TIMER_PROC( void, WakeableSleep )( uint32_t milliseconds );
TIMER_PROC( void, WakeableNamedSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedSleep( name, n )   WakeableNamedSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedSleeperEx )( CTEXTSTR name DBG_PASS );
#define WakeNamedSleeper( name )   WakeNamedSleeperEx( name DBG_SRC )
TIMER_PROC( void, WakeableNamedThreadSleepEx )( CTEXTSTR name, uint32_t n DBG_PASS );
#define WakeableNamedThreadSleep( name, n )   WakeableNamedThreadSleepEx( name, n DBG_SRC )
TIMER_PROC( void, WakeNamedThreadSleeperEx )( CTEXTSTR name, THREAD_ID therad DBG_PASS );
#define WakeNamedThreadSleeper( name, thread )   WakeNamedThreadSleeperEx( name, thread DBG_SRC )
#ifdef USE_PIPE_SEMS
TIMER_PROC( int, GetThreadSleeper )( PTHREAD thread );
#endif
/* <combine sack::timers::WakeableSleepEx@uint32_t milliseconds>
   \ \                                                      */
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC )
/* Wake a thread by ID, if the pThread is not available. Can be
   used cross-process for instance. Although someone could add a
   method to provide a PTHREAD wrapper around THREAD_ID for
   threads in remote processes, this may not be a best practice.
   Parameters
   thread_id :  THREAD_ID from GetMyThreadID, which is a macro
                appropriate for a platform.                      */
TIMER_PROC( void, WakeThreadIDEx )( THREAD_ID thread DBG_PASS );
/* Wake a thread.
   Example
   See WakeableSleepEx.
   Parameters
   pThread :  thread to wake up from a WakeableSleep. */
TIMER_PROC( void, WakeThreadEx )( PTHREAD thread DBG_PASS );
/* <combine sack::timers::WakeThreadIDEx@THREAD_ID thread>
   \ \                                                     */
#define WakeThreadID(thread) WakeThreadIDEx( thread DBG_SRC )
/* <combine sack::timers::WakeThreadEx@PTHREAD thread>
   \ \                                                 */
#define WakeThread(t) WakeThreadEx(t DBG_SRC )
/* This can be checked to see if the THREAD_ID to wake still has
   an event. Sometimes threads end.
   Parameters
   thread :  thread identifier to check to see if it exists/can be
             woken.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.      */
TIMER_PROC( int, TestWakeThreadID )( THREAD_ID thread );
/* This can be checked to see if the PTHREAD to wake still has
   an event. Sometimes threads call UnmakeThread(). This is a
   more practical test using a THREAD_ID instead. See
   TestWakeThreadID.
   Returns
   TRUE if the thread can be signaled to wake up.
   FALSE if the thread cannot be found or cannot be woken up.  */
TIMER_PROC( int, TestWakeThread )( PTHREAD thread );
//TIMER_PROC( void, WakeThread )( PTHREAD thread );
TIMER_PROC( void, EndThread )( PTHREAD thread );
/* This tests to see if a pointer to a thread references the
   current thread.
   Parameters
   thread :  thread to check to see if it is the current thread.
   Returns
   TRUE if this thread is the same as the PTHREAD passed.
   otherwise FALSE.
   Example
   <code lang="c++">
   PTHREAD main_thread;
   LOGICAL thread_finished_check;
   uintptr_t CPROC ThreadProc( PTHREAD thread )
   {
       if( IsThisThread( main_thread ) )
            printf( "This thread is not the main thread.\\n" );
       else
            printf( "This is the main thread - cannot happen :)\\n" );
   </code>
   <code>
       // mark that this thread is complete
       thread_finished_check = TRUE;
   </code>
   <code lang="c++">
       // hmm - for some reason, just pass the uintptr_t that was passed to ThreadTo as the result.
       return GetThreadParam( thread );
   }
   int main( void )
   {
        main_thread = MakeThread();
        ThreadTo( ThreadProc, 0 );
        // wait for the thread to finish its thread identity check.
        while( !thread_finished_check )
            Relinquish();
        return 0;
   }
   </code>                                                                                         */
TIMER_PROC( int, IsThisThreadEx )( PTHREAD pThreadTest DBG_PASS );
/* <combine sack::timers::IsThisThreadEx@PTHREAD pThreadTest>
   \ \                                                        */
#define IsThisThread(thread) IsThisThreadEx(thread DBG_SRC)
/* Enter a critical section. Only a single thread may be in a
   critical section, if a second thread attempts to enter the
   section while another thread is in it will block until the
   original thread leaves the section. The same thread may enter
   a critical section multiple times. For each time a critical
   section is entered, the thread must also leave the critical
   section (See LeaveCriticalSection).
   Parameters
   pcs :  pointer to a critical section to enter                 */
TIMER_PROC( LOGICAL, EnterCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Leaves a critical section. See EnterCriticalSecEx.
   Parameters
   pcs :  pointer to a critical section.              */
TIMER_PROC( LOGICAL, LeaveCriticalSecEx )( PCRITICALSECTION pcs DBG_PASS );
/* Does nothing. There are no extra resources required for
   critical sections, and the memory is allocated by the
   application.
   Parameters
   pcs :  pointer to critical section to do nothing with.  */
TIMER_PROC( void, DeleteCriticalSec )( PCRITICALSECTION pcs );
#ifdef _WIN32
	TIMER_PROC( HANDLE, GetWakeEvent )( void );
	TIMER_PROC( HANDLE, GetThreadHandle )( PTHREAD thread );
#endif
#ifdef __LINUX__
	TIMER_PROC( pthread_t, GetThreadHandle )(PTHREAD thread);
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
#define EnterCriticalSec(pcs) EnterCriticalSection( pcs )
#define LeaveCriticalSec(pcs) LeaveCriticalSection( pcs )
#else
/* <combine sack::timers::EnterCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define EnterCriticalSec( pcs ) EnterCriticalSecEx( (pcs) DBG_SRC )
/* <combine sack::timers::LeaveCriticalSecEx@PCRITICALSECTION pcs>
   \ \                                                             */
#define LeaveCriticalSec( pcs ) LeaveCriticalSecEx( (pcs) DBG_SRC )
#endif
TIMER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::timers;
#endif
#endif
// $Log: timers.h,v $
// Revision 1.37  2005/05/16 19:06:58  jim
// Extend wakeable sleep to know the originator of the sleep.
//
// Revision 1.36  2004/09/29 16:42:51  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.35  2004/07/07 15:33:54  d3x0r
// Cleaned c++ warnings, bad headers, fixed make system, fixed reallocate...
//
// Revision 1.34  2004/05/02 02:04:16  d3x0r
// Begin border exclusive option, define PushMethod explicitly, fix LaunchProgram in timers.h
//
// Revision 1.33  2003/12/10 15:38:25  panther
// Move Sleep and GetTickCount to real code
//
// Revision 1.32  2003/11/02 00:31:47  panther
// Added debuginfo pass to wakethread
//
// Revision 1.31  2003/10/24 14:59:21  panther
// Added Load/Unload Function for system shared library abstraction
//
// Revision 1.30  2003/10/17 00:56:04  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.29  2003/09/21 04:03:30  panther
// Build thread ID with pthread_self and getgid
//
// Revision 1.28  2003/07/29 10:41:25  panther
// Predefine struct threads_tag to avoid warning
//
// Revision 1.27  2003/07/24 22:49:20  panther
// Define callback procs as CDECL
//
// Revision 1.26  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.25  2003/07/22 15:33:19  panther
// Added comment about idle()
//
// Revision 1.24  2003/04/03 10:10:20  panther
// Add file/line debugging to addtimer
//
// Revision 1.23  2003/03/27 13:47:14  panther
// Immplement a EndThread
//
// Revision 1.22  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef MAXPATH
// windef.h has MAX_PATH
#  define MAXPATH MAX_PATH
#  if (!MAXPATH)
#    undef MAXPATH
#    define MAXPATH 256
#  endif
#endif
#ifndef PATH_MAX
// sometimes PATH_MAX is what's used, well it's should be MAXPATH which is MAX_PATH
# define PATH_MAX MAXPATH
#endif
#ifdef _UNICODE
#  ifdef _WIN32
#    ifdef CONSOLE_SHELL
    // in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#      define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( GetCommandLineW(), &a, &b ); Deallocate( char*, tmp ); {
	//int n; TEXTCHAR **b; b = NewArray( TEXTSTR, a + 1 ); for( n = 0; n < a; n++ ) b[n] = DupCharToText( argv_real[n] ); b[n] = NULL; {
#      define EndSaneWinMain() } }
#    else
#      define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { char *tmp; int a; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#      define EndSaneWinMain() } }
#    endif
#  else
#    if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#      define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#      define EndSaneWinMain()
#    else
#      define SaneWinMain(a,b) int main( int a, char **argv_real ) { int n; TEXTCHAR **b; b = NewArray( TEXTSTR, a + 1 ); for( n = 0; n < a; n++ ) b[n] = DupCharToText( argv_real[n] ); b[n] = NULL; {
#      define EndSaneWinMain() } }
#    endif
#  endif
#else
#  ifdef _WIN32
#    ifdef CONSOLE_SHELL
// in order to get wide characters from the commandline we have to use the GetCommandLineW function, convert it to utf8 for internal usage.
#      define SaneWinMain(a,b) int main( int a, char **argv_real ) { char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); Deallocate( char*, tmp ); {
#      define EndSaneWinMain() } }
#    else
#      define SaneWinMain(a,b) int APIENTRY WinMain( HINSTANCE hInst, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow ) { int a; char *tmp; TEXTCHAR **b; ParseIntoArgs( tmp = WcharConvert( GetCommandLineW() ), &a, &b ); {
#      define EndSaneWinMain() } }
#    endif
#  else
#    if defined( __ANDROID__ ) && !defined( ANDROID_CONSOLE_UTIL )
#      define SaneWinMain(a,b) int SACK_Main( int a, char **b )
#      define EndSaneWinMain()
#    else
#      define SaneWinMain(a,b) int main( int a, char **b ) { char **argv_real = b; {
#      define EndSaneWinMain() } }
#    endif
#  endif
#endif
//  these are rude defines overloading otherwise very practical types
// but - they have to be dispatched after all standard headers.
#ifndef FINAL_TYPES
#define FINAL_TYPES
#  ifdef __WATCOMC__
 //__WATCOMC__
#  endif
#  ifdef _WIN32
#    include <basetsd.h>
  // this redefines lprintf sprintf etc... and strsafe is preferred
 // more things that need override by strsafe.h
#    include <tchar.h>
 // added for mingw64 actually
#    ifdef __GNUC__
#      undef __CRT__NO_INLINE
#    endif
#    ifndef MINGW_SUX
#      include <strsafe.h>
#    else
#      define STRSAFE_E_INSUFFICIENT_BUFFER  0x8007007AL
#    endif
#  else
#  endif
// may consider changing this to uint16_t* for unicode...
#ifdef UNICODE
#  ifndef NO_UNICODE_C
#    define strrchr          wcsrchr
#    define strchr           wcschr
#    define strncpy          wcsncpy
#    ifdef strcpy
#      undef strcpy
#    endif
#    define strcpy           wcscpy
#    define strcmp           wcscmp
#    ifndef __LINUX__
// linux also translates 'i' to 'case' in sack_typelib.h
#      define stricmp          wcsicmp
#      define strnicmp         wcsnicmp
//#  define strlen           mbrlen
#    endif
#    define strlen           wcslen
#    ifdef WIN32
#      define stat(a,b)        _wstat(a,b)
#    else
#    endif
#    define printf           wprintf
#    define fprintf          fwprintf
#    define fputs            fputws
#    define fgets            fgetws
#    define atoi             _wtoi
#    ifdef __WATCOMC__
#      undef atof
#    endif
//#    define atof             _wtof
#    ifdef _MSC_VER
#      ifndef __cplusplus_cli
#        define fprintf   fwprintf
#        define atoi      _wtoi
// define sprintf here.
#      endif
#    endif
#    if defined( _ARM_ ) && defined( WIN32 )
// len should be passed as character count. this was the wrongw ay to default this.
#      define snprintf StringCbPrintf
//#define snprintf StringCbPrintf
#    endif
#  else
//#    define atoi             wtoi
#  endif
 // not unicode...
#else
#endif
#  ifdef _MSC_VER
#    define SUFFER_WITH_NO_SNPRINTF
#    ifndef SUFFER_WITH_NO_SNPRINTF
#      define vnsprintf protable_vsnprintf
//   this one gives deprication warnings
//   #    define vsnprintf _vsnprintf
//   this one doesn't work to measure strings
//   #    define vsnprintf(buf,len,format,args) _vsnprintf_s(buf,len,(len)/sizeof(TEXTCHAR),format,args)
//   this one doesn't macro well, and doesnt' measure strings
//  (SUCCEEDED(StringCbVPrintf( buf, len, format, args ))?StrLen(buf):-1)
#      define snprintf portable_snprintf
//   this one gives deprication warnings
//   #    define snprintf _snprintf
//   this one doesn't work to measure strings
//   #    define snprintf(buf,len,format,...) _snprintf_s(buf,len,(len)/sizeof(TEXTCHAR),format,##__VA_ARGS__)
//   this one doesn't macro well, and doesnt' measure strings
//   (SUCCEEDED(StringCbPrintf( buf, len, format,##__VA_ARGS__ ))?StrLen(buf):-1)
// make sure this is off, cause we really don't, and have to include the following
#      undef HAVE_SNPRINTF
 // define this anyhow so we can avoid name collisions
#      define PREFER_PORTABLE_SNPRINTF
#      ifdef SACK_CORE_BUILD
#        include <../src/snprintf_2.2/snprintf.h>
#      else
#        include <snprintf-2.2/snprintf.h>
 // SACK_CORE_BUILD
#      endif
 // SUFFER_WITH_WARNININGS
#    else
#      define snprintf _snprintf
#      define vsnprintf _vsnprintf
#      if defined( _UNICODE )
#        define tnprintf _snwprintf
#        define vtnprintf _vsnwprintf
#      else
#        define tnprintf _snprintf
#        define vtnprintf _vsnprintf
#      endif
#    define snwprintf _snwprintf
// suffer_with_warnings
#    endif
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf_s
#    else
#    define tscanf sscanf_s
#    endif
#    define scanf sscanf_s
#    define swcanf swscanf_s
 // _MSC_VER
#  endif
#  ifdef  __GNUC__
#      if defined( _UNICODE )
#        define VSNPRINTF_FAILS_RETURN_SIZE
#        define tnprintf  swprintf
#        define vtnprintf vswprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf   swprintf
#           define vsnprintf  vswprintf
//#           define sscanf     swscanf
#        else
#        endif
#      else
#        define tnprintf snprintf
#        define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#    if defined( _UNICODE ) && !defined( NO_UNICODE_C )
#    define tscanf swscanf
#    else
#    define tscanf sscanf
#    endif
#      endif
 // __GNUC__
#  endif
#  ifdef __WATCOMC__
#      if defined( _UNICODE )
#        define tnprintf  _snwprintf
#        define vtnprintf _vsnwprintf
#        if !defined( NO_UNICODE_C )
#           define snprintf  _snwprintf
#           define vsnprintf _vsnwprintf
#           define sscanf     swscanf
#        else
#        endif
#      else
#         define tnprintf  snprintf
#         define vtnprintf vsnprintf
//#        define snprintf snprintf
//#        define vsnprintf vsnprintf
#      endif
#        define snwprintf  _snwprintf
 // __WATCOMC__
#  endif
#endif
#endif
 // tolower on linux
#  include <ctype.h>
/*
 *  Created By Jim Buckeyne
 *
 *  Purpose:
 *    Provides some cross platform/library functionatlity for
 *  filesystem activities.
 *  - File dates, times, stuff like that
 *  - make paths, change paths
 *  - path parsing (like strchr, strrchr, but looking for closest / or \)
 *  - scan a directory for a set of files... using a recursive callback method
 */
#ifndef FILESYSTEM_UTILS_DEFINED
/* Header multiple inclusion protection symbol. */
#define FILESYSTEM_UTILS_DEFINED
#if _MSC_VER >= 1600
#include <share.h>
#endif
#if !defined( UNDER_CE )
#include <fcntl.h>
#if !defined( __LINUX__ )
#include <io.h>
#else
#define LPFILETIME uint64_t*
#define FILETIME uint64_t
#endif
#endif
/* uhmm in legacy usage this was not CPROC, but was unspecified */
#define FILESYS_API CPROC
// DOM-IGNORE-BEGIN
#ifdef FILESYSTEM_LIBRARY_SOURCE
#  define FILESYS_PROC EXPORT_METHOD
#else
#  define FILESYS_PROC IMPORT_METHOD
#endif
// DOM-IGNORE-END
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _FILESYS_NAMESPACE  namespace filesys {
/* Define the ending symbol for file system namespace. */
#define _FILESYS_NAMESPACE_END }
/* Defined the namespace of file montior utilities. File monitor
   provides event notification based on file system changes.     */
#define _FILEMON_NAMESPACE  namespace monitor {
/* Define the end symbol for file monitor namespace. */
#define _FILEMON_NAMESPACE_END }
#else
#define _FILESYS_NAMESPACE
#define _FILESYS_NAMESPACE_END
#define _FILEMON_NAMESPACE
#define _FILEMON_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define FILESYS_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define FILESYS_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE
/* Define end file monitor namespace. */
#define FILEMON_NAMESPACE_END _FILEMON_NAMESPACE_END _FILESYS_NAMESPACE_END SACK_NAMESPACE_END
/* Defines the file montior namespace when compiling C++. */
#define FILEMON_NAMESPACE SACK_NAMESPACE _FILESYS_NAMESPACE _FILEMON_NAMESPACE
SACK_NAMESPACE
/* \File system abstractions. A few things like get current path
   may or may not exist on a function.
   Primarily this defines functions 'pathchr' and 'pathrchr'
   which resemble 'strchr' and 'strrchr' but search a string for
   a path character. A path character is either a / or a \\.
   Also in this area is file monitoring functions which support
   methods on windows and linux to get event notifications when
   directories and, by filtering, files that have changed.
                                                                 */
_FILESYS_NAMESPACE
	enum ScanFileFlags {
 // go into subdirectories
SFF_SUBCURSE    = 1,
 // return directory names also
SFF_DIRECTORIES = 2,
 // don't concatenate base with filename to result.
SFF_NAMEONLY    = 4,
 // when matching filename - do not match case.
SFF_IGNORECASE  = 8,
 // don't concatenate base with filename to result, but do build path relative to root specified
SFF_SUBPATHONLY    = 16,
	};
 // flags sent to Process when called with a matching name
enum ScanFileProcessFlags{
 // is a directory...
SFF_DIRECTORY  = 1,
 // this is a drive...
		SFF_DRIVE      = 2,
};
struct file_system_mounted_interface;
/* Extended external file system interface to be able to use external file systems */
struct file_system_interface {
                                                  //filename
	void* (CPROC *open)(uintptr_t psvInstance, const char *, const char *);
                                                 //file *
	int (CPROC *_close)(void *);
                    //file *, buffer, length (to read)
	size_t (CPROC *_read)(void *,char *, size_t);
                    //file *, buffer, length (to write)
	size_t (CPROC *_write)(void*,const char *, size_t);
	size_t (CPROC *seek)( void *, size_t, int whence);
	void  (CPROC *truncate)( void *);
	int (CPROC *_unlink)( uintptr_t psvInstance, const char *);
 // get file size
	size_t (CPROC *size)( void *);
 // get file current position
	size_t (CPROC *tell)( void *);
	int (CPROC *flush )(void *kp);
	int (CPROC *exists)( uintptr_t psvInstance, const char *file );
	LOGICAL (CPROC*copy_write_buffer)(void );
	struct find_cursor *(CPROC *find_create_cursor )( uintptr_t psvInstance, const char *root, const char *filemask );
	int (CPROC *find_first)( struct find_cursor *cursor );
	int (CPROC *find_close)( struct find_cursor *cursor );
	int (CPROC *find_next)( struct find_cursor *cursor );
	char * (CPROC *find_get_name)( struct find_cursor *cursor );
	size_t (CPROC *find_get_size)( struct find_cursor *cursor );
	LOGICAL (CPROC *find_is_directory)( struct find_cursor *cursor );
	LOGICAL (CPROC *is_directory)( uintptr_t psvInstance, const char *cursor );
	LOGICAL (CPROC *rename )( uintptr_t psvInstance, const char *original_name, const char *new_name );
};
/* \ \
   Parameters
   mask :      This is the mask used to compare
   name :      this is the name to compare against using the mask.
   keepcase :  if TRUE, must match case also.
   Returns
   TRUE if name is matched by mask. Otherwise returns FALSE.
   Example
   <code lang="c++">
   if( CompareMask( "*.exe", "program.exe", FALSE ) )
   {
       // then program.exe is matched by the mask.
   }
   </code>
   Remarks
   The mask support standard 'globbing' characters.
   ? matches one character
   \* matches 0 or more characters
   otherwise the literal character must match, unless comparing
   case insensitive, in which case 'A' == 'a' also.                */
FILESYS_PROC  int FILESYS_API  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase );
// ScanFiles usage:
//   base - base path to scan
//   mask - file mask to process if NULL or "*" is everything "*.*" must contain a .
//   pInfo is a pointer to a void* - this pointer is used to maintain
//        internal information...
//   Process is called with the full name of any matching files
//   subcurse is a flag - set to go into all subdirectories looking for files.
// There is no way to abort the scan...
FILESYS_PROC  int FILESYS_API  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
           , int flags
		   , uintptr_t psvUser, LOGICAL begin_sub_path, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  ScanFiles ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
           , int flags
           , uintptr_t psvUser );
FILESYS_PROC  void FILESYS_API  ScanDrives ( void (CPROC *Process)(uintptr_t user, CTEXTSTR letter, int flags)
										  , uintptr_t user );
// result is length of name filled into pResult if pResult == NULL && nResult = 0
// the result will the be length of the name matching the file.
FILESYS_PROC  int FILESYS_API  GetMatchingFileName ( CTEXTSTR filemask, int flags, TEXTSTR pResult, int nResult );
// searches a path for the last '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathrchr ( CTEXTSTR path );
#ifdef __cplusplus
FILESYS_PROC  TEXTSTR FILESYS_API  pathrchr ( TEXTSTR path );
#endif
// searches a path for the first '/' or '\'
FILESYS_PROC  CTEXTSTR FILESYS_API  pathchr ( CTEXTSTR path );
// returns pointer passed (if it worked?)
FILESYS_PROC  TEXTSTR FILESYS_API  GetCurrentPath ( TEXTSTR path, int buffer_len );
FILESYS_PROC  int FILESYS_API  SetCurrentPath ( CTEXTSTR path );
/* Creates a directory. If parent peices of the directory do not
   exist, those parts are created also.
   Example
   <code lang="c#">
   MakePath( "c:\\where\\I'm/going/to/store/data" );
   </code>                                                       */
FILESYS_PROC  int FILESYS_API  MakePath ( CTEXTSTR path );
/* A boolean result function whether a specified name is a
   directory or not. (if not, assumes it's a file).
   Example
   <code lang="c#">
   if( IsPath( "c:/windows" ) )
   {
       // if yes, then c:\\windows is a directory.
   }
   </code>                                                 */
FILESYS_PROC LOGICAL  FILESYS_API  IsPath ( CTEXTSTR path );
FILESYS_PROC LOGICAL  FILESYS_API  IsAbsolutePath( CTEXTSTR path );
FILESYS_PROC  uint64_t     FILESYS_API  GetFileWriteTime ( CTEXTSTR name );
FILESYS_PROC  uint64_t     FILESYS_API  GetTimeAsFileTime ( void );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileWriteTime( CTEXTSTR name, uint64_t filetime );
FILESYS_PROC  LOGICAL FILESYS_API  SetFileTimes( CTEXTSTR name
  // last modification time.
															  , uint64_t filetime_create
 // last modification time.
															  , uint64_t filetime_modify
  // last modification time.
															  , uint64_t filetime_access
															  );
FILESYS_PROC  void    FILESYS_API  SetDefaultFilePath ( CTEXTSTR path );
FILESYS_PROC  INDEX   FILESYS_API  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_prepend_path ( INDEX group, CTEXTSTR filename );
/* This is a new feature added for supporting systems without a
   current file location. This gets an integer ID of a group of
   files by name.
   the name 'default' is used to specify files to go into the
   'current working directory'
	There are some special symbols.
	. = use CurrentPath
	@ = use program path base
   ^ = use program startup path (may not be current)
   Parameters
   groupname :     name of the group
   default_path :  the path of the group, if the name is not
                   found.
   Returns
   the ID of a file group.
   Example
   <code lang="c++">
   int group = GetFileGroup( "fonts", "./fonts" );
   </code>                                                      */
FILESYS_PROC INDEX FILESYS_API  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path );
FILESYS_PROC TEXTSTR FILESYS_API GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPathEx( CTEXTSTR path, struct file_system_interface *fsi );
FILESYS_PROC TEXTSTR FILESYS_API ExpandPath( CTEXTSTR path );
FILESYS_PROC LOGICAL FILESYS_API SetFileLength( CTEXTSTR path, size_t length );
/* \Returns the size of the file.
   Parameters
   name :  name of the file to get information about
   Returns
   \Returns the size of the file. or -1 if the file did not
   exist.                                                   */
FILESYS_PROC  size_t FILESYS_API  GetSizeofFile ( TEXTCHAR *name, uint32_t* unused );
#ifndef __ANDROID__
/* An extended function, which returns a uint64_t bit time
   appropriate for the current platform. This is meant to
   replace 'stat'. It can get all commonly checked attributes of
   a file.
   Parameters
   name :              name of the file to get information about
   lpCreationTime :    pointer to a FILETIME type to get creation
                       time. can be NULL.
   lpLastAccessTime :  pointer to a FILETIME type to get access
                       time. can be NULL.
   lpLastWriteTime :   pointer to a FILETIME type to get write
                       time. can be NULL.
   IsDirectory :       pointer to a LOGICAL to receive indicator
                       whether the file was a directory. can be
                       NULL.
   Returns
   \Returns the size of the file. or -1 if the file did not
	exist.                                                         */
FILESYS_PROC  uint32_t FILESYS_API  GetFileTimeAndSize ( CTEXTSTR name
													, LPFILETIME lpCreationTime
													,  LPFILETIME lpLastAccessTime
													,  LPFILETIME lpLastWriteTime
													, int *IsDirectory
													);
FILESYS_PROC void FILESYS_API ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime );
FILESYS_PROC uint64_t FILESYS_API ConvertFileTimeToInt( const FILETIME *filetime );
#endif
// can use 0 as filegroup default - single 'current working directory'
#ifndef NEED_OLDNAMES
#define _NO_OLDNAMES
#endif
//#ifdef UNDER_CE
# ifndef O_RDONLY
#define O_RDONLY       0x0000
#define O_WRONLY       0x0001
#define O_RDWR         0x0002
#define O_APPEND       0x0008
#define O_CREAT        0x0100
#define O_TRUNC        0x0200
#define O_EXCL         0x0400
#endif
#ifndef __ANDROID__
#  ifndef S_IRUSR
#    define S_IRUSR 1
#    define S_IWUSR 2
#  endif
#endif
//# endif
#ifndef __LINUX__
FILESYS_PROC  HANDLE FILESYS_API  sack_open ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_set_eof ( HANDLE file_handle );
FILESYS_PROC  long  FILESYS_API   sack_tell( INDEX file_handle );
FILESYS_PROC  HANDLE FILESYS_API  sack_openfile ( INDEX group, CTEXTSTR filename, OFSTRUCT *of, int flags );
FILESYS_PROC  HANDLE FILESYS_API  sack_creat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  int FILESYS_API  sack_close ( HANDLE file_handle );
FILESYS_PROC  int FILESYS_API  sack_lseek ( HANDLE file_handle, int pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_read ( HANDLE file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_write ( HANDLE file_handle, CPOINTER buffer, int size );
#endif
FILESYS_PROC  INDEX FILESYS_API  sack_iopen ( INDEX group, CTEXTSTR filename, int opts, ... );
FILESYS_PROC  INDEX FILESYS_API  sack_iopenfile ( INDEX group, CTEXTSTR filename, int opts, int flags );
FILESYS_PROC  INDEX FILESYS_API  sack_icreat ( INDEX group, CTEXTSTR file, int opts, ... );
FILESYS_PROC  LOGICAL FILESYS_API  sack_iset_eof ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_iclose ( INDEX file_handle );
FILESYS_PROC  int FILESYS_API  sack_ilseek ( INDEX file_handle, size_t pos, int whence );
FILESYS_PROC  int FILESYS_API  sack_iread ( INDEX file_handle, POINTER buffer, int size );
FILESYS_PROC  int FILESYS_API  sack_iwrite ( INDEX file_handle, CPOINTER buffer, int size );
/* internal (c library) file system is registered as prority 1000.... lower priorities are checked first for things like
  ScanFiles(), fopen( ..., "r" ), ... exists(), */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_mount_filesystem( const char *name, struct file_system_interface *, int priority, uintptr_t psvInstance, LOGICAL writable );
FILESYS_PROC void FILESYS_API sack_unmount_filesystem( struct file_system_mounted_interface *mount );
// get a mounted filesystem by name
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_mounted_filesystem( const char *name );
// returrn inteface used on the mounted filesystem.
FILESYS_PROC struct file_system_interface * FILESYS_API sack_get_mounted_filesystem_interface( struct file_system_mounted_interface * );
FILESYS_PROC uintptr_t FILESYS_API sack_get_mounted_filesystem_instance( struct file_system_mounted_interface *mount );
/* sometimes you want scanfiles to only scan external files...
  so this is how to get that mount */
FILESYS_PROC struct file_system_mounted_interface * FILESYS_API sack_get_default_mount( void );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted... */
FILESYS_PROC  FILE* FILESYS_API  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts );
/* specify a mounted system to open... multiple volumes of the same type need a different handle */
FILESYS_PROC  FILE* FILESYS_API  sack_fsopenEx ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode, struct file_system_mounted_interface *fsi );
/* if mode is read, all mounted file systems are attempted...
   if mode is write/create only the first writable file system is used...
*/
FILESYS_PROC  FILE* FILESYS_API  sack_fsopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode );
FILESYS_PROC  struct file_system_interface * FILESYS_API sack_get_filesystem_interface( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_default_filesystem_interface( struct file_system_interface *fsi );
FILESYS_PROC  void FILESYS_API sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi );
FILESYS_PROC  int FILESYS_API  sack_fclose ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount );
FILESYS_PROC  size_t FILESYS_API  sack_fseek ( FILE *file_file, size_t pos, int whence );
FILESYS_PROC  size_t FILESYS_API  sack_ftell ( FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fsize ( FILE *file_file );
FILESYS_PROC  LOGICAL FILESYS_API  sack_existsEx ( const char * filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  LOGICAL FILESYS_API  sack_exists ( const char *file_file );
// tests if the text passed is a directory or path to a file... for a specific mount.
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi );
// tests if the text passed is a directory or path to a file... for all mounts
FILESYS_PROC  LOGICAL FILESYS_API  sack_isPath( const char * filename );
FILESYS_PROC  size_t FILESYS_API  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  size_t FILESYS_API  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file );
FILESYS_PROC  TEXTSTR FILESYS_API  sack_fgets ( TEXTSTR  buffer, size_t size,FILE *file_file );
FILESYS_PROC  int FILESYS_API  sack_fflush ( FILE *file );
FILESYS_PROC  int FILESYS_API  sack_ftruncate ( FILE *file );
FILESYS_PROC int FILESYS_API sack_vfprintf( FILE *file_handle, const char *format, va_list args );
FILESYS_PROC int FILESYS_API sack_fprintf( FILE *file, const char *format, ... );
FILESYS_PROC int FILESYS_API sack_fputs( const char *format, FILE *file );
FILESYS_PROC  int FILESYS_API  sack_unlinkEx ( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_unlink ( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_rmdir( INDEX group, CTEXTSTR filename );
FILESYS_PROC  int FILESYS_API  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount );
FILESYS_PROC  int FILESYS_API  sack_rename ( CTEXTSTR file_source, CTEXTSTR new_name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_application( CTEXTSTR name );
FILESYS_PROC  void FILESYS_API sack_set_common_data_producer( CTEXTSTR name );
#ifndef NO_FILEOP_ALIAS
#  ifndef NO_OPEN_MACRO
# define open(a,...) sack_iopen(0,a,##__VA_ARGS__)
# define set_eof(a)  sack_iset_eof(a)
#  endif
#ifdef WIN32
#if !defined( SACK_BAG_EXPORTS ) && !defined( BAG_EXTERNALS ) && !defined( FILESYSTEM_LIBRARY_SOURCE )
# define _lopen(a,...) sack_open(0,a,##__VA_ARGS__)
# define tell(a)      sack_tell(a)
# define lseek(a,b,c) sack_ilseek(a,b,c)
# define _llseek(a,b,c) sack_lseek(a,b,c)
# define HFILE HANDLE
# undef HFILE_ERROR
# define HFILE_ERROR INVALID_HANDLE_VALUE
# define creat(a,...)  sack_icreat( 0,a,##__VA_ARGS__ )
# define close(a)  sack_iclose(a)
# define OpenFile(a,b,c) sack_openfile(0,a,b,c)
# define _lclose(a)  sack_close(a)
# define read(a,b,c) sack_iread(a,b,c)
# define write(a,b,c) sack_iwrite(a,b,c)
# define _lread(a,b,c) sack_read(a,b,c)
# define _lwrite(a,b,c) sack_write(a,b,c)
# define _lcreat(a,b) sack_creat(0,a,b)
# define remove(a)   sack_unlink(0,a)
# define unlink(a)   sack_unlink(0,a)
#endif
#endif
 //NO_FILEOP_ALIAS
#endif
#ifdef __LINUX__
#define SYSPATHCHAR WIDE("/")
#else
#define SYSPATHCHAR WIDE("\\")
#endif
FILESYS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::filesys;
#endif
#endif
/*
 * Create: James Buckeyne
 *
 * Purpose: Provide a general structure to register names of
 *   routines and data structures which may be consulted
 *   for runtime linking.  Aliases and other features make this
 *   a useful library for tracking interface registration...
 *
 *  The namespace may be enumerated.
 */
#ifndef PROCEDURE_REGISTRY_LIBRARY_DEFINED
#define PROCEDURE_REGISTRY_LIBRARY_DEFINED
#ifndef DEADSTART_DEFINED
#define DEADSTART_DEFINED
#ifdef WIN32
//#include <stdhdrs.h>
#endif
 // leach, assuming this will be compiled with this part at least.
#define pastejunk_(a,b) a##b
#define pastejunk(a,b) pastejunk_(a,b)
#ifdef __cplusplus
#define USE_SACK_DEADSTART_NAMESPACE using namespace sack::app::deadstart;
#define SACK_DEADSTART_NAMESPACE   SACK_NAMESPACE namespace app { namespace deadstart {
#define SACK_DEADSTART_NAMESPACE_END    } } SACK_NAMESPACE_END
SACK_NAMESPACE
	namespace app{
/* Application namespace. */
/* These are compiler-platform abstractions to provide a method
   of initialization that allows for creation of threads, and
   transparent (easy to use) method of scheduling routines for
   initialization.
   Example
   This schedules a routine to run at startup. Fill in the
   routine with the code you want, and it will run at
   DEFAULT_PRELOAD_PRIORITY which is the number 69.
   <code lang="c++">
   PRELOAD( MyCustomInit )
   {
       // do something here (do anything here,
       // without limitations that are imposed by DllMain/LibMain.
   }
   </code>
   If you wanted a routine which was guaranteed to run before
   MyCustomInit you might use PRIORITY_PRELOAD whcih allows you
   to specify a priority.
   <code lang="c++">
   PRIORITY_PRELOAD( MyOtherInit, DEFAULT_PRELOAD_PRIORITY-10 )
   {
      // this will run before other things.
   }
   </code>
   Priorities are listed in deadstart.h and exit_priorities.h. The
   priorities are treated backwards, so low number startup
   priorities go first, and higher number shutdown priorities go
   first.
   Remarks
   In some compilers and compile modes this is also fairly easy
   to do. A lot of compilers do not offer priority, and are
   impossible to maintain an order in. Some compilers only
   provide startup priority for C++ mode. This system works as
   \long as there is a way to run a single function at some
   point before main() and after C runtime initializes.
   In Windows, you might think you have this ability with
   DllMain, but there are severe limitations that you would have
   to get around; primary is the inability to create a thread,
   well, you can create it, but it will remain suspended until
   you leave DllMains and all DllMains finish. There is also no
   way to consistantly provide initialization order, like memory
   needs to be initialized before anything else.
                                                                   */
		namespace deadstart {
#else
#define USE_SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE
#define SACK_DEADSTART_NAMESPACE_END
#endif
#ifdef TYPELIB_SOURCE
#define DEADSTART_SOURCE
#endif
/* A macro to specify the call type of schedule routines. This
   can be changed in most projects without affect, it comes into
   play if plugins built by different compilers are used,
   __cdecl is most standard.                                     */
#define DEADSTART_CALLTYPE CPROC
#  if defined( _TYPELIBRARY_SOURCE_STEAL )
#    define DEADSTART_PROC extern
#  elif defined( _TYPELIBRARY_SOURCE )
#    define DEADSTART_PROC EXPORT_METHOD
#  else
/* A definition for how to declare these functions. if the
   source itself is comipling these are _export, otherwise
   external things linking here are _import.               */
#    define DEADSTART_PROC IMPORT_METHOD
#  endif
   /* this is just a global space initializer (shared, named
      region, allows static link plugins to share information)
      Allocates its shared memory global region, so if this library
      is built statically and referenced in multiple plugins
      ConfigScript can share the same symbol tables. This also
      provides sharing between C++ and C.                           */
#define CONFIG_SCRIPT_PRELOAD_PRIORITY    (SQL_PRELOAD_PRIORITY-3)
   // this is just a global space initializer (shared, named region, allows static link plugins to share information)
#define SQL_PRELOAD_PRIORITY    (SYSLOG_PRELOAD_PRIORITY-1)
/* Level at which logging is initialized. Nothing under this
   should be doing logging, if it does, the behavior is not as
   well defined.                                               */
#define SYSLOG_PRELOAD_PRIORITY 35
   // global_init_preload_priority-1 is used by sharemem.. memory needs init before it can register itself
#define GLOBAL_INIT_PRELOAD_PRIORITY 37
 // OS A[bstraction] L[ayer] O[n] T[op] - system lib
#define OSALOT_PRELOAD_PRIORITY (CONFIG_SCRIPT_PRELOAD_PRIORITY-1)
/* Level which names initializes. Names is the process
   registration code. It has a common shared global registered.
   <link sack::app::registry, procreg; aka names.c>             */
#define NAMESPACE_PRELOAD_PRIORITY 39
/* image_preload MUST be after Namespce preload (anything that
   uses RegisterAndCreateGlobal) should init this before vidlib
   (which needs image?)                                         */
#define IMAGE_PRELOAD_PRIORITY  45
/* Level at which the video render library performs its
   initialization; RegisterClass() level code.          */
#define VIDLIB_PRELOAD_PRIORITY 46
/* Initialization level where PSI registers its builtin
   controls.                                            */
#define PSI_PRELOAD_PRIORITY    47
// need to open the queues and threads before the service server can begin...
#define MESSAGE_CLIENT_PRELOAD_PRIORITY 65
/* Level which message core service initializes. During startup
   message services can register themselves also; but not before
   this priority level.                                          */
#define MESSAGE_SERVICE_PRELOAD_PRIORITY 66
/* Routines are scheduled at this priority when the PRELOAD
   function is used.                                        */
#define DEFAULT_PRELOAD_PRIORITY (DEADSTART_PRELOAD_PRIORITY-1)
/* Not sure where this is referenced, this the core routine
   itself is scheduled with this symbol to the compiler if
   appropriate.                                             */
#define DEADSTART_PRELOAD_PRIORITY 70
#define PRIORITY_UNLOAD(proc,priority) PRIORITY_ATEXIT( proc##_unload, priority )
/* Used by PRELOAD and PRIORITY_PRELOAD macros to register a
   startup routine at a specific priority. Lower number
   priorities are scheduled to run before higher number
   priorities*backwards from ATEXIT priorities*. Using this
   scheduling mechanisms, routines which create threads under
   windows are guaranteed to run before main, and are guaranteed
   able to create threads. (They are outside of the loader lock)
   Parameters
   function :  pointer to a function to call at startup.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityStartupProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* Used by ATEXIT and PRIORITY_ATEXIT macros to register a
   shutdown routine at a specific priority. Higher number
   priorities are scheduled to run before lower number
   priorities. *backwards from PRELOAD priorities* This
   registers functions which are run while the program exits if
   it is at all able to run when exiting. calling exit() or
   BAG_Exit() will invoke these.
   Parameters
   function :  pointer to a function to call at shutdown.
   name :      text name of the function
   priority :  priority at which to call the function.
   unused :    this is an unused parameter. The macros fill it
               with &amp;ThisRegisteringRoutine, so that the
               routine itself is referenced by code, and helps
               the compile not optimize out this code. The
               functions which perform the registration are prone
               to be optimized because it's hard for the compiler
               to identify that they are refernced by other names
               indirectly.
   file\ :     usually DBG_PASS of the code doing this
               registration.
   line :      usually DBG_PASS of the code doing this
               registration.                                      */
DEADSTART_PROC  void DEADSTART_CALLTYPE  RegisterPriorityShutdownProc( void(CPROC*)(void), CTEXTSTR,int,void* unused DBG_PASS);
/* This routine is used internally when LoadFunction is called.
   After MarkDeadstartComplete is called, any call to a
   RegisterPriorityStartupProc will call the startup routine
   immediately instead of waiting. This function disables the
   auto-running of this function, and instead enques the startup
   to the list of startups. When completed, at some later point,
   call ResumeDeadstart() to dispatched all scheduled routines,
   and release the suspend; however, if initial deastart was not
   dispatched, then ResumeDeadstart does not do the invoke, it
   only releases the suspend.                                    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  SuspendDeadstart ( void );
/* Resumes a suspended deadstart. If root deadstart is
   completed, then ResumeDeadstart will call InvokeDeadstarts
   after resuming deadstart.                                  */
DEADSTART_PROC  void DEADSTART_CALLTYPE  ResumeDeadstart ( void );
/* Not usually used by user code, but this invokes all the
   routines which have been scheduled to run for startup. If
   your compiler doesn't have a method of handling deadstart
   code, this can be manually called. It can also be called if
   you loaded a library yourself without using the LoadFunction
   interface, to invoke startups scheduled in the loaded
   library.                                                     */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeDeadstart (void);
/* This just calls the list of shutdown procedures. This should
   not be used usually from user code, since internally this is
   handled by catching atexit() or with a static destructor.    */
DEADSTART_PROC  void DEADSTART_CALLTYPE  InvokeExits (void);
/* This is typically called after the first InvokeDeadstarts
   completes. The code that runs this is usually a routine just
   before main(). So once code in main begins to run, all prior
   initialization has been performed.                           */
DEADSTART_PROC  void DEADSTART_CALLTYPE  MarkRootDeadstartComplete ( void );
/* \returns whether InvokeDeadstarts has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartStarted ( void );
/* \returns whether MarkRootDeadstartComplete has been called. */
DEADSTART_PROC  LOGICAL DEADSTART_CALLTYPE  IsRootDeadstartComplete ( void );
#if defined( __LINUX__ )
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef DOC_O_MAT
// call this after a fork().  Otherwise, it will falsely invoke shutdown when it exits.
DEADSTART_PROC  void DEADSTART_CALLTYPE  DispelDeadstart ( void );
#endif
#ifdef __cplusplus
/* Defines some code to run at program inialization time. Allows
   specification of a priority. Lower priorities run first. (default
   is 69).
   Example
   <code>
   PRIORITY_PRELOAD( MyOtherInit, 153 )
   {
      // run some code probably after most all other initializtion is done.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                         */
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityStartupProc( name,TOSTR(name),priority,(void*)this DBG_SRC);	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* This is used once in deadstart_prog.c which is used to invoke
   startups when the program finishes loading.                   */
#define MAGIC_PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {	     public:pastejunk(schedule_,name)() {	  name();	    }	  } pastejunk(do_schedul_,name);	     static void name(void)
/* A macro to define some code to run during program shutdown. An
   additional priority may be specified if the order matters. Higher
   numbers are called first.
                                                                     */
#define ATEXIT_PRIORITY(name,priority) static void CPROC name(void);    static class pastejunk(schedule_,name) {        public:pastejunk(schedule_,name)() {	    RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	  }	  } pastejunk(do_schedule_,name);	     static void name(void)
/* Defines some code to run at program shutdown time. Allows
   specification of a priority. Higher priorities are run first.
   Example
   <code>
   PRIORITY_ATEXIT( MyOtherShutdown, 153 )
   {
      // run some code probably before most library code dissolves.
      // last to load, first to unload.
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>                 */
	/*name(); / * call on destructor of static object.*/
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static class pastejunk(shutdown_,name) {	   public:pastejunk(shutdown_,name)() {       RegisterPriorityShutdownProc( name,TOSTR(name),priority,(void*)this DBG_SRC );	   }	  } do_shutdown_##name;	     void name(void)
/* This is the most basic way to define some code to run
   initialization before main.
   Example
   <code lang="c++">
   PRELOAD( MyInitCode )
   {
      // some code here
   }
   </code>
   See Also
   <link sack::app::deadstart, deadstart Namespace>      */
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
/* Basic way to register a routine to run when the program exits
   gracefully.
   Example
   \    <code>
   ATEXIT( MyExitRoutine )
   {
       // this will be run sometime during program shutdown
   }
   </code>                                                       */
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
/* This is the core atexit. It dispatches all other exit
   routines. This is defined for internal use only...    */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
//------------------------------------------------------------------------------------
// Win32 Watcom
//------------------------------------------------------------------------------------
#elif defined( __WATCOMC__ )
#pragma off (check_stack)
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef unsigned short  __type_pad;
typedef void(*__type_rtn ) ( void );
#ifdef __cplusplus
#pragma pack(1)
#else
#pragma pack(1)
#endif
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
      // - routine
    __type_rtn  rtn;
};
#pragma pack()
/* end code taken from openwatcom/bld/watcom/h/rtinit.h */
//------------------------------------------------------------------------------------
// watcom
//------------------------------------------------------------------------------------
//void RegisterStartupProc( void (*proc)(void) );
#define PRIORITY_PRELOAD(name,priority) static void pastejunk(schedule_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_ctor_label)={0,(DEADSTART_PRELOAD_PRIORITY-1),pastejunk(schedule_,name)};	 static void pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,&pastejunk(name,_ctor_label) DBG_SRC );	}	                                       void name(void)
#define ATEXIT_PRIORITY(name,priority) static void pastejunk(schedule_exit_,name)(void); static void CPROC name(void);	 static struct rt_init __based(__segname("XI")) pastejunk(name,_dtor_label)={0,69,pastejunk(schedule_exit_,name)};	 static void pastejunk(schedule_exit_,name)(void) {	                                              RegisterPriorityShutdownProc( name,TOSTR(name),priority,&name##_dtor_label DBG_SRC );	}	                                       void name(void)
// syslog runs preload at priority 65
// message service runs preload priority 66
// deadstart itself tries to run at priority 70 (after all others have registered)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
// this is a special case macro used in client.c
// perhaps all PRIORITY_ATEXIT routines should use this
// this enables cleaning up things that require threads to be
// active under windows... (message disconnect)
// however this routine is only triggered in windows by calling
// BAG_Exit(nn) which is aliased to replace exit(n) automatically
#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY( name,priority)
/*
static void name(void); static void name##_x_(void);	static struct rt_init __based(__segname("YI")) name##_dtor_label={0,priority,name##_x_};	 static void name##_x_(void) { char myname[256];myname[0]=*(CTEXTSTR)&name##_dtor_label;GetModuleFileName(NULL,myname,sizeof(myname));name(); }	 static void name(void)
  */
#define ROOT_ATEXIT(name) ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_ROOT)
#define ATEXIT(name)      PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
// if priority_atexit is used with priority 0 - the proc is scheduled into
// atexit, and exit() is then invoked.
//#define PRIORITY_ATEXIT(name,priority) ATEXIT_PRIORITY(name,priority )
//------------------------------------------------------------------------------------
// Linux
//------------------------------------------------------------------------------------
#elif defined( __GNUC__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __64__ ) ||defined( __arm__ )||defined( __GNUC__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	 CTEXTSTR file;
#endif
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#if defined( __GNUC__ ) && defined( __64__)
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#define RTINIT_STATIC static
#define ATEXIT_PRIORITY PRIORITY_ATEXIT
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#ifdef __MAC__
#  define DEADSTART_SECTION "TEXT,deadstart_list"
#else
#  define DEADSTART_SECTION "deadstart_list"
#endif
#ifdef __MANUAL_PRELOAD__
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)		__attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 =	 {0,0,pr INIT_PADDING, __LINE__, name PASS_FILENAME	, TOSTR(name) JUNKINIT(name)} ;	 void name(void);	 void pastejunk(registerStartup,name)(void) __attribute__((constructor));	 void pastejunk(registerStartup,name)(void) {	 RegisterPriorityStartupProc(name,TOSTR(name),pr,NULL DBG_SRC); }	 void name(void)
#else
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct rt_init pastejunk(name,_ctor_label)	   __attribute__((section(DEADSTART_SECTION))) __attribute__((used))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 void name(void) __attribute__((used));	  void name(void)
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void name(void); static void pastejunk(atexit,name)(void) __attribute__((constructor));  void pastejunk(atexit,name)(void)                                                  {	                                                                        RegisterPriorityShutdownProc(name,TOSTR(name),priority,NULL DBG_SRC);                          }                                                                          void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT( name,ATEXIT_PRIORITY_DEFAULT )
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// CYGWIN (-mno-cygwin)
//------------------------------------------------------------------------------------
#elif defined( __CYGWIN__ )
/* code taken from openwatcom/bld/watcom/h/rtinit.h */
typedef unsigned char   __type_rtp;
typedef void(*__type_rtn ) ( void );
 // structure placed in XI/YI segment
struct rt_init
{
#ifdef __cplusplus
	//rt_init( int _rtn_type ) { rt_init::rtn_type = _rtn_type; }
	/*rt_init( int _priority, CTEXTSTR name, __type_rtn rtn, CTEXTSTR _file, int _line )
	{
		rtn_type = 0;
		scheduled = 0;
		priority = priority;
		file = _file;
		line = _line;
      routine = rtn;
		}
      */
#endif
#define DEADSTART_RT_LIST_START 0xFF
 // - near=0/far=1 routine indication
    __type_rtp  rtn_type;
                          //   also used when walking table to flag
                          //   completed entries
 // has this been scheduled? (0 if no)
    __type_rtp  scheduled;
 // - priority (0-highest 255-lowest)
    __type_rtp  priority;
#if defined( __GNUC__ ) || defined( __64__ ) || defined( __arm__ ) || defined( __CYGWIN__ )
#define INIT_PADDING ,{0}
 // need this otherwise it's 23 bytes and that'll be bad.
	 char padding[1];
#else
#define INIT_PADDING
#endif
 // 32 bits in 64 bits....
	 int line;
// this ends up being nicely aligned for 64 bit platforms
// specially with the packed attributes
      // - routine (rtn)
	 __type_rtn  routine;
	 CTEXTSTR file;
	 CTEXTSTR funcname;
	 struct rt_init *junk;
#if defined( __GNUC__ ) && defined( __64__ )
    // this provides padding - inter-object segments are packed
    // to 32 bytes...
	 struct rt_init *junk2[3];
#endif
} __attribute__((packed));
#define JUNKINIT(name) ,&pastejunk(name,_ctor_label)
#ifdef __cplusplus
#define RTINIT_STATIC
#else
#define RTINIT_STATIC static
#endif
typedef void(*atexit_priority_proc)(void (*)(void),CTEXTSTR,int DBG_PASS);
#define ATEXIT_PRIORITY(name,priority) static void name(void); static void atexit##name(void) __attribute__((constructor));	  void atexit_failed##name(void(*f)(void),int i,CTEXTSTR s1,CTEXTSTR s2,int n) { lprintf( WIDE("Failed to load atexit_priority registerar from core program.") );} void atexit##name(void)                                                  {	                                                                        static char myname[256];HMODULE mod;if(myname[0])return;myname[0]='a';GetModuleFileName( NULL, myname, sizeof( myname ) );	mod=LoadLibrary(myname);if(mod){   typedef void (*x)(void);void(*rsp)( x,const CTEXTSTR,int,const CTEXTSTR,int);	 if((rsp=((void(*)(void(*)(void),const CTEXTSTR,int,const CTEXTSTR,int))(GetProcAddress( mod, WIDE("RegisterPriorityShutdownProc"))))))	 {rsp( name,TOSTR(name),priority DBG_SRC);}	 else atexit_failed##name(name,priority,TOSTR(name) DBG_SRC);	        }     FreeLibrary( mod);	 }             void name( void)
#ifdef _DEBUG
#  define PASS_FILENAME ,WIDE__FILE__
#else
#  define PASS_FILENAME
#endif
#define PRIORITY_PRELOAD(name,pr) static void name(void);	 RTINIT_STATIC struct pastejunk(rt_init name,_ctor_label)	   __attribute__((section("deadstart_list")))	 ={0,0,pr INIT_PADDING	     ,__LINE__,name	          PASS_FILENAME	        ,TOSTR(name)	        JUNKINIT(name)};	 static void name(void)
#define ATEXIT(name)      ATEXIT_PRIORITY(name,ATEXIT_PRIORITY_DEFAULT)
#define PRIORITY_ATEXIT ATEXIT_PRIORITY
#define ROOT_ATEXIT(name) static void name(void) __attribute__((destructor));    static void name(void)
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//------------------------------------------------------------------------------------
// WIN32 MSVC
//------------------------------------------------------------------------------------
#elif defined( _MSC_VER ) && defined( _WIN32 )
//#define PRELOAD(name) __declspec(allocate(".CRT$XCAA")) void CPROC name(void)
//#pragma section(".CRT$XCA",long,read)
//#pragma section(".CRT$XCZ",long,read)
// put init in both C startup and C++ startup list...
// looks like only one or the other is invoked, not both?
/////// also the variables to be put into these segments
#if defined( __cplusplus_cli )
#define LOG_ERROR(n) System::Console::WriteLine( gcnew System::String(n) + gcnew System::String( myname) ) )
#else
#define LOG_ERROR(n) SystemLog( n )
// since we get linked first, then the runtime is added, we have to link against the last indicator of section,
// so we get put between start to end.
#define _STARTSEG_ ".CRT$XIM"
#define _STARTSEG2_ ".CRT$XCY"
#define _ENDSEG_ ".CRT$XTM"
//#pragma data_seg(".CRT$XIA")
#pragma data_seg(".CRT$XIM")
#pragma section(".CRT$XIM",long,read)
#pragma data_seg(".CRT$XCY")
#pragma section(".CRT$XCY",long,read)
//#pragma data_seg(".CRT$XIZ")
//#pragma data_seg(".CRT$YCZ")
#pragma data_seg(".CRT$XTM")
#pragma section(".CRT$XTM",long,read)
#pragma data_seg()
	                                       /*static __declspec(allocate(_STARTSEG_)) void (CPROC*pointer_##name)(void) = pastejunk(schedule_,name);*/
#define PRIORITY_PRELOAD(name,priority) static void CPROC name(void);    static int CPROC pastejunk(schedule_,name)(void);	   __declspec(allocate(_STARTSEG_)) int (CPROC*pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)))(void) = pastejunk(schedule_,name);	 int CPROC pastejunk(schedule_,name)(void) {	                 RegisterPriorityStartupProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( pastejunk(x_,name),__LINE__)) DBG_SRC );	return 0;	 }	 static void CPROC name(void)
#define ROOT_ATEXIT(name) static void name(void);	 __declspec(allocate(_ENDSEG_)) static void (*f##name)(void)=name;    static void name(void)
#define ATEXIT(name) PRIORITY_ATEXIT(name,ATEXIT_PRIORITY_DEFAULT)
typedef void(*atexit_priority_proc)(void (*)(void),int,CTEXTSTR DBG_PASS);
#define PRIORITY_ATEXIT(name,priority) static void CPROC name(void);    static int schedule_atexit_##name(void);	   __declspec(allocate(_STARTSEG_)) void (CPROC*pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)))(void) = (void(CPROC*)(void))schedule_atexit_##name;	 static int schedule_atexit_##name(void) {	                 RegisterPriorityShutdownProc( name,TOSTR(name),priority,pastejunk(TARGET_LABEL,pastejunk( x_##name,__LINE__)) DBG_SRC );	return 0;	 }	                                       static void CPROC name(void)
#define ATEXIT_PRIORITY(name,priority) PRIORITY_ATEXIT(name,priority)
#endif
#ifdef __cplusplus_cli
#define InvokeDeadstart() do {	                                              TEXTCHAR myname[256];HMODULE mod;	 mod=LoadLibrary("sack_bag.dll");if(mod){           void(*rsp)(void);	 if((rsp=((void(*)(void))(GetProcAddress( mod, "RunDeadstart"))))){rsp();}else{lprintf( WIDE("Hey failed to get proc %d"), GetLastError() );}	FreeLibrary( mod); }} while(0)
#else
#endif
#define PRELOAD(name) PRIORITY_PRELOAD(name,DEFAULT_PRELOAD_PRIORITY)
//extern uint32_t deadstart_complete;
//#define DEADSTART_LINK uint32_t *deadstart_link_couple = &deadstart_complete; // make sure we reference this symbol
//#pragma data_seg(".CRT$XCAA")
//extern void __cdecl __security_init_cookie(void);
//static _CRTALLOC(".CRT$XCAA") _PVFV init_cookie = __security_init_cookie;
//#pragma data_seg()
//------------------------------------------------------------------------------------
// UNDEFINED
//------------------------------------------------------------------------------------
#else
#error "there's nothing I can do to wrap PRELOAD() or ATEXIT()!"
/* This is the most basic way to define some startup code that
   runs at some point before the program starts. This code is
   declared as static, so the same preload initialization name
   can be used in multiple files.
   <link sack::app::deadstart, See Also.>                      */
#define PRELOAD(name)
#endif
// the higher the number the earlier it is run
#define ATEXIT_PRIORITY_SHAREMEM  1
#define ATEXIT_PRIORITY_THREAD_SEMS ATEXIT_PRIORITY_SYSLOG-1
#define ATEXIT_PRIORITY_SYSLOG    35
#define ATEXIT_PRIORITY_MSGCLIENT 85
#define ATEXIT_PRIORITY_DEFAULT   90
#define ATEXIT_PRIORITY_TIMERS   (ATEXIT_PRIORITY_DEFAULT+1)
// this is the first exit to be run.
// under linux it is __attribute__((destructor))
// under all it is registered during preload as atexit()
// only the runexits in deadstart should use ROOT_ATEXIT
#ifdef __WATCOMC__
#define ATEXIT_PRIORITY_ROOT 255
#else
#define ATEXIT_PRIORITY_ROOT 101
#endif
SACK_DEADSTART_NAMESPACE_END
USE_SACK_DEADSTART_NAMESPACE
#endif
#ifdef PROCREG_SOURCE
#define PROCREG_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PROCREG_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#ifdef __cplusplus_cli
//using namespace System;
#endif
#   define _INTERFACE_NAMESPACE namespace Interface {
#   define _INTERFACE_NAMESPACE_END }
#define PROCREG_NAMESPACE namespace sack { namespace app { namespace registry {
#define _PROCREG_NAMESPACE namespace registry {
#define _APP_NAMESPACE namespace app {
#define PROCREG_NAMESPACE_END }}}
//extern "C"  {
#else
#   define _INTERFACE_NAMESPACE
#   define _INTERFACE_NAMESPACE_END
#define _PROCREG_NAMESPACE
#define _APP_NAMESPACE
#define PROCREG_NAMESPACE
#define PROCREG_NAMESPACE_END
#endif
SACK_NAMESPACE
/* Deadstart is support which differs per compiler, but allows
   applications access a C++ feature - static classes with
   constructors that initialize at loadtime, but, have the
   feature that you can create threads. Deadstart code is run
   after the DLL load lock under windows that prevents creation
   of threads; however, deadstart is run before main. Deadstart
   routines can have a priority. Certain features require others
   to be present always. This allows explicit control of
   priority unlink using classes with static constructors, which
   requires ordering of objects to provide linking order. Also
   provides a similar registration mechanism for atexit, but
   extending with priority. Deadstop registrations are done
   sometime during normal C atexit() handling, but may be
   triggered first by calling BAG_Exit.
   Registry offers support to register functions, and data under
   a hierarchy of names. Names are kept in a string cache, which
   applications can take benefit of. Strings will exist only a
   single time. This table could be saved, and a look-aside
   table for language translation purposes. Registry is the
   support that the latest PSI relies on for registering event
   callbacks for controls. The registry was always used, but,
   the access to it was encapsulated by DoRegisterControl
   registering the appropriate methods.                          */
	_APP_NAMESPACE
   /* Contains methods dealing with registering routines and values
      in memory. Provisions are available to save the configuration
      state, but the best that can be offered here would be a
      translation tool for text strings. The namespace is savable,
      but most of the content of the registration space are short
      term pointers. Namespace containing registry namespace.
      old notes - very discongruant probably should delete them.
      Process name registry
      it's a tree of names.
      there are paths, and entries
      paths are represented as class_name
      PCLASSROOT is also a suitable class name
      PCLASSROOT is defined as a valid CTEXTSTR.
      there is (apparently) a name that is not valid as a path name
      that is TREE
      guess.
      POINTER in these two are equal to (void(*)(void)) but -
      that's rarely the most useful thing... so
      name class is a tree of keys... /\<...\>
      psi/control/## might contain procs Init Destroy Move
      RegAlias( WIDE("psi/control/3"), WIDE("psi/control/button")
      ); psi/control/button and psi/control/3 might reference the
      same routines
      psi/frame Init Destroy Move memlib Alloc Free
      network/tcp
      I guess name class trees are somewhat shallow at the moment
      not going beyond 1-3 layers
      names may eventually be registered and reference out of body
      services, even out of box...
      the values passed as returntype and parms/args need not be
      real genuine types, but do need to be consistant between the
      registrant and the requestor... this provides for full name
      dressing, return type and paramter type may both cause
      overridden functions to occur...                              */
_PROCREG_NAMESPACE
#ifndef REGISTRY_STRUCTURE_DEFINED
	// make these a CTEXTSTR to be compatible with name_class...
#ifdef __cplusplus
	// because of name mangling and stronger type casting
	// it becomes difficult to pass a tree_def_tag * as a CTEXTSTR classname
	// as valid as this is.
	typedef struct tree_def_tag const * PCLASSROOT;
#else
	typedef CTEXTSTR PCLASSROOT;
#endif
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#else
	typedef struct tree_def_tag const * PCLASSROOT;
	typedef void (CPROC *PROCEDURE)(void);
#ifdef __cplusplus_cli
	typedef void (__stdcall *STDPROCEDURE)(array<System::Object^>^);
#endif
#endif
/* CheckClassRoot reads for a path of names, but does not create
   it if it does not exist.                                      */
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR class_name );
/* \Returns a PCLASSROOT of a specified path. The path may be
   either a PCLASSROOT or a text string indicating the path. the
   Ex versions allow passing a base PCLASSROOT path and an
   additional subpath to get. GetClassRoot will always create
   the path if it did not exist before, and will always result
   with a root.
   Remarks
   a CTEXTSTR (plain text string, probably wide character if
   compiled unicode) and a PCLASSROOT are always
   interchangeable. Though you may need a forced type cast, I
   have defined both CTEXTSTR and PCLASSROOT function overloads
   for c++ compiled code, and C isn't so unkind about the
   conversion. I think problem might lie that CTEXTSTR has a
   const qualifier and PCLASSROOT doesn't (but should).
   Example
   <code lang="c++">
   PCLASSROOT root = GetClassRoot( "psi/resource" );
   // returns the root of all resource names.
   </code>
   <code>
   PCLASSROOT root2 = GetClassRootEx( "psi/resource", "buttons" );
   </code>                                                         */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class );
#ifdef __cplusplus
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT class_name );
/* <combine sack::app::registry::GetClassRoot@CTEXTSTR>
   \ \                                                  */
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class );
#endif
/* Fills a string with the path name to the specified node */
PROCREG_PROC( int, GetClassPath )( TEXTSTR out, size_t len, PCLASSROOT root );
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename );
/* Get[First/Next]RegisteredName( WIDE("classname"), &amp;data );
   these operations are not threadsafe and multiple thread
   accesses will cause mis-stepping
   These functions as passed the address of a POINTER. this
   POINTER is for the use of the browse routines and should is
   meaningless to he calling application.
   Parameters
   root :       The root to search from
   classname :  A sub\-path from the root to search from
   data :       the address of a pointer that keeps track of
                information about the search. (opaque to user)
   Example
   Usage:
   <code lang="c++">
   CTEXTSTR result;
   POINTER data = NULL;
   for( result = GetFirstRegisteredName( "some/class/path", &amp;data );
        \result;
        \result = GetNextRegisteredName( &amp;data ) )
   {
        // result is a string name of the current node.
        // can use that name and GetRegistered____ (function/int/value)
        if( NameHasBranches( &amp;data ) ) // for consitancy in syntax
        {
            // consider recursing through tree, name becomes a valid classname for GetFirstRegisteredName()
        }
   }
   </code>                                                                                                  */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data );
#ifdef __cplusplus
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
	PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data );
#endif
/* <combine sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *>
   \ \                                                                                      */
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data );
/* Steps to the next registered name being browsed. Is passed
   only the pointer to data. See GetFirstRegisteredName for
   usage.
   See Also
   <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, sack::app::registry::GetFirstRegisteredNameEx Function> */
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data );
/* When using GetFirstRegisteredName and GetNextRegisteredName
   to browse through names, this function is able to get the
   current PCLASSROOT of the current node, usually you end up
   with just the content of that registered name.
   \result with the current node ( useful for pulling registered
   subvalues like description, or file and line )
                                                                 */
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data );
#ifdef __cplusplus
//PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, POINTER *data );
//PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( POINTER *data );
#endif
// while doing a scan for registered procedures, allow applications to check for branches
//PROCREG_PROC( int, NameHasBranches )( POINTER *data );
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data );
// while doing a scan for registered procedures, allow applications to ignore aliases...
PROCREG_PROC( int, NameIsAlias )( PCLASSROOT *data );
/*
 * RegisterProcedureExx(
 *
 */
 // root name or PCLASSROOT of base path
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
 // an additional path on root
													  , CTEXTSTR name_class
 // the name of the value entry saved in the tree
													  , CTEXTSTR public_name
 // the text return type of this function - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR returntype
 // name of the library this symbol is in - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR library
 // actual C function name in library - may be checked to validate during GetRegisteredProcedure
													  , CTEXTSTR name
 // preferably the raw argument string of types and no variable references "([type][,type]...)"
													  , CTEXTSTR args
 // file and line of the calling application.  May be no parameter in release mode.
													  DBG_PASS
													  );
/*
 * RegisterProcedureEx( root       // root path
 *                    , name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedureEx(root,nc,n,rtype,proc,args)  RegisterProcedureExx( (root),(nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * RegisterProcedure( name_class // additional name
 *                    , nice_name  // nice name
 *                    , return type not in quotes  'void'
 *                    , function_name in quotes '"Function"'
 *                    , args not in quotes '(int,char,float,UserType*)'
 */
#define RegisterProcedure(nc,n,rtype,proc,args)  RegisterProcedureExx( NULL, (nc),(n),#rtype,TARGETNAME,(proc), #args DBG_SRC)
/*
 * Branches on the tree may be aliased together to form a single branch
 *
 */
				// RegisterClassAlias( WIDE("psi/control/button"), WIDE("psi/control/3") );
				// then the same set of values can be referenced both ways with
				// really only a single modified value.
/* parameters to RegisterClassAliasEx are the original name, and the new alias name for the origianl branch*/
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias );
/* <combine sack::app::registry::RegisterClassAliasEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                              */
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR newalias );
// root, return, public, args, address
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR parms
																  );
#define ReadRegisteredProcedure( root,rt,a) ((rt(CPROC*)a)ReadRegisteredProcedureEx(root,WIDE(#rt),WIDE(#a)))
/* Gets a function that has been registered. */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
#define GetRegisteredProcedureExx(root,nc,rt,n,a) ((rt (CPROC*)a)GetRegisteredProcedureExxx(root,nc,_WIDE(#rt),n,_WIDE(#a)))
#define GetRegisteredProcedure2(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),WIDE(#rtype), name, WIDE(#args) )
#define GetRegisteredProcedureNonCPROC(nc,rtype,name,args) (rtype (*)args)GetRegisteredProcedureEx((nc),WIDE(#rtype), name, WIDE(#args) )
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													, PCLASSROOT name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
													, PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root
																	 , PCLASSROOT name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root
																	 , CTEXTSTR name_class
                                                    , CTEXTSTR returntype
																	 , CTEXTSTR name
																	 , CTEXTSTR parms
																	 );
/* <combine sack::app::registry::GetRegisteredProcedureExxx@PCLASSROOT@PCLASSROOT@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                                        */
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class
																	, CTEXTSTR returntype
																	, CTEXTSTR name
																	, CTEXTSTR parms
																	);
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													, CTEXTSTR returntype
                                       , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  );
#endif
//#define RegisterFunctionExx( r,nc,p,rt,proc,ar ) RegisterFunctionExx( r,nc,p,rt,proc,ar,TARGETNAME,NULL DBG_SRC )
//#define RegisterFunctionEx(r,nc,pn,rt,proc,args,lib,rn) RegisterFunctionExx(r,nc,pn,rt,proc,args,lib,rn DBG_SRC)
#define RegisterFunctionEx( root,proc,rt,pn,a) RegisterFunctionExx( root,NULL,pn,rt,(PROCEDURE)(proc),a,NULL,NULL DBG_SRC )
#define RegisterFunction( nc,proc,rt,pn,a) RegisterFunctionExx( (PCLASSROOT)NULL,nc,pn,rt,(PROCEDURE)(proc),a,TARGETNAME,NULL DBG_SRC )
#define SimpleRegisterMethod(r,proc,rt,name,args) RegisterFunctionExx(r,NULL,name,rt,(PROCEDURE)proc,args,NULL,NULL DBG_SRC )
#define GetRegisteredProcedure(nc,rtype,name,args) (rtype (CPROC*)args)GetRegisteredProcedureEx((nc),_WIDE(#rtype), _WIDE(#name), _WIDE(#args) )
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value );
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value );
/* \ \
   Parameters
   root :        Root class to start searching from
   name_class :  An additional sub\-path to get the name from
   name :        the name within the path specified
   bIntVal :     a true/false whether to get the string or
                 integer value from the specified node.
   Returns
   A pointer to a string if bIntVal is not set. (NULL if there
   was no string).
   Otherwise will be an int shorter than or equal to the size of
   a pointer, which should be cast to an int if bIntVal is set,
   and there is a value registered there. Probably 0 if no
   value, so registered 0 value and no value is
   indistinguisable.                                             */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal );
PROCREG_PROC( int, RegisterIntValueEx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value );
#endif
/* This is like GetRegisteredValue, but takes the address of the
   type to return into instead of having to cast the final
   \result.
   if bIntValue, result should be passed as an (&amp;int)        */
PROCREG_PROC( int, GetRegisteredStaticValue )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name
															, CTEXTSTR *result
															, int bIntVal );
#define GetRegisteredStaticIntValue(r,nc,name,result) GetRegisteredStaticValue(r,nc,name,(CTEXTSTR*)result,TRUE )
/* <combine sack::app::registry::GetRegisteredValueExx@PCLASSROOT@CTEXTSTR@CTEXTSTR@int>
   \ \                                                                                   */
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name );
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name );
#ifdef __cplusplus
/* <combine sack::app::registry::GetRegisteredIntValueEx@PCLASSROOT@CTEXTSTR@CTEXTSTR>
   \ \                                                                                 */
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name );
#endif
typedef void (CPROC*OpenCloseNotification)( POINTER, uintptr_t );
#define PUBLIC_DATA( public, struct, open, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataType( WIDE("system/data/structs")	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)close ); }
#define PUBLIC_DATA_EX( public, struct, open, update, close )	    PRELOAD( Data_##open##_##close ) {	 RegisterDataTypeEx( WIDE("system/data/structs")	        , public, sizeof(struct)	    , (OpenCloseNotification)open, (OpenCloseNotification)update, (OpenCloseNotification)close ); }
#define GET_PUBLIC_DATA( public, type, instname )    (type*)CreateRegisteredDataType( WIDE("system/data/structs"), public, instname )
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , OpenCloseNotification open
												 , OpenCloseNotification close );
/* Registers a structure as creatable in shared memory by name.
   So a single name of the structure can be used to retrieve a
   pointer to one created.
   Example
   \ \
   <code lang="c++">
   POINTER p = CreateRegisteredDataType( "My types", "my_registered_type", "my instance" );
   // p will result to a region of type 'my_registered_type' called 'my_instance'
   // if it did not exist, it will be created, otherwise the one existing is returned.
   </code>
   Parameters
   root :          optional root name (ex version uses this)
   classname :     path to the type
   name :          name of the type to create an instance of
   instancename :  a name for the instance created.                                         */
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename );
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
													, CTEXTSTR classname
													, CTEXTSTR name
													, uintptr_t size
													, OpenCloseNotification Open
													, OpenCloseNotification Close );
/* <combine sack::app::registry::CreateRegisteredDataType@CTEXTSTR@CTEXTSTR@CTEXTSTR>
   \ \                                                                                */
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename );
/* Outputs through syslog a tree dump of all names registered. */
PROCREG_PROC( void, DumpRegisteredNames )( void );
/* Dumps through syslog all names registered from the specified
   root point. (instead of dumping the whole tree)              */
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root );
PROCREG_PROC( int, SaveTree )( void );
PROCREG_PROC( int, LoadTree )( void );
#define METHOD_PTR(type,name) type (CPROC *_##name)
#define DMETHOD_PTR(type,name) type (CPROC **_##name)
#define METHOD_ALIAS(i,name) ((i)->_##name)
#define PDMETHOD_ALIAS(i,name) (*(i)->_##name)
/* Releases an interface. When interfaces are registered, they
   register with a OnGetInterface and an OnDropInterface
   callback so that it may do additional work to cleanup from
   giving you a copy of the interface.
   Example
   <code lang="c++">
   POINTER p = GetInterface( "image" );
   DropInterface( p );
   </code>                                                     */
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_x );
/* \Returns the pointer to a registered interface. This is
   typically a structure that contains pointer to functions. Takes
   a text string to an interface. Interfaces are registered at a
   known location in the registry tree.                            */
PROCREG_PROC( POINTER, GetInterfaceDbg )( CTEXTSTR pServiceName DBG_PASS );
#define GetInterface(n) GetInterfaceDbg( n DBG_SRC )
#define GetRegisteredInterface(name) GetInterface(name)
PROCREG_PROC( LOGICAL, RegisterInterfaceEx )( CTEXTSTR name, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER) DBG_PASS );
PROCREG_PROC( LOGICAL, RegisterInterface )(CTEXTSTR name, POINTER( CPROC*load )(void), void(CPROC*unload)(POINTER));
#define RegisterInterface(n,l,u) RegisterInterfaceEx( n,l,u DBG_SRC )
// unregister a function, should be smart and do full return type
// and parameters..... but for now this only references name, this indicates
// that this has not been properly(fully) extended, and should be layered
// in such a way as to allow this function work in it's minimal form.
PROCREG_PROC( int, ReleaseRegisteredFunctionEx )( PCLASSROOT root
													, CTEXTSTR name_class
													, CTEXTSTR public_name
													  );
#define ReleaseRegisteredFunction(nc,pn) ReleaseRegisteredFunctionEx(NULL,nc,pn)
/* This is a macro used to paste two symbols together. */
#define paste_(a,b) _WIDE(a##b)
#define paste(a,b) paste_(a,b)
#define ___DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(Register,name),Method),line), SQL_PRELOAD_PRIORITY ) {	  SimpleRegisterMethod( task WIDE("/") classtype, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) );    RegisterValue( task WIDE("/") classtype WIDE("/") methodname, WIDE("Description"), desc ); }	                                                                          static returntype CPROC paste(name,line)
#define __DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)	   ___DefineRegistryMethod2(task,name,classtype,methodname,desc,returntype,argtypes,line)
#define ___DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIORITY_PRELOAD( paste(paste(paste(Register,name),Method),line), priority ) {	  SimpleRegisterMethod( task WIDE("/") classtype, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) );    RegisterValue( task WIDE("/") classtype WIDE("/") methodname, WIDE("Description"), desc ); }	                                                                          static returntype CPROC paste(name,line)
#define __DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)	   ___DefineRegistryMethod2P(priority,task,name,classtype,methodname,desc,returntype,argtypes,line)
#define ___DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(Register##name##Button,line) ) {	  SimpleRegisterMethod( task WIDE("/") classtype WIDE("/") classbase, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) ); }	                                                                          static returntype CPROC paste(name,line)
#define __DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   ___DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)	   static returntype __DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes)	  __DefineRegistryMethod(task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
// this macro is used for ___DefineRegistryMethodP. Because this is used with complex names
// an extra define wrapper of priority_preload must be used to fully resolve paramters.
#define PRIOR_PRELOAD(a,p) PRIORITY_PRELOAD(a,p)
#define ___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRIOR_PRELOAD( paste(Register##name##Button,line), priority ) {	  SimpleRegisterMethod( task WIDE("/") classtype WIDE("/") classbase, paste(name,line)	  , _WIDE(#returntype), methodname, _WIDE(#argtypes) ); }	                                                                          static returntype CPROC paste(name,line)
/* <combine sack::app::registry::SimpleRegisterMethod>
   General form to build a registered procedure. Used by simple
   macros to create PRELOAD'ed registered functions. This flavor
   requires the user to provide 'static' and a return type that
   matches the return type specified in the macro. This makes
   usage most C-like, and convenient to know what the return
   value of a function should be (if any).
   Parameters
   priority :    The preload priority to load at.
   task :        process level name registry. This would be
                 "Intershell" or "psi" or some other base prefix.
                 The prefix can contain a path longer than 1
                 level.
   name :        This is the function name to build. (Can be used
                 for link debugging sometimes)
   classtype :   class of the name being registered
   methodname :  name of the routine to register
   returntype :  the literal type of the return type of this
                 function (void, int, PStruct* )
   argtypes :    Argument signature of the routine in parenthesis
   line :        this is usually filled with __LINE__ so that the
                 same function name (name) will be different in
                 different files (even in the same file)
   Remarks
   This registers a routine at the specified preload priority.
   Registers under [task]/[classname]/methodname. The name of
   the registered routine from a C perspective is [name][line]. This
   function is not called directly, but will only be referenced
   from the registered name.
   Example
   See <link sack::app::registry::GetFirstRegisteredNameEx@PCLASSROOT@CTEXTSTR@PCLASSROOT *, GetFirstRegisteredNameEx> */
#define __DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   ___DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define _DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)	   __DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,line)
#define DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes)	  _DefineRegistryMethodP(priority,task,name,classtype,classbase,methodname,returntype,argtypes,__LINE__)
#define _DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes,line)	   CPROC paste(name,line)argtypes;	       PRELOAD( paste(Register##name##Button,line) ) {	  SimpleRegisterMethod( task WIDE("/") classtype WIDE("/") classbase WIDE("/") methodname, paste(name,line)	  , _WIDE(#returntype), subname, _WIDE(#argtypes) ); }	                                                                          static returntype CPROC paste(name,line)
#define DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes)	  _DefineRegistrySubMethod(task,name,classtype,classbase,methodname,subname,returntype,argtypes,__LINE__)
/* attempts to use dynamic linking functions to resolve passed
   global name if that fails, then a type is registered for this
   global, and an instance created, so that that instance may be
   reloaded again, otherwise the data in the main application is
   used... actually we should deprecate the dynamic loading
   part, and just register the type.
   SimpleRegisterAndCreateGlobal Simply registers the type as a
   global variable type. Allows creation of the global space
   later.
   Parameters
   name :         name of the pointer to global type to create.<p />text
                  string to register this created global as.
   ppGlobal :     address of the pointer to global memory.
   global_size :  size of the global area to create
   Example
   <code lang="c++">
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   PRELOAD( Init )
   {
       SimpleRegisterAndCreateGlobal( global );
   }
   </code>                                                               */
PROCREG_PROC( void, RegisterAndCreateGlobal )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name );
/* <combine sack::app::registry::RegisterAndCreateGlobal@POINTER *@uintptr_t@CTEXTSTR>
   \ \                                                                                   */
#define SimpleRegisterAndCreateGlobal( name )	 RegisterAndCreateGlobal( (POINTER*)&name, sizeof( *name ), WIDE(#name) )
/* Init routine is called, otherwise a 0 filled space is
   returned. Init routine is passed the pointer to the global
   and the size of the global block the global data block is
   zero initialized.
   Parameters
   ppGlobal :     Address of the pointer to the global region
   global_size :  size of the global region to create
   name :         name of the global region to register (so
                  future users get back the same data area)
   Init :         function to call to initialize the region when
                  created. (doesn't have to be a global. Could be
                  used to implement types that have class
                  constructors \- or not, since there's only one
                  instance of a global \- this is more for
                  singletons).
   Example
   <code>
   typedef struct {
      int data;
   } my_global;
   my_global *global;
   </code>
   <code lang="c++">
   void __cdecl InitRegion( POINTER region, uintptr_t region_size )
   {
       // do something to initialize 'region'
   }
   PRELOAD( InitGlobal )
   {
       SimpleRegisterAndCreateGlobalWithInit( global, InitRegion );
   }
   </code>                                                          */
PROCREG_PROC( void, RegisterAndCreateGlobalWithInit )( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Init)(POINTER,uintptr_t) );
/* <combine sack::app::registry::RegisterAndCreateGlobalWithInit@POINTER *@uintptr_t@CTEXTSTR@void __cdecl*InitPOINTER\,uintptr_t>
   \ \                                                                                                                              */
#define SimpleRegisterAndCreateGlobalWithInit( name,init )	 RegisterAndCreateGlobalWithInit( (POINTER*)&name, sizeof( *name ), WIDE(#name), init )
/* a tree dump will result with dictionary names that may translate automatically. */
/* This has been exported as a courtesy for StrDup.
 * this routine MAY result with a translated string.
 * this routine MAY result with the same pointer.
 * this routine MAY need to be improved if MANY more strdups are replaced
 * Add a binary tree search index when large.
 * Add a transaltion tree index at the same time.
 */
PROCREG_PROC( CTEXTSTR, SaveNameConcatN )( CTEXTSTR name1, ... );
// no space stripping, saves literal text
PROCREG_PROC( CTEXTSTR, SaveText )( CTEXTSTR text );
PROCREG_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::app::registry;
#endif
#endif
#ifdef SALTY_RANDOM_GENERATOR_SOURCE
#define SRG_EXPORT EXPORT_METHOD
#else
#define SRG_EXPORT IMPORT_METHOD
#endif
//
// struct random_context *entropy = CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
// uses sha1
SRG_EXPORT struct random_context *SRG_CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a larger salt generator... (sha2-512)
SRG_EXPORT struct random_context *SRG_CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a sha2-256
SRG_EXPORT struct random_context *SRG_CreateEntropy2_256( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//
// struct random_context *entropy = CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
//  uses a sha3-512
SRG_EXPORT struct random_context *SRG_CreateEntropy3( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user );
// Destroya  context.  Pass the address of your 'struct random_context *entropy;   ... SRG_DestroyEntropy( &entropy );
SRG_EXPORT void SRG_DestroyEntropy( struct random_context **ppEntropy );
// get a large number of bits of entropy from the random_context
// buffer needs to be an integral number of 32 bit elements....
SRG_EXPORT void SRG_GetEntropyBuffer( struct random_context *ctx, uint32_t *buffer, uint32_t bits );
// get a number of bits of entropy from the
// if get_signed is not 0, the result will be sign extended if the last bit is set
//  (coded on little endian; tests for if ( result & ( 1 << bits - 1 ) ) then sign extend
SRG_EXPORT int32_t SRG_GetEntropy( struct random_context *ctx, int bits, int get_signed );
// opportunity to reset an entropy generator back to initial condition
// next call to getentropy will be the same as the first call after create.
SRG_EXPORT void SRG_ResetEntropy( struct random_context *ctx );
// Manually load some salt into the next enropy buffer to e retreived.
// sets up to add the next salt into the buffer.
SRG_EXPORT void SRG_FeedEntropy( struct random_context *ctx, const uint8_t *salt, size_t salt_size );
// restore the random contxt from the external holder specified
// {
//    POINTER save_context;
//    SRG_RestoreState( ctx, save_context );
// }
SRG_EXPORT void SRG_RestoreState( struct random_context *ctx, POINTER external_buffer_holder );
// save the random context in an external buffer holder.
// external buffer holder needs to be initialized to NULL.
// {
//    POINTER save_context = NULL;
//    SRG_SaveState( ctx, &save_context );
// }
SRG_EXPORT void SRG_SaveState( struct random_context *ctx, POINTER *external_buffer_holder );
// usage
/// { uint8_t* buf; size_t buflen; SRG_DecryptData( <resultfrom encrypt>, &buf, &buflen ); }
//  buffer result must be released by user
SRG_EXPORT void SRG_DecryptData( CTEXTSTR local_password, uint8_t* *buffer, size_t *chars );
SRG_EXPORT void SRG_DecryptRawData( CPOINTER binary, size_t length, uint8_t* *buffer, size_t *chars );
// text result must release by user
SRG_EXPORT TEXTSTR SRG_DecryptString( CTEXTSTR local_password );
// encrypt a block of binary data to another binary buffer
SRG_EXPORT void SRG_EncryptRawData( CPOINTER buffer, size_t buflen, uint8_t* *result_buf, size_t *result_size );
// text result must release by user
SRG_EXPORT TEXTCHAR * SRG_EncryptData( CPOINTER buffer, size_t buflen );
// text result must release by user
// calls EncrytpData with buffer and string length + 1 to include the null for decryption.
SRG_EXPORT TEXTCHAR * SRG_EncryptString( CTEXTSTR buffer );
// return a unique ID using SRG2
SRG_EXPORT char * SRG_ID_Generator( void );
// return a unique ID using SRG2_256
SRG_EXPORT char *SRG_ID_Generator_256( void );
// return a unique ID using SRG3
SRG_EXPORT char *SRG_ID_Generator3( void );
#ifndef SACK_VFS_DEFINED
/* Header multiple inclusion protection symbol. */
#define SACK_VFS_DEFINED
#ifdef SACK_VFS_STATIC
#  ifdef SACK_VFS_SOURCE
#    define SACK_VFS_PROC
#  else
#    define SACK_VFS_PROC extern
#  endif
#else
#  ifdef SACK_VFS_SOURCE
#    define SACK_VFS_PROC EXPORT_METHOD
#  else
#    define SACK_VFS_PROC IMPORT_METHOD
#  endif
#endif
#ifdef __cplusplus
/* defined the file system partial namespace (under
   SACK_NAMESPACE probably)                         */
#define _SACK_VFS_NAMESPACE  namespace SACK_VFS {
/* Define the ending symbol for file system namespace. */
#define _SACK_VFS_NAMESPACE_END }
#else
#define _SACK_VFS_NAMESPACE
#define _SACK_VFS_NAMESPACE_END
#endif
/* define the file system namespace end. */
#define SACK_VFS_NAMESPACE_END _SACK_VFS_NAMESPACE_END SACK_NAMESPACE_END
/* define the file system namespace. */
#define SACK_VFS_NAMESPACE SACK_NAMESPACE _SACK_VFS_NAMESPACE
SACK_VFS_NAMESPACE
// if the option to auto mount a file system is used, this is the
// name of the 'file system interface'  ( sack_get_filesystem_interface( SACK_VFS_FILESYSTEM_NAME ) )
#define SACK_VFS_FILESYSTEM_NAME WIDE("sack_shmem")
// open a volume at the specified pathname.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// same as load_cyrypt_volume with userkey and devkey NULL.
SACK_VFS_PROC struct volume * CPROC sack_vfs_load_volume( CTEXTSTR filepath );
// open a volume at the specified pathname.  Use the specified keys to encrypt it.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// if the keys are NULL same as load_volume.
SACK_VFS_PROC struct volume * CPROC sack_vfs_load_crypt_volume( CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// pass some memory and a memory length of the memory to use as a volume.
// if userkey and/or devkey are not NULL the memory is assume to be encrypted with those keys.
// the space is opened as readonly; write accesses/expanding operations will fail.
SACK_VFS_PROC struct volume * CPROC sack_vfs_use_crypt_volume( POINTER filemem, size_t size, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// close a volume; release all resources; any open files will keep the volume open.
// when the final file closes the volume will complete closing.
SACK_VFS_PROC void            CPROC sack_vfs_unload_volume( struct volume * vol );
// remove unused extra allocated space at end of volume.  During working process, extra space is preallocated for
// things to be stored in.
SACK_VFS_PROC void            CPROC sack_vfs_shrink_volume( struct volume * vol );
// remove encryption from volume.
SACK_VFS_PROC LOGICAL         CPROC sack_vfs_decrypt_volume( struct volume *vol );
// change the key applied to a volume.
SACK_VFS_PROC LOGICAL         CPROC sack_vfs_encrypt_volume( struct volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 );
// create a signature of current directory of volume.
// can be used to validate content.  Returns 256 character hex string.
SACK_VFS_PROC const char *    CPROC sack_vfs_get_signature( struct volume *vol );
// pass an offset from memory start and the memory start...
// computes the distance, uses that to generate a signature
// returns BLOCK_SIZE length signature; recommend using at least 128 bits of it.
SACK_VFS_PROC const uint8_t * CPROC sack_vfs_get_signature2( POINTER disk, POINTER diskReal );
// ---------- Operations on files in volumes ------------------
// open a file, creates if does not exist.
SACK_VFS_PROC struct sack_vfs_file * CPROC sack_vfs_openfile( struct volume *vol, CTEXTSTR filename );
// check if a file exists (if it does not exist, and you don't want it created, can use this and not openfile)
SACK_VFS_PROC int CPROC sack_vfs_exists( struct volume *vol, const char * file );
// close a file.
SACK_VFS_PROC int CPROC sack_vfs_close( struct sack_vfs_file *file );
// get the current File Position Index (FPI).
SACK_VFS_PROC size_t CPROC sack_vfs_tell( struct sack_vfs_file *file );
// get the length of the file
SACK_VFS_PROC size_t CPROC sack_vfs_size( struct sack_vfs_file *file );
// set the current File Position Index (FPI).
SACK_VFS_PROC size_t CPROC sack_vfs_seek( struct sack_vfs_file *file, size_t pos, int whence );
// write starting at the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_write( struct sack_vfs_file *file, const char * data, size_t length );
// read starting at the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_read( struct sack_vfs_file *file, char * data, size_t length );
// sets the file length to the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_truncate( struct sack_vfs_file *file );
// psv should be struct volume *vol;
// delete a filename.  Clear the space it was occupying.
SACK_VFS_PROC int CPROC sack_vfs_unlink_file( struct volume *vol, const char * filename );
// rename a file within the filesystem; if the target name exists, it is deleted.  If the target file is also open, it will be prevented from deletion; and duplicate filenames will end up exising(?)
SACK_VFS_PROC LOGICAL CPROC sack_vfs_rename( uintptr_t psvInstance, const char *original, const char *newname );
// -----------  directory interface commands. ----------------------
// returns find_info which is then used in subsequent commands.
SACK_VFS_PROC struct find_info * CPROC sack_vfs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask );
// reset find_info to the first directory entry.  returns 0 if no entry.
SACK_VFS_PROC int CPROC sack_vfs_find_first( struct find_info *info );
// closes a find cursor; returns 0.
SACK_VFS_PROC int CPROC sack_vfs_find_close( struct find_info *info );
// move to the next entry returns 0 if no entry.
SACK_VFS_PROC int CPROC sack_vfs_find_next( struct find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC char * CPROC sack_vfs_find_get_name( struct find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC size_t CPROC sack_vfs_find_get_size( struct find_info *info );
// open a volume at the specified pathname.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// same as load_cyrypt_volume with userkey and devkey NULL.
SACK_VFS_PROC struct fs_volume * CPROC sack_vfs_fs_load_volume( CTEXTSTR filepath );
// open a volume at the specified pathname.  Use the specified keys to encrypt it.
// if the volume does not exist, will create it.
// if the volume does exist, a quick validity check is made on it, and then the result is opened
// returns NULL if failure.  (permission denied to the file, or invalid filename passed, could be out of space... )
// if the keys are NULL same as load_volume.
SACK_VFS_PROC struct fs_volume * CPROC sack_vfs_fs_load_crypt_volume( CTEXTSTR filepath, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// pass some memory and a memory length of the memory to use as a volume.
// if userkey and/or devkey are not NULL the memory is assume to be encrypted with those keys.
// the space is opened as readonly; write accesses/expanding operations will fail.
SACK_VFS_PROC struct fs_volume * CPROC sack_vfs_fs_use_crypt_volume( POINTER filemem, size_t size, uintptr_t version, CTEXTSTR userkey, CTEXTSTR devkey );
// close a volume; release all resources; any open files will keep the volume open.
// when the final file closes the volume will complete closing.
SACK_VFS_PROC void            CPROC sack_vfs_fs_unload_volume( struct fs_volume * vol );
// remove unused extra allocated space at end of volume.  During working process, extra space is preallocated for
// things to be stored in.
SACK_VFS_PROC void            CPROC sack_vfs_fs_shrink_volume( struct fs_volume * vol );
// remove encryption from volume.
SACK_VFS_PROC LOGICAL         CPROC sack_vfs_fs_decrypt_volume( struct fs_volume *vol );
// change the key applied to a volume.
SACK_VFS_PROC LOGICAL         CPROC sack_vfs_fs_encrypt_volume( struct fs_volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 );
// create a signature of current directory of volume.
// can be used to validate content.  Returns 256 character hex string.
SACK_VFS_PROC const char *    CPROC sack_vfs_fs_get_signature( struct fs_volume *vol );
// pass an offset from memory start and the memory start...
// computes the distance, uses that to generate a signature
// returns BLOCK_SIZE length signature; recommend using at least 128 bits of it.
SACK_VFS_PROC const uint8_t * CPROC sack_vfs_fs_get_signature2( POINTER disk, POINTER diskReal );
// ---------- Operations on files in volumes ------------------
// open a file, creates if does not exist.
SACK_VFS_PROC struct sack_vfs_fs_file * CPROC sack_vfs_fs_openfile( struct fs_volume *vol, CTEXTSTR filename );
// check if a file exists (if it does not exist, and you don't want it created, can use this and not openfile)
SACK_VFS_PROC int CPROC sack_vfs_fs_exists( struct fs_volume *vol, const char * file );
// close a file.
SACK_VFS_PROC int CPROC sack_vfs_fs_close( struct sack_vfs_fs_file *file );
// get the current File Position Index (FPI).
SACK_VFS_PROC size_t CPROC sack_vfs_fs_tell( struct sack_vfs_fs_file *file );
// get the length of the file
SACK_VFS_PROC size_t CPROC sack_vfs_fs_size( struct sack_vfs_fs_file *file );
// set the current File Position Index (FPI).
SACK_VFS_PROC size_t CPROC sack_vfs_fs_seek( struct sack_vfs_fs_file *file, size_t pos, int whence );
// write starting at the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_fs_write( struct sack_vfs_fs_file *file, const char * data, size_t length );
// read starting at the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_fs_read( struct sack_vfs_fs_file *file, char * data, size_t length );
// sets the file length to the current FPI.
SACK_VFS_PROC size_t CPROC sack_vfs_fs_truncate( struct sack_vfs_fs_file *file );
// psv should be struct fs_volume *vol;
// delete a filename.  Clear the space it was occupying.
SACK_VFS_PROC int CPROC sack_vfs_fs_unlink_file( struct fs_volume *vol, const char * filename );
// rename a file within the filesystem; if the target name exists, it is deleted.  If the target file is also open, it will be prevented from deletion; and duplicate filenames will end up exising(?)
SACK_VFS_PROC LOGICAL CPROC sack_vfs_fs_rename( uintptr_t psvInstance, const char *original, const char *newname );
// -----------  directory interface commands. ----------------------
// returns find_info which is then used in subsequent commands.
SACK_VFS_PROC struct find_info * CPROC sack_vfs_fs_find_create_cursor( uintptr_t psvInst, const char *base, const char *mask );
// reset find_info to the first directory entry.  returns 0 if no entry.
SACK_VFS_PROC int CPROC sack_vfs_fs_find_first( struct find_info *info );
// closes a find cursor; returns 0.
SACK_VFS_PROC int CPROC sack_vfs_fs_find_close( struct find_info *info );
// move to the next entry returns 0 if no entry.
SACK_VFS_PROC int CPROC sack_vfs_fs_find_next( struct find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC char * CPROC sack_vfs_fs_find_get_name( struct find_info *info );
// get file information for the file at the current cursor position...
SACK_VFS_PROC size_t CPROC sack_vfs_fs_find_get_size( struct find_info *info );
#if defined USE_VFS_FS_INTERFACE
#define volume fs_volume
#define sack_vfs_file sack_vfs_fs_file
#define sack_vfs_load_volume  sack_vfs_fs_load_volume
#define sack_vfs_load_crypt_volume  sack_vfs_fs_load_crypt_volume
#define sack_vfs_use_crypt_volume  sack_vfs_fs_use_crypt_volume
#define sack_vfs_unload_volume  sack_vfs_fs_unload_volume
#define sack_vfs_shrink_volume  sack_vfs_fs_shrink_volume
#define sack_vfs_decrypt_volume  sack_vfs_fs_decrypt_volume
#define sack_vfs_encrypt_volume  sack_vfs_fs_encrypt_volume
#define sack_vfs_get_signature  sack_vfs_fs_get_signature
#define sack_vfs_get_signature2  sack_vfs_fs_get_signature2
#define sack_vfs_openfile  sack_vfs_fs_openfile
#define sack_vfs_exists  sack_vfs_fs_exists
#define sack_vfs_close  sack_vfs_fs_close
#define sack_vfs_tell  sack_vfs_fs_tell
#define sack_vfs_size  sack_vfs_fs_size
#define sack_vfs_seek  sack_vfs_fs_seek
#define sack_vfs_write  sack_vfs_fs_write
#define sack_vfs_read  sack_vfs_fs_read
#define sack_vfs_truncate  sack_vfs_fs_truncate
#define sack_vfs_unlink_file  sack_vfs_fs_unlink_file
#define sack_vfs_rename  sack_vfs_fs_rename
#define sack_vfs_find_create_cursor  sack_vfs_fs_find_create_cursor
#define sack_vfs_find_first  sack_vfs_fs_find_first
#define sack_vfs_find_close  sack_vfs_fs_find_close
#define sack_vfs_find_next  sack_vfs_fs_find_next
#define sack_vfs_find_get_name  sack_vfs_fs_find_get_name
#define sack_vfs_find_get_size  sack_vfs_fs_find_get_size
#endif
SACK_VFS_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::SACK_VFS;
#endif
#endif
#ifndef SQL_OPTIONS_DEFINED
#define SQL_OPTIONS_DEFINED
/* more documentation at end */
/*
 *
 *   Creator: Panther   #implemented in Dekware
 *   Modified by: Jim Buckeyne #ported to service SQL via proxy.
 *   Returned to sack by: Jim Buckeyne
 *                  # stripped application specific
 *                  # features, returned to SACK.
 *
 *  Provides a simple, intuitive interface to SQL.  Used sensibly,
 *  provides garbage collection of resources.
 *
 *  Commands without an ODBC specifier are the perferred method to
 *  use this interface.  This allows the internal system to maintain
 *  a primary and a redundant backup connection to provide transparent
 *  reliability to the application.
 *
 *  Provides some slick table creation routines
 *     - check for existance, and drop  (CTO_DROP)
 *     - check for existance, and match (CTO_MATCH)
 *     - check for existance, and merge (CTO_MERGE)
 *     - create table if not exist.
 *
 *  Latest additions provide ...RecordQuery... functions which
 *  result with a const CTEXTSTR * of results;  (ie, result[0] = (CTEXTSTR)result1 )
 *  also available are the column names from the query.
 *  I strongly recommend passing NULL always to the field names, and
 *  using sensible enumerators that follow the query definition.
 *
 *  (c)Freedom Collective (Jim Buckeyne 2000-2016)
 *
 */
#ifndef PSSQL_STUB_DEFINED
/* multiple inclusion protection symbol */
#define PSSQL_STUB_DEFINED
#if defined( SQLSTUB_SOURCE ) || defined( SQLPROXY_LIBRARY_SOURCE )
#define PSSQL_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define PSSQL_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _SQL_NAMESPACE   namespace sql {
#define _SQL_NAMESPACE_END   }
#define SQL_NAMESPACE   namespace sack { namespace sql {
#define SQL_NAMESPACE_END } }
#else
#define _SQL_NAMESPACE
#define _SQL_NAMESPACE_END
#define SQL_NAMESPACE
#define SQL_NAMESPACE_END
#endif
SACK_NAMESPACE
/* SQL access library. This provides a simple access to ODBC
   connections, and to sqlite. If no database is specified,
   there is an internal database that can be used. These methods
   on the PODBC connection are NOT thread safe. Multiple threads
   shall never use the same PODBC; they can use seperate PODBC
   connections. Under linux this links to unixODBC.
   DoSQLCommandf
   DoSQLRecordQueryf
   GetSQLRecord
   ConnectToDatabase
   DoSQLCommandf
   DoSQLRecordQueryf
   FetchSQLRecord
   There is a configuration file for the default SQL connection,
   this is kept in a file 'sql.config' which is processed with
   ProcessConfigurationFile(); If this file does not exist, it
   will be automatically created with default values.
   (Need to describe this sql.config file)                       */
_SQL_NAMESPACE
/* <combine PSSQL_PROC>
   \ \                    */
#define SQLPROXY_PROC PSSQL_PROC
/* This is the connection object that provides interface to the
   database. Can be NULL to specify the default connection
   interface. See namespace <link sack::sql, sql>.
   An ODBC connection handles commands as a stack. Each command
   is done as a temporary entry on the stack. A query is done as
   an entry on the stack, but the entry remains on the stack
   until the final result is retrieved or an early PopODBC is
   called.
   The structure of this is such that if a command is slow to a
   database, it would be possible to stack commands that are
   temporary and pending until the database connection is
   restored.
   Example
   <code lang="c++">
   int f( void )
   {
       // results from the query
       CTEXTSTR *results;
       // connect.
       PODBC odbc = ConnectToDatabase( "system_dsn_name" );
       // do a command, does a temporary entry on the stack, unless the database is slow
       SQLCommandf( odbc, "create temporary table my_test_table( ID int, value int )" );
       // start a new entry on the command stack.
       SQLRecordQueryf( odbc, NULL, &amp;results, NULL, "select 1+1" );
       // when this command is done, it is stacked on the query.
       SQLCommandf( odbc, "insert into my_test_table (value) values(%d)", 1234 );
       // at this point there is technically 2 entries on the command stack until the next
       // FetchSQLResult( odbc, &amp;results );
   }
	</code>                                                                                 */
#if !defined( __GNUC__ ) || !defined( SQLSTUB_SOURCE )
   // GCC doesn't identify this as exactly the same declaration
	typedef struct odbc_handle_tag *PODBC;
#endif
typedef struct odbc_handle_tag ODBC;
// recently added {} container braces for structure element
#define FIELDS(n) {( sizeof( n ) / sizeof( FIELD ) ), n}
/* a field definition can be a rename, and contain prior names,
   so that the rename can be tracked and migrated appropraitely.
   Unfortuntaly this sort of operation only affects this code,
   and not all auxiliary code.                                   */
#define MAX_PREVIOUS_FIELD_NAMES 4
/* <combine sack::sql::required_field_tag>
   <code lang="c++">
     FIELD fields[] = { { "ID", WIDE("int") }, ... };
   </code>                                            */
typedef struct required_field_tag
{
	/* This is the name of the column described in this table. */
	CTEXTSTR name;
	/* pointer to a string describing the type of this column.  */
	CTEXTSTR type;
	/* extra information about the field... grab all addtional
	   information like 'NOT NULL' "default 'zxa'" to describe a
	   field. Sometimes target databases don't understand extra
	   \parameters, and these can be translated as required or
	   ignored.                                                  */
	CTEXTSTR extra;
	// if you have renamed this column more than 1
	// times - you really need to stop messing around
	// and get a life.
	CTEXTSTR previous_names[MAX_PREVIOUS_FIELD_NAMES];
} FIELD, *PFIELD;
#if !defined( _MSC_VER ) || ( _MSC_VER >= 800 )
/* A macro to append a NULL automatically to a list of strings.
   Example
   <code lang="c++">
   CTEXTSTR strings[] = { KEY_COLUMNS( "one", "two", "three" ) };
   </code>
   strings will be set to 4 elements with the 3 strings listed
   in KEY_COLUMNS plus a NULL string.                             */
#define KEY_COLUMNS(...) { __VA_ARGS__, NULL }
#endif
/* sets the count and the array of a statically declared
   required_table_tag.
   Example
   <code lang="c++">
   </code>
   <code>
   FIELD fields[5];
   DB_KEY_DEF keys[3];
   TABLE table = { "table_name", FIELDS( fields ), TABLE_KEYS( keys ) };
   </code>
   This creates a static table definition with the name
   "table_name" and 5 fields with 3 keys. fields[] = { } is
   usally the declartion. Also DB_KEY_DEF keys[] = { ... }; for
   keys.
                                                                         */
#define TABLE_KEYS(n) {( sizeof( n ) / sizeof( DB_KEY_DEF ) ), n}
/* maximum columns that can be specified for a multicolumn index
   in required_key_def.                                          */
#define MAX_KEY_COLUMNS 8
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  DB_KEY_DEF;
enum uniqueResolutions {
  // no on conflict specification.
	UNIQRES_UNSET = 0,
	UNIQRES_REPLACE,
	UNIQRES_IGNORE,
	UNIQRES_FAIL,
	UNIQRES_ABORT,
	UNIQRES_ROLLBACK
};
/* <combine sack::sql::required_key_def>
   \ \                                   */
typedef struct required_key_def  *PDB_KEY_DEF;
struct required_key_def
{
	/* Flags describing attributes of this key */
	/* <combine sack::sql::required_key_def::flags@1>
	   \ \                                            */
	struct {
		/* this defines the primary key for the table */
		BIT_FIELD bPrimary : 1;
		/* the key is meant to be unique. */
		BIT_FIELD bUnique : 1;
		BIT_FIELD uniqueResolution : 3;
	} flags;
	/* Name of the key column. Can be NULL if primary. */
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
#ifdef __cplusplus
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = NULL; }
   /* <combine sack::sql::required_key_def>
      This is used when actually building C++ for providing an
      initializer to this structure.                           */
   required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = 0; }
	/* Just another required_key_def constructor. */
	required_key_def( int bPrimary, int bUnique, CTEXTSTR _name, CTEXTSTR colname1, CTEXTSTR colname2, CTEXTSTR colname3 ) { flags.bPrimary = bPrimary; flags.bUnique = bUnique; name = _name; colnames[0] = colname1; colnames[1] = colname2; colnames[2] = colname3; colnames[3] = 0; }
#else
#define required_key_def( a,b,c,...) { {a,b}, c, {__VA_ARGS__} }
#endif
};
 /* Describes a key column of a table.
      <code lang="c++">
      DB_KEY_DEF keys[] = { { "lockey", KEY_COLUMNS("hall_id","charity_id") } };
      </code>                                                                    */
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  DB_CONSTRAINT_DEF;
/* <combine sack::sql::required_constraint_def>
   \ \                                   */
typedef struct required_constraint_def  *PDB_CONSTRAINT_DEF;
struct required_constraint_def
{
	struct {
		BIT_FIELD cascade_on_delete : 1;
		BIT_FIELD cascade_on_update : 1;
		BIT_FIELD restrict_on_delete : 1;
		BIT_FIELD restrict_on_update : 1;
		BIT_FIELD noaction_on_delete : 1;
		BIT_FIELD noaction_on_update : 1;
		BIT_FIELD setnull_on_delete : 1;
		BIT_FIELD setnull_on_update : 1;
		BIT_FIELD setdefault_on_delete : 1;
		BIT_FIELD setdefault_on_update : 1;
		BIT_FIELD foreign_key : 1;
	} flags;
	CTEXTSTR name;
 // uhm up to 5 colnames...
	CTEXTSTR colnames[MAX_KEY_COLUMNS];
	CTEXTSTR references;
 // uhm up to 5 colnames...
	CTEXTSTR foriegn_colnames[MAX_KEY_COLUMNS];
 // if not null, broken structure...
	CTEXTSTR null;
 // Describes a constraint clause
};
/* Example
   By default, CreateTable( CTEXTSTR tablename, CTEXTSTR
   filename ) which reads a 'create table' statement from a file
   to create a table, this now parses the create table structure
   into an internal structure TABLE which has FIELDs and
   DB_KEY_DEFs. This structure is now passed to CheckODBCTable
   which is able to compare the structure with the table
   definition available from the database via DESCRIBE TABLE,
   and then update the table in the database to match the TABLE
   definition.
   One can use the table structure to define tables instead of
   maintaining external files... and without having to create a
   temporary external file which could then contain a create
   table statement to create the table.
   <code>
   // declare some fields...
   FIELD some_table_field_array_name[] = { { "field one", "int", NULL }
   , { "field two", "varchar(100)", NULL }
   , { "ID field", "int", "auto_increment" }
   , { "some other field", "int", "NOT NULL default '8'" }
   };
   // define some keys...
   DB_KEY_DEF some_table_key_array_name[] = { { .flags = { .bPrimary = 1 }, NULL, {"ID Field"} }
   , { {0}, "namekey", { "field two", NULL } }
   };
   </code>
   // the structure for DB_KEY_DEF takes an array of column
   names used to define the key, there should be a NULL to end
   the list. The value after the array of field names is called
   'null' which should always be set to NULL. If these are
   declared in global data space, then any unset value will be
   initialized to zero.
   <code>
   TABLE some_table_var_name = { "table name", FIELDS( some_table_field_array_name ), TABLE_KEYS( some_table_key_array_name ), 1 );
    LOGICAL CheckODBCTable( PODBC odbc, PTABLE table, uint32_t options )
        PODBC odbc - may be left NULL to use the default database connection.
        PTABLE table - a pointer to a TABLE structure which has been initialized.
        uint32_t options - zero or more of  the following symbols or'ed together.
                   \#define CTO_MATCH 4  // attempt to figure out alter statements to drop or add columns to exact match definition
                   \#define CTO_MERGE 8  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
   </code>
   Then some routine later
   <code>
   {
      ...
      CheckODBCTable( NULL, &amp;some_table_var_name, CTO_MERGE );
      ..
   }
   </code>
   * ---------------------------------------------------------- *
   alternatively tables may be checked and updated using the
   following code, given an internal constant text string that
   is the create table statement, this may be parsed into a
   PTABLE structure which the resulting table can be used in
   CheckODBCTable();
   <code>
   static CTEXTSTR create_player_info = "CREATE TABLE `players_info` ("
         "  `player_id` int(11) NOT NULL auto_increment,           "
         "  PRIMARY KEY  (`player_id`),                            "
         ")                               ";
   PTABLE table = GetFieldsInSQL( create_player_info, FALSE );
   CheckODBCTable( NULL, table, CTO_MERGE );
   DestroySQLTable( table );
   </code>                                                                                                                          */
struct required_table_tag
{
	/* This is the name of the table. */
	CTEXTSTR name;
	/* describes the columns (fields) in a table. */
	struct pssql_table_fields {
		/* number of fields in the array pointed at by field. */
		int count;
		/* pointer to an array of FIELD. */
		PFIELD field;
	} fields;
	/* Describes the keys on the table.  */
	/* <combine sack::sql::required_table_tag::keys@1>
	   \ \                                             */
	struct pssql_table_key {
		/* number of keys pointed at by key. */
		int count;
      /* pointer to an array of DB_REQ_KEY. */
      PDB_KEY_DEF key;
	} keys;
	struct pssql_table_constraint {
		int count;
		PDB_CONSTRAINT_DEF constraint;
	} constraints;
	/* <combine sack::sql::required_table_tag::flags@1>
	   \ \                                              */
	/* flags controlling the table. */
		struct pssql_table_flags {
         // set this if defined dynamically (from getfields in SQL)
		BIT_FIELD bDynamic : 1;
		/* This is a table that is allocated in memory, static table
		   definitions should leave this 0.                          */
		BIT_FIELD bTemporary : 1;
		/* Issue the create statement always, but include 'if not
		   exists'. Don't try and compare the table structure.    */
		BIT_FIELD bIfNotExist : 1;
	} flags;
   /* name of another table that already exists. Creates this table
      using that table's description.                               */
   CTEXTSTR create_like_table_name;
   /* name of the database that contains this table. */
   CTEXTSTR database;
   /* an additional field that can specify the database storage
      engine to use. (Hmm maybe use this to specify sqlite target?) */
   CTEXTSTR type;
   /* This is an additional field to add as a description to the
      database if supported by the target database.              */
   CTEXTSTR comment;
};
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag TABLE;
/* <combine sack::sql::required_table_tag>
   \ \                                     */
typedef struct required_table_tag *PTABLE;
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTableEx)( PODBC odbc, PTABLE table, uint32_t options DBG_PASS );
/* Checks a table in a database to see if it exists, and that
   all the columns in the table definition passed exist as
   column in the database. Will generate alter statements to the
   table as appropriate.
   Parameters
   odbc :     connection to check the table on
   table :    a table which was created with GetFieldsInSQL, or
              created by filling in a structure.
   options :  Options from CreateTableOptions.                   */
PSSQL_PROC( LOGICAL, CheckODBCTable)( PODBC odbc, PTABLE table, uint32_t options );
/* <combine sack::sql::CheckODBCTableEx@PODBC@PTABLE@uint32_t options>
   \ \                                                            */
#define CheckODBCTable(odbc,t,opt) CheckODBCTableEx(odbc,t,opt DBG_SRC )
/* Enable or disable logging SQL to the sql.log file and to the
   application's log.
   Parameters
   odbc :      connection to disable logging on
   bDisable :  if TRUE disables logging, else restores logging. */
PSSQL_PROC( void, SetSQLLoggingDisable )( PODBC odbc, LOGICAL bDisable );
#ifndef SQLPROXY_INCLUDE
// result is FALSE on error
// result is TRUE on success
PSSQL_PROC( int, DoSQLCommandEx )( CTEXTSTR command DBG_PASS);
#endif
/* <combine sack::sql::DoSQLCommandEx@CTEXTSTR command>
   \ \                                                  */
#define DoSQLCommand(c) DoSQLCommandEx(c DBG_SRC )
/* Generate a commit for any outstanding transactions. Commit
   syntax is variable depending on the connection. Connections
   also have the feature to auto generate begin transaction, and
   flush after a period of idle.
   Parameters
   odbc :  connection to database to commit                      */
PSSQL_PROC( void, SQLCommit )( PODBC odbc );
/* generates the begin transaction for a commection.
   Parameters
   odbc :  connection to database to start a transaction        */
PSSQL_PROC( void, SQLBeginTransact )( PODBC odbc );
// parameters to this are pairs of "name", type, WIDE("value")
//  type == 0 - value is text, do not quote
//  type == 1 - value is text, add quotes appropriate for database
//  type == 2 - value is an integer, do not quote
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
#ifndef SQLPROXY_INCLUDE
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnection )( PODBC );
#endif
/* This opens or re-opens a database connection. Mostly an
   \internal function(?)
   Parameters
   odbc :  connection to open.                             */
PSSQL_PROC( int, OpenSQLConnectionEx )( PODBC DBG_PASS );
/* <combine sack::sql::OpenSQLConnectionEx@PODBC>
   \ \                                            */
#define OpenSQLConnect(o) OpenSQLConnectionEx( o DBG_SRC )
// should pass to this a &(CTEXTSTR) which starts as NULL for result.
// result is FALSE on error
// result is TRUE on success, and **result is updated to
// contain the resulting data.
PSSQL_PROC( int, DoSQLQueryEx )( CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::DoSQLQueryEx@CTEXTSTR@CTEXTSTR *result>
   \ \                                                         */
#define DoSQLQuery(q,r) DoSQLQueryEx( q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
#define DoSQLRecordQuery(q,r,c,f) SQLRecordQueryEx( NULL,q,r,c,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define DoSQLQueryRecord(q,r,c)   DoSQLRecordQuery(q,r,c,NULL)
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLQueryRecord(o,q,r,c)   SQLRecordQuery(o,q,r,c,NULL)
/* <combine sack::sql::GetSQLRecord@CTEXTSTR **>
   \ \                                           */
#define GetSQLResultRecord(r,c)   GetSQLRecord(c)
/* <combine sack::sql::FetchSQLResult@PODBC@CTEXTSTR *>
   \ \                                                  */
PSSQL_PROC( int, GetSQLResult )( CTEXTSTR *result );
/* <combine sack::sql::FetchSQLRecord@PODBC@CTEXTSTR **>
   \ \                                                   */
PSSQL_PROC( int, GetSQLRecord )( CTEXTSTR **result );
/* Gets the last result on the default ODBC connection.
   Parameters
   result\ :  address of a string pointer to get set to the error
              string.
   Example
   <code>
   {
      CTEXTSTR error;
      GetSQLError( &amp;error );
      printf( "Error: %s", error );
   }
   </code>                                                        */
PSSQL_PROC( int, GetSQLError )( CTEXTSTR *result );
/* This is a test command that tests to see if the default
   database connection is able to work.                    */
PSSQL_PROC( int, IsSQLReady )( void );
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
PSSQL_PROC( int, PushSQLQuery )( void );
/* <combine sack::sql::PopODBCEx@PODBC>
   \ \                                  */
PSSQL_PROC( void, PopODBC )( void );
#ifndef SQLPROXY_INCLUDE
/* Clear the top non temporary sql statement from the PODBC
   stack.
   Parameters
   odbc :  connection to remove the statement from.
   Remarks
   A SQLCommand is temporary, a SQLQuery or a PushODBC is not. Pop
   MAY be used to clear a query early, but it is recommended to
   read to the end of it instead.                                  */
PSSQL_PROC( void, PopODBCExx )( PODBC, LOGICAL DBG_PASS );
PSSQL_PROC( void, PopODBCEx )( PODBC );
/* <combine sack::sql::PopODBCExx@PODBC@LOGICAL>
   \ \                                           */
#define PopODBCEx(o) PopODBCExx(o,FALSE DBG_SRC)
/* <combine sack::sql::PopODBCEx>
   \ \                            */
#define PopODBC() PopODBCExx(NULL,FALSE DBG_SRC)
#endif
/* This terminates a query on the PODBC stack. (It was mentioned
   in pop odbc that it could be used to terminate a query, but
   that will log that a pop is being done without a push. This
   is the proper way to prematurely end a query.)
   Parameters
   odbc :  connection to end a query on.                         */
PSSQL_PROC( void, SQLEndQuery )( PODBC odbc );
// release any open queries on the database... all result
// sets are now invalid... uhmm what about things like fields?
// could be messy...
PSSQL_PROC( void, ReleaseODBC )( PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
#ifndef SQLPROXY_INCLUDE
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   date :    string to parse
   year :    pointer to an int that will receive the year portion
             of the date
   month :   pointer to an int that will receive the month
             portion of the date
   day :     pointer to an int that will receive the day portion
             of the date
   hour :    pointer to an int that will receive the hours
             portion of the date
   minute :  pointer to an int that will receive the minutes
             portion of the date
   second :  pointer to an int that will receive the second
             portion of the date
   msec :    pointer to an int that will receive the milli\-second
             portion of the date
   nsec :    pointer to an int that will receive the nano second portion
             of the date                                                 */
PSSQL_PROC( void, ConvertSQLDateEx )( CTEXTSTR date
												  , int *year, int *month, int *day
												  , int *hour, int *minute, int *second
												  , int *msec, int32_t *nsec
												  , int *zone_hr, int *zone_mn
												  );
#endif
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDate( date, y,m,d) ConvertSQLDateEx( date,y,m,d,NULL,NULL,NULL,NULL,NULL)
/* <combine sack::sql::ConvertSQLDateEx@CTEXTSTR@int *@int *@int *@int *@int *@int *@int *@int32_t *>
   \ \                                                                                             */
#define ConvertSQLDateTime( date, y,mo,d,h,mn,s) ConvertSQLDateEx( date,y,mo,d,h,mn,s,NULL,NULL)
//------------------------------
// this set of functions will auto create a suitable name table
// providing table_name_id and table_name_name as the columns to query by standard
// previous defaults where "id" and "name" which results in inability to use natural join
//
PSSQL_PROC( INDEX, FetchSQLNameID )( PODBC odbc, CTEXTSTR table_name, CTEXTSTR name );
/* A specialized function which takes a name, looks in a SQL
   table on the default database connection for in column
   'name', and returns the value in the 'ID' column. This
   function may create a table with the required fields. This
   table is very bad, if you have 3 tables all with the same
   'name' column reverse engineering and natural join clauses
   fail.
   Parameters
   table_name :  name of the table to get the name's ID from.
   name :        name to lookup its ID for.
   Returns
   the ID of the name or INVALID_INDEX if not found.          */
PSSQL_PROC( INDEX, GetSQLNameID )( CTEXTSTR table_name, CTEXTSTR name );
/* Still a bad function to use.... just don't.
   Parameters
   odbc :        _nt_
   table_name :  _nt_
   iName :       _nt_                          */
PSSQL_PROC( CTEXTSTR, FetchSQLName )( PODBC odbc, CTEXTSTR table_name, INDEX iName );
/* A specialized function which takes an ID, looks in a SQL
   table on the default database connection for in column 'ID',
   and returns the value in the 'name' column. This function may
   create a table with the required fields. This table is very
   bad, if you have 3 tables all with the same 'name' column
   reverse engineering and natural join clauses fail.
   Parameters
   table_name :  name of the database table to read from
   iName :       ID of the name to get                           */
PSSQL_PROC( CTEXTSTR, GetSQLName )( CTEXTSTR table_name, INDEX iName );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \
   Note
   If database connection is not specified or is NULL, uses the
   default SQL connection.                                                                         */
PSSQL_PROC( INDEX, ReadNameTableExEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTableExx( name,table,col,namecol,bCreate) ReadNameTableExEx( name,table,col,namecol,bCreate DBG_SRC )
//column name if NOT specified will be 'ID'
PSSQL_PROC( INDEX, ReadNameTableEx)( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::ReadNameTableExEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                    */
#define ReadNameTable(n,t,c) ReadNameTableExEx( n,t,c, WIDE("name"),TRUE DBG_SRC )
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
PSSQL_PROC( int, ReadFromNameTableEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_colname, CTEXTSTR name_colname, CTEXTSTR *result DBG_PASS);
/* TRUE if name in result... again if !colname colname = 'ID'
   Parameters
   odbc :       connection to use
   id :         ID of the name to read
   table :      table to read from
   id_column :  name of the column that contains the ID
   colname :    name of the column that is where the name is
   result\ :    pointer to a CTEXTSTR which will be filled with
                the name in the table                           */
PSSQL_PROC( int, ReadFromNameTableExEx )( INDEX id, CTEXTSTR table, CTEXTSTR id_column, CTEXTSTR colname, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::ReadFromNameTableExEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                          */
#define ReadFromNameTableExx(id,t,ic,nc,r) ReadFromNameTableExEx(id,t,ic,nc,r DBG_SRC )
/* <combine sack::sql::ReadFromNameTableEx@INDEX@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR *result>
   \ \                                                                                        */
#define ReadFromNameTable(id,t,c,r) ReadFromNameTableEx(id,t,c,WIDE("name"),r DBG_SRC )
/* This is a better name resolution function. It will also
   create a table that contains the required columns, but the
   column names may be more intelligent than 'ID' and 'name'.
   Parameters
   odbc :     database connection to read from
   name :     the name to lookup the ID for
   table :    table the name column is in
   col :      name of the key column(s) to read.
   namecol :  name of column containing the name to lookup.
   bCreate :  if TRUE, will insert the name into the table, and
              return the resulting columns.                     */
PSSQL_PROC( INDEX, SQLReadNameTableExEx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTableExx( odbc,name,table,col,namecol,bCreate) SQLReadNameTableExEx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::SQLReadNameTableExEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                             */
#define SQLReadNameTable(o,n,t,c) SQLReadNameTableExEx( o,n,t,c,WIDE( "name" ),TRUE DBG_SRC )
/* Reads a table that's assumed to be a primary key ID and a
   name sort of dictionary table. This also maintains an
   \internal cache of names queried, since it is assumed words
   in a dictionary don't move or change.
   Parameters
   odbc :      odbc connection to use
   name :      name to get the index of
   table :     table to get the index from
   col :       column name of the ID columns (macros allow this to
               be defaulted)
   namecol :   column name of the name column (macros allow this to
               be defaulted)
   bCreate :   If the name doesn't exist, setting this to TRUE will
               insert the new name, else return will be
               INVALID_INDEX.
   bQuote :    Indicates if the name should be quoted (else use no
               quotes)
   DBG_PASS :  _nt_                                                 */
PSSQL_PROC( INDEX, GetNameIndexExtended)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate, int bQuote DBG_PASS );
/* <combine sack::sql::GetNameIndexExtended@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int@int bQuote>
   \ \                                                                                                */
PSSQL_PROC( INDEX, GetNameIndexExx)( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndexEx( odbc,name,table,col,namecol,bCreate) GetNameIndexExx( odbc,name,table,col,namecol,bCreate DBG_SRC )
/* <combine sack::sql::GetNameIndexExx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@int bCreate>
   \ \                                                                                        */
#define GetNameIndex(o,n,t,c) GetNameIndexExx( o,n,t,c,WIDE( "name" ),TRUE DBG_SRC )
// table and col are not used if a MySQL backend is used...
// they are needed to get the last ID from a postgresql backend.
PSSQL_PROC( INDEX, GetLastInsertIDEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertID(t,c) GetLastInsertIDEx(t,c DBG_SRC )
/* Gets the ID of the primary key from the prior insert. This
   value can be used in subsequent inserts to relate detail
   records to a master.
   Parameters
   odbc :    database connection
   table :   if NULL, just get's the connection's last insert
             into whatever table. PostgreSQL requires a table
             name and column name to get the last insert for. So,
             proper portability for certain databases may use
             this parameter.
   column :  if NULL, just get's the connection's last insert id
             from the auto increment primary key. PostgreSQL
             requires a table name and column name to get the
             last insert for. So, proper portability for certain
             databases may use this parameter.
   Returns
   a 64 bit row identifier.                                       */
PSSQL_PROC( INDEX, FetchLastInsertIDEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertID(o,t,c) FetchLastInsertIDEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
#define FetchLastInsertKey(o,t,c) FetchLastInsertKeyEx(o,t,c DBG_SRC )
/* <combine sack::sql::FetchLastInsertIDEx@PODBC@CTEXTSTR@CTEXTSTR col>
   \ \                                                                  */
PSSQL_PROC( CTEXTSTR, FetchLastInsertKeyEx)( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
PSSQL_PROC( CTEXTSTR, GetLastInsertKeyEx)( CTEXTSTR table, CTEXTSTR col DBG_PASS );
/* <combine sack::sql::GetLastInsertIDEx@CTEXTSTR@CTEXTSTR col>
   \ \                                                          */
#define GetLastInsertKey(t,c) GetLastInsertKeyEx(t,c DBG_SRC )
// CreateTable Options (CTO_)
enum CreateTableOptions {
   // drop old table before create.
 CTO_DROP  = 1,
  // attempt to figure out alter statements to drop or add columns to exact match definition
 CTO_MATCH = 4,
  // attempt to figure out alter statements to add missing columns, do not drop.  Rename?
 CTO_MERGE = 8,
 // log changes to "changes.sql"
		CTO_LOG_CHANGES = 16
};
/* \ \
   Parameters
   odbc :          database connection to check table in
   filename :      name of file containing sql CREATE TABLE
                   statements.
   templatename :  name of the table specified by the CREATE
                   TABLE statement.
   tablename :     table name to use when actually creating this.
                   May be different from template table name.
   options :       Options from CreateTableOptions.               */
PSSQL_PROC( int, SQLCreateTableEx )(PODBC odbc, CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::SQLCreateTableEx@PODBC@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                                        */
#define SQLCreateTable( odbc, file, table ) SQLCreateTableEx(odbc,file,table,table,0)
/* Creates a table in a database by reading an external file
   containing the table definition. It can also perform
   iterative updates to table structure if the template
   definition adds or deletes columns.
   Parameters
   filename :      filename to read the template from
   templatename :  name of the table in the create table template
                   statement.
   tablename :     the name of the table to create (may be
                   different than template)
   options :       Options from CreateTableOptions.
   Returns
   TRUE if success.
   FALSE if failure. (No further information)                     */
PSSQL_PROC( int, CreateTableEx )( CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options );
/* <combine sack::sql::CreateTableEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@uint32_t>
   \ \                                                               */
#define CreateTable( file, table ) CreateTableEx(file,table,table,0)
// results in a static buffer with escapes filled in for characterws
// which would otherwise conflict with string punctuators.
PSSQL_PROC( TEXTSTR ,EscapeStringEx )( CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeString(s) EscapeStringEx( s DBG_SRC )
/* <combine sack::sql::EscapeStringEx@CTEXTSTR name>
   \ \                                               */
#define EscapeStringOpt(s,q) EscapeSQLBinaryExx( NULL,s,StrLen(s),NULL, q DBG_SRC )
/* \ \
   Parameters
   odbc :  connection to escape the string appropriately for. Different
           database engines require different string escapes.
   name :  string to escape
   Returns
   a TEXTSTR that is the content of the string passed properly
   escaped.
   it is appropriate to Release( result );
   Example
   This is difficult to describe coorectly, since in C, you have
   to do escaping on the parameters anyhow....
   <code lang="c++">
   {
       TEXTSTR result = EscapeSQLString( "\\"test \\'escape\\'" );
       printf( "original : %s\\n"
               "result   : %s\\n"
             , "\\"test \\'escape\\'"
             , \result );
   }
   </code>
   \Output
   <code lang="c++">
   original : "test 'escape'
   \result   : \\"test \\'escape\\'
   </code>                                                              */
PSSQL_PROC( TEXTCHAR *,EscapeSQLStringEx )( PODBC odbc, CTEXTSTR name DBG_PASS );
/* <combine sack::sql::EscapeSQLStringEx@PODBC@CTEXTSTR name>
   \ \                                                        */
#define EscapeSQLString(odbc, s) EscapeSQLStringEx( odbc, s DBG_SRC )
// the following functions return an allcoated buffer which the application must Release()
PSSQL_PROC( TEXTSTR ,EscapeBinaryEx )( CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinary(b,bl) EscapeBinaryEx(b,bl DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
#define EscapeBinaryOpt(b,bl,q) EscapeSQLBinaryExx(NULL,b,bl,NULL,q DBG_SRC )
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
PSSQL_PROC( TEXTSTR,EscapeSQLBinaryExx )( PODBC odbc, CTEXTSTR blob, size_t bloblen, size_t *resultLen, LOGICAL bQuote DBG_PASS );
/* <combine sack::sql::EscapeBinaryEx@CTEXTSTR@uintptr_t bloblen>
   \ \                                                           */
//PSSQL_PROC( TEXTSTR,EscapeSQLBinaryEx )( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen DBG_PASS );
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinary(odbc,blob,len) EscapeSQLBinaryExx( odbc,blob,len, NULL, FALSE DBG_SRC )
/* <combine sack::sql::EscapeSQLBinaryEx@PODBC@CTEXTSTR@uintptr_t bloblen>
   \ \                                                                    */
#define EscapeSQLBinaryOpt(odbc,blob,len,q) EscapeSQLBinaryExx( odbc,blob,len,NULL,q DBG_SRC )
#define EscapeSQLBinaryLen(odbc,blob,len,resLen,q) EscapeSQLBinaryExx( odbc,blob,len,resLen, q DBG_SRC )
/* Remove escape sequences which are inserted into a text
   string. (for things like quotes and binary characters?)
   Parameters
   name :  string to remove string escapes from
   Returns
   a copy of the string without quotes. This result should be
   freed with Release when user is done with it.              */
PSSQL_PROC( TEXTSTR ,RevertEscapeString )( CTEXTSTR name );
/* Remove escape sequences which are inserted into a binary
   string.
   Parameters
   blob :     pointer to data to remove binary escape sequences
              from
   bloblen :  length of the data block to handle
   Returns
   a pointer to the string without escapes. (Even though it says
   binary, it's still to and from text?) This result should be
   freed with Release when user is done with it.                 */
PSSQL_PROC( TEXTSTR ,RevertEscapeBinary )( CTEXTSTR blob, size_t *bloblen );
/* Parse a Blob string stored as hex... that is text character
   0-9 and A-F.
   Parameters
   blob :    pointer to the string containing the blob string
   buffer :  target buffer for data
   buflen :  length of target buffer                           */
PSSQL_PROC( TEXTSTR , DeblobifyString )( CTEXTSTR blob, TEXTSTR buffer, size_t buflen );
/* parse the string passed as a date/time as returned from a
   MySQL database.
   Parameters
   timestring :     string to parse
   endtimestring :  pointer to a pointer to a string to receive
                    the position of the character after the
                    timestring.
   year :           pointer to an int that will receive the year
                    portion of the date
   month :          pointer to an int that will receive the month
                    portion of the date
   day :            pointer to an int that will receive the day
                    portion of the date
   hour :           pointer to an int that will receive the hours
                    portion of the date
   minute :         pointer to an int that will receive the
                    minutes portion of the date
   second :         pointer to an int that will receive the
                    second portion of the date
   Returns
   A true/false status whether the string passed was a valid
   time string (?).                                               */
PSSQL_PROC( int, ConvertDBTimeString )( CTEXTSTR timestring
                                      , CTEXTSTR *endtimestring
                                      , int *pyr, int *pmo, int *pdy
                                      , int *phr, int *pmn, int *psc );
#ifndef SQLPROXY_INCLUDE
/* Issue a command to a SQL database. Things like Update and
   Insert are commands.
   Parameters
   odbc :     database connection to perform the command on. If
              NULL uses the default global connection.
   command :  text string to send to the database to execute.
   Returns
   TRUE if the statement succeeds.
   FALSE if the statement fails. See FetchSQLError.             */
PSSQL_PROC( int, SQLCommandEx )( PODBC odbc, CTEXTSTR command DBG_PASS);
#endif
PSSQL_PROC( int, SQLCommandExx )(PODBC odbc, CTEXTSTR command, size_t commandLen DBG_PASS);
/* <combine sack::sql::SQLCommandEx@PODBC@CTEXTSTR command>
   \ \                                                      */
#define SQLCommand(o,c) SQLCommandEx(o,c DBG_SRC )
#define SQLCommandLen(o,c,len) SQLCommandExx(o,c,len DBG_SRC )
   /* Begin collecting insert statements for batch output.
   Parameters
   odbc :  database connection to start collecting inserts for */
PSSQL_PROC( int, SQLInsertBegin )( PODBC odbc );
/* Generate a SQL insert statement from a variable parameter
   list.
   Parameters
   odbc :   connection to generate an insert on
   table :  table to insert into
   args :   a list of fields.
   Remarks
   args each column is a set of 3 parameters; the first
   parameter is the name of the column to insert into, the
   second is a value 0 or 1 whether to quote the value or not,
   and a string pointer.
   Inserts may be batched together and flushed as a whole to the
   database connection.                                          */
PSSQL_PROC( int, vSQLInsert )( PODBC odbc, CTEXTSTR table, va_list args );
/* Generate an insert to the database. Inserts to a single table
   can be cached internally and flushed.
   Parameters
   odbc :   database connection to use
   table :  name of table to insert into
   ... :    sets of column paramters.                            */
PSSQL_PROC( int, SQLInsert )( PODBC odbc, CTEXTSTR table, ... );
PSSQL_PROC( int, DoSQLInsert )( CTEXTSTR table, ... );
/* Flushes all cached inserts collected on a database
   connection.
   Parameters
   odbc :  database connection to flush inserts       */
PSSQL_PROC( int, SQLInsertFlush )( PODBC odbc );
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   query :    the string query to do
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code lang="c++">
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQuery( odbc, "select 1,2,3", &amp;result );
   printf( "result : %s" );
   </code>
   \Output
   <code lang="c++">
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQuery                                                */
PSSQL_PROC( int, SQLQueryEx )( PODBC odbc, CTEXTSTR query, CTEXTSTR *result DBG_PASS);
/* <combine sack::sql::SQLQueryEx@PODBC@CTEXTSTR@CTEXTSTR *result>
   \ \                                                             */
#define SQLQuery(o,q,r) SQLQueryEx( o,q,r DBG_SRC )
/* <combine sack::sql::DoSQLRecordQueryf@int *@CTEXTSTR **@CTEXTSTR **@CTEXTSTR@...>
   \ \                                                                               */
PSSQL_PROC( int, SQLRecordQueryEx )( PODBC odbc
                                   , CTEXTSTR query
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , CTEXTSTR **fields DBG_PASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     connection to do the query on.
   query :    query to execute.
   queryLength : actual length of the query (allows embedded NUL characters)
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   resultLengths : pointer to a size_t* that will contain an array of
              lengths of the result values.
   fields :   address of a pointer to strings which will get the
              field names
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_PROC( int, SQLRecordQueryExx )( PODBC odbc
                                   , CTEXTSTR query
                                   , size_t queryLength
                                   , int *pnResult
                                   , CTEXTSTR **result
                                   , size_t **resultLengths
                                   , CTEXTSTR **fields
                                   DBG_PASS);
/* <combine sack::sql::SQLRecordQueryEx@PODBC@CTEXTSTR@int *@CTEXTSTR **@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQuery(o,q,prn,r,f) SQLRecordQueryEx( o,q,prn,r,f DBG_SRC )
/* <combine sack::sql::SQLRecordQueryExx@PODBC@CTEXTSTR@size_t@int *@CTEXTSTR **@size_t *@CTEXTSTR **fields>
   \ \                                                                                      */
#define SQLRecordQueryLen(o,q,ql,prn,r,rl,f) SQLRecordQueryExx( o,q,ql,prn,r,rl,f DBG_SRC )
   /* Gets the next result from a query.
   Parameters
   odbc :     database connection that the query was executed on
   result\ :  address of the result variable.
   Example
   See SQLRecordQueryf.                                          */
PSSQL_PROC( int, FetchSQLResult )( PODBC, CTEXTSTR *result );
/* Gets the next record result from the connection.
   Parameters
   odbc :     connection to get the result from; if NULL, uses
              \internal static connection.
   result\ :  address of a CTEXTSTR *; to set to an array of
              CTEXTSTR results.
   Remarks
   Values received are invalid after the next FetchSQLRecord or
   possibly other query.                                        */
PSSQL_PROC( int, FetchSQLRecord )( PODBC, CTEXTSTR **result );
/* Gets the last result on the specified ODBC connection.
   Parameters
   odbc :     connection to get the last error of
   result\ :  address of a string pointer to receive the error
              \result.
   Example
   <code lang="c++">
   {
      CTEXTSTR error;
      FetchSQLError( NULL, &amp;error );
   </code>
   <code>
      printf( "Error: %s", error );
   </code>
   <code lang="c++">
   }
   </code>                                                     */
PSSQL_PROC( int, FetchSQLError )( PODBC, CTEXTSTR *result );
#ifndef SQLPROXY_INCLUDE
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpenEx )( PODBC DBG_PASS );
/* Test if a database connection is open
   Parameters
   odbc :  database connection to check
   Returns
   TRUE if the connection is open and works.
   FALSE if the connection would not work because it is not
   connected.                                               */
PSSQL_PROC( int, IsSQLOpen )( PODBC );
/* <combine sack::sql::IsSQLOpenEx@PODBC>
   \ \                                    */
#define IsSQLOpen(odbc) IsSQLOpenEx(odbc DBG_SRC )
/* An PODBC connection handles commands as a stack, this saves
   the current query state (that you want to still get results
   from), so you can start a new query within the outer query.
   Parameters
   odbc :  database connection to save the current query state. */
PSSQL_PROC( int, PushSQLQueryExEx )(PODBC DBG_PASS);
PSSQL_PROC( int, PushSQLQueryEx )(PODBC);
/* <combine sack::sql::PushSQLQueryExEx@PODBC>
   \ \                                         */
#define PushSQLQueryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
// no application support for username/password, sorry, trust thy odbc layer, please
PSSQL_PROC( PODBC, ConnectToDatabase )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBC )( CTEXTSTR dsn );
PSSQL_PROC( PODBC, SQLGetODBCEx )( CTEXTSTR dsn, CTEXTSTR user, CTEXTSTR pass );
PSSQL_PROC( void, SQLDropODBC )( PODBC odbc );
PSSQL_PROC( void, SQLDropAndCloseODBC )( CTEXTSTR dsn );
#endif
// default parameter to require is the global flag RequireConnection from sql.config....
PSSQL_PROC( PODBC, ConnectToDatabaseExx )( CTEXTSTR DSN, LOGICAL bRequireConnection DBG_PASS );
PSSQL_PROC( PODBC, ConnectToDatabaseEx )( CTEXTSTR DSN, LOGICAL bRequireConnection );
#define ConnectToDatabaseEx( dsn, required ) ConnectToDatabaseExx( dsn, required DBG_SRC )
#define ConnectToDatabase( dsn ) ConnectToDatabaseExx( dsn, FALSE DBG_SRC )
/* Close a database connection. Releases all resources
   associated with the odbc connection.
   Parameters
   odbc :  connection to database to close. Should not be NULL.  */
PSSQL_PROC( void, CloseDatabase)(PODBC odbc );
// does a query responce kinda thing returning types.
// if( GetSQLTypes() ) while( GetSQLResult( &result ) && result )
PSSQL_PROC( int, GetSQLTypes )( void );
/* ODBC only (sqlite no support?). Gets the types of data that
   the ODBC connection supports.
   Parameters
   odbc :  database connection to get the types from.
   Example
   <code>
   PODBC odbc = NULL; // or do a ConnectToDatabsae
   CTEXTSTR result; // the singular line result
   if( FetchSQLTypes(odbc) )
       while( FetchSQLResult( &amp;result ) &amp;&amp; result )
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>
   <code lang="c++">
   if( GetSQLTypes() )
       while( GetSQLResult( &amp;result ) &amp;&amp; result )
   </code>
   <code>
       {
           printf( "Supported Type: %s\\n", result );
       }
   </code>                                                      */
PSSQL_PROC( int, FetchSQLTypes )( PODBC );
#define PSSQL_VARARG_PROC(a,b,c)  PSSQL_PROC(a,b)c; typedef a(CPROC * __f_##b)c; PSSQL_PROC( __f_##b, __##b )(DBG_VOIDPASS);
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   See SQLRecordQueryf, but omit the database parameter.         */
PSSQL_VARARG_PROC( int, DoSQLRecordQueryf ,( int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define DoSQLRecordQueryf   (__DoSQLRecordQueryf( DBG_VOIDSRC ))
/* <combine sack::sql::SQLQueryf@PODBC@CTEXTSTR *@CTEXTSTR@...>
   \ \                                                          */
PSSQL_VARARG_PROC( int, DoSQLQueryf, ( CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define DoSQLQueryf   (__DoSQLQueryf( DBG_VOIDSRC ))
/* This does a command to the database as a formatted command.
   This allows the user to simply specify the command and
   \parameters, and not also maintain a buffer to build the
   string into before passing the string to the ODBC connection
   as a command.
   Parameters
   fmt :  format string appropriate for vsnprintf. ... \: extra
          \parameters to fill the format string.
   See Also
   SQLCommandf
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from GetSQLError.
	*/
PSSQL_VARARG_PROC( int, DoSQLCommandf, ( CTEXTSTR fmt, ... ) );
#define DoSQLCommandf   (__DoSQLCommandf( DBG_VOIDSRC ))
/* Do a SQL query on the default odbc connection. The first
   record results immediately if there are any records. Returns
   the results as an array of strings. If you know the select
   you are using .... "select a,b,c from xyz" then you know that
   this will have 3 columns resulting.
   Parameters
   odbc :     database connection to perform the query on
   columns :  pointer to an int to receive the number of columns
              in the result. (the user will know this based on
              the query issued usually, so it can be NULL to
              ignore parameter)
   result\ :  pointer to a pointer to strings... see example
   fields :   address of a pointer to strings which will get the
              field names. May be ommited if you don't want to
              know the names. (is less work internally if this is
              not built).
   fmt :      format string as is appropriate for vsnprintf
   .... :     extra arguments to pass to format string
   Example
   <code lang="c++">
   PODBC odbc = ConnectToDatabase( "MySQL" );
   CTEXTSTR *results;
   CTEXTSTR *column_names;
   int columns;
   for( SQLRecordQueryf( odbc, &amp;columns, &amp;results, &amp;column_names
                       , "select a,b,c from %s where %s=%s"
                       , "table_name"
                       , "column_name"
                       , "'value'"
                       );
        results;
        FetchSQLRecord( odbc, &amp;results ) )
   {
      int n;
       // draw a seperator between rows returned
      printf( " ----- record data ----- \\n" );
      for( n = 0; n \< columns; n++ )
      {
         printf( "Result column '%s' = '%s'\\n", column_name[n], results[n] );
      }
   }
   CloseDatabase( odbc );
   </code>
   If the default connection is used, odbc can be NULL in the
   prior example, or the for staement could be
   <code>
   for( DoSQLRecordQueryf( &amp;columns, &amp;results, &amp;column_names
                         , "select a,b,c from %s where %s=%s"
                         , "table_name"
                         , "column_name"
                         , "'value'"
                         );
        results;
        GetSQLRecord( &amp;results ) )
   {
   }
   </code>                                                                     */
//PSSQL_PROC( int, SQLRecordQueryf )( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... );
PSSQL_VARARG_PROC( int, SQLRecordQueryf, ( PODBC odbc, int *columns, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf   (__SQLRecordQueryf( DBG_VOIDSRC ))
PSSQL_VARARG_PROC( int, SQLRecordQueryf_v2, ( PODBC odbc, int *nResults, CTEXTSTR **result, size_t **resultLengths, CTEXTSTR **fields, CTEXTSTR fmt, ... ) );
#define SQLRecordQueryf_v2   (__SQLRecordQueryf_v2( DBG_VOIDSRC ))
/* This was the original implementation, it returned the results
   as a comma separated list, with quotes around results that
   had commas in them, and quotes around empty strings to
   distinguish NULL result which is just ',,'.
   Parameters
   odbc :     database connection to do the query
   result\ :  address of a CTEXTSTR to get a comma seperated
              \result of the query in.
   query :    the string query to do
   ... :      extra parameters for the query format string
   Returns
   TRUE if the query succeeded
   FALSE if the query was in error. See FetchSQLError.
   Example
   <code>
   PODBC odbc = NULL; // just use the default connection...
   CTEXTSTR result;
   DoSQLQueryf( odbc, &amp;result, "select %d,%d,%d", 1, 2, 3 );
   printf( "result : %s" );
   </code>
   \Output
   <code>
   \result : 1,2,3
   </code>
   See Also
   SQLRecordQueryf                                               */
PSSQL_VARARG_PROC( int, SQLQueryf ,( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... ) );
#define SQLQueryf   (__SQLQueryf( DBG_VOIDSRC ))
/* This performs a command on a SQL connection.
   Parameters
   odbc :  database connection to do the command on
   fmt :   format string as appropriate for vsnprintf
   ... :   extra arguments as required by the format string
   Returns
   TRUE if command success, else FALSE.
   if FALSE, can get the error from FetchSQLError.
                                                            */
PSSQL_VARARG_PROC( int, SQLCommandf, ( PODBC odbc, CTEXTSTR fmt, ... ) );
#define SQLCommandf   (__SQLCommandf( DBG_VOIDSRC ))
/* Function signature for the callback when the SQL layer can
   log a status about a database connection (connection,
   disconnected, failed...) See SQLSetFeedbackHandler.        */
typedef void (CPROC *HandleSQLFeedback)(CTEXTSTR message);
// register a feedback message for startup messages
//  allows external bannering of status... perhaps this can handle failures
//  and disconnects also...
PSSQL_PROC( void, SQLSetFeedbackHandler )( HandleSQLFeedback handler );
/* Parses a CREATE TABLE statement and builds a PTABLE from it.
   Parameters
   cmd :         a CREATE TABLE sql command. It is a little
                 sqlite/mysql centric, and may fail on column
                 types for SQL Server.
   writestate :  if writestate is TRUE, a file called
                 'sparse.txt' will be generated with a C
                 structure of the Create Table statement passed. This
                 \file could then be used to copy into code, and
                 have a code\-static definition instead of going
                 from the create table statement.
   Returns
   a PTABLE which represents the create table statement.              */
PSSQL_PROC( PTABLE, GetFieldsInSQLEx )( CTEXTSTR cmd, int writestate DBG_PASS );
/* <combine sack::sql::GetFieldsInSQLEx@CTEXTSTR@int writestate>
   \ \                                                           */
#define GetFieldsInSQL(c,w) GetFieldsInSQLEx( c, w DBG_SRC )
//PSSQL_PROC( PTABLE, GetFieldsInSQL )( CTEXTSTR cmd, int writestate);
// this is used to destroy the table returned by GetFieldsInSQL
PSSQL_PROC( void, DestroySQLTable )( PTABLE table );
// allow setting and getting of a bit of user data associated with the PODBC...
// though this can result in memory losses at the moment, cause there is no notification
// that the PODBC has gone away, and that the user needs to remove his data...
PSSQL_PROC( uintptr_t, SQLGetUserData )( PODBC odbc );
/* A PODBC may have a user data assigned to it.
   Parameters
   odbc :  connection to set the data for; shouldn't be NULL.
   psv :   user data to assign to the database connection.
   See Also
   SQLGetUserData                                             */
PSSQL_PROC( void, SQLSetUserData )( PODBC odbc, uintptr_t );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  */
PSSQL_PROC( CTEXTSTR, GetGUID )( void );
/* Returns a text string GUID, This uses UuidCreateSequential  */
PSSQL_PROC( CTEXTSTR, GetSeqGUID )( void );
/* Returns a text string GUID, the guid is saved in psersistant text space and will
   not be released or overwritten.  This tring is the constant 0 guid */
PSSQL_PROC( CTEXTSTR, GuidZero )( void );
/* convert a string GUID to a binary representation of 16 bytes.
   litte_endian will byte-swap the grouped portions of numbers in a guid so they can be printed appropriately*/
PSSQL_PROC( uint8_t*, GetGUIDBinaryEx )( CTEXTSTR guid, LOGICAL litte_endian );
#define GetGUIDBinary(g) GetGUIDBinaryEx(g, TRUE )
struct guid_binary {
	union {
		struct {
			uint8_t bytes[16];
			uint8_t zero[2];
		} b;
		struct {
			uint32_t l1;
			uint16_t w1;
			uint16_t w2;
			uint16_t w3;
			uint64_t ll1;
		} d;
	} u;
};
// snprintf( buf, 256, guid_format, guid_param_pass(&guid_binary) )
// snprintf( buf, 256, guid_format, guid_param_pass(binary_buffer_result) )
#define guid_format WIDE("%08")_32fx WIDE("-%04")_16fx WIDE("-%04")_16fx WIDE("-%04")_16fx WIDE("-%012")_64fx
#define guid_param_pass(n) ((struct guid_binary*)(n))->u.d.l1,((struct guid_binary*)(n))->u.d.w1,((struct guid_binary*)(n))->u.d.w2,((struct guid_binary*)(n))->u.d.w3,((struct guid_binary*)(n))->u.d.ll1
/* some internal stub-proxy linkage for generating remote
   responders..
   This was work in progress for providing a msgsvr service to
   SQL. One of the implementations of this library was across a
   windows message queue using ATOM types to transport results
   and commands. Was going to implement this on the abstract
   msgqueue interface.                                          */
typedef struct responce_tag
{
	struct {
		BIT_FIELD bSingleLine : 1;
		BIT_FIELD bMultiLine : 1;
		BIT_FIELD bFields : 1;
	} flags;
	PVARTEXT result_single_line;
   int nLines;
	CTEXTSTR *pLines;
   CTEXTSTR *pFields;
} SQL_RESPONCE, *PSQL_RESPONCE;
/* *WORK IN PROGRESS* function call signature for callback method passed to
   RegisterResponceHandler.                              */
typedef void (CPROC *result_responder)( int responce
									  , PSQL_RESPONCE result );
/* *WORK IN PROGRESS*
   result_responder :  callback function to get called with sql
                       global status messages.
   See Also
   <link sack::sql::result_responder, Result Responder Type>    */
PSSQL_PROC( void, RegisterResponceHandler )( result_responder );
/* Thread protect means to use critical sections to protect this
   connection against multiple thread access. Recommended usage
   is to not use a PODBC with more than one thread in the first
   place.
   Parameters
   odbc :     connection to enable; if null, references the
              \internal static connection.
   bEnable :  TRUE to enable, FALSE to disable.                  */
PSSQL_PROC( void, SetSQLThreadProtect )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
   to trigger this process early.
   Parameters
   odbc :     connection to set auto transact on
   bEnable :  TRUE to enable, FALSE to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransact )( PODBC odbc, LOGICAL bEnable );
/* Enable using 'BEGIN TRANSACTION' and 'COMMIT' commands automatically
   around commands. If there is a lull of 500ms (1/2 second),
   then the commit automatically fires. SQLCommit can be called
	to trigger this process early.
	if Callback is set, automatically enables AutoTransact
   if Callback is NULL, automatically clears AutoTransact
   Parameters
   odbc :     connection to set auto transact on
   callback :  not NULL to enable, NULL to disable.                         */
PSSQL_PROC( void, SetSQLAutoTransactCallback )( PODBC odbc, void (CPROC*callback)(uintptr_t,PODBC), uintptr_t psv );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is closed (allowing the file to be
   not-in-use during idle). PODBC odject remains valid, and
   connection to database is re-enabled on next usage.
   Parameters
   odbc :     connection to enable auto close behavior on
   bEnable :  TRUE to enable auto close FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoClose )( PODBC odbc, LOGICAL bEnable );
/* Relevant for SQLite databases. After a certain period of
   inactivity the database is issued a PRAGMA wal_checkpoint
   Parameters
   odbc :     connection to enable auto checkpoint behavior on
   bEnable :  TRUE to enable auto checkpoint FALSE to disable.     */
PSSQL_PROC( void, SetSQLAutoCheckpoint )( PODBC odbc, LOGICAL bEnable );
/* returns the current value of auto checkpoint mode on a conneciton
   Parameters
   odbc :     connection to enable auto checkpoint behavior on */
PSSQL_PROC( LOGICAL, GetSQLAutoCheckpoint )( PODBC odbc );
/* A function to apply a time offset for fiscal time
   calculations; sometimes the day doesn't end at midnight, but
   a shift might last until 5 in the morning.
   Parameters
   odbc :            connection to get the appropriate SQL
                     expression for
   BeginOfDayType :  name of the type of beginning of the day
   default_begin :   the default time when a day begins.
   Note
   default_begin is a format sort of like a time. If this is a
   simple integer 5 then it's 5:00am, if it's more than 100,
   then it's assumed to be hours and minutes so 530 would be
   5:30 in the monring. this is also stored in the option
   databse, so the default value can be overridden; if the SQL
   value has a ':' in it then it is parsed as hours and minutes.
   Negative time may be used to indicate that the day begins
   before the day ends (-2 would be day end at 10pm).            */
PSSQL_PROC( CTEXTSTR, GetSQLOffsetDate )( PODBC odbc, CTEXTSTR BeginOfDayType, int default_begin );
/* Performs a low level backup of one database to another.  This API supports
   sqlite3 connections ONLY.
   Parameters
   source :            original database to copy from
   dest :    database to copy to
   */
PSSQL_PROC( LOGICAL, BackupDatabase )( PODBC source, PODBC dest );
/* return the underlaying native connection handle of the database connection
 */
// deprecated during dev, instead added function hook exports
//PSSQL_PROC( POINTER, GetODBCHandle )( PODBC odbc );
/* set a handler to be triggered when SQLite Database finds corruption type error...
 */
PSSQL_PROC( void, SetSQLCorruptionHandler )( PODBC odbc, void (CPROC*f)(uintptr_t psv, PODBC odbc), uintptr_t psv );
/* Utility function to parse DSN according to sack sqlite vfs rules... */
PSSQL_PROC( void, ParseDSN )( CTEXTSTR dsn, char **vfs, char **vfsInfo, char **dbFile );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#ifdef __cplusplus
SQL_NAMESPACE_END
#endif
struct sqlite3_value;
struct sqlite3_context;
#ifdef __cplusplus
SQL_NAMESPACE
#endif
PSSQL_PROC( int, PSSQL_AddSqliteFunction )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteProcedure )( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( int, PSSQL_AddSqliteAggregate )( PODBC odbc
	, const char *name
	, void( *callStep )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callFinal )( struct sqlite3_context*onwhat )
	, void( *callUserDestroy )( void * )
	, int args
	, void *userData );
PSSQL_PROC( POINTER, PSSQL_GetSqliteFunctionData )( struct sqlite3_context*context );
PSSQL_PROC( void, PSSQL_ResultSqliteText )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteBlob )( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) );
PSSQL_PROC( void, PSSQL_ResultSqliteDouble )( struct sqlite3_context*context, double val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt )( struct sqlite3_context*context, int val );
PSSQL_PROC( void, PSSQL_ResultSqliteInt64 )( struct sqlite3_context*context, int64_t val );
PSSQL_PROC( void, PSSQL_ResultSqliteNull )( struct sqlite3_context*context );
enum sqlite_data_types {
	PSSQL_TYPE_INTEGER= 1,
	PSSQL_TYPE_FLOAT= 2,
	PSSQL_TYPE_TEXT = 3,
	PSSQL_TYPE_BLOB  = 4,
	PSSQL_TYPE_NULL = 5,
};
PSSQL_PROC( enum sqlite_data_types, PSSQL_GetSqliteValueType )( struct sqlite3_value *val );
PSSQL_PROC( void, PSSQL_GetSqliteValueText )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueBlob )( struct sqlite3_value *val, const char **text, int *textLen );
PSSQL_PROC( void, PSSQL_GetSqliteValueDouble )( struct sqlite3_value *val, double *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt )( struct sqlite3_value *val, int *result );
PSSQL_PROC( void, PSSQL_GetSqliteValueInt64 )( struct sqlite3_value *val, int64_t *result );
PSSQL_PROC( const char *, PSSQL_GetColumnTableName )( PODBC odbc, int col );
PSSQL_PROC( const char *, PSSQL_GetColumnTableAliasName )( PODBC odbc, int col );
PSSQL_PROC( void, PSSQL_GetSqliteValue )( struct sqlite3_value *val, const char **text, int *textLen );
#endif
SQL_NAMESPACE_END
#ifdef __cplusplus
	using namespace sack::sql;
#endif
#endif
#if 0
#endif
// sqloptint.h leaves namespace open.
// these headers should really be collapsed.
#ifndef SQL_GET_OPTION_DEFINED
#define SQL_GET_OPTION_DEFINED
#ifdef __cplusplus
#define _OPTION_NAMESPACE namespace options {
#define _OPTION_NAMESPACE_END };
#define USE_OPTION_NAMESPACE	 using namespace sack::sql::options;
#else
#define _OPTION_NAMESPACE
#define _OPTION_NAMESPACE_END
#define USE_OPTION_NAMESPACE
#endif
SACK_NAMESPACE
   _SQL_NAMESPACE
	/* Contains methods for saving and recovering options from a
	   database. If enabled, will use a local option.db sqlite
	   database. Use EditOptions application to modify options. Can
	   use any database connection, but sql.config file will specify
	   'option.db' to start.                                         */
	_OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE SACK_NAMESPACE _SQL_NAMESPACE _OPTION_NAMESPACE
#define SACK_OPTION_NAMESPACE_END _OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
#ifdef SQLGETOPTION_SOURCE
#define SQLGETOPTION_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SQLGETOPTION_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifndef __NO_INTERFACES__
   _INTERFACE_NAMESPACE
/* Defines a set of functions that can be registered as an
   interface, and the interface can be used for saving options. Module
   ideas might be to save into the windows registry system or
   into INI files.                                                     */
typedef struct option_interface_tag
{
   // these provide simple section, key, value queries.
	METHOD_PTR( size_t, GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame );
	METHOD_PTR( int32_t, GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
	METHOD_PTR( size_t, GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer );
	METHOD_PTR( int32_t, GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
   // these provide an additional level of abstraction - the ini file
	METHOD_PTR( LOGICAL, WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
	METHOD_PTR( int32_t, WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
	METHOD_PTR( LOGICAL, WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
	METHOD_PTR( int32_t, WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
   // these offer(expose) the option to be quiet
	METHOD_PTR( size_t, GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
	METHOD_PTR( size_t, GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTSTR pBuffer, size_t nBuffer, LOGICAL bQuiet );
	METHOD_PTR( int32_t, GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
	METHOD_PTR( LOGICAL, WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush );
	METHOD_PTR( LOGICAL, WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL commit );
} *POPTION_INTERFACE;
#define GetOptionInterface() ((POPTION_INTERFACE)GetInterface( WIDE("options") ))
//POPTION_INTERFACE GetOptionInterface( void );
//void DropOptionInterface( POPTION_INTERFACE );
#ifndef DEFAULT_OPTION_INTERFACE
#define DEFAULT_OPTION_INTERFACE ((!pOptionInterface)?(pOptionInterface=GetOptionInterface()):pOptionInterface)
#ifdef USES_OPTION_INTERFACE
static POPTION_INTERFACE pOptionInterface;
#ifdef __WATCOMC__
static void UseInterface( void )
{
	// use the value of this function and set pOptionInterface with it
	// makes pOptionInterface marked as used so is UseInterface.
	// Visual Studio pucked on this because converting a function pointer to data pointer
   // but this function should never be called.
   pOptionInterface = (POPTION_INTERFACE)UseInterface;
}
#endif
#endif
#endif
   _INTERFACE_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::sql::options::Interface;
#endif
#endif
#define OptGetPrivateProfileString   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileString)
#define OptGetPrivateProfileInt      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileInt)
#define OptGetProfileString          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileString)
#define OptGetProfileInt             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileInt)
#define OptWritePrivateProfileString METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileString)
#define OptWritePrivateProfileInt    METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileInt)
#define OptWriteProfileString        METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileString)
#define OptWriteProfileInt           METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileInt)
#define OptGetPrivateProfileStringEx   METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileStringEx)
#define OptGetPrivateProfileIntEx      METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetPrivateProfileIntEx)
#define OptGetProfileStringEx          METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileStringEx)
#define OptGetProfileIntEx             METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),GetProfileIntEx)
#define OptWritePrivateProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WritePrivateProfileStringEx)
#define OptWriteProfileStringEx     METHOD_ALIAS((DEFAULT_OPTION_INTERFACE),WriteProfileStringEx)
SACK_OPTION_NAMESPACE_END
#endif
SACK_OPTION_NAMESPACE
typedef struct sack_option_tree_family_node *POPTION_TREE_NODE;
typedef struct sack_option_tree_family *POPTION_TREE;
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int, SACK_GetProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval );
/* All gets eventually end up here. This function gets a value
   from a database. Functions which return an 'int' use this
   function, but has extra processing to convert the text into a
   number; also if the text is 'Y', or 'y' then the option's int
   value is 1.
   Parameters
   pSection :     Path of the option to retrieve.
   pOptname :     Actual option name to retrieve.
   pDefaultbuf :  Default value if the option doesn't exist
                  already.
   pBuffer :      Pointer to the buffer to get the result
   nBuffer :      size of the result buffer in characters (not
                  bytes).
   pININame :     This is the upper level name. If a function
                  does not have a pININame, then the name
                  "DEFAULT' is used. (pass NULL here for
                  non\-private)
   bQuiet :       Boolean, if configured to prompt the user for
                  option values, this overrides the default to
                  disable prompting.                             */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR pININame, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateOptionStringEx )(PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush);
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( size_t, SACK_GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, LOGICAL bQuiet );
/* <combine sack::sql::options::SACK_GetPrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@TEXTCHAR *@size_t@CTEXTSTR@LOGICAL>
   \ \                                                                                                                        */
SQLGETOPTION_PROC( int32_t, SACK_GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile, LOGICAL bQuiet );
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL bFlush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIfile, LOGICAL flush );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, LOGICAL bQuiet );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( LOGICAL, SACK_WriteOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WriteProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer,  CTEXTSTR app);
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   returns boolean true/false whether the write worked or not.
   \ \                                                                                                            */
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value );
/* <combinewith sack::sql::options::SACK_WritePrivateProfileStringEx@CTEXTSTR@CTEXTSTR@CTEXTSTR@CTEXTSTR@LOGICAL>
   \ \                                                                                                            */
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExxx )( PODBC odbc
																				, CTEXTSTR pSection
																				, CTEXTSTR pOptname
																				, CTEXTSTR pDefaultbuf
																				, TEXTCHAR *pBuffer
																				, size_t nBuffer
																				, CTEXTSTR pININame
																				, LOGICAL bQuiet
																				 DBG_PASS
																				);
#ifdef __NO_OPTIONS__
#define SACK_GetProfileInt( s,e,d ) (d)
#define SACK_GetProfileString( s,e,d,b,n ) ((d)?StrCpyEx( b,d,n ):0)
#endif
#define SACK_GetPrivateOptionString( odbc, section, option, default_buf, buf, buf_size, ini_name )	   SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionStringEx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, ini_name, quiet DBG_SRC )
#define SACK_GetOptionString( odbc, section, option, default_buf, buf, buf_size )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, FALSE DBG_SRC )
#define SACK_GetOptionStringEx( odbc, section, option, default_buf, buf, buf_size, quiet )      SACK_GetPrivateProfileStringExxx( odbc, section, option, default_buf, buf, buf_size, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntExx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pININame, LOGICAL bQuiet DBG_PASS );
#define SACK_GetPrivateOptionInt( odbc, section, option, default_val, ini_name )	   SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, FALSE DBG_SRC )
#define SACK_GetPrivateOptionIntEx( odbc, section, option, default_val, ini_name, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, ini_name, quiet DBG_SRC )
#define SACK_GetOptionInt( odbc, section, option, default_val )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, FALSE DBG_SRC )
#define SACK_GetOptionIntEx( odbc, section, option, default_val, quiet )      SACK_GetPrivateProfileIntExx( odbc, section, option, default_val, NULL, quiet DBG_SRC )
SQLGETOPTION_PROC( CTEXTSTR, GetSystemID )( void );
SQLGETOPTION_PROC( void, EnumOptions )( POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( void, EnumOptionsEx )( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
                , uintptr_t psvUser );
SQLGETOPTION_PROC( POPTION_TREE, GetOptionTreeExxx )( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS );
/* Sets the option database to use (does not prevent
   preload/deadstart code from using the old database) but this
   can be used for comparison utilities.
   Parameters
   odbc :  The PODBC connection to use.
   See Also
   PODBC                                                        */
SQLGETOPTION_PROC( POPTION_TREE, SetOptionDatabase )( PODBC odbc );
SQLGETOPTION_PROC( CTEXTSTR, GetDefaultOptionDatabaseDSN )( void );
SQLGETOPTION_PROC( void, SetOptionDatabaseOption )( PODBC odbc );
SQLGETOPTION_PROC( void, BeginBatchUpdate )( void );
SQLGETOPTION_PROC( void, EndBatchUpdate )( void );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexEx )( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexExx )( PODBC odbc, POPTION_TREE_NODE parent, CTEXTSTR program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
#define GetOptionIndex(p,f,b,v) GetOptionIndexEx( p,f,b,v,FALSE,FALSE DBG_SRC )
SQLGETOPTION_PROC( size_t, GetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS );
SQLGETOPTION_PROC( void,SetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE node, CTEXTSTR value );
SQLGETOPTION_PROC( size_t, GetOptionStringValue )( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len );
SQLGETOPTION_PROC( LOGICAL, SetOptionStringValue )( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue );
SQLGETOPTION_PROC( void, DeleteOption )( POPTION_TREE_NODE iRoot );
SQLGETOPTION_PROC( void, DuplicateOption )( POPTION_TREE_NODE iRoot, CTEXTSTR pNewName );
 // flush the map cache.
SQLGETOPTION_PROC( void, ResetOptionMap )( PODBC odbc );
SQLGETOPTION_PROC( PODBC, GetOptionODBCEx )( CTEXTSTR dsn DBG_PASS );
SQLGETOPTION_PROC( void, DropOptionODBCEx )( PODBC odbc DBG_PASS );
SQLGETOPTION_PROC( PODBC, GetOptionODBC )( CTEXTSTR dsn );
SQLGETOPTION_PROC( void, DropOptionODBC )( PODBC odbc );
#define GetOptionODBC( b) GetOptionODBCEx( b DBG_SRC )
#define DropOptionODBC(a) DropOptionODBCEx( a DBG_SRC )
SQLGETOPTION_PROC( void, FindOptions )( PODBC odbc, PLIST *result_list, CTEXTSTR name );
_OPTION_NAMESPACE_END _SQL_NAMESPACE_END SACK_NAMESPACE_END
	USE_OPTION_NAMESPACE
#endif
#else
#  include <sack.h>
 // tolower on linux
//#include <filesys.h>
//#include <procreg.h>
//#include <salty_generator.h>
//#include <sack_vfs.h>
//#include <sqlgetoption.h>
#endif
SACK_VFS_NAMESPACE
//#define PARANOID_INIT
//#define DEBUG_TRACE_LOG
#ifdef DEBUG_TRACE_LOG
#define LoG( a,... ) lprintf( a,##__VA_ARGS__ )
#else
#define LoG( a,... )
#endif
/**************
  VFS_VERSION
     used to track migration of keys and keying methods.
  0x100 = version 1; SHORTKEY_LENGTH = 16
 **************/
#define VFS_VERSION     0x100
// 12 bits = 1 << 12 = 4096
#define BLOCK_SIZE_BITS 12
// BLOCKINDEX is either 4 or 8 bytes... sizeof( size_t )...
// all constants though should compile out to a single value... and just for grins went to 16 bit size_t and 0 shift... or 1 byte
#define BLOCK_SHIFT (BLOCK_SIZE_BITS-(sizeof(BLOCKINDEX)==16?4:sizeof(BLOCKINDEX)==8?3:sizeof(BLOCKINDEX)==4?2:sizeof(BLOCKINDEX)==2?1:0) )
#define BLOCK_SIZE (1<<BLOCK_SIZE_BITS)
#define BLOCK_MASK (BLOCK_SIZE-1)
#define BLOCKS_PER_BAT (BLOCK_SIZE/sizeof(BLOCKINDEX))
#define BLOCKS_PER_SECTOR (1 + (BLOCK_SIZE/sizeof(BLOCKINDEX)))
// per-sector perumation; needs to be a power of 2 (in bytes)
#define SHORTKEY_LENGTH 16
#ifndef VFS_DISK_DATATYPE
#  define VFS_DISK_DATATYPE size_t
#endif
 // BLOCK_SIZE blocks...
typedef VFS_DISK_DATATYPE BLOCKINDEX;
 // file position type
typedef VFS_DISK_DATATYPE FPI;
enum block_cache_entries
{
	BLOCK_CACHE_DIRECTORY
#ifdef VIRTUAL_OBJECT_STORE
	, BLOCK_CACHE_HASH_DIRECTORY
	, BLOCK_CACHE_HASH_DIRECTORY_LAST = BLOCK_CACHE_HASH_DIRECTORY + 16
#endif
	, BLOCK_CACHE_NAMES
	, BLOCK_CACHE_BAT
	, BLOCK_CACHE_DATAKEY
	, BLOCK_CACHE_FILE
	, BLOCK_CACHE_FILE_LAST = BLOCK_CACHE_FILE + 10
	, BLOCK_CACHE_COUNT
};
PREFIX_PACKED struct directory_entry
{
  // name offset from beginning of disk
	FPI name_offset;
  // first block of data of the file
	BLOCKINDEX first_block;
  // how big the file is
	VFS_DISK_DATATYPE filesize;
	//uint32_t filler;  // extra data(unused)
} PACKED;
#define VFS_DIRECTORY_ENTRIES ( BLOCK_SIZE/sizeof( struct directory_entry) )
struct disk
{
	// BAT is at 0 of every BLOCK_SIZE blocks (4097 total)
	// &BAT[0] == itself....
	// BAT[0] == first directory entry (actually next entry; first is always here)
	// BAT[1] == first name entry (actually next name block; first is known as here)
	// bat[BLOCK_SIZE] == NEXT_BAT[0]; NEXT_BAT = BAT + BLOCK_SIZE + 1024*BLOCK_SIZE;
	// bat[8192] == ... ( 0 + ( BLOCK_SIZE + BLOCKS_PER_BAT*BLOCK_SIZE ) * N >> 12 )
	BLOCKINDEX BAT[BLOCKS_PER_BAT];
	//struct directory_entry directory[BLOCK_SIZE/sizeof( struct directory_entry)]; // 256
	//char  names[BLOCK_SIZE/sizeof(char)];
	uint8_t  block_data[BLOCKS_PER_BAT][BLOCK_SIZE];
};
#ifdef SACK_VFS_FS_SOURCE
PREFIX_PACKED struct fs_volume {
	const char * volname;
	FILE *file;
	uintptr_t dwSize;
  // used for directory signatures
	const char * datakey;
	const char * userkey;
	const char * devkey;
	enum block_cache_entries curseg;
// cached segment with usekey[n]
	BLOCKINDEX _segment[BLOCK_CACHE_COUNT];
// associated with usekey[n]
	BLOCKINDEX segment[BLOCK_CACHE_COUNT];
	FLAGSET( dirty, BLOCK_CACHE_COUNT );
	uint8_t fileCacheAge[BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE];
	uint8_t fileNextAge;
	struct random_context *entropy;
  // allow byte encrypting...
	uint8_t* key;
  // allow byte encrypting... key based on sector volume file index
	uint8_t* segkey;
  // signature of executable attached as header
	uint8_t* sigkey;
 // composite key
	uint8_t* usekey[BLOCK_CACHE_COUNT];
  // (unused) adds salt for the signature?
	uint8_t* sigsalt;
	size_t sigkeyLength;
 // when reopened file structures need to be updated also...
	PLIST files;
	LOGICAL read_only;
	LOGICAL external_memory;
	LOGICAL closed;
	uint32_t lock;
	uint8_t tmpSalt[16];
	uintptr_t clusterKeyVersion;
} PACKED;
struct sack_vfs_fs_file
{
  // where to write the directory entry update to
	FPI entry_fpi;
  // has file size within
	struct directory_entry entry;
	struct directory_entry dirent_key;
 // which volume this is in
	struct fs_volume *vol;
	FPI fpi;
	BLOCKINDEX first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
};
#define TSEEK(type,v,o,c) ((type)vfs_fs_SEEK(v,o,&c))
#define BTSEEK(type,v,o,c) ((type)vfs_fs_BSEEK(v,o,&c))
#else
PREFIX_PACKED struct volume {
	const char * volname;
#ifdef FILE_BASED_VFS
	FILE *file;
#else
	struct disk *disk;
 // disk might be offset from diskReal because it's a .exe attached.
	struct disk *diskReal;
#endif
	//uint32_t dirents;  // constant 0
	//uint32_t nameents; // constant 1
	uintptr_t dwSize;
  // used for directory signatures
	const char * datakey;
	const char * userkey;
	const char * devkey;
	enum block_cache_entries curseg;
// cached segment with usekey[n]
	BLOCKINDEX _segment[BLOCK_CACHE_COUNT];
// associated with usekey[n]
	BLOCKINDEX segment[BLOCK_CACHE_COUNT];
	uint8_t fileCacheAge[BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE];
	uint8_t fileNextAge;
	struct random_context *entropy;
  // root of all cached key buffers
	uint8_t* key;
  // allow byte encrypting... key based on sector volume file index
	uint8_t* segkey;
  // signature of executable attached as header
	uint8_t* sigkey;
  // signature of executable attached as header
	uint8_t* sigsalt;
	size_t sigkeyLength;
 // composite key
	uint8_t* usekey[BLOCK_CACHE_COUNT];
  // root buffer space of all cache blocks
	uint8_t* key_buffer;
 // data cache blocks
	uint8_t* usekey_buffer[BLOCK_CACHE_COUNT];
#ifdef FILE_BASED_VFS
	FPI bufferFPI[BLOCK_CACHE_COUNT];
#endif
 // when reopened file structures need to be updated also...
	PLIST files;
	LOGICAL read_only;
	LOGICAL external_memory;
	LOGICAL closed;
	uint32_t lock;
	uint8_t tmpSalt[16];
	uintptr_t clusterKeyVersion;
} PACKED;
struct sack_vfs_file
{
#ifdef FILE_BASED_VFS
  // where to write the directory entry update to
	FPI entry_fpi;
  // has file size within
	struct directory_entry _entry;
  // has file size within
	struct directory_entry *entry;
#else
  // has file size within
	struct directory_entry *entry;
#endif
	struct directory_entry dirent_key;
 // which volume this is in
	struct volume *vol;
	FPI fpi;
	BLOCKINDEX _first_block;
 // this should be in-sync with current FPI always; plz
	BLOCKINDEX block;
  // someone already deleted this...
	LOGICAL delete_on_close;
};
#define TSEEK(type,v,o,c) ((type)vfs_SEEK(v,o,&c))
#define BTSEEK(type,v,o,c) ((type)vfs_BSEEK(v,o,&c))
#endif
#ifdef __GNUC__
#define HIDDEN __attribute__ ((visibility ("hidden")))
#else
#define HIDDEN
#endif
uintptr_t vfs_SEEK( struct volume *vol, FPI offset, enum block_cache_entries *cache_index ) HIDDEN;
uintptr_t vfs_BSEEK( struct volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) HIDDEN;
//BLOCKINDEX vfs_GetNextBlock( struct volume *vol, BLOCKINDEX block, int init, LOGICAL expand );
uintptr_t vfs_fs_SEEK( struct fs_volume *vol, FPI offset, enum block_cache_entries *cache_index ) HIDDEN;
uintptr_t vfs_fs_BSEEK( struct fs_volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) HIDDEN;
static struct {
	struct directory_entry zero_entkey;
	uint8_t zerokey[BLOCK_SIZE];
} l;
#define EOFBLOCK  (~(BLOCKINDEX)0)
#define EOBBLOCK  ((BLOCKINDEX)1)
#define EODMARK   (1)
#define GFB_INIT_NONE   0
#define GFB_INIT_DIRENT 1
#define GFB_INIT_NAMES  2
static BLOCKINDEX GetFreeBlock( struct volume *vol, int init );
static struct directory_entry * ScanDirectory( struct volume *vol, const char * filename, struct directory_entry *dirkey, int path_match );
static char mytolower( int c ) {	if( c == '\\' ) return '/'; return tolower( c ); }
static int  PathCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && ( (s1[0]=='/'&&s2[0]=='\\')||(s1[0]=='\\'&&s2[0]=='/')||
									 (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0])) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
// read the byte from namespace at offset; decrypt byte in-register
// compare against the filename bytes.
static int MaskStrCmp( struct volume *vol, const char * filename, FPI name_offset, int path_match ) {
	if( vol->key ) {
		int c;
		while(  ( c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BLOCK_CACHE_NAMES][name_offset&BLOCK_MASK] ) )
			  && filename[0] ) {
			int del = mytolower(filename[0]) - mytolower(c);
			if( ( filename[0] == '/' && c == '\\' )
			    || ( filename[0] == '\\' && c == '/' ) )
				del = 0;
			if( del ) return del;
			filename++;
			name_offset++;
			if( path_match && !filename[0] ) {
				c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BLOCK_CACHE_NAMES][name_offset&BLOCK_MASK] );
				if( c == '/' || c == '\\' ) return 0;
			}
		}
		// c will be 0 or filename will be 0...
		if( path_match ) return 1;
		return filename[0] - c;
	} else {
		//LoG( "doesn't volume always have a key?" );
		if( path_match ) {
			size_t l;
			int r = PathCaseCmpEx( filename, (const char *)(((uint8_t*)vol->disk) + name_offset), l = strlen( filename ) );
			if( !r )
				if( ((const char *)(((uint8_t*)vol->disk) + name_offset))[l] == '/' || ((const char *)(((uint8_t*)vol->disk) + name_offset))[l] == '\\' )
					return 0;
				else
					return 1;
			return r;
		}
		else
			return PathCaseCmpEx( filename, (const char *)(((uint8_t*)vol->disk) + name_offset), strlen(filename) );
	}
}
#ifdef DEBUG_TRACE_LOG
static void MaskStrCpy( char *output, size_t outlen, struct volume *vol, FPI name_offset ) {
	if( vol->key ) {
		int c;
		FPI name_start = name_offset;
		while(  ( c = ( ((uint8_t*)vol->disk)[name_offset] ^ vol->usekey[BLOCK_CACHE_NAMES][name_offset&BLOCK_MASK] ) ) ) {
			if( ( name_offset - name_start ) < outlen )
				output[name_offset-name_start] = c;
			name_offset++;
		}
		if( ( name_offset - name_start ) < outlen )
			output[name_offset-name_start] = 0;
		else
			output[outlen-1] = 0;
	} else {
		//LoG( "doesn't volume always have a key?" );
		StrCpyEx( output, (const char *)(((uint8_t*)vol->disk) + name_offset), outlen );
	}
}
#endif
static enum block_cache_entries UpdateSegmentKey( struct volume *vol, enum block_cache_entries cache_idx, BLOCKINDEX segment )
{
	if( !vol->key ) {
		vol->segment[cache_idx] = segment;
		return cache_idx;
	}
	if( cache_idx == BLOCK_CACHE_FILE ) {
		int n, m;
		int nLeast;
		uint8_t next = 0;
		for( n = 0; n < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); n++ ) {
			if( vol->segment[cache_idx + n] == segment ) {
				cache_idx = (enum block_cache_entries)((cache_idx)+n);
				for( m = 0; m < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); m++ ) {
					if( !vol->fileCacheAge[m] ) break;
					if( vol->fileCacheAge[m] > vol->fileCacheAge[n] )
						vol->fileCacheAge[m]--;
				}
				vol->fileCacheAge[n] = m;
				break;
			}
			if( !vol->fileCacheAge[n] ) {
				cache_idx = (enum block_cache_entries)((cache_idx)+n);
				for( m = 0; m < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); m++ ) {
					if( !vol->fileCacheAge[m] ) break;
					if( vol->fileCacheAge[m] >( n + 1 ) )
						vol->fileCacheAge[m]--;
				}
				vol->fileCacheAge[n] = n + 1;
				break;
			}
			if( vol->fileCacheAge[n] == 1 ) nLeast = n;
		}
		if( n == (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE) ) {
			for( n = 0; n < (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE); n++ ) {
				vol->fileCacheAge[n]--;
			}
			vol->fileCacheAge[nLeast] = (BLOCK_CACHE_FILE_LAST - BLOCK_CACHE_FILE);
			cache_idx = (enum block_cache_entries)(BLOCK_CACHE_FILE + nLeast);
		}
	}
	vol->segment[cache_idx] = segment;
	if( vol->segment[cache_idx] == vol->_segment[cache_idx] )
		return cache_idx;
	SRG_ResetEntropy( vol->entropy );
	vol->_segment[cache_idx] = vol->segment[cache_idx];
  // so we know which 'segment[idx]' to use.
	vol->curseg = cache_idx;
	SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->segkey, SHORTKEY_LENGTH * 8 );
	{
		int n;
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[cache_idx];
		uint64_t* volkey = (uint64_t*)vol->key;
		uint64_t* segkey = (uint64_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey += 2;
			volkey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[cache_idx];
		uint32_t* volkey = (uint32_t*)vol->key;
		uint32_t* segkey = (uint32_t*)vol->segkey;
		for( n = 0; n < (BLOCK_SIZE / SHORTKEY_LENGTH); n++ ) {
			usekey[0] = volkey[0] ^ (segkey[0]);
			usekey[1] = volkey[1] ^ (segkey[1]);
			usekey[2] = volkey[2] ^ (segkey[2]);
			usekey[3] = volkey[3] ^ (segkey[3]);
			usekey += 4;
			volkey += 4;
		}
#endif
	}
	return cache_idx;
}
static LOGICAL ValidateBAT( struct volume *vol ) {
	BLOCKINDEX first_slab = 0;
	BLOCKINDEX slab = vol->dwSize / ( BLOCK_SIZE );
	BLOCKINDEX last_block = ( slab * BLOCKS_PER_BAT ) / BLOCKS_PER_SECTOR;
	BLOCKINDEX n;
	if( vol->key ) {
		for( n = first_slab; n < slab; n += BLOCKS_PER_SECTOR  ) {
			size_t m;
			BLOCKINDEX *BAT;
			BLOCKINDEX *blockKey;
			BAT = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE);
			blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
			UpdateSegmentKey( vol, BLOCK_CACHE_BAT, n + 1 );
			for( m = 0; m < BLOCKS_PER_BAT; m++ )
			{
				BLOCKINDEX block = BAT[0] ^ blockKey[0];
				BAT++; blockKey++;
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) break;
				if( block >= last_block ) return FALSE;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	} else {
		for( n = first_slab; n < slab; n += BLOCKS_PER_SECTOR  ) {
			size_t m;
			BLOCKINDEX *BAT = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				BLOCKINDEX block = BAT[m];
				if( block == EOFBLOCK ) continue;
				if( block == EOBBLOCK ) break;
				if( block >= last_block ) return FALSE;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	if( !ScanDirectory( vol, NULL, NULL, 0 ) ) return FALSE;
	return TRUE;
}
//-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
static POINTER GetExtraData( POINTER block )
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	POINTER source_memory = block;
	{
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)source_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
 // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize += (BLOCK_SIZE*2)-1;
 // mask off the low bits; floor result to block boundary
			dwSize &= ~(BLOCK_SIZE-1);
			return (POINTER)Seek( source_memory, dwSize );
		}
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
static void AddSalt2( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct datatype { void* start; size_t length; } *data = (struct datatype*)psv;
	(*salt_size) = data->length;
	(*salt) = (POINTER)data->start;
	// only need to make one pass of it....
	data->length = 0;
	data->start = NULL;
}
const uint8_t *sack_vfs_get_signature2( POINTER disk, POINTER diskReal ) {
	if( disk != diskReal ) {
		static uint8_t usekey[BLOCK_SIZE];
		static struct random_context *entropy;
		static struct datatype { void* start; size_t length; } data;
		data.start = diskReal;
		data.length = ((uintptr_t)disk - (uintptr_t)diskReal) - BLOCK_SIZE;
		if( !entropy ) entropy = SRG_CreateEntropy2( AddSalt2, (uintptr_t)&data );
		SRG_ResetEntropy( entropy );
		SRG_GetEntropyBuffer( entropy, (uint32_t*)usekey, BLOCK_SIZE*CHAR_BIT );
		return usekey;
	}
	return NULL;
}
// add some space to the volume....
static LOGICAL ExpandVolume( struct volume *vol ) {
	LOGICAL created;
	LOGICAL path_checked = FALSE;
	struct disk* new_disk;
	size_t oldsize = vol->dwSize;
	if( vol->read_only ) return TRUE;
	if( !vol->dwSize ) {
		{
			char *tmp = StrDup( vol->volname );
			char *dir = (char*)pathrchr( tmp );
			if( dir ) {
				dir[0] = 0;
				if( !IsPath( tmp ) ) MakePath( tmp );
			}
			Deallocate( char*, tmp );
		}
		new_disk = (struct disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
		if( new_disk && vol->dwSize ) {
			CloseSpace( vol->diskReal );
			vol->diskReal = new_disk;
#ifdef WIN32
			// elf has a different signature to check for .so extended data...
			struct disk *actual_disk;
			if( ((char*)new_disk)[0] == 'M' && ((char*)new_disk)[1] == 'Z' ) {
				actual_disk = (struct disk*)GetExtraData( new_disk );
				if( actual_disk ) {
					if( ( ( (uintptr_t)actual_disk - (uintptr_t)new_disk ) < vol->dwSize ) ) {
						const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), new_disk );
						if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
							lprintf( "Signature failed comparison; the core has changed since it was attached" );
							CloseSpace( vol->diskReal );
							vol->diskReal = NULL;
							vol->dwSize = 0;
							return FALSE;
						}
						vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)new_disk);
						new_disk = actual_disk;
					} else {
						lprintf( "Signature failed comparison; the core is not attached to anything." );
						CloseSpace( vol->diskReal );
						vol->diskReal = NULL;
						vol->dwSize = 0;
						return FALSE;
					}
				}
			}
#endif
			vol->disk = new_disk;
			if( created && vol->disk == vol->diskReal ) {
				enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
				struct directory_entry *next_entries = BTSEEK( struct directory_entry *, vol, 0, cache );
				struct directory_entry *entkey = (vol->key) ? ((struct directory_entry *)vol->usekey[BLOCK_CACHE_DIRECTORY]) : &l.zero_entkey;
				// initialize directory list.
				((struct directory_entry*)(((uintptr_t)vol->disk) + BLOCK_SIZE))->first_block = EODMARK ^ entkey->first_block;
				// initialize first BAT block.
				cache = BLOCK_CACHE_BAT;
				TSEEK( BLOCKINDEX*, vol, 0, cache );
				((BLOCKINDEX*)(((uintptr_t)vol->disk) + 0))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[0];
			}
			return TRUE;
		}
		else {
			// really this is bad anyway.
			if( new_disk )
 // zero size result?, but with memory
				created = 1;
		}
	}
	if( oldsize ) CloseSpace( vol->diskReal );
	vol->dwSize += ((uintptr_t)vol->disk - (uintptr_t)vol->diskReal);
	// a BAT plus the sectors it references... ( BLOCKS_PER_BAT + 1 ) * BLOCK_SIZE
	vol->dwSize += BLOCKS_PER_SECTOR*BLOCK_SIZE;
	new_disk = (struct disk*)OpenSpaceExx( NULL, vol->volname, 0, &vol->dwSize, &created );
	LoG( "created expanded volume: %p from %p size:%" _size_f, new_disk, vol->disk, vol->dwSize );
	if( new_disk && new_disk != vol->disk ) {
		INDEX idx;
		struct sack_vfs_file *file;
		CloseSpace( vol->diskReal );
		vol->diskReal = new_disk;
#ifdef WIN32
		// elf has a different signature to check for .so extended data...
		{
			struct disk *actual_disk;
			if( ((char*)new_disk)[0] == 'M' && ((char*)new_disk)[1] == 'Z' ) {
				actual_disk = (struct disk*)GetExtraData( new_disk );
				if( actual_disk ) {
					const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), new_disk );
					if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
						lprintf( "Signature failed comparison; the core has changed since it was attached" );
						CloseSpace( vol->diskReal );
						vol->diskReal = NULL;
						vol->dwSize = 0;
						return FALSE;
					}
					vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)new_disk);
					new_disk = actual_disk;
				}
			}
		}
#endif
		LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file ) {
			file->entry = (struct directory_entry*)((uintptr_t)file->entry - (uintptr_t)vol->disk + (uintptr_t)new_disk);
		}
		vol->disk = new_disk;
	}
	if( vol->key ) {
		BLOCKINDEX first_slab = oldsize / ( BLOCK_SIZE );
		BLOCKINDEX slab = vol->dwSize / ( BLOCK_SIZE );
		BLOCKINDEX n;
		for( n = first_slab; n < slab; n++  ) {
			//vol->segment[BLOCK_CACHE_BAT] = n + 1;
			if( ( n % (BLOCKS_PER_SECTOR) ) == 0 )	 UpdateSegmentKey( vol, BLOCK_CACHE_BAT, n + 1 );
#ifdef PARANOID_INIT
			else SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->usekey[BLOCK_CACHE_BAT], BLOCK_SIZE * 8 );
#else
			else continue;
#endif
			//memcpy( ((uint8_t*)vol->disk) + n * BLOCK_SIZE, vol->usekey[BLOCK_CACHE_BAT], BLOCK_SIZE );
			((BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[0];
			memset( ((BLOCKINDEX*)(((uint8_t*)vol->disk) + n * BLOCK_SIZE))+1, 0, BLOCK_SIZE - sizeof( BLOCKINDEX ) );
		}
	}
	else if( !oldsize )  {
		memset( vol->disk, 0, vol->dwSize );
	} else if( oldsize )  {
		memset( ((uint8_t*)vol->disk) + oldsize, 0, vol->dwSize - oldsize );
	}
	if( !oldsize ) {
		// can't recover dirents and nameents dynamically; so just assume
		// use the GetFreeBlock because it will update encypted
		//vol->disk->BAT[0] = EOFBLOCK;  // allocate 1 directory entry block
		//vol->disk->BAT[1] = EOFBLOCK;  // allocate 1 name block
		if( created && vol->disk == vol->diskReal ) {
			UpdateSegmentKey( vol, BLOCK_CACHE_BAT, 1 );
			((BLOCKINDEX*)(((uintptr_t)vol->disk) + 0))[0] = EOBBLOCK ^ ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[0];
		}
		/* vol->dirents = */
GetFreeBlock( vol, GFB_INIT_DIRENT );
		/* vol->nameents = */
GetFreeBlock( vol, GFB_INIT_NAMES );
	}
	return TRUE;
}
// shared with fuse module
uintptr_t vfs_SEEK( struct volume *vol, FPI offset, enum block_cache_entries *cache_index ) {
	while( offset >= vol->dwSize ) if( !ExpandVolume( vol ) ) return 0;
	if( vol->key ) {
		BLOCKINDEX seg = ( offset / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			//vol->segment[cache_index] = seg;
			cache_index[0] = UpdateSegmentKey( vol, cache_index[0], seg );
		}
	}
	return ((uintptr_t)vol->disk) + (uintptr_t)offset;
}
// shared with fuse module
uintptr_t vfs_BSEEK( struct volume *vol, BLOCKINDEX block, enum block_cache_entries *cache_index ) {
	BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_SHIFT) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + ( block & (BLOCKS_PER_BAT-1) ) * BLOCK_SIZE;
	while( b >= vol->dwSize ) if( !ExpandVolume( vol ) ) return 0;
	if( vol->key ) {
		BLOCKINDEX seg = ( b / BLOCK_SIZE ) + 1;
		if( seg != vol->segment[cache_index[0]] ) {
			//vol->segment[cache_index] = seg;
			if( (cache_index[0] == BLOCK_CACHE_FILE)
				&& (seg < 3) ) {
				lprintf( "CRITICAL FAILURE, SEEK OUT OF DISK %d", seg );
				(*(int*)0) = 0;
			}
			cache_index[0] = UpdateSegmentKey( vol, cache_index[0], seg );
		}
	}
	return ((uintptr_t)vol->disk) + (uintptr_t)b;
}
static BLOCKINDEX GetFreeBlock( struct volume *vol, int init )
{
	size_t n;
	int b = 0;
	enum block_cache_entries cache = BLOCK_CACHE_BAT;
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
	if( !current_BAT ) return 0;
	do
	{
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
		for( n = 0; n < BLOCKS_PER_BAT; n++ )
		{
			check_val = current_BAT[0] ^ blockKey[0];
			if( !check_val || (check_val == EOBBLOCK) )
			{
				// mark it as claimed; will be enf of file marker...
				// adn thsi result will overwrite previous EOF.
				current_BAT[0] = EOFBLOCK ^ blockKey[0];
				if( init )
				{
					enum block_cache_entries cache;
					cache = UpdateSegmentKey( vol, BLOCK_CACHE_FILE, b * (BLOCKS_PER_SECTOR)+n + 1 + 1 );
					while( ((vol->segment[cache]-1)*BLOCK_SIZE) > vol->dwSize ){
						LoG( "looping to get a size %d", ((vol->segment[cache]-1)*BLOCK_SIZE) );
						if( !ExpandVolume( vol ) ) return 0;
					}
					if( init == GFB_INIT_DIRENT )
						((struct directory_entry*)(((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE))[0].first_block = EODMARK^((struct directory_entry*)vol->usekey[cache])->first_block;
					else if( init == GFB_INIT_NAMES )
						((char*)(((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE))[0] = ((char*)vol->usekey[cache])[0];
					//else
					//	memcpy( ((uint8_t*)vol->disk) + (vol->segment[cache]-1) * BLOCK_SIZE, vol->usekey[cache], BLOCK_SIZE );
				}
				if( (check_val == EOBBLOCK) )
					if(n < (BLOCKS_PER_BAT-1))
						current_BAT[1] = EOBBLOCK ^ blockKey[1];
					else {
						current_BAT = TSEEK( BLOCKINDEX*, vol, (b + 1) * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
						blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
						current_BAT[0] = EOBBLOCK ^ blockKey[0];
					}
				return b * BLOCKS_PER_BAT + n;
			}
			current_BAT++;
			blockKey++;
		}
		b++;
		current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
	}while( 1 );
}
static BLOCKINDEX vfs_GetNextBlock( struct volume *vol, BLOCKINDEX block, int init, LOGICAL expand ) {
	BLOCKINDEX sector = block >> BLOCK_SHIFT;
	enum block_cache_entries cache = BLOCK_CACHE_BAT;
	BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX *, vol, sector * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
	BLOCKINDEX seg;
	BLOCKINDEX check_val = (this_BAT[block & (BLOCKS_PER_BAT-1)]);
 // if this passes, later ones will also.
	if( !this_BAT ) return 0;
	seg = ( ((uintptr_t)this_BAT - (uintptr_t)vol->disk) / BLOCK_SIZE ) + 1;
	if( seg != vol->segment[BLOCK_CACHE_BAT] ) {
		//vol->segment[BLOCK_CACHE_BAT] = seg;
		UpdateSegmentKey( vol, BLOCK_CACHE_BAT, seg );
	}
	check_val ^= ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[block & (BLOCKS_PER_BAT-1)];
	if( check_val == EOBBLOCK ) {
		lprintf( "the file itself should never get a EOBBLOCK in it." );
		(*(int*)0) = 0;
		// the file itself should never get a EOBBLOCK in it.
		//(this_BAT[block & (BLOCKS_PER_BAT-1)]) = EOFBLOCK^((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[block & (BLOCKS_PER_BAT-1)];
		//(this_BAT[1+block & (BLOCKS_PER_BAT-1)]) = EOBBLOCK^((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[1+block & (BLOCKS_PER_BAT-1)];
	}
	if( check_val == EOFBLOCK ) {
		if( expand ) {
			BLOCKINDEX key;
			check_val = GetFreeBlock( vol, init );
			// free block might have expanded...
			this_BAT = TSEEK( BLOCKINDEX*, vol, sector * ( BLOCKS_PER_SECTOR*BLOCK_SIZE ), cache );
			key = vol->key ? ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[block & (BLOCKS_PER_BAT - 1)] : 0;
			if( !this_BAT ) return 0;
			// segment could already be set from the GetFreeBlock...
			this_BAT[block & (BLOCKS_PER_BAT-1)] = check_val ^ key;
		}
	}
	return check_val;
}
static void AddSalt( uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	struct volume *vol = (struct volume *)psv;
	if( vol->sigsalt ) {
		(*salt_size) = vol->sigkeyLength;
		(*salt) = (POINTER)vol->sigsalt;
		vol->sigsalt = NULL;
	}
	else if( vol->datakey ) {
		(*salt_size) = BLOCK_SIZE;
		(*salt) = (POINTER)vol->datakey;
		vol->datakey = NULL;
	}
	else if( vol->userkey ) {
		(*salt_size) = StrLen( vol->userkey );
		(*salt) = (POINTER)vol->userkey;
		vol->userkey = NULL;
	}
	else if( vol->devkey ) {
		(*salt_size) = StrLen( vol->devkey );
		(*salt) = (POINTER)vol->devkey;
		vol->devkey = NULL;
	}
	else if( vol->segment[vol->curseg] ) {
		BLOCKINDEX sector = vol->segment[vol->curseg];
		switch( vol->clusterKeyVersion ) {
		case 0:
			( *salt_size ) = sizeof( vol->segment[vol->curseg] );
			( *salt ) = &vol->segment[vol->curseg];
			break;
		case 1:
			memcpy( vol->tmpSalt, vol->key, 16 );
			vol->tmpSalt[sector & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[0];
			vol->tmpSalt[( sector >> 4 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[1];
			vol->tmpSalt[( sector >> 8 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[2];
			vol->tmpSalt[( sector >> 12 ) & 0xF] ^= ( (uint8_t*)( &vol->segment[vol->curseg] ) )[3];
			( (BLOCKINDEX*)vol->tmpSalt )[0] ^= sector;
			( (BLOCKINDEX*)vol->tmpSalt )[1] ^= sector;
// sizeof( vol->segment[vol->curseg] );
			( *salt_size ) = 12;
			( *salt ) = vol->tmpSalt;
			break;
		}
	}
	else
		(*salt_size) = 0;
}
static void AssignKey( struct volume *vol, const char *key1, const char *key2 )
{
	vol->userkey = key1;
	vol->devkey = key2;
	if( key1 || key2 )
	{
		uintptr_t size = BLOCK_SIZE + BLOCK_SIZE * BLOCK_CACHE_COUNT + BLOCK_SIZE + SHORTKEY_LENGTH;
		int n;
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( AddSalt, (uintptr_t)vol );
		else
			SRG_ResetEntropy( vol->entropy );
		vol->key = (uint8_t*)OpenSpace( NULL, NULL, &size );
		for( n = 0; n < BLOCK_CACHE_COUNT; n++ ) {
			vol->usekey[n] = vol->key + (n + 1) * BLOCK_SIZE;
			vol->segment[n] = 0;
		}
		vol->segkey = vol->key + BLOCK_SIZE * (BLOCK_CACHE_COUNT + 1);
		vol->sigkey = vol->key + BLOCK_SIZE * (BLOCK_CACHE_COUNT + 1) + SHORTKEY_LENGTH;
		vol->curseg = BLOCK_CACHE_DIRECTORY;
		vol->segment[BLOCK_CACHE_DIRECTORY] = 0;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)vol->key, BLOCK_SIZE * 8 );
	}
	else {
		int n;
		for( n = 0; n < BLOCK_CACHE_COUNT; n++ )
			vol->usekey[n] = l.zerokey;
		vol->segkey = l.zerokey;
		vol->sigkey = l.zerokey;
		vol->key = NULL;
	}
}
struct volume *sack_vfs_load_volume( const char * filepath )
{
	struct volume *vol = New( struct volume );
	memset( vol, 0, sizeof( struct volume ) );
	vol->volname = SaveText( filepath );
	AssignKey( vol, NULL, NULL );
	if( !ExpandVolume( vol ) || !ValidateBAT( vol ) ) { Deallocate( struct volume*, vol ); return NULL; }
	return vol;
}
struct volume *sack_vfs_load_crypt_volume( const char * filepath, uintptr_t version, const char * userkey, const char * devkey ) {
	struct volume *vol = New( struct volume );
	MemSet( vol, 0, sizeof( struct volume ) );
	if( !version ) version = 2;
	vol->clusterKeyVersion = version - 1;
	vol->volname = SaveText( filepath );
	vol->userkey = userkey;
	vol->devkey = devkey;
	AssignKey( vol, userkey, devkey );
	if( !ExpandVolume( vol ) || !ValidateBAT( vol ) ) { sack_vfs_unload_volume( vol ); return NULL; }
	return vol;
}
struct volume *sack_vfs_use_crypt_volume( POINTER memory, size_t sz, uintptr_t version, const char * userkey, const char * devkey ) {
	struct volume *vol = New( struct volume );
	MemSet( vol, 0, sizeof( struct volume ) );
	vol->read_only = 1;
	AssignKey( vol, userkey, devkey );
	if( !version ) version = 2;
	vol->clusterKeyVersion = version - 1;
	vol->external_memory = TRUE;
	vol->diskReal = (struct disk*)memory;
	vol->dwSize = sz;
#ifdef WIN32
	// elf has a different signature to check for .so extended data...
	struct disk *actual_disk;
	if( ((char*)memory)[0] == 'M' && ((char*)memory)[1] == 'Z' ) {
		actual_disk = (struct disk*)GetExtraData( memory );
		if( actual_disk ) {
			if( ( ( (uintptr_t)actual_disk - (uintptr_t)memory ) < vol->dwSize ) ) {
				const uint8_t *sig = sack_vfs_get_signature2( (POINTER)((uintptr_t)actual_disk-BLOCK_SIZE), memory );
				if( memcmp( sig, (POINTER)(((uintptr_t)actual_disk)-BLOCK_SIZE), BLOCK_SIZE ) ) {
					lprintf( "Signature failed comparison; the core has changed since it was attached" );
					vol->diskReal = NULL;
					vol->dwSize = 0;
					sack_vfs_unload_volume( vol );
					return FALSE;
				}
				vol->dwSize -= ((uintptr_t)actual_disk - (uintptr_t)memory);
				memory = (POINTER)actual_disk;
			} else {
				lprintf( "Signature failed comparison; the core is not attached to anything." );
				vol->diskReal = NULL;
				vol->disk = NULL;
				vol->dwSize = 0;
				sack_vfs_unload_volume( vol );
				return NULL;
			}
		}
	}
#endif
	vol->disk = (struct disk*)memory;
	if( !ValidateBAT( vol ) ) { sack_vfs_unload_volume( vol );  return NULL; }
	return vol;
}
void sack_vfs_unload_volume( struct volume * vol ) {
	INDEX idx;
	struct sack_vfs_file *file;
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file )
		break;
	if( file ) {
		vol->closed = TRUE;
		return;
	}
	DeleteListEx( &vol->files DBG_SRC );
	if( !vol->external_memory )	CloseSpace( vol->diskReal );
	if( vol->key ) {
		Deallocate( uint8_t*, vol->key );
		SRG_DestroyEntropy( &vol->entropy );
	}
	Deallocate( struct volume*, vol );
}
void sack_vfs_shrink_volume( struct volume * vol ) {
	size_t n;
	int b = 0;
	//int found_free; // this block has free data; should be last BAT?
	BLOCKINDEX last_block = 0;
	int last_bat = 0;
	enum block_cache_entries cache = BLOCK_CACHE_BAT;
	BLOCKINDEX *current_BAT = TSEEK( BLOCKINDEX*, vol, 0, cache );
 // expand failed, tseek failed in response, so don't do anything
	if( !current_BAT ) return;
	do {
		BLOCKINDEX check_val;
		BLOCKINDEX *blockKey;
		blockKey = (BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT];
		for( n = 0; n < BLOCKS_PER_BAT; n++ ) {
			check_val = *(current_BAT++);
			if( vol->key )	check_val ^= *(blockKey++);
			if( check_val ) {
				last_bat = b;
				last_block = n;
			}
		}
		b++;
		if( b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) < vol->dwSize ) {
			current_BAT = TSEEK( BLOCKINDEX*, vol, b * ( BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
		} else
			break;
	}while( 1 );
	Deallocate( struct disk *, vol->diskReal );
	SetFileLength( vol->volname,
			((uintptr_t)vol->disk - (uintptr_t)vol->diskReal) +
			(size_t)(last_bat * BLOCKS_PER_SECTOR * BLOCK_SIZE + ( last_block + 1 + 1 )* BLOCK_SIZE) );
	// setting 0 size will cause expand to do an initial open instead of expanding
	vol->dwSize = 0;
}
static void mask_block( struct volume *vol, size_t n ) {
	BLOCKINDEX b = ( 1 + (n >> BLOCK_SHIFT) * (BLOCKS_PER_SECTOR) + (n & (BLOCKS_PER_BAT - 1)));
	UpdateSegmentKey( vol, BLOCK_CACHE_DATAKEY, b + 1 );
	{
#ifdef __64__
		uint64_t* usekey = (uint64_t*)vol->usekey[BLOCK_CACHE_DATAKEY];
		uint64_t* block = (uint64_t*)(((uintptr_t)vol->disk) + b * BLOCK_SIZE );
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block += 2; usekey += 2;
		}
#else
		uint32_t* usekey = (uint32_t*)vol->usekey[BLOCK_CACHE_DATAKEY];
		uint32_t* block = (uint32_t*)(((uintptr_t)vol->disk) + b * BLOCK_SIZE );
		for( n = 0; n < (BLOCK_SIZE / 16); n++ ) {
			block[0] = block[0] ^ usekey[0];
			block[1] = block[1] ^ usekey[1];
			block[2] = block[2] ^ usekey[2];
			block[3] = block[3] ^ usekey[3];
			block += 4; usekey += 4;
		}
#endif
	}
}
LOGICAL sack_vfs_decrypt_volume( struct volume *vol )
{
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume is already decrypted, cannot remove key
	if( !vol->key ) { vol->lock = 0; return FALSE; }
	{
		enum block_cache_entries cache = BLOCK_CACHE_BAT;
		size_t n;
		BLOCKINDEX slab = vol->dwSize / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				block[0] ^= blockKey[0];
				if( block[0] == EOBBLOCK ) break;
				else if( block[0] ) mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block++;
				blockKey++;
			}
			if( m < BLOCKS_PER_BAT ) break;
		}
	}
	AssignKey( vol, NULL, NULL );
	vol->lock = 0;
	return TRUE;
}
LOGICAL sack_vfs_encrypt_volume( struct volume *vol, uintptr_t version, CTEXTSTR key1, CTEXTSTR key2 ) {
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
 // volume already has a key, cannot apply new key
	if( vol->key ) { vol->lock = 0; return FALSE; }
	if( !version ) version = 2;
	vol->clusterKeyVersion = version-1;
	AssignKey( vol, key1, key2 );
	{
		int done;
		size_t n;
		enum block_cache_entries cache = BLOCK_CACHE_BAT;
		BLOCKINDEX slab = (vol->dwSize + (BLOCKS_PER_SECTOR*BLOCK_SIZE-1)) / ( BLOCKS_PER_SECTOR * BLOCK_SIZE );
		done = 0;
		for( n = 0; n < slab; n++  ) {
			size_t m;
			BLOCKINDEX *blockKey;
// = (BLOCKINDEX*)(((uint8_t*)vol->disk) + n * (BLOCKS_PER_SECTOR * BLOCK_SIZE));
			BLOCKINDEX *block;
			block = TSEEK( BLOCKINDEX*, vol, n * (BLOCKS_PER_SECTOR*BLOCK_SIZE), cache );
			blockKey = ((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT]);
			//vol->segment[BLOCK_CACHE_BAT] = n + 1;
			for( m = 0; m < BLOCKS_PER_BAT; m++ ) {
				if( block[0] == EOBBLOCK ) done = TRUE;
				else if( block[0] ) mask_block( vol, (n*BLOCKS_PER_BAT) + m );
				block[0] ^= blockKey[0];
				if( done ) break;
				block++;
				blockKey++;
			}
			if( done ) break;
		}
	}
	vol->lock = 0;
	return TRUE;
}
const char *sack_vfs_get_signature( struct volume *vol ) {
	static char signature[257];
	static const char *output = "0123456789ABCDEF";
	if( !vol )
		return NULL;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	{
		static BLOCKINDEX datakey[BLOCKS_PER_BAT];
		uint8_t* usekey = vol->key?vol->usekey[BLOCK_CACHE_DATAKEY]:l.zerokey;
		signature[256] = 0;
		memset( datakey, 0, sizeof( datakey ) );
		{
			{
				size_t n;
				BLOCKINDEX this_dir_block = 0;
				BLOCKINDEX next_dir_block;
				BLOCKINDEX *next_entries;
				do {
					enum block_cache_entries cache = BLOCK_CACHE_DATAKEY;
					next_entries = BTSEEK( BLOCKINDEX *, vol, this_dir_block, cache );
					for( n = 0; n < BLOCKS_PER_BAT; n++ )
						datakey[n] ^= next_entries[n] ^ ((BLOCKINDEX*)(((uint8_t*)usekey)))[n];
					next_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, FALSE );
					if( this_dir_block == next_dir_block )
						DebugBreak();
					if( next_dir_block == 0 )
						DebugBreak();
					this_dir_block = next_dir_block;
				}
				while( next_dir_block != EOFBLOCK );
			}
		}
		if( !vol->entropy )
			vol->entropy = SRG_CreateEntropy2( AddSalt, (uintptr_t)vol );
		SRG_ResetEntropy( vol->entropy );
		vol->curseg = BLOCK_CACHE_DIRECTORY;
		vol->segment[vol->curseg] = 0;
		vol->datakey = (const char *)datakey;
		SRG_GetEntropyBuffer( vol->entropy, (uint32_t*)usekey, 128 * 8 );
		{
			int n;
			for( n = 0; n < 128; n++ ) {
				signature[n*2] = output[( usekey[n] >> 4 ) & 0xF];
				signature[n*2+1] = output[usekey[n] & 0xF];
			}
		}
	}
	vol->lock = 0;
	return signature;
}
struct directory_entry * ScanDirectory( struct volume *vol, const char * filename, struct directory_entry *dirkey, int path_match ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	BLOCKINDEX next_dir_block;
	struct directory_entry *next_entries;
	if( filename && filename[0] == '.' && filename[1] == '/' ) filename += 2;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			BLOCKINDEX bi;
			enum block_cache_entries name_cache = BLOCK_CACHE_NAMES;
			struct directory_entry *entkey = ( vol->key)?((struct directory_entry *)vol->usekey[BLOCK_CACHE_DIRECTORY])+n:&l.zero_entkey;
			//const char * testname;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
 // done.
			if( filename && !name_ofs )	return NULL;
			//LoG( "%d name_ofs = %" _size_f "(%" _size_f ") block = %d  vs %s"
			//   , n, name_ofs
			//   , next_entries[n].name_offset ^ entkey->name_offset
			//   , next_entries[n].first_block ^ entkey->first_block
			//   , filename );
			bi = next_entries[n].first_block ^ entkey->first_block;
			// if file is deleted; don't check it's name.
			if( !bi ) continue;
			// if file is end of directory, done sanning.
 // done.
			if( bi == EODMARK ) return filename?NULL:((struct directory_entry*)1);
			if( name_ofs > vol->dwSize ) { return NULL; }
			//testname =
			if( filename ) {
 // have to do the seek to the name block otherwise it might not be loaded.
				TSEEK( const char *, vol, name_ofs, name_cache );
				if( MaskStrCmp( vol, filename, name_ofs, path_match ) == 0 ) {
					if( dirkey ) dirkey[0] = (*entkey);
					LoG( "return found entry: %p (%" _size_f ":%" _size_f ") %s", next_entries + n, name_ofs, next_entries[n].first_block ^ dirkey->first_block, filename );
					return next_entries + n;
				}
			}
		}
		next_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
#ifdef _DEBUG
		if( this_dir_block == next_dir_block ) DebugBreak();
#endif
  // should have a last-entry before no more blocks....
		if( next_dir_block == 0 ) { DebugBreak(); return NULL; }
		this_dir_block = next_dir_block;
	}
	while( 1 );
}
// this results in an absolute disk position
static FPI SaveFileName( struct volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_name_block = 1;
	while( 1 ) {
		enum block_cache_entries cache = BLOCK_CACHE_NAMES;
		TEXTSTR names = BTSEEK( TEXTSTR, vol, this_name_block, cache );
		unsigned char *name = (unsigned char*)names;
		while( name < ( (unsigned char*)names + BLOCK_SIZE ) ) {
			int c = name[0];
			if( vol->key ) c = c ^ vol->usekey[BLOCK_CACHE_NAMES][name-(unsigned char*)names];
			if( !c ) {
				size_t namelen;
				if( ( namelen = StrLen( filename ) ) < (size_t)( ( (unsigned char*)names + BLOCK_SIZE ) - name ) ) {
					LoG( "using unused entry for new file...%" _size_f "  %" _size_f " %s", this_name_block, (uintptr_t)name - (uintptr_t)names, filename );
					if( vol->key ) {
						for( n = 0; n < namelen + 1; n++ )
							name[n] = filename[n] ^ vol->usekey[BLOCK_CACHE_NAMES][n + (name-(unsigned char*)names)];
						if( (namelen + 1) < (size_t)(((unsigned char*)names + BLOCK_SIZE) - name) )
							name[n] = vol->usekey[BLOCK_CACHE_NAMES][n + (name - (unsigned char*)names)];
					} else
						memcpy( name, filename, ( namelen + 1 ) );
					return ((uintptr_t)name) - ((uintptr_t)vol->disk);
				}
			}
			else
				if( MaskStrCmp( vol, filename, name - (unsigned char*)vol->disk, 0 ) == 0 ) {
					LoG( "using existing entry for new file...%s", filename );
					return ((uintptr_t)name) - ((uintptr_t)vol->disk);
				}
			if( vol->key ) {
				while( ( name[0] ^ vol->usekey[BLOCK_CACHE_NAMES][name-(unsigned char*)names] ) ) name++;
				name++;
			} else
				name = name + StrLen( (const char*)name ) + 1;
			LoG( "new position is %" _size_f "  %" _size_f, this_name_block, (uintptr_t)name - (uintptr_t)names );
		}
		this_name_block = vfs_GetNextBlock( vol, this_name_block, GFB_INIT_DIRENT, TRUE );
		LoG( "Need a new directory block....", this_name_block );
	}
}
static struct directory_entry * GetNewDirectory( struct volume *vol, const char * filename ) {
	size_t n;
	BLOCKINDEX this_dir_block = 0;
	struct directory_entry *next_entries;
	LOGICAL moveMark = FALSE;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
		next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
		for( n = 0; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( vol->key )?((struct directory_entry *)vol->usekey[cache])+n:&l.zero_entkey;
			struct directory_entry *ent = next_entries + n;
			FPI name_ofs = ent->name_offset ^ entkey->name_offset;
			BLOCKINDEX first_blk = ent->first_block ^ entkey->first_block;
			// not name_offset (end of list) or not first_block(free entry) use this entry
			if( name_ofs && (first_blk > 1) )  continue;
			if( first_blk == EODMARK ) moveMark = TRUE;
			name_ofs = SaveFileName( vol, filename ) ^ entkey->name_offset;
			first_blk = GetFreeBlock( vol, FALSE ) ^ entkey->first_block;
			// get free block might have expanded and moved the disk; reseek and get ent address
			next_entries = BTSEEK( struct directory_entry *, vol, this_dir_block, cache );
			ent = next_entries + n;
			ent->filesize = entkey->filesize;
			ent->name_offset = name_ofs;
			ent->first_block = first_blk;
			if( n < (VFS_DIRECTORY_ENTRIES - 1) ) {
				if( moveMark ) {
					struct directory_entry *enttmp = next_entries + (n + 1);
					enttmp->first_block = EODMARK ^ entkey[1].first_block;
				}
			} else {
				// otherwise pre-init the next directory sector
				this_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
			}
			return ent;
		}
		this_dir_block = vfs_GetNextBlock( vol, this_dir_block, GFB_INIT_DIRENT, TRUE );
	}
	while( 1 );
}
struct sack_vfs_file * CPROC sack_vfs_openfile( struct volume *vol, const char * filename ) {
	struct sack_vfs_file *file = New( struct sack_vfs_file );
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( filename[0] == '.' && filename[1] == '/' ) filename += 2;
	LoG( "sack_vfs open %s = %p on %s", filename, file, vol->volname );
	file->entry = ScanDirectory( vol, filename, &file->dirent_key, 0 );
	if( !file->entry ) {
		if( vol->read_only ) { LoG( "Fail open: readonly" ); vol->lock = 0; Deallocate( struct sack_vfs_file *, file ); return NULL; }
		else file->entry = GetNewDirectory( vol, filename );
	}
	if( vol->key )
		memcpy( &file->dirent_key, vol->usekey[BLOCK_CACHE_DIRECTORY] + ( (uintptr_t)file->entry & BLOCK_MASK ), sizeof( struct directory_entry ) );
	else
		memset( &file->dirent_key, 0, sizeof( struct directory_entry ) );
	file->vol = vol;
	file->fpi = 0;
	file->delete_on_close = 0;
	file->_first_block = file->block = file->entry->first_block ^ file->dirent_key.first_block;
	AddLink( &vol->files, file );
	vol->lock = 0;
	return file;
}
static struct sack_vfs_file * CPROC sack_vfs_open( uintptr_t psvInstance, const char * filename, const char *opts ) {
	return sack_vfs_openfile( (struct volume*)psvInstance, filename );
}
int CPROC sack_vfs_exists( struct volume *vol, const char * file ) {
	struct directory_entry entkey;
	struct directory_entry *ent;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	if( file[0] == '.' && file[1] == '/' ) file += 2;
	ent = ScanDirectory( vol, file, &entkey, 0 );
	//lprintf( "sack_vfs exists %s %s", ent?"ya":"no", file );
	vol->lock = 0;
	if( ent ) return TRUE;
	return FALSE;
}
size_t CPROC sack_vfs_tell( struct sack_vfs_file *file ) { return (size_t)file->fpi; }
size_t CPROC sack_vfs_size( struct sack_vfs_file *file ) { return (size_t)(file->entry->filesize ^ file->dirent_key.filesize); }
size_t CPROC sack_vfs_seek( struct sack_vfs_file *file, size_t pos, int whence )
{
	FPI old_fpi = file->fpi;
	if( whence == SEEK_SET ) file->fpi = pos;
	if( whence == SEEK_CUR ) file->fpi += pos;
	if( whence == SEEK_END ) file->fpi = ( file->entry->filesize  ^ file->dirent_key.filesize ) + pos;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	{
		if( ( file->fpi & ( ~BLOCK_MASK ) ) >= ( old_fpi & ( ~BLOCK_MASK ) ) ) {
			do {
				if( ( file->fpi & ( ~BLOCK_MASK ) ) == ( old_fpi & ( ~BLOCK_MASK ) ) ) {
					file->vol->lock = 0;
					return (size_t)file->fpi;
				}
				file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
				old_fpi += BLOCK_SIZE;
			} while( 1 );
		}
	}
	{
		size_t n = 0;
		BLOCKINDEX b = file->_first_block;
		while( n * BLOCK_SIZE < ( pos & ~BLOCK_MASK ) ) {
			b = vfs_GetNextBlock( file->vol, b, FALSE, TRUE );
			n++;
		}
		file->block = b;
	}
	file->vol->lock = 0;
	return (size_t)file->fpi;
}
static void MaskBlock( struct volume *vol, uint8_t* usekey, uint8_t* block, BLOCKINDEX block_ofs, size_t ofs, const char *data, size_t length ) {
	size_t n;
	block += block_ofs;
	usekey += ofs;
	if( vol->key )
		for( n = 0; n < length; n++ ) (*block++) = (*data++) ^ (*usekey++);
	else
		memcpy( block, data, length );
}
size_t CPROC sack_vfs_write( struct sack_vfs_file *file, const char * data, size_t length ) {
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	LoG( "Write to file %p %" _size_f "  @%" _size_f, file, length, ofs );
	if( ofs ) {
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, BLOCK_SIZE - ofs );
			data += BLOCK_SIZE - ofs;
			written += BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			length -= BLOCK_SIZE - ofs;
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], block, ofs, ofs, data, length );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length )
	{
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, BLOCK_SIZE - ofs );
			data += BLOCK_SIZE;
			written += BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
			length -= BLOCK_SIZE;
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], block, 0, 0, data, length );
			data += length;
			written += length;
			file->fpi += length;
			if( file->fpi > ( file->entry->filesize ^ file->dirent_key.filesize ) )
				file->entry->filesize = file->fpi ^ file->dirent_key.filesize;
			length = 0;
		}
	}
	file->vol->lock = 0;
	return written;
}
size_t CPROC sack_vfs_read( struct sack_vfs_file *file, char * data, size_t length ) {
	size_t written = 0;
	size_t ofs = file->fpi & BLOCK_MASK;
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
	if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < ( file->fpi + length ) ) {
		if( ( file->entry->filesize  ^ file->dirent_key.filesize ) < file->fpi )
			length = 0;
		else
			length = (size_t)( file->entry->filesize  ^ file->dirent_key.filesize ) - (size_t)file->fpi;
	}
	if( !length ) {  file->vol->lock = 0; return 0; }
	if( ofs ) {
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= ( BLOCK_SIZE - ( ofs ) ) ) {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), BLOCK_SIZE - ofs );
			written += BLOCK_SIZE - ofs;
			data += BLOCK_SIZE - ofs;
			length -= BLOCK_SIZE - ofs;
			file->fpi += BLOCK_SIZE - ofs;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, ofs, (const char*)(block+ofs), length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	// if there's still length here, FPI is now on the start of blocks
	while( length ) {
		enum block_cache_entries cache = BLOCK_CACHE_FILE;
		uint8_t* block = (uint8_t*)vfs_BSEEK( file->vol, file->block, &cache );
		if( length >= BLOCK_SIZE ) {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, BLOCK_SIZE - ofs );
			written += BLOCK_SIZE;
			data += BLOCK_SIZE;
			length -= BLOCK_SIZE;
			file->fpi += BLOCK_SIZE;
			file->block = vfs_GetNextBlock( file->vol, file->block, FALSE, TRUE );
		} else {
			MaskBlock( file->vol, file->vol->usekey[cache], (uint8_t*)data, 0, 0, (const char*)block, length );
			written += length;
			file->fpi += length;
			length = 0;
		}
	}
	file->vol->lock = 0;
	return written;
}
static void sack_vfs_unlink_file_entry( struct volume *vol, struct directory_entry *entry, struct directory_entry *entkey, BLOCKINDEX first_block, LOGICAL deleted ) {
	BLOCKINDEX block, _block;
	struct sack_vfs_file *file_found = NULL;
	struct sack_vfs_file *file;
	INDEX idx;
	LIST_FORALL( vol->files, idx, struct sack_vfs_file *, file ) {
		if( file->_first_block == entry->first_block ) {
			file_found = file;
			file->delete_on_close = TRUE;
		}
	}
	if( !deleted ) {
 // zero the block... keep the name.
		entry->first_block = entkey->first_block;
	}
	if( !file_found ) {
// entry->first_block ^ entkey->first_block;
		_block = block = first_block;
		LoG( "(marking physical deleted (again?)) entry starts at %d", block );
		// wipe out file chain BAT
		do {
			enum block_cache_entries cache = BLOCK_CACHE_BAT;
			BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
			BLOCKINDEX _thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[_block & (BLOCKS_PER_BAT-1)]:0;
			BLOCKINDEX b = BLOCK_SIZE + (block >> BLOCK_SHIFT) * (BLOCKS_PER_SECTOR*BLOCK_SIZE) + (block & (BLOCKS_PER_BAT - 1)) * BLOCK_SIZE;
			uint8_t* blockData = (uint8_t*)(((uintptr_t)vol->disk) + b);
			//LoG( "Clearing file datablock...%p", (uintptr_t)blockData - (uintptr_t)vol->disk );
			memset( blockData, 0, BLOCK_SIZE );
			block = vfs_GetNextBlock( vol, block, FALSE, FALSE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
			_block = block;
		} while( block != EOFBLOCK );
	}
}
static void shrinkBAT( struct sack_vfs_file *file ) {
	struct volume *vol = file->vol;
	struct directory_entry *entry = file->entry;
	struct directory_entry *entkey = &file->dirent_key;
	BLOCKINDEX block, _block;
	size_t bsize = 0;
	_block = block = entry->first_block ^ entkey->first_block;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_BAT;
		enum block_cache_entries data_cache = BLOCK_CACHE_DATAKEY;
		BLOCKINDEX *this_BAT = TSEEK( BLOCKINDEX*, vol, ( ( block >> BLOCK_SHIFT ) * ( BLOCKS_PER_SECTOR*BLOCK_SIZE) ), cache );
		BLOCKINDEX _thiskey;
		_thiskey = ( vol->key )?((BLOCKINDEX*)vol->usekey[BLOCK_CACHE_BAT])[_block & (BLOCKS_PER_BAT-1)]:0;
		block = vfs_GetNextBlock( vol, block, FALSE, FALSE );
		if( bsize > (entry->filesize ^ entkey->filesize) ) {
			uint8_t* blockData = (uint8_t*)vfs_BSEEK( file->vol, _block, &data_cache );
			//LoG( "clearing a datablock after a file..." );
			memset( blockData, 0, BLOCK_SIZE );
			this_BAT[_block & (BLOCKS_PER_BAT-1)] = _thiskey;
		} else {
			bsize++;
			if( bsize > (entry->filesize ^ entkey->filesize) ) {
				uint8_t* blockData = (uint8_t*)vfs_BSEEK( file->vol, _block, &data_cache );
				//LoG( "clearing a partial datablock after a file..., %d, %d", BLOCK_SIZE-(entry->filesize & (BLOCK_SIZE-1)), ( entry->filesize & (BLOCK_SIZE-1)) );
				memset( blockData + ( entry->filesize & (BLOCK_SIZE-1)), 0, BLOCK_SIZE-(entry->filesize & (BLOCK_SIZE-1)) );
				this_BAT[_block & (BLOCKS_PER_BAT-1)] = ~_thiskey;
			}
		}
		_block = block;
	} while( block != EOFBLOCK );
}
size_t CPROC sack_vfs_truncate( struct sack_vfs_file *file ) { file->entry->filesize = file->fpi ^ file->dirent_key.filesize; shrinkBAT( file ); return (size_t)file->fpi; }
int CPROC sack_vfs_close( struct sack_vfs_file *file ) {
	while( LockedExchange( &file->vol->lock, 1 ) ) Relinquish();
#ifdef DEBUG_TRACE_LOG
	{
		enum block_cache_entries cache = BLOCK_CACHE_NAMES;
		static char fname[256];
		FPI name_ofs = file->entry->name_offset ^ file->dirent_key.name_offset;
 // have to do the seek to the name block otherwise it might not be loaded.
		TSEEK( const char *, file->vol, name_ofs, cache );
		MaskStrCpy( fname, sizeof( fname ), file->vol, name_ofs );
		LoG( "close file:%s(%p)", fname, file );
	}
#endif
	DeleteLink( &file->vol->files, file );
	if( file->delete_on_close ) sack_vfs_unlink_file_entry( file->vol, file->entry, &file->dirent_key, file->_first_block, TRUE );
	file->vol->lock = 0;
	if( file->vol->closed ) sack_vfs_unload_volume( file->vol );
	Deallocate( struct sack_vfs_file *, file );
	return 0;
}
int CPROC sack_vfs_unlink_file( struct volume *vol, const char * filename ) {
	int result = 0;
	struct directory_entry entkey;
	struct directory_entry *entry;
	if( !vol ) return 0;
	while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
	LoG( "unlink file:%s", filename );
	if( ( entry  = ScanDirectory( vol, filename, &entkey, 0 ) ) ) {
		sack_vfs_unlink_file_entry( vol, entry, &entkey, entry->first_block ^ entkey.first_block, FALSE );
		result = 1;
	}
	vol->lock = 0;
	return result;
}
	/* noop */
int CPROC sack_vfs_flush( struct sack_vfs_file *file ) {	return 0; }
static LOGICAL CPROC sack_vfs_need_copy_write( void ) {	return FALSE; }
struct find_info {
	BLOCKINDEX this_dir_block;
	char filename[BLOCK_SIZE];
	struct volume *vol;
	CTEXTSTR base;
	size_t base_len;
	size_t filenamelen;
	VFS_DISK_DATATYPE filesize;
	CTEXTSTR mask;
	size_t thisent;
};
struct find_info * CPROC sack_vfs_find_create_cursor(uintptr_t psvInst,const char *base,const char *mask )
{
	struct find_info *info = New( struct find_info );
	info->base = base;
	info->base_len = StrLen( base );
	info->mask = mask;
	info->vol = (struct volume *)psvInst;
	return info;
}
static int iterate_find( struct find_info *info ) {
	struct directory_entry *next_entries;
	size_t n;
	do {
		enum block_cache_entries cache = BLOCK_CACHE_DIRECTORY;
		enum block_cache_entries name_cache = BLOCK_CACHE_NAMES;
		next_entries = BTSEEK( struct directory_entry *, info->vol, info->this_dir_block, cache );
		for( n = info->thisent; n < VFS_DIRECTORY_ENTRIES; n++ ) {
			struct directory_entry *entkey = ( info->vol->key)?((struct directory_entry *)info->vol->usekey[cache])+n:&l.zero_entkey;
			FPI name_ofs = next_entries[n].name_offset ^ entkey->name_offset;
			if( !name_ofs )
				return 0;
			// if file is deleted; don't check it's name.
			if( !(next_entries[n].first_block ^ entkey->first_block ) )
				continue;
			if( (next_entries[n].first_block ^ entkey->first_block ) == EODMARK )
 // end of directory.
				return 0;
			info->filesize = next_entries[n].filesize ^ entkey->filesize;
			if( (name_ofs) > info->vol->dwSize ) {
				LoG( "corrupted volume." );
				return 0;
			}
			TSEEK( const char *, info->vol, name_ofs, name_cache );
			if( info->vol->key ) {
				int c;
				info->filenamelen = 0;
				while( ( c = ( ((uint8_t*)info->vol->disk)[name_ofs] ^ info->vol->usekey[name_cache][name_ofs&BLOCK_MASK] ) ) ) {
					info->filename[info->filenamelen++] = c;
					name_ofs++;
				}
				info->filename[info->filenamelen]	 = c;
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			} else {
				StrCpy( info->filename, (const char *)(((uint8_t*)info->vol->disk) + name_ofs) );
				LoG( "Scan return filename: %s", info->filename );
				if( info->base
				    && ( info->base[0] != '.' && info->base_len != 1 )
				    && StrCaseCmpEx( info->base, info->filename, info->base_len ) )
					continue;
			}
			info->thisent = n + 1;
			return 1;
		}
 // new block, set new starting index.
		info->thisent = 0;
		info->this_dir_block = vfs_GetNextBlock( info->vol, info->this_dir_block, FALSE, FALSE );
	}
	while( info->this_dir_block != EOFBLOCK );
	return 0;
}
int CPROC sack_vfs_find_first( struct find_info *info ) {
	info->this_dir_block = 0;
	info->thisent = 0;
	return iterate_find( info );
}
int CPROC sack_vfs_find_close( struct find_info *info ) { Deallocate( struct find_info*, info ); return 0; }
int CPROC sack_vfs_find_next( struct find_info *info ) { return iterate_find( info ); }
char * CPROC sack_vfs_find_get_name( struct find_info *info ) { return info->filename; }
size_t CPROC sack_vfs_find_get_size( struct find_info *info ) { return (size_t)info->filesize; }
LOGICAL CPROC sack_vfs_find_is_directory( struct find_cursor *cursor ) { return FALSE; }
LOGICAL CPROC sack_vfs_is_directory( uintptr_t psvInstance, const char *path ) {
	if( path[0] == '.' && path[1] == 0 ) return TRUE;
	{
		struct volume *vol = (struct volume *)psvInstance;
		if( ScanDirectory( vol, path, NULL, 1 ) ) {
			return TRUE;
		}
	}
	return FALSE;
}
LOGICAL CPROC sack_vfs_rename( uintptr_t psvInstance, const char *original, const char *newname ) {
	struct volume *vol = (struct volume *)psvInstance;
	// fail if the names are the same.
	if( strcmp( original, newname ) == 0 )
		return FALSE;
	if( vol ) {
		struct directory_entry entkey;
		struct directory_entry *entry;
		while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
		if( ( entry  = ScanDirectory( vol, original, &entkey, 0 ) ) ) {
			struct directory_entry new_entkey;
			struct directory_entry *new_entry;
			if( (new_entry = ScanDirectory( vol, newname, &new_entkey, 0 )) ) {
				vol->lock = 0;
				sack_vfs_unlink_file( vol, newname );
				while( LockedExchange( &vol->lock, 1 ) ) Relinquish();
			}
			entry->name_offset = SaveFileName( vol, newname ) ^ entkey.name_offset;
			vol->lock = 0;
			return TRUE;
		}
		vol->lock = 0;
	}
	return FALSE;
}
static struct file_system_interface sack_vfs_fsi = {
                                                     (void*(CPROC*)(uintptr_t,const char *, const char*))sack_vfs_open
                                                   , (int(CPROC*)(void*))sack_vfs_close
                                                   , (size_t(CPROC*)(void*,char*,size_t))sack_vfs_read
                                                   , (size_t(CPROC*)(void*,const char*,size_t))sack_vfs_write
                                                   , (size_t(CPROC*)(void*,size_t,int))sack_vfs_seek
                                                   , (void(CPROC*)(void*))sack_vfs_truncate
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_unlink_file
                                                   , (size_t(CPROC*)(void*))sack_vfs_size
                                                   , (size_t(CPROC*)(void*))sack_vfs_tell
                                                   , (int(CPROC*)(void*))sack_vfs_flush
                                                   , (int(CPROC*)(uintptr_t,const char*))sack_vfs_exists
                                                   , sack_vfs_need_copy_write
                                                   , (struct find_cursor*(CPROC*)(uintptr_t,const char *,const char *))             sack_vfs_find_create_cursor
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_first
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_close
                                                   , (int(CPROC*)(struct find_cursor*))             sack_vfs_find_next
                                                   , (char*(CPROC*)(struct find_cursor*))           sack_vfs_find_get_name
                                                   , (size_t(CPROC*)(struct find_cursor*))          sack_vfs_find_get_size
                                                   , sack_vfs_find_is_directory
                                                   , sack_vfs_is_directory
                                                   , sack_vfs_rename
                                                   };
PRIORITY_PRELOAD( Sack_VFS_Register, CONFIG_SCRIPT_PRELOAD_PRIORITY - 2 )
{
#ifdef ALT_VFS_NAME
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME ".runner"
#else
#   define DEFAULT_VFS_NAME SACK_VFS_FILESYSTEM_NAME
#endif
	sack_register_filesystem_interface( DEFAULT_VFS_NAME, &sack_vfs_fsi );
}
PRIORITY_PRELOAD( Sack_VFS_RegisterDefaultFilesystem, SQL_PRELOAD_PRIORITY + 1 ) {
	if( SACK_GetProfileInt( GetProgramName(), "SACK/VFS/Mount VFS", 0 ) ) {
		struct volume *vol;
		TEXTCHAR volfile[256];
		TEXTSTR tmp;
		SACK_GetProfileString( GetProgramName(), "SACK/VFS/File", "*/../assets.svfs", volfile, 256 );
		tmp = ExpandPath( volfile );
		vol = sack_vfs_load_volume( tmp );
		Deallocate( TEXTSTR, tmp );
		sack_mount_filesystem( "sack_shmem", sack_get_filesystem_interface( DEFAULT_VFS_NAME )
		                     , 900, (uintptr_t)vol, TRUE );
	}
}
SACK_VFS_NAMESPACE_END
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef _SHA1_H_
#define _SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifdef SACK_BAG_EXPORTS
#define SHA2_SOURCE
#endif
/*
 * FIPS 180-2 SHA-224/256/384/512 implementation
 * Last update: 02/02/2007
 * Issue date:  04/30/2005
 *
 * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#ifndef SHA2_H
#define SHA2_H
#ifdef SHA2_SOURCE
#define SHA2_PROC   EXPORT_METHOD
#else
#define SHA2_PROC   IMPORT_METHOD
#endif
#define SHA224_DIGEST_SIZE ( 224 / 8)
#define SHA256_DIGEST_SIZE ( 256 / 8)
#define SHA384_DIGEST_SIZE ( 384 / 8)
#define SHA512_DIGEST_SIZE ( 512 / 8)
#define SHA256_BLOCK_SIZE  ( 512 / 8)
#define SHA512_BLOCK_SIZE  (1024 / 8)
#define SHA384_BLOCK_SIZE  SHA512_BLOCK_SIZE
#define SHA224_BLOCK_SIZE  SHA256_BLOCK_SIZE
#ifndef SHA2_TYPES
#define SHA2_TYPES
typedef unsigned char uint8;
typedef unsigned int  uint32;
typedef unsigned long long uint64;
#endif
#ifdef __cplusplus
extern "C" {
#endif
typedef struct {
    unsigned int tot_len;
    unsigned int len;
    unsigned char block[2 * SHA256_BLOCK_SIZE];
    uint32 h[8];
}sha256_ctx;
typedef struct {
    unsigned int tot_len;
    unsigned int len;
    unsigned char block[2 * SHA512_BLOCK_SIZE];
    uint64 h[8];
}sha512_ctx;
typedef sha512_ctx sha384_ctx;
typedef sha256_ctx sha224_ctx;
SHA2_PROC void sha224_init(sha224_ctx *ctx);
SHA2_PROC void sha224_update(sha224_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha224_final(sha224_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha224(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha256_init(sha256_ctx * ctx);
SHA2_PROC void sha256_update(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha256_final(sha256_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha256(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha384_init(sha384_ctx *ctx);
SHA2_PROC void sha384_update(sha384_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha384_final(sha384_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha384(const unsigned char *message, unsigned int len,
            unsigned char *digest);
SHA2_PROC void sha512_init(sha512_ctx *ctx);
SHA2_PROC void sha512_update(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int len);
SHA2_PROC void sha512_final(sha512_ctx *ctx, unsigned char *digest);
SHA2_PROC void sha512(const unsigned char *message, unsigned int len,
            unsigned char *digest);
#ifdef __cplusplus
}
#endif
#endif
// from https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.h  2017/19/12
// sha3.h
// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>
// 2018-06-16 modified _final api to pass context then digest (reverse params from original)
#ifndef SHA3_H
#define SHA3_H
#ifndef KECCAKF_ROUNDS
#define KECCAKF_ROUNDS 24
#endif
#ifndef ROTL64
#define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))
#endif
// state context
typedef struct {
                                 // state:
    union {
                     // 8-bit bytes
        uint8_t b[200];
                     // 64-bit words
        uint64_t q[25];
    } st;
                    // these don't overflow
    int pt, rsiz, mdlen;
} sha3_ctx_t;
// Compression function.
void sha3_keccakf(uint64_t st[25]);
// OpenSSL - like interfece
    // mdlen = hash output in bytes
int sha3_init(sha3_ctx_t *c, int mdlen);
int sha3_update(sha3_ctx_t *c, const void *data, size_t len);
    // digest goes to md
int sha3_final(sha3_ctx_t *c, void *md );
// compute a sha3 hash (md) of given byte length from "in"
void *sha3(const void *in, size_t inlen, void *md, int mdlen);
// SHAKE128 and SHAKE256 extensible-output functions
#define shake128_init(c) sha3_init(c, 16)
#define shake256_init(c) sha3_init(c, 32)
#define shake_update sha3_update
void shake_xof(sha3_ctx_t *c);
void shake_out(sha3_ctx_t *c, void *out, size_t len);
#endif
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
#define SALTY_RANDOM_GENERATOR_SOURCE
#endif
#define MY_MASK_MASK(n,length)	(MASK_TOP_MASK(length) << ((n)&0x7) )
#define MY_GET_MASK(v,n,mask_size)  ( ( ((MASKSET_READTYPE*)((((uintptr_t)v))+(n)/CHAR_BIT))[0]											 & MY_MASK_MASK(n,mask_size) )																										>> (((n))&0x7))
struct random_context {
	LOGICAL use_version2 : 1;
	LOGICAL use_version2_256 : 1;
	LOGICAL use_version3 : 1;
	SHA1Context sha1_ctx;
	sha512_ctx  sha512;
	sha256_ctx  sha256;
	sha3_ctx_t  sha3;
	POINTER salt;
	size_t salt_size;
	void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size );
	uintptr_t psv_user;
	uint8_t entropy[SHA1HashSize];
	uint8_t entropy2[SHA512_DIGEST_SIZE];
	uint8_t entropy2_256[SHA256_DIGEST_SIZE];
#define SHA3_DIGEST_SIZE 64
	uint8_t entropy3[SHA3_DIGEST_SIZE];
	size_t bits_used;
	size_t bits_avail;
};
static void NeedBits( struct random_context *ctx )
{
	if( ctx->getsalt )
		ctx->getsalt( ctx->psv_user, &ctx->salt, &ctx->salt_size );
	else
		ctx->salt_size = 0;
	if( ctx->use_version3 ) {
		if( ctx->salt_size )
			sha3_update( &ctx->sha3, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
		sha3_final( &ctx->sha3, ctx->entropy3 );
		sha3_init( &ctx->sha3, SHA3_DIGEST_SIZE );
		sha3_update( &ctx->sha3, ctx->entropy3, SHA3_DIGEST_SIZE );
		ctx->bits_avail = sizeof( ctx->entropy3 ) * 8;
	} else if( ctx->use_version2_256 ) {
		if( ctx->salt_size )
			sha256_update( &ctx->sha256, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
		sha256_final( &ctx->sha256, ctx->entropy2_256 );
		sha256_init( &ctx->sha256 );
		sha256_update( &ctx->sha256, ctx->entropy2_256, SHA256_DIGEST_SIZE );
		ctx->bits_avail = sizeof( ctx->entropy2_256 ) * 8;
	} else if( ctx->use_version2 )
	{
		if( ctx->salt_size )
			sha512_update( &ctx->sha512, (const uint8_t*)ctx->salt, (unsigned int)ctx->salt_size );
		sha512_final( &ctx->sha512, ctx->entropy2 );
		sha512_init( &ctx->sha512 );
		sha512_update( &ctx->sha512, ctx->entropy2, SHA512_DIGEST_SIZE );
		ctx->bits_avail = sizeof( ctx->entropy2 ) * 8;
	}
	else
	{
		if( ctx->salt_size )
			SHA1Input( &ctx->sha1_ctx, (const uint8_t*)ctx->salt, ctx->salt_size );
		SHA1Result( &ctx->sha1_ctx, ctx->entropy );
		SHA1Reset( &ctx->sha1_ctx );
		SHA1Input( &ctx->sha1_ctx, ctx->entropy, SHA1HashSize );
		ctx->bits_avail = sizeof( ctx->entropy ) * 8;
	}
	ctx->bits_used = 0;
}
struct random_context *SRG_CreateEntropyInternal( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user
                                                , LOGICAL version2
                                                , LOGICAL version2_256
                                                , LOGICAL version3
                                                )
{
	struct random_context *ctx = New( struct random_context );
	ctx->use_version3 = version3;
	ctx->use_version2_256 = version2_256;
	ctx->use_version2 = version2;
	if( ctx->use_version3 )
		sha3_init( &ctx->sha3, SHA3_DIGEST_SIZE );
	else if( ctx->use_version2_256 )
		sha256_init( &ctx->sha256 );
	else if( ctx->use_version2 )
		sha512_init( &ctx->sha512 );
	else
		SHA1Reset( &ctx->sha1_ctx );
	ctx->getsalt = getsalt;
	ctx->psv_user = psv_user;
	ctx->bits_used = 0;
	ctx->bits_avail = 0;
	return ctx;
}
struct random_context *SRG_CreateEntropy( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, FALSE, FALSE );
}
struct random_context *SRG_CreateEntropy2( void (*getsalt)( uintptr_t, POINTER *salt, size_t *salt_size ), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, TRUE, FALSE, FALSE );
}
struct random_context *SRG_CreateEntropy2_256( void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, TRUE, FALSE );
}
struct random_context *SRG_CreateEntropy3( void( *getsalt )(uintptr_t, POINTER *salt, size_t *salt_size), uintptr_t psv_user )
{
	return SRG_CreateEntropyInternal( getsalt, psv_user, FALSE, FALSE, TRUE );
}
void SRG_DestroyEntropy( struct random_context **ppEntropy )
{
	Release( (*ppEntropy) );
	(*ppEntropy) = NULL;
}
void SRG_GetEntropyBuffer( struct random_context *ctx, uint32_t *buffer, uint32_t bits )
{
	uint32_t tmp;
	uint32_t partial_tmp;
	uint32_t partial_bits = 0;
	uint32_t get_bits;
	uint32_t resultBits = 0;
	do
	{
		if( bits > sizeof( tmp ) * 8 )
			get_bits = sizeof( tmp ) * 8;
		else
			get_bits = bits;
		// if there were 1-31 bits of data in partial, then can only get 32-partial max.
		if( ( 32 - partial_bits ) < get_bits )
			get_bits = 32-partial_bits;
		// check1 :
		//    if get_bits == 32
		//    but bits_used is 1-7, then it would have to pull 5 bytes to get the 32 required
		//    so truncate get_bits to 25-31 bits
		if( ( 32 - ( ctx->bits_used & 0x7 ) ) < get_bits )
			get_bits = ( 32 - ( ctx->bits_used & 0x7 ) );
		// if resultBits is 1-7 offset, then would have to store up to 5 bytes of value
		//    so have to truncate to just the up to 4 bytes that will fit.
		if( get_bits > (32 - resultBits ) )
			get_bits = 32-resultBits;
		// only greater... if equal just grab the bits.
		if( get_bits > ( ctx->bits_avail - ctx->bits_used ) )
		{
			// if there are any bits left, grab the partial bits.
			if( ctx->bits_avail - ctx->bits_used )
			{
				partial_bits = (uint32_t)(ctx->bits_avail - ctx->bits_used);
				// partial can never be greater than 32; input is only max of 32
				//if( partial_bits > (sizeof( partial_tmp ) * 8) )
				//	partial_bits = (sizeof( partial_tmp ) * 8);
				if( ctx->use_version3 )
					partial_tmp = MY_GET_MASK( ctx->entropy3, ctx->bits_used, partial_bits );
				else if( ctx->use_version2_256 )
					partial_tmp = MY_GET_MASK( ctx->entropy2_256, ctx->bits_used, partial_bits );
				else if( ctx->use_version2 )
					partial_tmp = MY_GET_MASK( ctx->entropy2, ctx->bits_used, partial_bits );
				else
					partial_tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, partial_bits );
			}
			NeedBits( ctx );
			bits -= partial_bits;
		}
		else
		{
			if( ctx->use_version3 )
				tmp = MY_GET_MASK( ctx->entropy3, ctx->bits_used, get_bits );
			else if( ctx->use_version2_256 )
				tmp = MY_GET_MASK( ctx->entropy2_256, ctx->bits_used, get_bits );
			else if( ctx->use_version2 )
				tmp = MY_GET_MASK( ctx->entropy2, ctx->bits_used, get_bits );
			else
				tmp = MY_GET_MASK( ctx->entropy, ctx->bits_used, get_bits );
			ctx->bits_used += get_bits;
			if( partial_bits )
			{
				tmp = partial_tmp | ( tmp << partial_bits );
				partial_bits = 0;
			}
			(*buffer) = tmp << resultBits;
			resultBits += get_bits;
			while( resultBits >= 8 ) {
#if defined( __cplusplus ) || defined( __GNUC__ )
				buffer = (uint32_t*)(((uintptr_t)buffer) + 1);
#else
				((intptr_t)buffer)++;
#endif
				resultBits -= 8;
			}
			bits -= get_bits;
		}
	} while( bits );
}
int32_t SRG_GetEntropy( struct random_context *ctx, int bits, int get_signed )
{
	int32_t result;
	SRG_GetEntropyBuffer( ctx, (uint32_t*)&result, bits );
	if( get_signed )
		if( result & ( 1 << ( bits - 1 ) ) )
		{
			uint32_t negone = ~0;
			negone <<= bits;
			return (int32_t)( result | negone );
		}
	return result;
}
void SRG_ResetEntropy( struct random_context *ctx )
{
	if( ctx->use_version3 )
		sha3_init( &ctx->sha3, SHA3_DIGEST_SIZE );
	else if( ctx->use_version2_256 )
		sha256_init( &ctx->sha256 );
	else if( ctx->use_version2 )
		sha512_init( &ctx->sha512 );
	else
		SHA1Reset( &ctx->sha1_ctx );
	ctx->bits_used = 0;
	ctx->bits_avail = 0;
}
void SRG_FeedEntropy( struct random_context *ctx, const uint8_t *salt, size_t salt_size )
{
	if( ctx->use_version3 )
		sha3_update( &ctx->sha3, salt, (unsigned int)salt_size );
	else if( ctx->use_version2_256 )
		sha256_update( &ctx->sha256, salt, (unsigned int)salt_size );
	else if( ctx->use_version2 )
		sha512_update( &ctx->sha512, salt, (unsigned int)salt_size );
	else
		SHA1Input( &ctx->sha1_ctx, salt, salt_size );
}
void SRG_SaveState( struct random_context *ctx, POINTER *external_buffer_holder )
{
	if( !(*external_buffer_holder) )
		(*external_buffer_holder) = New( struct random_context );
	MemCpy( (*external_buffer_holder), ctx, sizeof( struct random_context ) );
}
void SRG_RestoreState( struct random_context *ctx, POINTER external_buffer_holder )
{
	MemCpy( ctx, (external_buffer_holder), sizeof( struct random_context ) );
}
static void salt_generator(uintptr_t psv, POINTER *salt, size_t *salt_size ) {
	static uint32_t tick;
	tick = GetTickCount();
	salt[0] = &tick;
	salt_size[0] = sizeof( tick );
}
char *SRG_ID_Generator( void ) {
	static struct random_context *ctx;
	uint32_t buf[2*(16+16)];
	size_t outlen;
	if( !ctx ) ctx = SRG_CreateEntropy2( salt_generator, 0 );
	SRG_GetEntropyBuffer( ctx, buf, 8*(16+16) );
	return EncodeBase64Ex( (uint8*)buf, (16+16), &outlen, (const char *)1 );
}
char *SRG_ID_Generator_256( void ) {
	static struct random_context *ctx;
	uint32_t buf[2 * (16 + 16)];
	size_t outlen;
	if( !ctx ) ctx = SRG_CreateEntropy2_256( salt_generator, 0 );
	SRG_GetEntropyBuffer( ctx, buf, 8 * (16 + 16) );
	return EncodeBase64Ex( (uint8*)buf, (16 + 16), &outlen, (const char *)1 );
}
char *SRG_ID_Generator3( void ) {
	static struct random_context *ctx;
	uint32_t buf[2 * (16 + 16)];
	size_t outlen;
	if( !ctx ) ctx = SRG_CreateEntropy3( salt_generator, 0 );
	SRG_GetEntropyBuffer( ctx, buf, 8 * (16 + 16) );
	return EncodeBase64Ex( (uint8*)buf, (16 + 16), &outlen, (const char *)1 );
}
#ifdef WIN32
#if 0
// if standalone?
BOOL WINAPI DllMain(
	HINSTANCE hinstDLL,
	DWORD fdwReason,
	LPVOID lpvReserved
						 )
{
	return TRUE;
}
#endif
// this is the watcom deadstart entry point.
// by supplying this routine, then the native runtime doesn't get pulled
// and no external clbr symbols are required.
//void __DLLstart( void )
//{
//}
#endif
/*
 *  Creator: Jim Buckeyne
 *  Header for configscript.lib(bag.lib)
 *  Provides definitions for handling configuration files
 *  or any particular file which has machine generated
 *  characteristics, it can handle translators to decrypt
 *  encrypt.  Method of operation is to create a configuration
 *  evaluator, then AddConfiguratMethod()s to it.
 *  configuration methods are format descriptors for the lines
 *  and a routine which is called when such a line is matched.
 *  One might think of it as a trigger library for MUDs ( a
 *  way to trigger an event based on certain text input,
 *  variations in the text input may be assigned as variables
 *  to be used within the event.
 *
 *  More about configuration string parsing is available in
 *  $(SACK_BASE)/src/configlib/config.rules text file.
 *
 *  A vague attempt at providing a class to derrive a config-
 *  uration reader class, which may contain private data
 *  within such a class, or otherwise provide an object with
 *  simple namespace usage. ( add(), go() )
 *
 *  This library also imlements several PTEXT based methods
 *  which can evaluate text segments into valid binary types
 *  such as text to integer, float, color, etc.  Some of the type
 *  validators applied for the format argument matching of added
 *  methods are available for external reference.
 *
 */
#ifndef CONFIGURATION_SCRIPT_HANDLER
#define CONFIGURATION_SCRIPT_HANDLER
/* Define COLOR type. Basically the image library regards color
   as 32 bits of data. User applications end up needing to
   specify colors in the correct method for the platform they
   are working on. This provides aliases to rearrange colors.
   For instance the colors on windows and the colors for OpenGL
   are not exactly the same. If the OpenGL driver is specified
   as the output device, the entire code would need to be
   rebuilt for specifying colors correctly for opengl. While
   otherwise they are both 32 bits, and peices work, they get
   very ugly colors output.
   See Also
   <link Colors>                                                */
#ifndef COLOR_STRUCTURE_DEFINED
/* An exclusion symbol for defining CDATA and color operations. */
#define COLOR_STRUCTURE_DEFINED
#ifdef __cplusplus
SACK_NAMESPACE
	namespace image {
#endif
		// byte index values for colors on the video buffer...
		enum color_byte_index {
 I_BLUE  = 0,
 I_GREEN = 1,
 I_RED   = 2,
 I_ALPHA = 3
		};
#if defined( __ANDROID__ ) || defined( _OPENGL_DRIVER )
#  define USE_OPENGL_COMPAT_COLORS
#endif
#if ( !defined( IMAGE_LIBRARY_SOURCE_MAIN ) && ( !defined( FORCE_NO_INTERFACE ) || defined( ALLOW_IMAGE_INTERFACE ) ) )      && !defined( FORCE_COLOR_MACROS )
#define Color( r,g,b ) MakeColor(r,g,b)
#define AColor( r,g,b,a ) MakeAlphaColor(r,g,b,a)
#define SetAlpha( rgb, a ) SetAlphaValue( rgb, a )
#define SetGreen( rgb, g ) SetGreeValue(rgb,g )
#define AlphaVal(color) GetAlphaValue( color )
#define RedVal(color)   GetRedValue(color)
#define GreenVal(color) GetGreenValue(color)
#define BlueVal(color)  GetBlueValue(color)
#else
#if defined( _OPENGL_DRIVER ) || defined( USE_OPENGL_COMPAT_COLORS )
#  define Color( r,g,b ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|0xFF000000)
#  define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)(r))|((uint16_t)((uint8_t)(g))<<8))|(((uint32_t)((uint8_t)(b))<<16)))|((a)<<24))
#  define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
#  define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0xFF)<<8 ) )
#  define SetBlue( rgb, b )  ( ((rgb)&0xFF00FFFF) | ( ((b)&0xFF)<<16 ) )
#  define SetRed( rgb, r )   ( ((rgb)&0xFFFFFF00) | ( ((r)&0xFF)<<0 ) )
#  define GLColor( c )  (c)
#  define AlphaVal(color) ((color&0xFF000000) >> 24)
#  define RedVal(color)   ((color&0x000000FF) >> 0)
#  define GreenVal(color) ((color&0x0000FF00) >> 8)
#  define BlueVal(color)  ((color&0x00FF0000) >> 16)
#else
#  ifdef _WIN64
#    define AND_FF &0xFF
#  else
/* This is a macro to cure a 64bit warning in visual studio. */
#    define AND_FF
#  endif
/* A macro to create a solid color from R G B coordinates.
   Example
   <code lang="c++">
   CDATA color1 = Color( 255,0,0 ); // Red only, so this is bright red
   CDATA color2 = Color( 0,255,0); // green only, this is bright green
   CDATA color3 = Color( 0,0,255); // blue only, this is birght blue
   CDATA color4 = Color(93,93,32); // this is probably a goldish grey
   </code>                                                             */
#define Color( r,g,b ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|0xFF000000)
/* Build a color with alpha specified. */
#define AColor( r,g,b,a ) (((uint32_t)( ((uint8_t)((b)AND_FF))|((uint16_t)((uint8_t)((g))AND_FF)<<8))|(((uint32_t)((uint8_t)((r))AND_FF)<<16)))|(((a)AND_FF)<<24))
/* Sets the alpha part of a color. (0-255 value, 0 being
   transparent, and 255 solid(opaque))
   Example
   <code lang="c++">
   CDATA color = BASE_COLOR_RED;
   CDATA hazy_color = SetAlpha( color, 128 );
   </code>
 */
#define SetAlpha( rgb, a ) ( ((rgb)&0x00FFFFFF) | ( (a)<<24 ) )
/* Sets the green channel of a color. Expects a value 0-255.  */
#define SetGreen( rgb, g ) ( ((rgb)&0xFFFF00FF) | ( ((g)&0x0000FF)<<8 ) )
/* Sets the blue channel of a color. Expects a value 0-255.  */
#define SetBlue( rgb, b ) ( ((rgb)&0xFFFFFF00) | ( ((b)&0x0000FF)<<0 ) )
/* Sets the red channel of a color. Expects a value 0-255.  */
#define SetRed( rgb, r ) ( ((rgb)&0xFF00FFFF) | ( ((r)&0x0000FF)<<16 ) )
/* Return a CDATA that is meant for output to OpenGL. */
#define GLColor( c )  (((c)&0xFF00FF00)|(((c)&0xFF0000)>>16)|(((c)&0x0000FF)<<16))
/* Get the alpha value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define AlphaVal(color) (((color) >> 24) & 0xFF)
/* Get the red value of a color. This is a 0-255 unsigned byte. */
#define RedVal(color)   (((color) >> 16) & 0xFF)
/* Get the green value of a color. This is a 0-255 unsigned
   byte.                                                    */
#define GreenVal(color) (((color) >> 8) & 0xFF)
/* Get the blue value of a color. This is a 0-255 unsigned byte. */
#define BlueVal(color)  (((color)) & 0xFF)
#endif
 // IMAGE_LIBRARY_SOURCE
#endif
		/* a definition for a single color channel - for function replacements for ___Val macros*/
		typedef unsigned char COLOR_CHANNEL;
        /* a 4 byte array of color (not really used, we mostly went with CDATA and PCDATA instead of COLOR and PCOLOR */
		typedef COLOR_CHANNEL COLOR[4];
		// color data raw...
		typedef uint32_t CDATA;
		/* pointer to an array of 32 bit colors */
		typedef uint32_t *PCDATA;
		/* A Pointer to <link COLOR>. Probably an array of color (a
		 block of pixels for instance)                            */
		typedef COLOR *PCOLOR;
//-----------------------------------------------
// common color definitions....
//-----------------------------------------------
// both yellows need to be fixed.
#define BASE_COLOR_BLACK         Color( 0,0,0 )
#define BASE_COLOR_BLUE          Color( 0, 0, 128 )
#define BASE_COLOR_DARKBLUE          Color( 0, 0, 42 )
/* An opaque Green.
   See Also
   <link Colors>    */
#define BASE_COLOR_GREEN         Color( 0, 128, 0 )
/* An opaque cyan - kind of a light sky like blue.
   See Also
   <link Colors>                                   */
#define BASE_COLOR_CYAN          Color( 0, 128, 128 )
/* An opaque red.
   See Also
   <link Colors>  */
#define BASE_COLOR_RED           Color( 192, 32, 32 )
/* An opaque BROWN. Brown is dark yellow... so this might be
   more like a gold sort of color instead.
   See Also
   <link Colors>                                             */
#define BASE_COLOR_BROWN         Color( 140, 140, 0 )
#define BASE_COLOR_LIGHTBROWN         Color( 221, 221, 85 )
#define BASE_COLOR_MAGENTA       Color( 160, 0, 160 )
#define BASE_COLOR_LIGHTGREY     Color( 192, 192, 192 )
/* An opaque darker grey (gray?).
   See Also
   <link Colors>                  */
#define BASE_COLOR_DARKGREY      Color( 128, 128, 128 )
/* An opaque a bight or light color blue.
   See Also
   <link Colors>                          */
#define BASE_COLOR_LIGHTBLUE     Color( 0, 0, 255 )
/* An opaque lighter, brighter green color.
   See Also
   <link Colors>                            */
#define BASE_COLOR_LIGHTGREEN    Color( 0, 255, 0 )
/* An opaque a lighter, more bight cyan color.
   See Also
   <link Colors>                               */
#define BASE_COLOR_LIGHTCYAN     Color( 0, 255, 255 )
/* An opaque bright red.
   See Also
   <link Colors>         */
#define BASE_COLOR_LIGHTRED      Color( 255, 0, 0 )
/* An opaque Lighter pink sort of red-blue color.
   See Also
   <link Colors>                                  */
#define BASE_COLOR_LIGHTMAGENTA  Color( 255, 0, 255 )
/* An opaque bright yellow.
   See Also
   <link Colors>            */
#define BASE_COLOR_YELLOW        Color( 255, 255, 0 )
/* An opaque White.
   See Also
   <link Colors>    */
#define BASE_COLOR_WHITE         Color( 255, 255, 255 )
#define BASE_COLOR_ORANGE        Color( 204,96,7 )
#define BASE_COLOR_NICE_ORANGE   Color( 0xE9, 0x7D, 0x26 )
#define BASE_COLOR_PURPLE        Color( 0x7A, 0x11, 0x7C )
#ifdef __cplusplus
 //	 namespace image {
};
SACK_NAMESPACE_END
using namespace sack::image;
#endif
#endif
// $Log: colordef.h,v $
// Revision 1.4  2003/04/24 00:03:49  panther
// Added ColorAverage to image... Fixed a couple macros
//
// Revision 1.3  2003/03/25 08:38:11  panther
// Add logging
//
/* Defines a simple FRACTION type. Fractions are useful for
   scaling one value to another. These operations are handles
   continously. so iterating a fraction like 13 denominations of
   100 will be smooth.                                           */
#ifndef FRACTIONS_DEFINED
/* Multiple inclusion protection symbol. */
#define FRACTIONS_DEFINED
#ifdef __cplusplus
#  define _FRACTION_NAMESPACE namespace fraction {
#  define _FRACTION_NAMESPACE_END }
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE namespace math {
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END } } }
#else
#  define _FRACTION_NAMESPACE
#  define _FRACTION_NAMESPACE_END
#  ifndef _MATH_NAMESPACE
#    define _MATH_NAMESPACE
#  endif
#  define	 SACK_MATH_FRACTION_NAMESPACE_END
#endif
SACK_NAMESPACE
	/* Namespace of custom math routines.  Contains operators
	 for Vectors and fractions. */
	_MATH_NAMESPACE
	/* Fraction namespace contains a PFRACTION type which is used to
   store integer fraction values. Provides for ration and
   proportion scaling. Can also represent fractions that contain
   a whole part and a fractional part (5 2/3 : five and
	two-thirds).                                                  */
	_FRACTION_NAMESPACE
/* Define the call type of the function. */
#define FRACTION_API CPROC
#  ifdef FRACTION_SOURCE
#    define FRACTION_PROC EXPORT_METHOD
#  else
/* Define the library linkage for a these functions. */
#    define FRACTION_PROC IMPORT_METHOD
#  endif
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
/* Pointer to a <link sack::math::fraction::FRACTION, FRACTION>. */
/* The faction type. Stores a fraction as integer
   numerator/denominator instead of a floating point scalar. */
typedef struct fraction_tag {
	/* Numerator of the fraction. (This is the number on top of a
	   fraction.)                                                 */
	int numerator;
	/* Denominator of the fraction. (This is the number on bottom of
	   a fraction.) This specifies the denominations.                */
	int denominator;
} FRACTION, *PFRACTION;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct coordpair_tag {
	union {
		FRACTION x;
		FRACTION width;
	};
	union {
		FRACTION y;
		FRACTION height;
	};
} COORDPAIR, *PCOORDPAIR;
#else
/* A coordinate pair is a 2 dimensional fraction expression. can
   be regarded as x, y or width,height. Each coordiante is a
   Fraction type.                                                */
typedef struct coordpair_tag {
	       /* The x part of the coordpair. */
	       FRACTION x;
	       /* The y part of the coordpair. */
	       FRACTION y;
} COORDPAIR, *PCOORDPAIR;
#endif
/* \ \
   Parameters
   fraction :     the fraction to set
   numerator :    numerator of the fraction
   demoninator :  denominator of the fraction */
#define SetFraction(f,n,d) ((((f).numerator=((int)(n)) ),((f).denominator=((int)(d)))),(f))
/* Sets the value of a FRACTION. This is passed as the whole
   number and the fraction.
   Parameters
   fraction :  the fraction to set
   w :         this is the whole number to set
   n :         numerator of remainder to set
   d :         denominator of fraction to set.
   Example
   Fraction f = 3 1/2;
   <code lang="c++">
   FRACTION f;
   SetFractionV( f, 3, 1, 2 );
   // the resulting fraction will be 7/2
   </code>                                                   */
#define SetFractionV(f,w,n,d) (  (d)?	 ((((f).numerator=((int)((n)*(w))) )	  ,((f).denominator=((int)(d)))),(f))	  :	 ((((f).numerator=((int)((w))) )	  ,((f).denominator=((int)(1)))),(f))  )
/* \ \
   Parameters
   base :    origin point (content is modified by adding offset
             to it)
   offset :  offset point                                       */
FRACTION_PROC  void FRACTION_API  AddCoords ( PCOORDPAIR base, PCOORDPAIR offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  AddFractions ( PFRACTION base, PFRACTION offset );
/* Add one fraction to another.
   Parameters
   base :    This is the starting value, and recevies the result
             of (base+offset)
   offset :  This is the fraction to add to base.
   Returns
   base                                                          */
FRACTION_PROC  PFRACTION FRACTION_API  SubtractFractions ( PFRACTION base, PFRACTION offset );
/* NOT IMPLEMENTED */
FRACTION_PROC  PFRACTION FRACTION_API  MulFractions ( PFRACTION f, PFRACTION x );
/* Log a fraction into a string. */
FRACTION_PROC  int FRACTION_API  sLogFraction ( TEXTCHAR *string, PFRACTION x );
/* Unsafe log of a coordinate pair's value into a string. The
   string should be at least 69 characters long.
   Parameters
   string :  the string to print the fraction into
   pcp :     the coordinate pair to print                     */
FRACTION_PROC  int FRACTION_API  sLogCoords ( TEXTCHAR *string, PCOORDPAIR pcp );
/* Log coordpair to logfile. */
FRACTION_PROC  void FRACTION_API  LogCoords ( PCOORDPAIR pcp );
/* scales a fraction by a signed integer value.
   Parameters
   result\ :  pointer to a FRACTION to receive the result
   value :    the amount to be scaled
   f :        the fraction to multiply the value by
   Returns
   \result; the pointer the fraction to receive the result. */
FRACTION_PROC  PFRACTION FRACTION_API  ScaleFraction ( PFRACTION result, int32_t value, PFRACTION f );
/* Results in the integer part of the fraction. If the faction
   was 330/10 then the result would be 33.                     */
FRACTION_PROC  int32_t FRACTION_API  ReduceFraction ( PFRACTION f );
/* Scales a 32 bit integer value by a fraction. The result is
   the scaled value result.
   Parameters
   f :      pointer to the faction to multiply value by
   value :  the value to scale
   Returns
   The (value * f) integer value of.                          */
FRACTION_PROC  uint32_t FRACTION_API  ScaleValue ( PFRACTION f, int32_t value );
/* \ \
   Parameters
   f :      The fraction to scale the value by
   value :  the value to scale by (1/f)
   Returns
   the value of ( value * 1/ f )               */
FRACTION_PROC  uint32_t FRACTION_API  InverseScaleValue ( PFRACTION f, int32_t value );
	SACK_MATH_FRACTION_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::math::fraction;
#endif
#endif
//---------------------------------------------------------------------------
// $Log: fractions.h,v $
// Revision 1.6  2004/09/03 14:43:40  d3x0r
// flexible frame reactions to font changes...
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.4  2003/01/27 09:45:03  panther
// Fix lack of anonymous structures
//
// Revision 1.3  2002/10/09 13:16:02  panther
// Support for linux shared memory mapping.
// Support for better linux compilation of configuration scripts...
// Timers library is now Threads AND Timers.
//
//
#ifdef CONFIGURATION_LIBRARY_SOURCE
#define CONFIGSCR_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define CONFIGSCR_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace config {
#endif
typedef char *__arg_list[1];
typedef __arg_list arg_list;
// declare 'va_list args = NULL;' to use successfully...
// the resulting thing is of type va_list.
typedef struct va_args_tag va_args;
enum configArgType {
	CONFIG_ARG_STRING,
	CONFIG_ARG_INT64,
	CONFIG_ARG_FLOAT,
	CONFIG_ARG_DATA,
	CONFIG_ARG_DATA_SIZE,
	CONFIG_ARG_LOGICAL,
	CONFIG_ARG_FRACTION,
	CONFIG_ARG_COLOR,
};
struct va_args_tag {
	int argsize; arg_list *args; arg_list *tmp_args; int argCount;
};
//#define va_args struct { int argsize; arg_list *args; arg_list *tmp_args; }
#define init_args(name) name.argCount = 0; name.argsize = 0; name.args = NULL;
  // 32 bits.
#define ARG_STACK_SIZE 4
#define PushArgument( argset, argType, type, arg )	 ((argset.args = (arg_list*)Preallocate( argset.args		  , argset.argsize += ((sizeof( enum configArgType )				 + sizeof( type )				  + (ARG_STACK_SIZE-1) )&-ARG_STACK_SIZE) ) )	 ?(argset.argCount++),((*(enum configArgType*)(argset.args))=(argType)),(*(type*)(((uintptr_t)argset.args)+sizeof(enum configArgType)) = (arg)),0	   :0)
#define PopArguments( argset ) { Release( argset.args ); argset.args=NULL; }
#define pass_args(argset) (( (argset).tmp_args = (argset).args ),(*(arg_list*)(&argset.tmp_args)))
/*
 * Config methods are passed an arg_list
 * parameters from arg_list are retrieved using
 * PARAM( arg_list_param_name, arg_type, arg_name );
 * ex.
 *
 *   PARAM( args, char *, name );
 *    // results in a variable called name
 *    // initialized from the first argument in arg_list args;
 */
#define my_va_arg(ap,type)     ((ap)[0]+=        ((sizeof(enum configArgType)+sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)),        (*(type *)((ap)[0]-((sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
#define my_va_arg_type(ap,type)     (         (*(type *)((ap)[0]-(sizeof(enum configArgType)+(sizeof(type)+ARG_STACK_SIZE-1)&~(ARG_STACK_SIZE-1)))))
//#define my_va_next_arg_type(ap,type)     (*(type *)((ap)[0]))
#define my_va_next_arg_type(ap)     ( ( *(enum configArgType *)((ap)[0]) ) )
#define PARAM_COUNT( args ) (((int*)(args+1))[0])
#define PARAM( args, type, name ) type name = my_va_arg( args, type )
#define PARAMEX( args, type, name, argTypeName ) type name = my_va_arg( args, type ); enum configArgType argTypeName = my_va_arg_type(args)
#define FP_PARAM( args, type, name, fa ) type (CPROC*name)fa = (type (CPROC*)fa)(my_va_arg( args, void *))
typedef struct config_file_tag* PCONFIG_HANDLER;
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void );
#define CreateConfigurationHandler CreateConfigurationEvaluator
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch );
#define DestroyConfigurationHandler DestroyConfigurationEvaluator
// this pushes all prior state information about configuration file
// processing, and allows a new set of rules to be made...
CONFIGSCR_PROC( void, BeginConfiguration )( PCONFIG_HANDLER pch );
// begins a sub configuration, and marks to save it for future use
// so we don't have to always recreate the configuration states...
CONFIGSCR_PROC( LOGICAL, BeginNamedConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR name );
// then, when you're done with the new set of rules (end of config section)
// use this to restore the prior configuration state.
CONFIGSCR_PROC( void, EndConfiguration )( PCONFIG_HANDLER pch );
typedef uintptr_t (CPROC*USER_CONFIG_HANDLER)( uintptr_t, arg_list args );
typedef uintptr_t( CPROC*USER_CONFIG_HANDLER_EX )(uintptr_t, uintptr_t, arg_list args);
CONFIGSCR_PROC( void, AddConfigurationEx )( PCONFIG_HANDLER pch
														, CTEXTSTR format
														, USER_CONFIG_HANDLER Process DBG_PASS );
CONFIGSCR_PROC( void, AddConfigurationExx )(PCONFIG_HANDLER pch
	, CTEXTSTR format
	, USER_CONFIG_HANDLER_EX Process, uintptr_t processHandler DBG_PASS);
//CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch
//					, char *format
//													 , USER_CONFIG_HANDLER Process );
// make a nice wrapper - otherwise we get billions of complaints.
//#define AddConfiguration(pch,format,process) AddConfiguration( (pch), (format), process )
#define AddConfiguration(pch,f,pr) AddConfigurationEx(pch,f,pr DBG_SRC )
#define AddConfigurationMethod AddConfiguration
// FILTER receives a uintptr_t that was given at configuration (addition to handler)
// it receives a PTEXT block of (binary) data... and must result with
// PTEXT segments which are lines which may or may not have \r\n\\ all
// of which are removed before being resulted to the application.
//   POINTER* is a pointer to a pointer, this pointer may be used
//      for private state data.  The last line of the configuration will
//      call the filter chain with NULL to flush data...
typedef PTEXT (CPROC*USER_FILTER)( POINTER *, PTEXT );
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter );
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch );
CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch, uintptr_t (CPROC *Process)( uintptr_t ) );
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) );
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch
															  , CTEXTSTR name
															  , uintptr_t psv
															  );
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR block, size_t size, uintptr_t psv );
/*
 * TO BE IMPLEMENTED
 *
CONFIGSCR_PROC( int, vcsprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, va_list args );
CONFIGSCR_PROC( int, csprintf )( PCONFIG_HANDLER pch, CTEXTSTR format, ... );
*/
CONFIGSCR_PROC( int, GetBooleanVar )( PTEXT *start, LOGICAL *data );
CONFIGSCR_PROC( int, GetColorVar )( PTEXT *start, CDATA *data );
//CONFIGSCR_PROC( int, IsBooleanVar )( PCONFIG_ELEMENT pce, PTEXT *start );
//CONFIGSCR_PROC( int, IsColorVar )( PCONFIG_ELEMENT pce, PTEXT *start );
// takes a binary block of data and creates a base64-like string which may be stored.
CONFIGSCR_PROC( void, EncodeBinaryConfig )( TEXTSTR *encode, POINTER data, size_t length );
// this isn't REALLY the same function that's used, but serves the same purpose...
CONFIGSCR_PROC( int, DecodeBinaryConfig )( CTEXTSTR String, POINTER *binary_buffer, size_t *buflen );
CONFIGSCR_PROC( CTEXTSTR, FormatColor )( CDATA color );
CONFIGSCR_PROC( void, StripConfigString )( TEXTSTR out, CTEXTSTR in );
CONFIGSCR_PROC( void, ExpandConfigString )( TEXTSTR out, CTEXTSTR in );
#ifdef __cplusplus
//typedef uintptr_t CPROC ::(*USER_CONFIG_METHOD)( ... );
typedef class config_reader {
   PCONFIG_HANDLER pch;
public:
	config_reader() {
      pch = CreateConfigurationEvaluator();
	}
	~config_reader() {
		if( pch ) DestroyConfigurationEvaluator( pch );
      pch = (PCONFIG_HANDLER)NULL;
	}
	inline void add( CTEXTSTR format, USER_CONFIG_HANDLER Process )
	{
      AddConfiguration( pch, format, Process );
	}
   /*
	inline void add( char *format, USER_CONFIG_METHOD Process )
	{
		union {
			struct {
				uint32_t junk;
            USER_CONFIG_HANDLER Process
			} c;
         USER_CONFIG_METHOD Process;
		} x;
      x.Process = Process;
      AddConfiguration( pch, format, x.c.Process );
		}
      */
	inline int go( CTEXTSTR file, POINTER p )
	{
		return ProcessConfigurationFile( pch, file, (uintptr_t)p );
	}
} CONFIG_READER;
#endif
#ifdef __cplusplus
 //namespace sack { namespace config {
}
SACK_NAMESPACE_END
using namespace sack::config;
#endif
#endif
// $Log: configscript.h,v $
// Revision 1.17  2004/12/05 15:32:06  panther
// Some minor cleanups fixed a couple memory leaks
//
// Revision 1.16  2004/08/13 16:48:19  d3x0r
// added ability to put filters on config script data read.
//
// Revision 1.15  2004/02/18 20:46:37  d3x0r
// Add some aliases for badly named routines
//
// Revision 1.14  2004/02/08 23:33:15  d3x0r
// Add a iList class for c++, public access to building parameter va_lists
//
// Revision 1.13  2003/12/09 16:15:56  panther
// Define unhnalded callback set
//
// Revision 1.12  2003/11/09 22:31:58  panther
// Fix CPROC indication on endconfig method
//
// Revision 1.11  2003/10/13 04:25:14  panther
// Fix configscript library... make sure types are consistant (watcom)
//
// Revision 1.10  2003/10/12 02:47:05  panther
// Cleaned up most var-arg stack abuse ARM seems to work.
//
// Revision 1.9  2003/09/24 02:53:58  panther
// Define c++ wrapper for config script library
//
// Revision 1.8  2003/07/24 22:49:01  panther
// Modify addconfig method macro to auto typecast - dangerous by simpler
//
// Revision 1.7  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.6  2003/04/17 09:32:51  panther
// Added true/false result from processconfigfile.  Added default load from /etc to msgsvr and display
//
// Revision 1.5  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef SALTY_RANDOM_GENERATOR_SOURCE
#define SALTY_RANDOM_GENERATOR_SOURCE
#endif
static struct crypt_local
{
	char * use_salt;
	struct random_context *entropy;
} crypt_local;
static void FeedSalt( uintptr_t psv, POINTER *salt, size_t *salt_size )
{
	if( crypt_local.use_salt)
	{
		(*salt) = crypt_local.use_salt;
		(*salt_size) = 4;
	}
	else
	{
		static uint32_t tick;
		tick = timeGetTime();
		(*salt) = &tick;
		(*salt_size) = 4;
	}
}
void SRG_DecryptRawData( CPOINTER binary, size_t length, uint8_t* *buffer, size_t *chars )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, (uintptr_t)0 );
	{
		uint32_t mask;
		uint8_t* pass_byte_in;
		uint8_t* pass_byte_out;
		int index;
		//if( length < chars )
		{
			SRG_ResetEntropy( crypt_local.entropy );
			crypt_local.use_salt = (char *)binary;
			pass_byte_in = ((uint8_t*)binary) + 4;
			length -= 4;
			(*buffer) = NewArray( uint8_t, length );
			pass_byte_out = (*buffer);
			for( index = 0; length; length--, index++ )
			{
				if( ( index & 3 ) == 0 )
					mask = SRG_GetEntropy( crypt_local.entropy, 32, FALSE );
				pass_byte_out[0] = pass_byte_in[0] ^ ((uint8_t*)&mask)[ index & 0x3 ];
				pass_byte_out++;
				pass_byte_in++;
			}
			(*chars) = pass_byte_out - (*buffer);
		}
	}
}
void SRG_DecryptData( CTEXTSTR local_password, uint8_t* *buffer, size_t *chars )
{
	{
		POINTER binary;
		size_t length;
		if( local_password && DecodeBinaryConfig( local_password, &binary, &length ) )
		{
			SRG_DecryptRawData( (uint8_t*)binary, length, buffer, chars );
		}
		else
		{
			(*buffer) = 0;
			(*chars) = 0;
			//lprintf( WIDE("failed to decode data") );
		}
	}
}
TEXTSTR SRG_DecryptString( CTEXTSTR local_password )
{
	uint8_t* buffer;
	size_t chars;
	SRG_DecryptData( local_password, &buffer, &chars );
	return (TEXTSTR)buffer;
}
void SRG_EncryptRawData( CPOINTER buffer, size_t buflen, uint8_t* *result_buf, size_t *result_size )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, 0 );
	{
		{
			uint32_t mask;
			uint32_t seed;
			uint8_t* pass_byte_in;
			uint8_t* pass_byte_out;
			int index;
			uint8_t* tmpbuf;
			crypt_local.use_salt = NULL;
			(*result_buf) = tmpbuf = NewArray( uint8_t, buflen + 4 );
			(*result_size) = buflen + 4;
			SRG_ResetEntropy( crypt_local.entropy );
			seed = (uint32_t)GetCPUTick();
			tmpbuf[0] = ((seed >> 17) & 0xFF) ^ ((seed >> 8) & 0xFF);
			tmpbuf[1] = ((seed >> 11) & 0xFF) ^ ((seed >> 4) & 0xFF);
			tmpbuf[2] = ((seed >> 5) & 0xFF) ^ ((seed >> 12) & 0xFF);
			tmpbuf[3] = ((seed >> 0) & 0xFF) ^ ((seed >> 13) & 0xFF);
			crypt_local.use_salt = (char*)tmpbuf;
			SRG_ResetEntropy( crypt_local.entropy );
			pass_byte_in = ((uint8_t*)buffer);
			pass_byte_out = (uint8_t*)tmpbuf + 4;
			for( index = 0; buflen; buflen--, index++ )
			{
				if( ( index & 3 ) == 0 )
					mask = SRG_GetEntropy( crypt_local.entropy, 32, FALSE );
				pass_byte_out[0] = pass_byte_in[0] ^ ((uint8_t*)&mask)[ index & 0x3 ];
				pass_byte_out++;
				pass_byte_in++;
			}
		}
	}
}
TEXTCHAR * SRG_EncryptData( CPOINTER buffer, size_t buflen )
{
	if( !crypt_local.entropy )
		crypt_local.entropy = SRG_CreateEntropy( FeedSalt, 0 );
	{
		uint8_t* result_buf;
		size_t result_size;
		TEXTSTR tmpbuf;
		SRG_EncryptRawData( buffer, buflen, &result_buf, &result_size );
		EncodeBinaryConfig( &tmpbuf, result_buf, buflen + 4 );
		return tmpbuf;
	}
	return NULL;
}
TEXTSTR SRG_EncryptString( CTEXTSTR buffer )
{
	return SRG_EncryptData( (uint8_t*)buffer, StrLen( buffer ) + 1 );
}
/* MD5C.C - RSA Data Security, Inc., MD5 message-digest algorithm
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#define MD5_SOURCE
/* MD5.H - header file for MD5C.C
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#ifndef MD5_ALGORITHM_DEFINED
#define MD5_ALGORITHM_DEFINED
#ifdef MD5_SOURCE
#define MD5_PROC(type,name) EXPORT_METHOD type name
#else
#define MD5_PROC(type,name) IMPORT_METHOD type name
#endif
/* MD5 context. */
typedef struct {
	uint32_t state[4];
	uint32_t count[2];
  unsigned char buffer[64];
} MD5_CTX;
MD5_PROC( void, MD5Init )(MD5_CTX *);
MD5_PROC( void, MD5Update )(MD5_CTX *, unsigned char *, unsigned int);
MD5_PROC( void, MD5Final )(unsigned char [16], MD5_CTX *);
#endif
/* Constants for MD5Transform routine.
 */
#define S11 7
#define S12 12
#define S13 17
#define S14 22
#define S21 5
#define S22 9
#define S23 14
#define S24 20
#define S31 4
#define S32 11
#define S33 16
#define S34 23
#define S41 6
#define S42 10
#define S43 15
#define S44 21
static void MD5Transform (uint32_t [4], unsigned char [64]);
static void Encode (unsigned char *, uint32_t *, unsigned int);
static void Decode (uint32_t *, unsigned char *, unsigned int);
static void MD5_memcpy (uint8_t*, uint8_t*, unsigned int);
static void MD5_memset (uint8_t*, int, unsigned int);
static unsigned char PADDING[64] = {
  0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
/* F, G, H and I are basic MD5 functions.
 */
#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))
/* ROTATE_LEFT rotates x left n bits.
 */
#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32-(n))))
/* FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4.
Rotation is separate from addition to prevent recomputation.
 */
#define FF(a, b, c, d, x, s, ac) {  (a) += F ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define GG(a, b, c, d, x, s, ac) {  (a) += G ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define HH(a, b, c, d, x, s, ac) {  (a) += H ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
#define II(a, b, c, d, x, s, ac) {  (a) += I ((b), (c), (d)) + (x) + (uint32_t)(ac);  (a) = ROTATE_LEFT ((a), (s));  (a) += (b);   }
/* MD5 initialization. Begins an MD5 operation, writing a new context.
 */
MD5_PROC( void, MD5Init )( MD5_CTX *context )
{
  context->count[0] = context->count[1] = 0;
  /* Load magic initialization constants.
*/
  context->state[0] = 0x67452301;
  context->state[1] = 0xefcdab89;
  context->state[2] = 0x98badcfe;
  context->state[3] = 0x10325476;
}
/* MD5 block update operation. Continues an MD5 message-digest
  operation, processing another message block, and updating the
  context.
 */
MD5_PROC( void, MD5Update ) ( MD5_CTX *context
									 , unsigned char *input
									 , unsigned int inputLen)
{
  unsigned int i, index, partLen;
  /* Compute number of bytes mod 64 */
  index = (unsigned int)((context->count[0] >> 3) & 0x3F);
  /* Update number of bits */
  if ((context->count[0] += ((uint32_t)inputLen << 3))
   < ((uint32_t)inputLen << 3))
 context->count[1]++;
  context->count[1] += ((uint32_t)inputLen >> 29);
  partLen = 64 - index;
  /* Transform as many times as possible.
*/
  if (inputLen >= partLen) {
 MD5_memcpy
   ((uint8_t*)&context->buffer[index], (uint8_t*)input, partLen);
 MD5Transform (context->state, context->buffer);
 for (i = partLen; i + 63 < inputLen; i += 64)
   MD5Transform (context->state, &input[i]);
 index = 0;
  }
  else
 i = 0;
  /* Buffer remaining input */
  MD5_memcpy
 ((uint8_t*)&context->buffer[index], (uint8_t*)&input[i],
  inputLen-i);
}
/* MD5 finalization. Ends an MD5 message-digest operation, writing the
  the message digest and zeroizing the context.
 */
MD5_PROC( void, MD5Final )(unsigned char *digest, MD5_CTX *context)
{
  unsigned char bits[8];
  unsigned int index, padLen;
  /* Save number of bits */
  Encode (bits, context->count, 8);
  /* Pad out to 56 mod 64.
*/
  index = (unsigned int)((context->count[0] >> 3) & 0x3f);
  padLen = (index < 56) ? (56 - index) : (120 - index);
  MD5Update (context, PADDING, padLen);
  /* Append length (before padding) */
  MD5Update (context, bits, 8);
  /* Store state in digest */
  Encode (digest, context->state, 16);
  /* Zeroize sensitive information.
*/
  MD5_memset ((uint8_t*)context, 0, sizeof (*context));
}
/* MD5 basic transformation. Transforms state based on block.
 */
static void MD5Transform (uint32_t state[4], unsigned char block[64])
{
  uint32_t a = state[0], b = state[1], c = state[2], d = state[3], x[16];
  Decode (x, block, 64);
  /* Round 1 */
  FF (a, b, c, d, x[ 0], S11, 0xd76aa478);
  FF (d, a, b, c, x[ 1], S12, 0xe8c7b756);
  FF (c, d, a, b, x[ 2], S13, 0x242070db);
  FF (b, c, d, a, x[ 3], S14, 0xc1bdceee);
  FF (a, b, c, d, x[ 4], S11, 0xf57c0faf);
  FF (d, a, b, c, x[ 5], S12, 0x4787c62a);
  FF (c, d, a, b, x[ 6], S13, 0xa8304613);
  FF (b, c, d, a, x[ 7], S14, 0xfd469501);
  FF (a, b, c, d, x[ 8], S11, 0x698098d8);
  FF (d, a, b, c, x[ 9], S12, 0x8b44f7af);
  FF (c, d, a, b, x[10], S13, 0xffff5bb1);
  FF (b, c, d, a, x[11], S14, 0x895cd7be);
  FF (a, b, c, d, x[12], S11, 0x6b901122);
  FF (d, a, b, c, x[13], S12, 0xfd987193);
  FF (c, d, a, b, x[14], S13, 0xa679438e);
  FF (b, c, d, a, x[15], S14, 0x49b40821);
 /* Round 2 */
  GG (a, b, c, d, x[ 1], S21, 0xf61e2562);
  GG (d, a, b, c, x[ 6], S22, 0xc040b340);
  GG (c, d, a, b, x[11], S23, 0x265e5a51);
  GG (b, c, d, a, x[ 0], S24, 0xe9b6c7aa);
  GG (a, b, c, d, x[ 5], S21, 0xd62f105d);
  GG (d, a, b, c, x[10], S22,  0x2441453);
  GG (c, d, a, b, x[15], S23, 0xd8a1e681);
  GG (b, c, d, a, x[ 4], S24, 0xe7d3fbc8);
  GG (a, b, c, d, x[ 9], S21, 0x21e1cde6);
  GG (d, a, b, c, x[14], S22, 0xc33707d6);
  GG (c, d, a, b, x[ 3], S23, 0xf4d50d87);
  GG (b, c, d, a, x[ 8], S24, 0x455a14ed);
  GG (a, b, c, d, x[13], S21, 0xa9e3e905);
  GG (d, a, b, c, x[ 2], S22, 0xfcefa3f8);
  GG (c, d, a, b, x[ 7], S23, 0x676f02d9);
  GG (b, c, d, a, x[12], S24, 0x8d2a4c8a);
  /* Round 3 */
  HH (a, b, c, d, x[ 5], S31, 0xfffa3942);
  HH (d, a, b, c, x[ 8], S32, 0x8771f681);
  HH (c, d, a, b, x[11], S33, 0x6d9d6122);
  HH (b, c, d, a, x[14], S34, 0xfde5380c);
  HH (a, b, c, d, x[ 1], S31, 0xa4beea44);
  HH (d, a, b, c, x[ 4], S32, 0x4bdecfa9);
  HH (c, d, a, b, x[ 7], S33, 0xf6bb4b60);
  HH (b, c, d, a, x[10], S34, 0xbebfbc70);
  HH (a, b, c, d, x[13], S31, 0x289b7ec6);
  HH (d, a, b, c, x[ 0], S32, 0xeaa127fa);
  HH (c, d, a, b, x[ 3], S33, 0xd4ef3085);
  HH (b, c, d, a, x[ 6], S34,  0x4881d05);
  HH (a, b, c, d, x[ 9], S31, 0xd9d4d039);
  HH (d, a, b, c, x[12], S32, 0xe6db99e5);
  HH (c, d, a, b, x[15], S33, 0x1fa27cf8);
  HH (b, c, d, a, x[ 2], S34, 0xc4ac5665);
  /* Round 4 */
  II (a, b, c, d, x[ 0], S41, 0xf4292244);
  II (d, a, b, c, x[ 7], S42, 0x432aff97);
  II (c, d, a, b, x[14], S43, 0xab9423a7);
  II (b, c, d, a, x[ 5], S44, 0xfc93a039);
  II (a, b, c, d, x[12], S41, 0x655b59c3);
  II (d, a, b, c, x[ 3], S42, 0x8f0ccc92);
  II (c, d, a, b, x[10], S43, 0xffeff47d);
  II (b, c, d, a, x[ 1], S44, 0x85845dd1);
  II (a, b, c, d, x[ 8], S41, 0x6fa87e4f);
  II (d, a, b, c, x[15], S42, 0xfe2ce6e0);
  II (c, d, a, b, x[ 6], S43, 0xa3014314);
  II (b, c, d, a, x[13], S44, 0x4e0811a1);
  II (a, b, c, d, x[ 4], S41, 0xf7537e82);
  II (d, a, b, c, x[11], S42, 0xbd3af235);
  II (c, d, a, b, x[ 2], S43, 0x2ad7d2bb);
  II (b, c, d, a, x[ 9], S44, 0xeb86d391);
  state[0] += a;
  state[1] += b;
  state[2] += c;
  state[3] += d;
  /* Zeroize sensitive information.
   */
  MD5_memset ((uint8_t*)x, 0, sizeof (x));
}
/* Encodes input (uint32_t) into output (unsigned char). Assumes len is
  a multiple of 4.
 */
static void Encode (unsigned char *output, uint32_t *input, unsigned int len)
{
  unsigned int i, j;
  for (i = 0, j = 0; j < len; i++, j += 4) {
 output[j] = (unsigned char)(input[i] & 0xff);
 output[j+1] = (unsigned char)((input[i] >> 8) & 0xff);
 output[j+2] = (unsigned char)((input[i] >> 16) & 0xff);
 output[j+3] = (unsigned char)((input[i] >> 24) & 0xff);
  }
}
/* Decodes input (unsigned char) into output (uint32_t). Assumes len is
  a multiple of 4.
 */
static void Decode (uint32_t *output, unsigned char *input, unsigned int len)
{
  unsigned int i, j;
  for (i = 0, j = 0; j < len; i++, j += 4)
 output[i] = ((uint32_t)input[j]) | (((uint32_t)input[j+1]) << 8) |
   (((uint32_t)input[j+2]) << 16) | (((uint32_t)input[j+3]) << 24);
}
/* Note: Replace "for loop" with standard memcpy if possible.
 */
static void MD5_memcpy (uint8_t* output, uint8_t* input, unsigned int len)
{
  unsigned int i;
  for (i = 0; i < len; i++)
    output[i] = input[i];
}
/* Note: Replace "for loop" with standard memset if possible.
 */
static void MD5_memset (uint8_t* output, int value, unsigned int len)
{
  unsigned int i;
  for (i = 0; i < len; i++)
 ((char *)output)[i] = (char)value;
}
/*
 *  sha1.c
 *
 *  Description:
 *      This file implements the Secure Hashing Algorithm 1 as
 *      defined in FIPS PUB 180-1 published April 17, 1995.
 *
 *      The SHA-1, produces a 160-bit message digest for a given
 *      data stream.  It should take about 2**n steps to find a
 *      message with the same digest as a given message and
 *      2**(n/2) to find any two messages with the same digest,
 *      when n is the digest size in bits.  Therefore, this
 *      algorithm can serve as a means of providing a
 *      "fingerprint" for a message.
 *
 *  Portability Issues:
 *      SHA-1 is defined in terms of 32-bit "words".  This code
 *      uses <stdint.h> (included via "sha1.h" to define 32 and 8
 *      bit unsigned integer types.  If your C compiler does not
 *      support 32 bit unsigned integers, this code is not
 *      appropriate.
 *
 *  Caveats:
 *      SHA-1 is designed to work with messages less than 2^64 bits
 *      long.  Although SHA-1 allows a message digest to be generated
 *      for messages of any number of bits less than 2^64, this
 *      implementation only works with messages with a length that is
 *      a multiple of the size of an 8-bit character.
 *
 */
/*
 *  sha1.h
 *
 *  Description:
 *      This is the header file for code which implements the Secure
 *      Hashing Algorithm 1 as defined in FIPS PUB 180-1 published
 *      April 17, 1995.
 *
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the names
 *      used in the publication.
 *
 *      Please read the file sha1.c for more information.
 *
 */
#ifndef _SHA1_H_
#define _SHA1_H_
#ifdef SHA1_SOURCE
#define SHA1_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SHA1_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#if !defined(  HAS_STDINT )
#ifndef __WATCOMC__
	typedef unsigned long uint32_t;
	typedef short int_least16_t;
	typedef unsigned char uint8_t;
#else
#endif
//typedef unsigned char uint8_t;
//typedef int int_least16_t;
#endif
/*
 * If you do not have the ISO standard stdint.h header file, then you
 * must typdef the following:
 *    name              meaning
 *  uint32_t         unsigned 32 bit integer
 *  uint8_t          unsigned 8 bit integer (i.e., unsigned char)
 *  int_least16_t    integer of >= 16 bits
 *
 */
#ifndef _SHA_enum_
#define _SHA_enum_
enum
{
    shaSuccess = 0,
    shaNull,
    shaInputTooLong,
    shaStateError
};
#endif
#define SHA1HashSize 20
/*
 *  This structure will hold context information for the SHA-1
 *  hashing operation
 */
typedef struct SHA1Context
{
    uint32_t Intermediate_Hash[SHA1HashSize/4];
    uint32_t Length_Low;
    uint32_t Length_High;
                               /* Index into message block array   */
    int_least16_t Message_Block_Index;
    uint8_t Message_Block[64];
    int Computed;
    int Corrupted;
} SHA1Context;
/*
 *  Function Prototypes
 */
SHA1_PROC( int, SHA1Reset )(  SHA1Context *);
SHA1_PROC( int, SHA1Input )(  SHA1Context *,
                const uint8_t *,
                size_t);
SHA1_PROC( int, SHA1Result )( SHA1Context *,
                uint8_t Message_Digest[SHA1HashSize]);
#endif
// $Log: $
#ifndef SHA1HashSize
#define SHA1Context SHA1_CTX
#endif
/*
 *  Define the SHA1 circular left shift macro
 */
#define SHA1CircularShift(bits,word)                 (((word) << (bits)) | ((word) >> (32-(bits))))
/* Local Function Prototyptes */
void SHA1PadMessage(SHA1Context *);
void SHA1ProcessMessageBlock(SHA1Context *);
/*
 *  SHA1Reset
 *
 *  Description:
 *      This function will initialize the SHA1Context in preparation
 *      for computing a new SHA1 message digest.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to reset.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Reset(SHA1Context *context)
{
    if (!context)
    {
        return shaNull;
    }
    context->Length_Low             = 0;
    context->Length_High            = 0;
    context->Message_Block_Index    = 0;
    context->Intermediate_Hash[0]   = 0x67452301;
    context->Intermediate_Hash[1]   = 0xEFCDAB89;
    context->Intermediate_Hash[2]   = 0x98BADCFE;
    context->Intermediate_Hash[3]   = 0x10325476;
    context->Intermediate_Hash[4]   = 0xC3D2E1F0;
    context->Computed   = 0;
    context->Corrupted  = 0;
    return shaSuccess;
}
/*
 *  SHA1Result
 *
 *  Description:
 *      This function will return the 160-bit message digest into the
 *      Message_Digest array  provided by the caller.
 *      NOTE: The first octet of hash is stored in the 0th element,
 *            the last octet of hash in the 19th element.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to use to calculate the SHA-1 hash.
 *      Message_Digest: [out]
 *          Where the digest is returned.
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Result( SHA1Context *context,
                uint8_t Message_Digest[SHA1HashSize])
{
    int i;
    if (!context || !Message_Digest)
    {
        return shaNull;
    }
    if (context->Corrupted)
    {
        return context->Corrupted;
    }
    if (!context->Computed)
    {
        SHA1PadMessage(context);
        for(i=0; i<64; ++i)
        {
            /* message may be sensitive, clear it out */
            context->Message_Block[i] = 0;
        }
        context->Length_Low = 0;
        context->Length_High = 0;
        context->Computed = 1;
    }
    for(i = 0; i < SHA1HashSize; ++i)
    {
        Message_Digest[i] = (uint8_t)(context->Intermediate_Hash[i>>2]
                            >> 8 * ( 3 - ( i & 0x03 ) ));
    }
    return shaSuccess;
}
/*
 *  SHA1Input
 *
 *  Description:
 *      This function accepts an array of octets as the next portion
 *      of the message.
 *
 *  Parameters:
 *      context: [in/out]
 *          The SHA context to update
 *      message_array: [in]
 *          An array of characters representing the next portion of
 *          the message.
 *      length: [in]
 *          The length of the message in message_array
 *
 *  Returns:
 *      sha Error Code.
 *
 */
int SHA1Input(    SHA1Context    *context,
                  const uint8_t  *message_array,
                  size_t       length)
{
    if (!length)
    {
        return shaSuccess;
    }
    if (!context || !message_array)
    {
        return shaNull;
    }
    if (context->Computed)
    {
        context->Corrupted = shaStateError;
        return shaStateError;
    }
    if (context->Corrupted)
    {
         return context->Corrupted;
    }
    while(length-- && !context->Corrupted)
    {
    context->Message_Block[context->Message_Block_Index++] =
                    (*message_array & 0xFF);
    context->Length_Low += 8;
    if (context->Length_Low == 0)
    {
        context->Length_High++;
        if (context->Length_High == 0)
        {
            /* Message is too long */
            context->Corrupted = 1;
        }
    }
    if (context->Message_Block_Index == 64)
    {
        SHA1ProcessMessageBlock(context);
    }
    message_array++;
    }
    return shaSuccess;
}
/*
 *  SHA1ProcessMessageBlock
 *
 *  Description:
 *      This function will process the next 512 bits of the message
 *      stored in the Message_Block array.
 *
 *  Parameters:
 *      None.
 *
 *  Returns:
 *      Nothing.
 *
 *  Comments:
 *      Many of the variable names in this code, especially the
 *      single character names, were used because those were the
 *      names used in the publication.
 *
 *
 */
void SHA1ProcessMessageBlock(SHA1Context *context)
{
    const uint32_t K[] =    {
                            0x5A827999,
                            0x6ED9EBA1,
                            0x8F1BBCDC,
                            0xCA62C1D6
                            };
    int           t;
    uint32_t      temp;
    uint32_t      W[80];
    uint32_t      A, B, C, D, E;
    /*
     *  Initialize the first 16 words in the array W
     */
    for(t = 0; t < 16; t++)
    {
        W[t] = context->Message_Block[t * 4] << 24;
        W[t] |= context->Message_Block[t * 4 + 1] << 16;
        W[t] |= context->Message_Block[t * 4 + 2] << 8;
        W[t] |= context->Message_Block[t * 4 + 3];
    }
    for(t = 16; t < 80; t++)
    {
       W[t] = SHA1CircularShift(1,W[t-3] ^ W[t-8] ^ W[t-14] ^ W[t-16]);
    }
    A = context->Intermediate_Hash[0];
    B = context->Intermediate_Hash[1];
    C = context->Intermediate_Hash[2];
    D = context->Intermediate_Hash[3];
    E = context->Intermediate_Hash[4];
    for(t = 0; t < 20; t++)
    {
        temp =  SHA1CircularShift(5,A) +
                ((B & C) | ((~B) & D)) + E + W[t] + K[0];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 20; t < 40; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[1];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 40; t < 60; t++)
    {
        temp = SHA1CircularShift(5,A) +
               ((B & C) | (B & D) | (C & D)) + E + W[t] + K[2];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    for(t = 60; t < 80; t++)
    {
        temp = SHA1CircularShift(5,A) + (B ^ C ^ D) + E + W[t] + K[3];
        E = D;
        D = C;
        C = SHA1CircularShift(30,B);
        B = A;
        A = temp;
    }
    context->Intermediate_Hash[0] += A;
    context->Intermediate_Hash[1] += B;
    context->Intermediate_Hash[2] += C;
    context->Intermediate_Hash[3] += D;
    context->Intermediate_Hash[4] += E;
    context->Message_Block_Index = 0;
}
/*
 *  SHA1PadMessage
 *
 *  Description:
 *      According to the standard, the message must be padded to an even
 *      512 bits.  The first padding bit must be a '1'.  The last 64
 *      bits represent the length of the original message.  All bits in
 *      between should be 0.  This function will pad the message
 *      according to those rules by filling the Message_Block array
 *      accordingly.  It will also call the ProcessMessageBlock function
 *      provided appropriately.  When it returns, it can be assumed that
 *      the message digest has been computed.
 *
 *  Parameters:
 *      context: [in/out]
 *          The context to pad
 *      ProcessMessageBlock: [in]
 *          The appropriate SHA*ProcessMessageBlock function
 *  Returns:
 *      Nothing.
 *
 */
void SHA1PadMessage(SHA1Context *context)
{
    /*
     *  Check to see if the current message block is too small to hold
     *  the initial padding bits and length.  If so, we will pad the
     *  block, process it, and then continue padding into a second
     *  block.
     */
    if (context->Message_Block_Index > 55)
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 64)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
        SHA1ProcessMessageBlock(context);
        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    else
    {
        context->Message_Block[context->Message_Block_Index++] = 0x80;
        while(context->Message_Block_Index < 56)
        {
            context->Message_Block[context->Message_Block_Index++] = 0;
        }
    }
    /*
     *  Store the message length as the last 8 octets
     */
    context->Message_Block[56] = (uint8_t)(context->Length_High >> 24);
    context->Message_Block[57] = (uint8_t)(context->Length_High >> 16);
    context->Message_Block[58] = (uint8_t)(context->Length_High >> 8);
    context->Message_Block[59] = (uint8_t)(context->Length_High);
    context->Message_Block[60] = (uint8_t)(context->Length_Low >> 24);
    context->Message_Block[61] = (uint8_t)(context->Length_Low >> 16);
    context->Message_Block[62] = (uint8_t)(context->Length_Low >> 8);
    context->Message_Block[63] = (uint8_t)(context->Length_Low);
    SHA1ProcessMessageBlock(context);
}
// $Log: sha1.c,v $
// Revision 1.5  2003/05/13 09:14:08  panther
// Remove carriage returns
//
// Revision 1.4  2003/03/25 08:45:57  panther
// Added CVS logging tag
//
/*
 * FIPS 180-2 SHA-224/256/384/512 implementation
 * Last update: 02/02/2007
 * Issue date:  04/30/2005
 *
 * Copyright (C) 2005, 2007 Olivier Gay <olivier.gay@a3.epfl.ch>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#if 0
#define UNROLL_LOOPS
#endif
#define SHA2_SOURCE
#define SHFR(x, n)    (x >> n)
#define ROTR(x, n)   ((x >> n) | (x << ((sizeof(x) << 3) - n)))
#define ROTL(x, n)   ((x << n) | (x >> ((sizeof(x) << 3) - n)))
#define CH(x, y, z)  ((x & y) ^ (~x & z))
#define MAJ(x, y, z) ((x & y) ^ (x & z) ^ (y & z))
#define SHA256_F1(x) (ROTR(x,  2) ^ ROTR(x, 13) ^ ROTR(x, 22))
#define SHA256_F2(x) (ROTR(x,  6) ^ ROTR(x, 11) ^ ROTR(x, 25))
#define SHA256_F3(x) (ROTR(x,  7) ^ ROTR(x, 18) ^ SHFR(x,  3))
#define SHA256_F4(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ SHFR(x, 10))
#define SHA512_F1(x) (ROTR(x, 28) ^ ROTR(x, 34) ^ ROTR(x, 39))
#define SHA512_F2(x) (ROTR(x, 14) ^ ROTR(x, 18) ^ ROTR(x, 41))
#define SHA512_F3(x) (ROTR(x,  1) ^ ROTR(x,  8) ^ SHFR(x,  7))
#define SHA512_F4(x) (ROTR(x, 19) ^ ROTR(x, 61) ^ SHFR(x,  6))
#define UNPACK32(x, str)                      {                                                 *((str) + 3) = (uint8) ((x)      );           *((str) + 2) = (uint8) ((x) >>  8);           *((str) + 1) = (uint8) ((x) >> 16);           *((str) + 0) = (uint8) ((x) >> 24);       }
#define PACK32(str, x)                        {                                                 *(x) =   ((uint32) *((str) + 3)      )               | ((uint32) *((str) + 2) <<  8)               | ((uint32) *((str) + 1) << 16)               | ((uint32) *((str) + 0) << 24);   }
#define UNPACK64(x, str)                      {                                                 *((str) + 7) = (uint8) ((x)      );           *((str) + 6) = (uint8) ((x) >>  8);           *((str) + 5) = (uint8) ((x) >> 16);           *((str) + 4) = (uint8) ((x) >> 24);           *((str) + 3) = (uint8) ((x) >> 32);           *((str) + 2) = (uint8) ((x) >> 40);           *((str) + 1) = (uint8) ((x) >> 48);           *((str) + 0) = (uint8) ((x) >> 56);       }
#define PACK64(str, x)                        {                                                 *(x) =   ((uint64) *((str) + 7)      )               | ((uint64) *((str) + 6) <<  8)               | ((uint64) *((str) + 5) << 16)               | ((uint64) *((str) + 4) << 24)               | ((uint64) *((str) + 3) << 32)               | ((uint64) *((str) + 2) << 40)               | ((uint64) *((str) + 1) << 48)               | ((uint64) *((str) + 0) << 56);   }
/* Macros used for loops unrolling */
#define SHA256_SCR(i)                         {                                                 w[i] =  SHA256_F4(w[i -  2]) + w[i -  7]            + SHA256_F3(w[i - 15]) + w[i - 16]; }
#define SHA512_SCR(i)                         {                                                 w[i] =  SHA512_F4(w[i -  2]) + w[i -  7]            + SHA512_F3(w[i - 15]) + w[i - 16]; }
#define SHA256_EXP(a, b, c, d, e, f, g, h, j)               {                                                               t1 = wv[h] + SHA256_F2(wv[e]) + CH(wv[e], wv[f], wv[g])          + sha256_k[j] + w[j];                                  t2 = SHA256_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);           wv[d] += t1;                                                wv[h] = t1 + t2;                                        }
#define SHA512_EXP(a, b, c, d, e, f, g ,h, j)               {                                                               t1 = wv[h] + SHA512_F2(wv[e]) + CH(wv[e], wv[f], wv[g])          + sha512_k[j] + w[j];                                  t2 = SHA512_F1(wv[a]) + MAJ(wv[a], wv[b], wv[c]);           wv[d] += t1;                                                wv[h] = t1 + t2;                                        }
static uint32 sha224_h0[8] =
            {0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4};
static uint32 sha256_h0[8] =
            {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};
static uint64 sha384_h0[8] =
            {0xcbbb9d5dc1059ed8ULL, 0x629a292a367cd507ULL,
             0x9159015a3070dd17ULL, 0x152fecd8f70e5939ULL,
             0x67332667ffc00b31ULL, 0x8eb44a8768581511ULL,
             0xdb0c2e0d64f98fa7ULL, 0x47b5481dbefa4fa4ULL};
static uint64 sha512_h0[8] =
            {0x6a09e667f3bcc908ULL, 0xbb67ae8584caa73bULL,
             0x3c6ef372fe94f82bULL, 0xa54ff53a5f1d36f1ULL,
             0x510e527fade682d1ULL, 0x9b05688c2b3e6c1fULL,
             0x1f83d9abfb41bd6bULL, 0x5be0cd19137e2179ULL};
static uint32 sha256_k[64] =
            {0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
             0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
             0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
             0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
             0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
             0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
             0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
             0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
             0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
             0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
             0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
             0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
             0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
             0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
             0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
             0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};
static uint64 sha512_k[80] =
            {0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
             0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
             0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
             0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
             0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
             0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
             0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
             0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
             0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
             0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
             0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
             0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
             0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
             0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
             0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
             0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
             0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
             0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
             0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
             0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
             0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
             0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
             0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
             0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
             0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
             0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
             0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
             0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
             0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
             0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
             0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
             0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
             0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
             0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
             0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
             0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
             0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
             0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
             0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
             0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL};
/* SHA-256 functions */
void sha256_transf(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int block_nb)
{
    uint32 w[64];
    uint32 wv[8];
    uint32 t1, t2;
    const unsigned char *sub_block;
    int i;
#ifndef UNROLL_LOOPS
    int j;
#endif
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 6);
#ifndef UNROLL_LOOPS
        for (j = 0; j < 16; j++) {
            PACK32(&sub_block[j << 2], &w[j]);
        }
        for (j = 16; j < 64; j++) {
            SHA256_SCR(j);
        }
        for (j = 0; j < 8; j++) {
            wv[j] = ctx->h[j];
        }
        for (j = 0; j < 64; j++) {
            t1 = wv[7] + SHA256_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
                + sha256_k[j] + w[j];
            t2 = SHA256_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            ctx->h[j] += wv[j];
        }
#else
        PACK32(&sub_block[ 0], &w[ 0]); PACK32(&sub_block[ 4], &w[ 1]);
        PACK32(&sub_block[ 8], &w[ 2]); PACK32(&sub_block[12], &w[ 3]);
        PACK32(&sub_block[16], &w[ 4]); PACK32(&sub_block[20], &w[ 5]);
        PACK32(&sub_block[24], &w[ 6]); PACK32(&sub_block[28], &w[ 7]);
        PACK32(&sub_block[32], &w[ 8]); PACK32(&sub_block[36], &w[ 9]);
        PACK32(&sub_block[40], &w[10]); PACK32(&sub_block[44], &w[11]);
        PACK32(&sub_block[48], &w[12]); PACK32(&sub_block[52], &w[13]);
        PACK32(&sub_block[56], &w[14]); PACK32(&sub_block[60], &w[15]);
        SHA256_SCR(16); SHA256_SCR(17); SHA256_SCR(18); SHA256_SCR(19);
        SHA256_SCR(20); SHA256_SCR(21); SHA256_SCR(22); SHA256_SCR(23);
        SHA256_SCR(24); SHA256_SCR(25); SHA256_SCR(26); SHA256_SCR(27);
        SHA256_SCR(28); SHA256_SCR(29); SHA256_SCR(30); SHA256_SCR(31);
        SHA256_SCR(32); SHA256_SCR(33); SHA256_SCR(34); SHA256_SCR(35);
        SHA256_SCR(36); SHA256_SCR(37); SHA256_SCR(38); SHA256_SCR(39);
        SHA256_SCR(40); SHA256_SCR(41); SHA256_SCR(42); SHA256_SCR(43);
        SHA256_SCR(44); SHA256_SCR(45); SHA256_SCR(46); SHA256_SCR(47);
        SHA256_SCR(48); SHA256_SCR(49); SHA256_SCR(50); SHA256_SCR(51);
        SHA256_SCR(52); SHA256_SCR(53); SHA256_SCR(54); SHA256_SCR(55);
        SHA256_SCR(56); SHA256_SCR(57); SHA256_SCR(58); SHA256_SCR(59);
        SHA256_SCR(60); SHA256_SCR(61); SHA256_SCR(62); SHA256_SCR(63);
        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
        SHA256_EXP(0,1,2,3,4,5,6,7, 0); SHA256_EXP(7,0,1,2,3,4,5,6, 1);
        SHA256_EXP(6,7,0,1,2,3,4,5, 2); SHA256_EXP(5,6,7,0,1,2,3,4, 3);
        SHA256_EXP(4,5,6,7,0,1,2,3, 4); SHA256_EXP(3,4,5,6,7,0,1,2, 5);
        SHA256_EXP(2,3,4,5,6,7,0,1, 6); SHA256_EXP(1,2,3,4,5,6,7,0, 7);
        SHA256_EXP(0,1,2,3,4,5,6,7, 8); SHA256_EXP(7,0,1,2,3,4,5,6, 9);
        SHA256_EXP(6,7,0,1,2,3,4,5,10); SHA256_EXP(5,6,7,0,1,2,3,4,11);
        SHA256_EXP(4,5,6,7,0,1,2,3,12); SHA256_EXP(3,4,5,6,7,0,1,2,13);
        SHA256_EXP(2,3,4,5,6,7,0,1,14); SHA256_EXP(1,2,3,4,5,6,7,0,15);
        SHA256_EXP(0,1,2,3,4,5,6,7,16); SHA256_EXP(7,0,1,2,3,4,5,6,17);
        SHA256_EXP(6,7,0,1,2,3,4,5,18); SHA256_EXP(5,6,7,0,1,2,3,4,19);
        SHA256_EXP(4,5,6,7,0,1,2,3,20); SHA256_EXP(3,4,5,6,7,0,1,2,21);
        SHA256_EXP(2,3,4,5,6,7,0,1,22); SHA256_EXP(1,2,3,4,5,6,7,0,23);
        SHA256_EXP(0,1,2,3,4,5,6,7,24); SHA256_EXP(7,0,1,2,3,4,5,6,25);
        SHA256_EXP(6,7,0,1,2,3,4,5,26); SHA256_EXP(5,6,7,0,1,2,3,4,27);
        SHA256_EXP(4,5,6,7,0,1,2,3,28); SHA256_EXP(3,4,5,6,7,0,1,2,29);
        SHA256_EXP(2,3,4,5,6,7,0,1,30); SHA256_EXP(1,2,3,4,5,6,7,0,31);
        SHA256_EXP(0,1,2,3,4,5,6,7,32); SHA256_EXP(7,0,1,2,3,4,5,6,33);
        SHA256_EXP(6,7,0,1,2,3,4,5,34); SHA256_EXP(5,6,7,0,1,2,3,4,35);
        SHA256_EXP(4,5,6,7,0,1,2,3,36); SHA256_EXP(3,4,5,6,7,0,1,2,37);
        SHA256_EXP(2,3,4,5,6,7,0,1,38); SHA256_EXP(1,2,3,4,5,6,7,0,39);
        SHA256_EXP(0,1,2,3,4,5,6,7,40); SHA256_EXP(7,0,1,2,3,4,5,6,41);
        SHA256_EXP(6,7,0,1,2,3,4,5,42); SHA256_EXP(5,6,7,0,1,2,3,4,43);
        SHA256_EXP(4,5,6,7,0,1,2,3,44); SHA256_EXP(3,4,5,6,7,0,1,2,45);
        SHA256_EXP(2,3,4,5,6,7,0,1,46); SHA256_EXP(1,2,3,4,5,6,7,0,47);
        SHA256_EXP(0,1,2,3,4,5,6,7,48); SHA256_EXP(7,0,1,2,3,4,5,6,49);
        SHA256_EXP(6,7,0,1,2,3,4,5,50); SHA256_EXP(5,6,7,0,1,2,3,4,51);
        SHA256_EXP(4,5,6,7,0,1,2,3,52); SHA256_EXP(3,4,5,6,7,0,1,2,53);
        SHA256_EXP(2,3,4,5,6,7,0,1,54); SHA256_EXP(1,2,3,4,5,6,7,0,55);
        SHA256_EXP(0,1,2,3,4,5,6,7,56); SHA256_EXP(7,0,1,2,3,4,5,6,57);
        SHA256_EXP(6,7,0,1,2,3,4,5,58); SHA256_EXP(5,6,7,0,1,2,3,4,59);
        SHA256_EXP(4,5,6,7,0,1,2,3,60); SHA256_EXP(3,4,5,6,7,0,1,2,61);
        SHA256_EXP(2,3,4,5,6,7,0,1,62); SHA256_EXP(1,2,3,4,5,6,7,0,63);
        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
#endif
    }
}
void sha256(const unsigned char *message, unsigned int len, unsigned char *digest)
{
    sha256_ctx ctx;
    sha256_init(&ctx);
    sha256_update(&ctx, message, len);
    sha256_final(&ctx, digest);
}
void sha256_init(sha256_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha256_h0[i];
    }
#else
    ctx->h[0] = sha256_h0[0]; ctx->h[1] = sha256_h0[1];
    ctx->h[2] = sha256_h0[2]; ctx->h[3] = sha256_h0[3];
    ctx->h[4] = sha256_h0[4]; ctx->h[5] = sha256_h0[5];
    ctx->h[6] = sha256_h0[6]; ctx->h[7] = sha256_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha256_update(sha256_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA256_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA256_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA256_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha256_transf(ctx, ctx->block, 1);
    sha256_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA256_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 6],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 6;
}
void sha256_final(sha256_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA256_BLOCK_SIZE - 9)
                     < (ctx->len % SHA256_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 6;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha256_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 8; i++) {
        UNPACK32(ctx->h[i], &digest[i << 2]);
    }
#else
   UNPACK32(ctx->h[0], &digest[ 0]);
   UNPACK32(ctx->h[1], &digest[ 4]);
   UNPACK32(ctx->h[2], &digest[ 8]);
   UNPACK32(ctx->h[3], &digest[12]);
   UNPACK32(ctx->h[4], &digest[16]);
   UNPACK32(ctx->h[5], &digest[20]);
   UNPACK32(ctx->h[6], &digest[24]);
   UNPACK32(ctx->h[7], &digest[28]);
#endif
}
/* SHA-512 functions */
void sha512_transf(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int block_nb)
{
    uint64 w[80];
    uint64 wv[8];
    uint64 t1, t2;
    const unsigned char *sub_block;
    int i, j;
    for (i = 0; i < (int) block_nb; i++) {
        sub_block = message + (i << 7);
#ifndef UNROLL_LOOPS
        for (j = 0; j < 16; j++) {
            PACK64(&sub_block[j << 3], &w[j]);
        }
        for (j = 16; j < 80; j++) {
            SHA512_SCR(j);
        }
        for (j = 0; j < 8; j++) {
            wv[j] = ctx->h[j];
        }
        for (j = 0; j < 80; j++) {
            t1 = wv[7] + SHA512_F2(wv[4]) + CH(wv[4], wv[5], wv[6])
                + sha512_k[j] + w[j];
            t2 = SHA512_F1(wv[0]) + MAJ(wv[0], wv[1], wv[2]);
            wv[7] = wv[6];
            wv[6] = wv[5];
            wv[5] = wv[4];
            wv[4] = wv[3] + t1;
            wv[3] = wv[2];
            wv[2] = wv[1];
            wv[1] = wv[0];
            wv[0] = t1 + t2;
        }
        for (j = 0; j < 8; j++) {
            ctx->h[j] += wv[j];
        }
#else
        PACK64(&sub_block[  0], &w[ 0]); PACK64(&sub_block[  8], &w[ 1]);
        PACK64(&sub_block[ 16], &w[ 2]); PACK64(&sub_block[ 24], &w[ 3]);
        PACK64(&sub_block[ 32], &w[ 4]); PACK64(&sub_block[ 40], &w[ 5]);
        PACK64(&sub_block[ 48], &w[ 6]); PACK64(&sub_block[ 56], &w[ 7]);
        PACK64(&sub_block[ 64], &w[ 8]); PACK64(&sub_block[ 72], &w[ 9]);
        PACK64(&sub_block[ 80], &w[10]); PACK64(&sub_block[ 88], &w[11]);
        PACK64(&sub_block[ 96], &w[12]); PACK64(&sub_block[104], &w[13]);
        PACK64(&sub_block[112], &w[14]); PACK64(&sub_block[120], &w[15]);
        SHA512_SCR(16); SHA512_SCR(17); SHA512_SCR(18); SHA512_SCR(19);
        SHA512_SCR(20); SHA512_SCR(21); SHA512_SCR(22); SHA512_SCR(23);
        SHA512_SCR(24); SHA512_SCR(25); SHA512_SCR(26); SHA512_SCR(27);
        SHA512_SCR(28); SHA512_SCR(29); SHA512_SCR(30); SHA512_SCR(31);
        SHA512_SCR(32); SHA512_SCR(33); SHA512_SCR(34); SHA512_SCR(35);
        SHA512_SCR(36); SHA512_SCR(37); SHA512_SCR(38); SHA512_SCR(39);
        SHA512_SCR(40); SHA512_SCR(41); SHA512_SCR(42); SHA512_SCR(43);
        SHA512_SCR(44); SHA512_SCR(45); SHA512_SCR(46); SHA512_SCR(47);
        SHA512_SCR(48); SHA512_SCR(49); SHA512_SCR(50); SHA512_SCR(51);
        SHA512_SCR(52); SHA512_SCR(53); SHA512_SCR(54); SHA512_SCR(55);
        SHA512_SCR(56); SHA512_SCR(57); SHA512_SCR(58); SHA512_SCR(59);
        SHA512_SCR(60); SHA512_SCR(61); SHA512_SCR(62); SHA512_SCR(63);
        SHA512_SCR(64); SHA512_SCR(65); SHA512_SCR(66); SHA512_SCR(67);
        SHA512_SCR(68); SHA512_SCR(69); SHA512_SCR(70); SHA512_SCR(71);
        SHA512_SCR(72); SHA512_SCR(73); SHA512_SCR(74); SHA512_SCR(75);
        SHA512_SCR(76); SHA512_SCR(77); SHA512_SCR(78); SHA512_SCR(79);
        wv[0] = ctx->h[0]; wv[1] = ctx->h[1];
        wv[2] = ctx->h[2]; wv[3] = ctx->h[3];
        wv[4] = ctx->h[4]; wv[5] = ctx->h[5];
        wv[6] = ctx->h[6]; wv[7] = ctx->h[7];
        j = 0;
        do {
            SHA512_EXP(0,1,2,3,4,5,6,7,j); j++;
            SHA512_EXP(7,0,1,2,3,4,5,6,j); j++;
            SHA512_EXP(6,7,0,1,2,3,4,5,j); j++;
            SHA512_EXP(5,6,7,0,1,2,3,4,j); j++;
            SHA512_EXP(4,5,6,7,0,1,2,3,j); j++;
            SHA512_EXP(3,4,5,6,7,0,1,2,j); j++;
            SHA512_EXP(2,3,4,5,6,7,0,1,j); j++;
            SHA512_EXP(1,2,3,4,5,6,7,0,j); j++;
        } while (j < 80);
        ctx->h[0] += wv[0]; ctx->h[1] += wv[1];
        ctx->h[2] += wv[2]; ctx->h[3] += wv[3];
        ctx->h[4] += wv[4]; ctx->h[5] += wv[5];
        ctx->h[6] += wv[6]; ctx->h[7] += wv[7];
#endif
    }
}
void sha512(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha512_ctx ctx;
    sha512_init(&ctx);
    sha512_update(&ctx, message, len);
    sha512_final(&ctx, digest);
}
void sha512_init(sha512_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha512_h0[i];
    }
#else
    ctx->h[0] = sha512_h0[0]; ctx->h[1] = sha512_h0[1];
    ctx->h[2] = sha512_h0[2]; ctx->h[3] = sha512_h0[3];
    ctx->h[4] = sha512_h0[4]; ctx->h[5] = sha512_h0[5];
    ctx->h[6] = sha512_h0[6]; ctx->h[7] = sha512_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha512_update(sha512_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA512_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA512_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA512_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha512_transf(ctx, ctx->block, 1);
    sha512_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA512_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 7],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 7;
}
void sha512_final(sha512_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = 1 + ((SHA512_BLOCK_SIZE - 17)
                     < (ctx->len % SHA512_BLOCK_SIZE));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 7;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha512_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 8; i++) {
        UNPACK64(ctx->h[i], &digest[i << 3]);
    }
#else
    UNPACK64(ctx->h[0], &digest[ 0]);
    UNPACK64(ctx->h[1], &digest[ 8]);
    UNPACK64(ctx->h[2], &digest[16]);
    UNPACK64(ctx->h[3], &digest[24]);
    UNPACK64(ctx->h[4], &digest[32]);
    UNPACK64(ctx->h[5], &digest[40]);
    UNPACK64(ctx->h[6], &digest[48]);
    UNPACK64(ctx->h[7], &digest[56]);
#endif
}
/* SHA-384 functions */
void sha384(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha384_ctx ctx;
    sha384_init(&ctx);
    sha384_update(&ctx, message, len);
    sha384_final(&ctx, digest);
}
void sha384_init(sha384_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha384_h0[i];
    }
#else
    ctx->h[0] = sha384_h0[0]; ctx->h[1] = sha384_h0[1];
    ctx->h[2] = sha384_h0[2]; ctx->h[3] = sha384_h0[3];
    ctx->h[4] = sha384_h0[4]; ctx->h[5] = sha384_h0[5];
    ctx->h[6] = sha384_h0[6]; ctx->h[7] = sha384_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha384_update(sha384_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA384_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA384_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA384_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha512_transf(ctx, ctx->block, 1);
    sha512_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA384_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 7],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 7;
}
void sha384_final(sha384_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA384_BLOCK_SIZE - 17)
                     < (ctx->len % SHA384_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 7;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha512_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 6; i++) {
        UNPACK64(ctx->h[i], &digest[i << 3]);
    }
#else
    UNPACK64(ctx->h[0], &digest[ 0]);
    UNPACK64(ctx->h[1], &digest[ 8]);
    UNPACK64(ctx->h[2], &digest[16]);
    UNPACK64(ctx->h[3], &digest[24]);
    UNPACK64(ctx->h[4], &digest[32]);
    UNPACK64(ctx->h[5], &digest[40]);
#endif
}
/* SHA-224 functions */
void sha224(const unsigned char *message, unsigned int len,
            unsigned char *digest)
{
    sha224_ctx ctx;
    sha224_init(&ctx);
    sha224_update(&ctx, message, len);
    sha224_final(&ctx, digest);
}
void sha224_init(sha224_ctx *ctx)
{
#ifndef UNROLL_LOOPS
    int i;
    for (i = 0; i < 8; i++) {
        ctx->h[i] = sha224_h0[i];
    }
#else
    ctx->h[0] = sha224_h0[0]; ctx->h[1] = sha224_h0[1];
    ctx->h[2] = sha224_h0[2]; ctx->h[3] = sha224_h0[3];
    ctx->h[4] = sha224_h0[4]; ctx->h[5] = sha224_h0[5];
    ctx->h[6] = sha224_h0[6]; ctx->h[7] = sha224_h0[7];
#endif
    ctx->len = 0;
    ctx->tot_len = 0;
}
void sha224_update(sha224_ctx *ctx, const unsigned char *message,
                   unsigned int len)
{
    unsigned int block_nb;
    unsigned int new_len, rem_len, tmp_len;
    const unsigned char *shifted_message;
    tmp_len = SHA224_BLOCK_SIZE - ctx->len;
    rem_len = len < tmp_len ? len : tmp_len;
    memcpy(&ctx->block[ctx->len], message, rem_len);
    if (ctx->len + len < SHA224_BLOCK_SIZE) {
        ctx->len += len;
        return;
    }
    new_len = len - rem_len;
    block_nb = new_len / SHA224_BLOCK_SIZE;
    shifted_message = message + rem_len;
    sha256_transf(ctx, ctx->block, 1);
    sha256_transf(ctx, shifted_message, block_nb);
    rem_len = new_len % SHA224_BLOCK_SIZE;
    memcpy(ctx->block, &shifted_message[block_nb << 6],
           rem_len);
    ctx->len = rem_len;
    ctx->tot_len += (block_nb + 1) << 6;
}
void sha224_final(sha224_ctx *ctx, unsigned char *digest)
{
    unsigned int block_nb;
    unsigned int pm_len;
    unsigned int len_b;
#ifndef UNROLL_LOOPS
    int i;
#endif
    block_nb = (1 + ((SHA224_BLOCK_SIZE - 9)
                     < (ctx->len % SHA224_BLOCK_SIZE)));
    len_b = (ctx->tot_len + ctx->len) << 3;
    pm_len = block_nb << 6;
    memset(ctx->block + ctx->len, 0, pm_len - ctx->len);
    ctx->block[ctx->len] = 0x80;
    UNPACK32(len_b, ctx->block + pm_len - 4);
    sha256_transf(ctx, ctx->block, block_nb);
#ifndef UNROLL_LOOPS
    for (i = 0 ; i < 7; i++) {
        UNPACK32(ctx->h[i], &digest[i << 2]);
    }
#else
   UNPACK32(ctx->h[0], &digest[ 0]);
   UNPACK32(ctx->h[1], &digest[ 4]);
   UNPACK32(ctx->h[2], &digest[ 8]);
   UNPACK32(ctx->h[3], &digest[12]);
   UNPACK32(ctx->h[4], &digest[16]);
   UNPACK32(ctx->h[5], &digest[20]);
   UNPACK32(ctx->h[6], &digest[24]);
#endif
}
#ifdef TEST_VECTORS
/* FIPS 180-2 Validation tests */
void test(const char *vector, unsigned char *digest,
          unsigned int digest_size)
{
    char output[2 * SHA512_DIGEST_SIZE + 1];
    int i;
    output[2 * digest_size] = '\0';
    for (i = 0; i < (int) digest_size ; i++) {
       sprintf(output + 2 * i, "%02x", digest[i]);
    }
    printf("H: %s\n", output);
    if (strcmp(vector, output)) {
        fprintf(stderr, "Test failed.\n");
        exit(EXIT_FAILURE);
    }
}
int main(void)
{
    static const char *vectors[4][3] =
    {
        {
        "23097d223405d8228642a477bda255b32aadbce4bda0b3f7e36c9da7",
        "75388b16512776cc5dba5da1fd890150b0c6455cb4f58b1952522525",
        "20794655980c91d8bbb4c1ea97618a4bf03f42581948b2ee4ee7ad67",
        },
        /* SHA-256 */
        {
        "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
        "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",
        "cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0",
        },
        /* SHA-384 */
        {
        "cb00753f45a35e8bb5a03d699ac65007272c32ab0eded1631a8b605a43ff5bed"
        "8086072ba1e7cc2358baeca134c825a7",
        "09330c33f71147e83d192fc782cd1b4753111b173b3b05d22fa08086e3b0f712"
        "fcc7c71a557e2db966c3e9fa91746039",
        "9d0e1809716474cb086e834e310a4a1ced149e9c00f248527972cec5704c2a5b"
        "07b8b3dc38ecc4ebae97ddd87f3d8985",
        },
        /* SHA-512 */
        {
        "ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a"
        "2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f",
        "8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018"
        "501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909",
        "e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb"
        "de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b"
        }
    };
    static const char message1[] = "abc";
    static const char message2a[] = "abcdbcdecdefdefgefghfghighijhi"
                                    "jkijkljklmklmnlmnomnopnopq";
    static const char message2b[] = "abcdefghbcdefghicdefghijdefghijkefghij"
                                    "klfghijklmghijklmnhijklmnoijklmnopjklm"
                                    "nopqklmnopqrlmnopqrsmnopqrstnopqrstu";
    unsigned char *message3;
    unsigned int message3_len = 1000000;
    unsigned char digest[SHA512_DIGEST_SIZE];
    message3 = malloc(message3_len);
    if (message3 == NULL) {
        fprintf(stderr, "Can't allocate memory\n");
        return -1;
    }
    memset(message3, 'a', message3_len);
    printf("SHA-2 FIPS 180-2 Validation tests\n\n");
    printf("SHA-224 Test vectors\n");
    sha224((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[0][0], digest, SHA224_DIGEST_SIZE);
    sha224((const unsigned char *) message2a, strlen(message2a), digest);
    test(vectors[0][1], digest, SHA224_DIGEST_SIZE);
    sha224(message3, message3_len, digest);
    test(vectors[0][2], digest, SHA224_DIGEST_SIZE);
    printf("\n");
    printf("SHA-256 Test vectors\n");
    sha256((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[1][0], digest, SHA256_DIGEST_SIZE);
    sha256((const unsigned char *) message2a, strlen(message2a), digest);
    test(vectors[1][1], digest, SHA256_DIGEST_SIZE);
    sha256(message3, message3_len, digest);
    test(vectors[1][2], digest, SHA256_DIGEST_SIZE);
    printf("\n");
    printf("SHA-384 Test vectors\n");
    sha384((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[2][0], digest, SHA384_DIGEST_SIZE);
    sha384((const unsigned char *)message2b, strlen(message2b), digest);
    test(vectors[2][1], digest, SHA384_DIGEST_SIZE);
    sha384(message3, message3_len, digest);
    test(vectors[2][2], digest, SHA384_DIGEST_SIZE);
    printf("\n");
    printf("SHA-512 Test vectors\n");
    sha512((const unsigned char *) message1, strlen(message1), digest);
    test(vectors[3][0], digest, SHA512_DIGEST_SIZE);
    sha512((const unsigned char *) message2b, strlen(message2b), digest);
    test(vectors[3][1], digest, SHA512_DIGEST_SIZE);
    sha512(message3, message3_len, digest);
    test(vectors[3][2], digest, SHA512_DIGEST_SIZE);
    printf("\n");
    printf("All tests passed.\n");
    return 0;
}
#endif
// http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
// from https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.c  2017/19/12
// sha3.c
// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>
// Revised 07-Aug-15 to match with official release of FIPS PUB 202 "SHA3"
// Revised 03-Sep-15 for portability + OpenSSL - style API
// 2018-06-16 modified _final api to pass context then digest (reverse params from original)
// from https://github.com/mjosaarinen/tiny_sha3/blob/master/sha3.h  2017/19/12
// sha3.h
// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>
// 2018-06-16 modified _final api to pass context then digest (reverse params from original)
#ifndef SHA3_H
#define SHA3_H
#ifndef KECCAKF_ROUNDS
#define KECCAKF_ROUNDS 24
#endif
#ifndef ROTL64
#define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))
#endif
// state context
typedef struct {
                                 // state:
    union {
                     // 8-bit bytes
        uint8_t b[200];
                     // 64-bit words
        uint64_t q[25];
    } st;
                    // these don't overflow
    int pt, rsiz, mdlen;
} sha3_ctx_t;
// Compression function.
void sha3_keccakf(uint64_t st[25]);
// OpenSSL - like interfece
    // mdlen = hash output in bytes
int sha3_init(sha3_ctx_t *c, int mdlen);
int sha3_update(sha3_ctx_t *c, const void *data, size_t len);
    // digest goes to md
int sha3_final(sha3_ctx_t *c, void *md );
// compute a sha3 hash (md) of given byte length from "in"
void *sha3(const void *in, size_t inlen, void *md, int mdlen);
// SHAKE128 and SHAKE256 extensible-output functions
#define shake128_init(c) sha3_init(c, 16)
#define shake256_init(c) sha3_init(c, 32)
#define shake_update sha3_update
void shake_xof(sha3_ctx_t *c);
void shake_out(sha3_ctx_t *c, void *out, size_t len);
#endif
// update the state with given number of rounds
void sha3_keccakf(uint64_t st[25])
{
    // constants
    const uint64_t keccakf_rndc[24] = {
        0x0000000000000001, 0x0000000000008082, 0x800000000000808a,
        0x8000000080008000, 0x000000000000808b, 0x0000000080000001,
        0x8000000080008081, 0x8000000000008009, 0x000000000000008a,
        0x0000000000000088, 0x0000000080008009, 0x000000008000000a,
        0x000000008000808b, 0x800000000000008b, 0x8000000000008089,
        0x8000000000008003, 0x8000000000008002, 0x8000000000000080,
        0x000000000000800a, 0x800000008000000a, 0x8000000080008081,
        0x8000000000008080, 0x0000000080000001, 0x8000000080008008
    };
    const int keccakf_rotc[24] = {
        1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14,
        27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44
    };
    const int keccakf_piln[24] = {
        10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4,
        15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1
    };
    // variables
    int i, j, r;
    uint64_t t, bc[5];
#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
    uint8_t *v;
    // endianess conversion. this is redundant on little-endian targets
    for (i = 0; i < 25; i++) {
        v = (uint8_t *) &st[i];
        st[i] = ((uint64_t) v[0])     | (((uint64_t) v[1]) << 8) |
            (((uint64_t) v[2]) << 16) | (((uint64_t) v[3]) << 24) |
            (((uint64_t) v[4]) << 32) | (((uint64_t) v[5]) << 40) |
            (((uint64_t) v[6]) << 48) | (((uint64_t) v[7]) << 56);
    }
#endif
    // actual iteration
    for (r = 0; r < KECCAKF_ROUNDS; r++) {
        // Theta
        for (i = 0; i < 5; i++)
            bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];
        for (i = 0; i < 5; i++) {
            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);
            for (j = 0; j < 25; j += 5)
                st[j + i] ^= t;
        }
        // Rho Pi
        t = st[1];
        for (i = 0; i < 24; i++) {
            j = keccakf_piln[i];
            bc[0] = st[j];
            st[j] = ROTL64(t, keccakf_rotc[i]);
            t = bc[0];
        }
        //  Chi
        for (j = 0; j < 25; j += 5) {
            for (i = 0; i < 5; i++)
                bc[i] = st[j + i];
            for (i = 0; i < 5; i++)
                st[j + i] ^= (~bc[(i + 1) % 5]) & bc[(i + 2) % 5];
        }
        //  Iota
        st[0] ^= keccakf_rndc[r];
    }
#if __BYTE_ORDER__ != __ORDER_LITTLE_ENDIAN__
    // endianess conversion. this is redundant on little-endian targets
    for (i = 0; i < 25; i++) {
        v = (uint8_t *) &st[i];
        t = st[i];
        v[0] = t & 0xFF;
        v[1] = (t >> 8) & 0xFF;
        v[2] = (t >> 16) & 0xFF;
        v[3] = (t >> 24) & 0xFF;
        v[4] = (t >> 32) & 0xFF;
        v[5] = (t >> 40) & 0xFF;
        v[6] = (t >> 48) & 0xFF;
        v[7] = (t >> 56) & 0xFF;
    }
#endif
}
// Initialize the context for SHA3
int sha3_init(sha3_ctx_t *c, int mdlen)
{
    int i;
	if( mdlen > 100 )
        mdlen = 100;
    for (i = 0; i < 25; i++)
        c->st.q[i] = 0;
    c->mdlen = mdlen;
    c->rsiz = 200 - 2 * mdlen;
    c->pt = 0;
    return 1;
}
// update state with more data
int sha3_update(sha3_ctx_t *c, const void *data, size_t len)
{
    size_t i;
    int j;
    j = c->pt;
    for (i = 0; i < len; i++) {
        c->st.b[j++] ^= ((const uint8_t *) data)[i];
        if (j >= c->rsiz) {
            sha3_keccakf(c->st.q);
            j = 0;
        }
    }
    c->pt = j;
    return 1;
}
// finalize and output a hash
int sha3_final( sha3_ctx_t *c, void *md )
{
    int i;
    c->st.b[c->pt] ^= 0x06;
    c->st.b[c->rsiz - 1] ^= 0x80;
    sha3_keccakf(c->st.q);
    for (i = 0; i < c->mdlen; i++) {
        ((uint8_t *) md)[i] = c->st.b[i];
    }
    return 1;
}
// compute a SHA-3 hash (md) of given byte length from "in"
void *sha3(const void *in, size_t inlen, void *md, int mdlen)
{
    sha3_ctx_t sha3;
    sha3_init(&sha3, mdlen);
    sha3_update(&sha3, in, inlen);
    sha3_final(&sha3, md);
    return md;
}
// SHAKE128 and SHAKE256 extensible-output functionality
void shake_xof(sha3_ctx_t *c)
{
    c->st.b[c->pt] ^= 0x1F;
    c->st.b[c->rsiz - 1] ^= 0x80;
    sha3_keccakf(c->st.q);
    c->pt = 0;
}
void shake_out(sha3_ctx_t *c, void *out, size_t len)
{
    size_t i;
    int j;
    j = c->pt;
    for (i = 0; i < len; i++) {
        if (j >= c->rsiz) {
            sha3_keccakf(c->st.q);
            j = 0;
        }
        ((uint8_t *) out)[i] = c->st.b[j++];
    }
    c->pt = j;
}
#ifdef _WIN64
#ifndef __64__
#define __64__
#endif
#endif
#ifdef WIN32
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x501
#endif
#endif
// debugging only gets you the ordering(priority) logging and something else...
// useful logging is now controlled with l.flags.bLog
#define DISABLE_DEBUG_REGISTER_AND_DISPATCH
//#define DEBUG_SHUTDOWN
#define LOG_ALL 0
//
// core library load
//    all procs scheduled, initial = 0
// Application starts, invokes preloads
//    additional libraries load, scheduling because of suspend
//    library load completes by invoking the newly registered list
// final core application schedulging happens, after initial preload completes
//    additional preload scheduligin happens( not suspended, is initial)
//#define DEBUG_CYGWIN_START
//#ifndef __LINUX__
#define IS_DEADSTART
#ifdef __LINUX__
#include <signal.h>
#endif
#ifdef WIN32
 // GetConsoleWindow()
#include <wincon.h>
#endif
#ifdef __NO_BAG__
#undef lprintf
#define lprintf printf
#define BAG_Exit exit
#else
#endif
//#define lprintf(f,...) printf(f "\n",##__VA_ARGS__)
//#define _lprintf(n) lprintf
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
SACK_DEADSTART_NAMESPACE
//#undef PRELOAD
EXPORT_METHOD void RunDeadstart( void );
typedef struct startup_proc_tag {
	DeclareLink( struct startup_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} STARTUP_PROC, *PSTARTUP_PROC;
typedef struct shutdown_proc_tag {
	DeclareLink( struct shutdown_proc_tag );
	int bUsed;
	int priority;
	void (CPROC*proc)(void);
	CTEXTSTR func;
#ifdef _DEBUG
	CTEXTSTR file;
	int line;
#endif
} SHUTDOWN_PROC, *PSHUTDOWN_PROC;
struct deadstart_local_data_
{
	// this is a lot of procs...
	int nShutdownProcs;
#define nShutdownProcs l.nShutdownProcs
	SHUTDOWN_PROC shutdown_procs[512];
#define shutdown_procs l.shutdown_procs
	int bInitialDone;
#define bInitialDone l.bInitialDone
	LOGICAL bInitialStarted;
#define bInitialStarted l.bInitialStarted
	int bSuspend;
#define bSuspend l.bSuspend
	int bDispatched;
//#define bDispatched l.bDispatched
	PSHUTDOWN_PROC shutdown_proc_schedule;
#define shutdown_proc_schedule l.shutdown_proc_schedule
 // count of used procs...
	int nProcs;
#define nProcs l.nProcs
	STARTUP_PROC procs[1024];
#define procs l.procs
	PSTARTUP_PROC proc_schedule;
#define proc_schedule l.proc_schedule
	struct
	{
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bLog : 1;
	} flags;
};
#ifdef UNDER_CE
#  ifndef __STATIC_GLOBALS__
#    define __STATIC_GLOBALS__
#  endif
#endif
#ifndef __STATIC_GLOBALS__
static struct deadstart_local_data_ *deadstart_local_data;
#define l (*deadstart_local_data)
#else
static struct deadstart_local_data_ deadstart_local_data;
#define l (deadstart_local_data)
#endif
EXPORT_METHOD void RunExits( void )
{
	InvokeExits();
}
static void InitLocal( void )
{
#ifndef __STATIC_GLOBALS__
	if( !deadstart_local_data )
	{
		SimpleRegisterAndCreateGlobal( deadstart_local_data );
	}
#endif
	if( !l.flags.bInitialized )
	{
		//atexit( RunExits );
		l.flags.bInitialized = 1;
	}
}
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
#define ENQUE_STARTUP_DBG_SRC DBG_SRC
void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc DBG_PASS )
#else
#define ENQUE_STARTUP_DBG_SRC
void EnqueStartupProc( PSTARTUP_PROC *root, PSTARTUP_PROC proc )
#endif
{
	PSTARTUP_PROC check;
	PSTARTUP_PROC last;
		if( proc->next || proc->me )
		{
			if( ( (*proc->me) = proc->next ) )
				proc->next->me = proc->me;
		}
		for( last = check = (*root); check; check = check->next )
		{
			// if the current one being added is less then the one in the list
			// then the one in the list becomes the new one's next...
			if( proc->priority < check->priority )
			{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
				_lprintf(DBG_RELAY)( WIDE("%s(%d) is to run before %s and after %s first is %s")
						 , proc->func
						 , proc - procs
						 , check->func
						 , (check->me==root)?WIDE("Is First"):((PSTARTUP_PROC)check->me)->func
						 , (*root)?(*root)->func:WIDE("First")
						 );
#endif
				proc->next = check;
				proc->me = check->me;
				(*check->me) = proc;
				check->me = &proc->next;
				break;
			}
			last = check;
		}
		if( !check )
		{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
			lprintf( WIDE("%s(%d) is to run after all")
					 , proc->func
					 , proc - procs
					 );
#endif
			proc->next = NULL;
			if( last )
			{
				last->next = proc;
				proc->me = &last->next;
			}
			else
			{
				(*root) = proc;
				proc->me = root;
			}
		}
}
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityStartupProc( void (CPROC*proc)(void), CTEXTSTR func,int priority, void *use_label DBG_PASS )
{
	int use_proc;
	InitLocal();
	if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		 (deadstart_local_data
#else
		(1
#endif
		&& l.flags.bLog ))
		lprintf( WIDE("Register %s@") DBG_FILELINEFMT_MIN WIDE(" %d"), func DBG_RELAY, priority);
	if( nProcs == 1024 )
	{
		for( use_proc = 0; use_proc < 1024; use_proc++ )
			if( !procs[use_proc].bUsed )
				break;
		if( use_proc == 1024 )
		{
			lprintf( WIDE( "Used all 1024, and, have 1024 startups total scheduled." ) );
			DebugBreak();
		}
	}
	else
		use_proc = nProcs;
	procs[use_proc].proc = proc;
	procs[use_proc].func = func;
#ifdef _DEBUG
	procs[use_proc].file = pFile;
	procs[use_proc].line = nLine;
#endif
	procs[use_proc].priority = priority;
	procs[use_proc].bUsed = 1;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].next = NULL;
 // initialize so it doesn't try unlink in requeue common routine.
	procs[use_proc].me = NULL;
	EnqueStartupProc( &proc_schedule, procs + use_proc ENQUE_STARTUP_DBG_SRC );
	if( nProcs < 1024 )
		nProcs++;
	/*
	if( nProcs == 1024 )
	{
		lprintf( WIDE( "Excessive number of startup procs!" ) );
		DebugBreak();
	}
	*/
	if( bInitialDone && !bSuspend )
	{
#define ONE_MACRO(a,b) a,b
#ifdef _DEBUG
		_xlprintf(LOG_NOISE,pFile,nLine)( WIDE( "Initial done, not suspended, dispatch immediate." ) );
#endif
		InvokeDeadstart();
	}
	//lprintf( WIDE("Total procs %d"), nProcs );
}
#ifdef __LINUX__
// this handles the peculiarities of fork() and exit()
void ClearDeadstarts( void )
{
	// this is reserved for the sole use of
	// fork() success and then exec() failing...
	// when oh wait - __attribute__((destructor))
	// if( registered_pid != getppid() )
	shutdown_proc_schedule = NULL;
	// be rude - yes we lose resources. but everything goes away cause
	// this is just a clone..
}
#endif
#ifndef UNDER_CE
#  if defined( WIN32 )
#    ifndef __cplusplus_cli
static BOOL WINAPI CtrlC( DWORD dwCtrlType )
{
	switch( dwCtrlType )
	{
	case CTRL_BREAK_EVENT:
	case CTRL_C_EVENT:
		InvokeExits();
		// allow C api to exit, whatever C api we're using
		// (allows triggering atexit functions)
		exit(3);
		return TRUE;
	case CTRL_CLOSE_EVENT:
		break;
	case CTRL_LOGOFF_EVENT:
		break;
	case CTRL_SHUTDOWN_EVENT:
		break;
	}
	// default... return not processed.
	return FALSE;
}
#    endif
#  endif
#  ifndef WIN32
static void CtrlC( int signal )
{
	exit(3);
}
#  endif
#endif
// wow no such thing as static-izing this... it's
// always retrieved with dynamic function loading, therefore
// MUST be exported if at all possible.
// this one is used when a library is loaded.
void InvokeDeadstart( void )
{
	PSTARTUP_PROC proc;
	PSTARTUP_PROC resumed_proc;
	//if( !bInitialDone /*|| bDispatched*/ )
	//   return;
	InitLocal();
	if( bInitialStarted )
		return;
	bInitialStarted = 1;
	// allowing initial start to be set lets final resume do this invoke.
	if( bSuspend )
	{
		if( l.flags.bLog )
			lprintf( WIDE("Suspended, first proc is %s"), proc_schedule?proc_schedule->func:WIDE("No First") );
		return;
	}
#ifdef WIN32
	if( !bInitialDone && !l.bDispatched )
	{
#  ifndef UNDER_CE
		if( GetConsoleWindow() )
		{
#    ifndef __cplusplus_cli
			//MessageBox( NULL, "!!--!! CtrlC", "blah", MB_OK );
			SetConsoleCtrlHandler( CtrlC, TRUE );
#    endif
		}
		else
		{
			//MessageBox( NULL, "!!--!! NO CtrlC", "blah", MB_OK );
 // do nothing if we're no actually a console window. this should fix ctrl-c not working in CMD prompts launched by MILK/InterShell
			;
		}
#  endif
	}
#endif
	while( ( proc = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
	{
		// need to set this to point to new head of list... it's not in proc_schedule anymore
		//proc->me = &proc;
		if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		 (deadstart_local_data
#else
		(1
#endif
		&& l.flags.bLog ))
		{
#ifdef _DEBUG
			lprintf( WIDE("Dispatch %s@%s(%d)p:%d "), proc->func,proc->file,proc->line, proc->priority );
#else
			lprintf( WIDE("Dispatch %s@p:%d "), proc->func, proc->priority );
#endif
		}
		{
			l.bDispatched = 1;
#ifdef _DEBUG
			if( proc->proc
#  ifndef __LINUX__
#    if  __WATCOMC__ >= 1280
				&& !IsBadCodePtr( (int(STDCALL*)(void))proc->proc )
#    elif defined( __64__ )
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#    else
//				&& !IsBadCodePtr( (int STDCALL(*)(void))proc->proc )
#    endif
#  endif
			  )
#endif
			{
				proc->proc();
			}
			proc->bUsed = 0;
			l.bDispatched = 0;
		}
		// look to see if anything new was scheduled.  Grab the list, add it to the one's we're processing.
		{
			{
				PSTARTUP_PROC newly_scheduled_things;
				proc->me = &proc;
				resumed_proc = proc;
				if( ( newly_scheduled_things = (PSTARTUP_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&proc_schedule, 0 ) ) != NULL )
				{
					newly_scheduled_things->me = &newly_scheduled_things;
					//lprintf( "------------------  newly scheduled startups; requeue old startups into new list ------------------ " );
					while( newly_scheduled_things )
					{
						EnqueStartupProc( &proc, newly_scheduled_things ENQUE_STARTUP_DBG_SRC );
					}
				}
				else
					resumed_proc = NULL;
			}
			proc_schedule = proc;
			proc_schedule->me = &proc_schedule;
		}
		if( resumed_proc )
			UnlinkThing( resumed_proc );
		else
			UnlinkThing( proc );
	}
	bInitialStarted = 0;
}
void MarkRootDeadstartComplete( void )
{
	bInitialDone = 1;
}
#ifndef __NO_OPTIONS__
// options initializes at SQL+1
PRIORITY_PRELOAD( InitDeadstartOptions, NAMESPACE_PRELOAD_PRIORITY+1 )
{
#ifdef DISABLE_DEBUG_REGISTER_AND_DISPATCH
#  ifndef __NO_OPTIONS
	l.flags.bLog = SACK_GetProfileIntEx( WIDE( "SACK/Deadstart" ), WIDE( "Logging Enabled?" ), 0, TRUE );
#  else
	l.flags.bLog = 0;
#  endif
#else
	l.flags.bLog = 1;
#endif
}
#endif
// parameter 4 is just used so the external code is not killed
// we don't actually do anything with this?
void RegisterPriorityShutdownProc( void (CPROC*proc)(void), CTEXTSTR func, int priority,void *use_label DBG_PASS )
{
	InitLocal();
	if( LOG_ALL ||
#ifndef __STATIC_GLOBALS__
		(deadstart_local_data
#else
		 (1
#endif
		  && l.flags.bLog ))
		lprintf( WIDE("Exit Proc %s(%p) from ") DBG_FILELINEFMT_MIN WIDE(" registered...")
				 , func
				 , proc DBG_RELAY );
	shutdown_procs[nShutdownProcs].proc = proc;
	shutdown_procs[nShutdownProcs].func = func;
#ifdef _DEBUG
	shutdown_procs[nShutdownProcs].file = pFile;
	shutdown_procs[nShutdownProcs].line = nLine;
#endif
	shutdown_procs[nShutdownProcs].bUsed = 1;
	shutdown_procs[nShutdownProcs].priority = priority;
	{
		PSHUTDOWN_PROC check;
		for( check = shutdown_proc_schedule; check; check = check->next )
		{
			if( shutdown_procs[nShutdownProcs].priority >= check->priority )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( WIDE("%s(%d) is to run before %s(%d) %s")
						 , shutdown_procs[nShutdownProcs].func
						 , nShutdownProcs
						 , check->file
						 , check->line
						 , check->func );
#endif
				shutdown_procs[nShutdownProcs].next = check;
				shutdown_procs[nShutdownProcs].me = check->me;
				(*check->me) = shutdown_procs + nShutdownProcs;
				check->me = &shutdown_procs[nShutdownProcs].next;
				break;
			}
		}
		if( !check )
			LinkLast( shutdown_proc_schedule, PSHUTDOWN_PROC, shutdown_procs + nShutdownProcs );
		//lprintf( WIDE("first routine is %s(%d)")
		//		 , shutdown_proc_schedule->func
		//		 , shutdown_proc_schedule->line );
	}
	nShutdownProcs++;
	//lprintf( WIDE("Total procs %d"), nProcs );
}
void InvokeExits( void )
{
	// okay well since noone previously scheduled exits...
	// this runs a prioritized list of exits - all within
	// a single moment of exited-ness.
	PSHUTDOWN_PROC proc;
	// shutdown is much easier than startup cause more
	// procedures shouldn't be added as a property of shutdown.
	// don't allow shutdown procs to schedule more shutdown procs...
	// although in theory we could; if the first list contained
	// ReleaseAllMemory(); then there is no memory.
	if(
#ifndef __STATIC_GLOBALS__
		deadstart_local_data &&
#endif
			( proc = (PSHUTDOWN_PROC)LockedExchangePtrSzVal( (PVPTRSZVAL)&shutdown_proc_schedule, 0 ) ) != NULL
		  )
	{
		// just before all memory goes away
		// global memory goes away (including mine) so deadstart_local_data is invalidated.
#ifndef __STATIC_GLOBALS__
		struct deadstart_local_data_ *local_pointer = (struct deadstart_local_data_*)(((uintptr_t)deadstart_local_data)-sizeof(PLIST));
#endif
		PSHUTDOWN_PROC proclist = proc;
		// link list to myself..
#ifndef __STATIC_GLOBALS__
		Hold( local_pointer );
#endif
		proc->me = &proclist;
		while( ( proc = proclist ) )
		{
#if defined( DEBUG_SHUTDOWN )
			lprintf( WIDE("Exit Proc %s(%p)(%d) priority %d from %s(%d)...")
			       , proc->func
			       , proc->proc
			       , proc - shutdown_procs
			       , proc->priority
			       , proc->file
			       , proc->line );
#endif
			if( proc->priority == 0 )
			{
				//atexit( proc->proc );
				//continue;
			}
			// don't release this stuff... memory might be one of the autoexiters.
			UnlinkThing( proc );
			if( proc->proc
#ifndef __LINUX__
				&& !IsBadCodePtr( (FARPROC)proc->proc )
#endif
			  )
			{
#ifdef DEBUG_SHUTDOWN
				lprintf( "Dispatching..." );
#endif
				proc->proc();
			}
			// okay I have the whol elist... so...
#ifdef DEBUG_SHUTDOWN
			lprintf( WIDE("Okay and that's done... next is %p %p"), proclist, shutdown_proc_schedule );
#endif
		}
		// nope by this time memory doesn't exist anywhere.
		//Release( local_pointer );
		//shutdown_proc_schedule = proc;
	}
#ifndef __STATIC_GLOBALS__
	deadstart_local_data = (struct deadstart_local_data_*)NULL;
#endif
	//shutdown_proc_schedule = NULL;
}
void DispelDeadstart( void )
{
	shutdown_proc_schedule = NULL;
}
#ifdef __cplusplus
ROOT_ATEXIT(AutoRunExits)
{
	InvokeExits();
}
#endif
void SuspendDeadstart( void )
{
	bSuspend++;
}
void ResumeDeadstart( void )
{
	bSuspend--;
	if( !bSuspend )
	{
		if( bInitialDone )
			InvokeDeadstart();
	}
}
SACK_DEADSTART_NAMESPACE_END
SACK_NAMESPACE
// linked into BAG to provide a common definition for function Exit()
// this then invokes an exit in the mainline program (if available)
void BAG_Exit( int code )
{
#ifndef __cplusplus_cli
	InvokeExits();
#endif
#undef exit
	exit( code );
}
// legacy linking code - might still be usin this for linux...
LOGICAL is_deadstart_complete( void )
{
	//extern uint32_t deadstart_complete;
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
//deadstart_complete;
		return bInitialDone;
#endif
	return FALSE;
}
SACK_NAMESPACE_END
SACK_DEADSTART_NAMESPACE
LOGICAL IsRootDeadstartStarted( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialStarted;
	return 0;
#else
	return bInitialStarted;
#endif
}
LOGICAL IsRootDeadstartComplete( void )
{
#ifndef __STATIC_GLOBALS__
	if( deadstart_local_data )
		return bInitialDone;
	return 0;
#else
	return bInitialDone;
#endif
}
#ifndef __STATIC__
#ifndef __WATCOMC__
#if !defined( __cplusplus_cli )
#if !defined( NO_DEADSTART_DLLMAIN ) && !defined( BUILD_PORTABLE_EXECUTABLE )
#  if !defined( __LINUX__ ) && !defined( __GNUC__ )
#    ifdef __cplusplus
extern "C"
#    endif
__declspec(dllexport)
	BOOL WINAPI DllMain(  HINSTANCE hinstDLL,
   DWORD fdwReason,
   LPVOID lpvReserved
		   )
{
	if( fdwReason == DLL_PROCESS_DETACH )
		InvokeExits();
	return TRUE;
}
#  else
void RootDestructor(void) __attribute__((destructor));
void RootDestructor( void )
{
	InvokeExits();
}
#  endif
#endif
#endif
#endif
#endif
SACK_DEADSTART_NAMESPACE_END
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2017++
 *
 *   created to provide standard logging features
 *   lprintf( format, ... ); simple, basic
 *   if DEBUG, then logs to a file of the same name as the program
 *   if RELEASE most of this logging goes away at compile time.
 *
 *  standardized to never use int.
 *
 * see also - include/logging.h
 *
 */
//#define SUPPORT_LOG_ALLOCATE
#define DEFAULT_OUTPUT_STDERR
#define COMPUTE_CPU_FREQUENCY
#define NO_UNICODE_C
//#undef UNICODE
#ifdef __LCC__
#include <intrinsics.h>
#endif
#ifdef __LINUX__
#include <time.h>
 // struct sockaddr_un
#include <sys/un.h>
#endif
#ifdef __ANDROID__
#include <android/log.h>
#endif
#ifdef WIN32
#ifndef _ARM_
 // unlink
#endif
#endif
#ifndef IDLE_FUNCTIONS_DEFINED
#define IDLE_FUNCTIONS_DEFINED
# ifdef IDLE_SOURCE
#  define IDLE_PROC(type,name) EXPORT_METHOD type CPROC name
# else
#  define IDLE_PROC(type,name) IMPORT_METHOD type CPROC name
# endif
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// return -1 if not the correct thread
// return 0 if no events processed
// return 1 if events were processed
typedef int (CPROC *IdleProc)(uintptr_t);
IDLE_PROC( void, AddIdleProc )( IdleProc Proc, uintptr_t psvUser );
IDLE_PROC( int, RemoveIdleProc )( IdleProc Proc );
IDLE_PROC( int, Idle )( void );
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds );
#ifdef __cplusplus
//	namespace timers {
	};
//namespace sack {
};
using namespace sack::timers;
#endif
#endif
// okay this brings TIGHT integration.... but standardization for core levels.
#ifndef __NO_OPTIONS__
#endif
#ifdef __cplusplus
#include <cstdio>
LOGGING_NAMESPACE
#endif
#ifndef _SH_DENYWR
#  define _SH_COMPAT 0x00
#  define _SH_DENYRW 0x10
#  define _SH_DENYWR 0x20
#  define _SH_DENYRD 0x30
#  define _SH_DENYNO 0x40
#  define _SH_SECURE 0x80
#endif
struct syslog_local_data {
int cannot_log;
#define cannot_log (*syslog_local).cannot_log
uint64_t cpu_tick_freq;
#define cpu_tick_freq (*syslog_local).cpu_tick_freq
// (*syslog_local).flags that control the operation of system logging....
struct state_flags{
	BIT_FIELD bInitialized : 1;
	BIT_FIELD bUseDay : 1;
	BIT_FIELD bUseDeltaTime : 1;
	BIT_FIELD bLogTime : 1;
	BIT_FIELD bLogHighTime : 1;
	BIT_FIELD bLogCPUTime : 1;
	BIT_FIELD bProtectLoggedFilenames : 1;
	BIT_FIELD bLogProgram : 1;
	BIT_FIELD bLogThreadID : 1;
	BIT_FIELD bLogOpenAppend : 1;
	BIT_FIELD bLogOpenBackup : 1;
	BIT_FIELD bLogSourceFile : 1;
	BIT_FIELD bOptionsLoaded : 1;
	BIT_FIELD group_ok : 1;
} flags;
// a conserviative minimalistic configuration...
//} (*syslog_local).flags = { 0,0,1,0,1,0,1,1,0};
 TEXTCHAR *pProgramName;
#define pProgramName (*syslog_local).pProgramName
 UserLoggingCallback UserCallback;
//#define User1Callback (*syslog_local).UserCallback
 enum syslog_types logtype;
#define logtype (*syslog_local).logtype
 // default log EVERYTHING
 uint32_t nLogLevel;
#define nLogLevel (*syslog_local).nLogLevel
 // bits enabled and disabled for custom mesasges...
 uint32_t nLogCustom;
#define nLogCustom (*syslog_local).nLogCustom
// = "LOG";
 CTEXTSTR gFilename;
#define gFilename (*syslog_local).gFilename
 FILE *file;
 SOCKET   hSock;
#define hSock (*syslog_local).hSock
 SOCKET   hSyslogdSock;
 // assume this works, until it fails
 int bCPUTickWorks;
#define bCPUTickWorks (*syslog_local).bCPUTickWorks
 uint64_t tick_bias;
 uint64_t lasttick;
 uint64_t lasttick2;
 LOGICAL bStarted;
 LOGICAL bLogging;
 LOGICAL bSyslogdLogging;
	PLINKQUEUE buffers;
#if defined( WIN32 )
	DWORD next_lprintf_tls;
#elif defined( __LINUX__ )
	pthread_key_t next_lprintf_tls;
#endif
};
#ifdef __ANDROID__
//#  if !USE_CUSTOM_ALLOCER
//#    define __STATIC_GLOBALS__
//#  endif //!USE_CUSTOM_ALLOCER
#endif
#ifndef __STATIC_GLOBALS__
struct syslog_local_data *syslog_local;
#else
struct syslog_local_data _syslog_local;
struct syslog_local_data *syslog_local = &_syslog_local;
#endif
static void DoSystemLog( const TEXTCHAR *buffer );
//----------------------------------------------------------------------------
// we should really wait until the very end to cleanup?
PRIORITY_ATEXIT( CleanSyslog, ATEXIT_PRIORITY_SYSLOG )
{
	enum syslog_types _logtype;
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
		return;
#endif
	_logtype = logtype;
	if( ( _logtype == SYSLOG_AUTO_FILE && (*syslog_local).file ) || ( _logtype == SYSLOG_NONE ) )
		lprintf( WIDE( "Final log - syslog clos(ing)ed." ) );
 // this was dynamic allocated memory, and it is now gone.
	pProgramName = NULL;
	logtype = SYSLOG_NONE;
	switch( _logtype )
	{
  // usually this is stderr ... don't do anything
	case SYSLOG_FILE:
		break;
	case SYSLOG_FILENAME:
		sack_fclose( (*syslog_local).file );
		break;
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
	case SYSLOG_SOCKET_SYSLOGD:
		closesocket( (*syslog_local).hSyslogdSock );
		(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		break;
#  endif
#endif
#ifndef __DISABLE_UDP_SYSLOG__
	case SYSLOG_UDP:
	case SYSLOG_UDPBROADCAST:
		closesocket( hSock );
		hSock = INVALID_SOCKET;
		break;
#endif
	default:
		// else... no resources to cleanup
		break;
	}
}
#if 0
        /*
         * this code would ideally check to see if
         * the cpu rdtsc instruction worked....
         * someday we should consider using the rdtscp instruction
         * but that will require fetching CPU characteristics
         * - SEE mmx.asm in src/imglib/
         */
void TestCPUTick( void )
{
	uint64_t tick, _tick;
	int n;
	bCPUTickWorks = 1;
	_tick = tick = GetCPUTick();
	for( n = 0; n < 10000000; n++ )
	{
#ifdef GCC
		//asm( "cpuid\n" );
#endif
		tick = GetCPUTick();
		if( tick > _tick )
		{
			//lprintf( "%020Ld %020Ld", _tick, tick );
			_tick = tick;
		}
		else
		{
			lprintf( "CPU TICK FAILED!" );
			bCPUTickWorks = 0;
			break;
		}
		Relinquish();
	}
}
#endif
#ifdef __WATCOMC__
unsigned __int64 rdtsc( void);
#pragma aux rdtsc = 0x0F 0x31 value [edx eax] parm nomemory modify exact [edx eax] nomemory;
//#pragma aux GetCPUTicks3 = "rdtsc"   "mov dword ptr tick, eax"	   "mov dword ptr tick+4, edx "
#endif
uint64_t GetCPUTick(void )
{
/*
 * being the core of CPU tick layer type stuff
 * this should result in ticks, and fail ticks
 * to return reasonable defaults...
 * I guess there should be a tick_base to result
 * the same type of number when it does go backwards
 */
	if( bCPUTickWorks )
	{
#if defined( __LCC__ )
		return _rdtsc();
#elif defined( __WATCOMC__ )
		uint64_t tick = rdtsc();
#ifndef __WATCOMC__
		// haha a nasty compiler trick to get the variable used
		// but it's also a 'meaningless expression' so watcom pukes.
		(1)?(0):(tick = 0);
#endif
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
#elif defined( _MSC_VER )
#ifdef _M_CEE_PURE
		//return System::DateTime::now;
		return 0;
#else
#   if defined( _WIN64 )
		uint64_t tick = __rdtsc();
#   else
		static uint64_t tick;
#     if _ARM_
		tick = tick+1;
#     else
		_asm rdtsc;
		_asm mov dword ptr [tick], eax;
		_asm mov dword ptr [tick + 4], edx;
#     endif
#   endif
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick;
		else if( tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick;
		return tick;
#endif
#elif defined( __GNUC__ ) && !defined( __arm__ ) && !defined( __aarch64__ )
		union {
			uint64_t tick;
			PREFIX_PACKED struct { uint32_t low, high; } PACKED parts;
		}tick;
		asm( "rdtsc\n" : "=a"(tick.parts.low), "=d"(tick.parts.high) );
		if( !(*syslog_local).lasttick )
			(*syslog_local).lasttick = tick.tick;
		else if( tick.tick < (*syslog_local).lasttick )
		{
			bCPUTickWorks = 0;
			cpu_tick_freq = 1;
/*GetTickCount()*/
			(*syslog_local).tick_bias = (*syslog_local).lasttick - ( timeGetTime() * 1000 );
 // more than prior, but no longer valid.
			tick.tick = (*syslog_local).lasttick + 1;
		}
		(*syslog_local).lasttick = tick.tick;
		return tick.tick;
#else
		DebugBreak();
#endif
	}
/*GetTickCount()*/
	return (*syslog_local).tick_bias + (timeGetTime() * 1000);
}
uint64_t GetCPUFrequency( void )
{
#ifdef COMPUTE_CPU_FREQUENCY
	{
		uint64_t cpu_tick, _cpu_tick;
		uint32_t tick, _tick;
		cpu_tick = _cpu_tick = GetCPUTick();
/*GetTickCount()*/
		tick = _tick = timeGetTime();
		cpu_tick_freq = 0;
/*GetTickCount()*/
		while( bCPUTickWorks && ( ( tick = timeGetTime() ) - _tick ) < 25 );
		cpu_tick = GetCPUTick();
		if( bCPUTickWorks )
 // microseconds;
			cpu_tick_freq = ( ( cpu_tick - _cpu_tick ) / ( tick - _tick ) )  / 1000;
	}
#else
	cpu_tick_freq = 1;
#endif
	return cpu_tick_freq;
}
void SetDefaultName( CTEXTSTR path, CTEXTSTR name, CTEXTSTR extra )
{
	TEXTCHAR *newpath;
	size_t len;
// = GetProgramPath();
	static CTEXTSTR filepath;
// = GetProgramName();
	static CTEXTSTR filename;
	if( path )
	{
		if( filepath )
			Release( (POINTER)filepath );
		filepath = StrDup( path );
	}
	if( name )
	{
		if( filename )
			Release( (POINTER)filename );
		filename = StrDup( name );
	}
	if( !filepath )
		filepath = ExpandPath( WIDE("*/") );
	if( !filename )
		filename = StrDup( GetProgramName() );
	if( !filename )
		filename = "org.d3x0r.sack";
	// this has to come from C heap.. my init isn't done yet probably and
	// sharemem will just fai(*syslog_local).  (it's probably trying to log... )
	newpath = (TEXTCHAR*)malloc( len = sizeof(TEXTCHAR)*(9 + StrLen( filepath ) + StrLen( filename ) + (extra?StrLen(extra):0) + 5) );
#ifdef __cplusplus_cli
	tnprintf( newpath, len, WIDE("%s/%s%s.cli.log"), filepath, filename, extra?extra:WIDE("") );
#else
	tnprintf( newpath, len, WIDE("%s/%s%s.log"), filepath, filename, extra?extra:WIDE("") );
#endif
//( newpath ); // use the C heap.
	gFilename = newpath;
	//free( newpath ); // get rid of this ...
}
#ifndef __NO_OPTIONS__
static void LoadOptions( void )
{
	if( !(*syslog_local).flags.bOptionsLoaded )
	{
		(*syslog_local).flags.bLogSourceFile = SACK_GetProfileIntEx( GetProgramName()
																 , WIDE( "SACK/Logging/Log Source File")
																 , (*syslog_local).flags.bLogSourceFile, TRUE );
#ifndef __ANDROID__
		// android has a system log that does just fine/ default startup sets that.
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Enable System Log" )
										, 0
										, TRUE ) )
		{
			logtype = SYSLOG_SYSTEM;
			(*syslog_local).flags.bLogProgram = 1;
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Enable File Log" )
										, ( logtype == SYSLOG_AUTO_FILE )
										, TRUE ) )
		{
			//logtype = SYSLOG_AUTO_FILE;
			(*syslog_local).flags.bLogOpenAppend = 0;
			(*syslog_local).flags.bLogOpenBackup = 1;
			(*syslog_local).flags.bLogProgram = 1;
		}
		// set all default parts of the name.
		// this overrides options with options available from SQL database.
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Logging/Default Log Location is current directory"), 0, TRUE ) )
		{
			// override filepath, if log exception.
			TEXTCHAR buffer[256];
			GetCurrentPath( buffer, sizeof( buffer ) );
			SetDefaultName( buffer, NULL, NULL );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Logging/Default Log Location is exectuable directory"), 0, TRUE ) )
		{
			SetDefaultName( GetProgramPath(), NULL, NULL );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Logging/Default Log Location is common data directory"), 1, TRUE ) )
		{
			SetDefaultName( NULL, NULL, NULL );
		}
		else
		{
			TEXTCHAR buffer[256];
			// if this is blank, then length result from getprofilestring is 0, and default is with the program.
			// so I'll lave functionality as expected for a default.
			SACK_GetProfileStringEx( GetProgramName(), WIDE( "SACK/Logging/Default Log Location" ), WIDE( "" ), buffer, sizeof( buffer ), TRUE );
			if( buffer[0] )
			{
				SetDefaultName( buffer, NULL, NULL );
			}
		}
#endif
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Send Log to UDP" ), 0, TRUE ) )
		{
			if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Broadcast UDP" ), 0, TRUE ) )
				logtype = SYSLOG_UDPBROADCAST;
			else
				logtype = SYSLOG_UDP;
		}
		nLogLevel = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Default Log Level (1001:all, 100:least)" ), nLogLevel, TRUE );
		// use the defaults; they may be overriden by reading the options.
		(*syslog_local).flags.bLogThreadID = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Thread ID" ), (*syslog_local).flags.bLogThreadID, TRUE );
		(*syslog_local).flags.bLogProgram = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Program" ), (*syslog_local).flags.bLogProgram, TRUE );
		(*syslog_local).flags.bLogSourceFile = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Source File" ), (*syslog_local).flags.bLogSourceFile, TRUE );
		if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log CPU Tick Time and Delta" ), (*syslog_local).flags.bLogCPUTime, TRUE ) )
		{
			SystemLogTime( SYSLOG_TIME_CPU|SYSLOG_TIME_DELTA );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Time as Delta" ), (*syslog_local).flags.bUseDeltaTime, TRUE ) )
		{
			SystemLogTime( SYSLOG_TIME_HIGH|SYSLOG_TIME_DELTA );
		}
		else if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Time" ), (*syslog_local).flags.bLogTime, TRUE ) )
		{
			if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Logging/Log Date" ), (*syslog_local).flags.bUseDay, TRUE ) )
			{
				SystemLogTime( SYSLOG_TIME_LOG_DAY|SYSLOG_TIME_HIGH );
			}
			else
				SystemLogTime( SYSLOG_TIME_HIGH );
		}
		else
			SystemLogTime( 0 );
		(*syslog_local).flags.bOptionsLoaded = 1;
	}
}
#endif
//static int init_complete;
void InitSyslog( int ignore_options )
{
#ifndef __STATIC_GLOBALS__
	if( syslog_local )
	{
#ifndef __NO_OPTIONS__
		if( !ignore_options )
			LoadOptions();
#endif
		return;
	}
	SimpleRegisterAndCreateGlobal( syslog_local );
	if( !(*syslog_local).flags.bInitialized )
#endif
	{
		//logtype = SYSLOG_FILE;
		//(*syslog_local).file = stderr;
#if defined( WIN32 )
		(*syslog_local).next_lprintf_tls = TlsAlloc();
#elif defined( __LINUX__ )
		pthread_key_create( &((*syslog_local).next_lprintf_tls), NULL );
#endif
		(*syslog_local).flags.bLogThreadID = 1;
		hSock = INVALID_SOCKET;
		(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		bCPUTickWorks = 1;
 // default log EVERYTHING
		nLogLevel = LOG_NOISE-1;
#ifdef __ANDROID__
		{
			logtype = SYSLOG_SYSTEM;
 // default log EVERYTHING
			nLogLevel = LOG_NOISE + 1000;
			(*syslog_local).flags.bLogSourceFile = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bLogThreadID = 1;
			(*syslog_local).flags.bLogProgram = 0;
			SystemLogTime( SYSLOG_TIME_HIGH );
		}
#else
#  if defined( _DEBUG ) || 1
		{
#    if defined( __LINUX__ ) && 0
			logtype = SYSLOG_SOCKET_SYSLOGD;
			(*syslog_local).flags.bLogProgram = 1;
#    else
			/* using SYSLOG_AUTO_FILE option does not require this to be open.
			* it is opened on demand.
			*/
#      if !defined( DEFAULT_OUTPUT_STDERR )
			logtype = SYSLOG_AUTO_FILE;
#      else
			logtype = SYSLOG_FILE;
			(*syslog_local).file = stderr;
#      endif
			(*syslog_local).flags.bLogOpenBackup = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bUseDeltaTime = 1;
			(*syslog_local).flags.bLogCPUTime = 1;
			(*syslog_local).flags.bLogProgram = 0;
			SystemLogTime( SYSLOG_TIME_HIGH );
#    endif
 // default log EVERYTHING
			nLogLevel = LOG_NOISE + 1000;
			(*syslog_local).flags.bLogOpenAppend = 0;
			(*syslog_local).flags.bLogSourceFile = 1;
			(*syslog_local).flags.bLogThreadID = 1;
			//SetDefaultName( NULL, NULL, NULL );
			//lprintf( WIDE("Syslog Initializing, debug mode, startup programname.log\n") );
		}
#  else
		// stderr?
		logtype = SYSLOG_NONE;
		(*syslog_local).file = NULL;
#  endif
#endif
		(*syslog_local).flags.bInitialized = 1;
	}
#ifndef __NO_OPTIONS__
	if( !ignore_options )
		LoadOptions();
#else
	(*syslog_local).flags.bOptionsLoaded = 1;
#  ifndef __ANDROID__
	SetDefaultName( NULL, NULL, NULL );
#  endif
#endif
}
PRIORITY_PRELOAD( InitSyslogPreload, SYSLOG_PRELOAD_PRIORITY )
{
	InitSyslog( 1 );
}
// delay reading options (unless we had to because of a logging requirement) but all core
// logging should be disabled (usually) until after init.
// that will allow these to be set with interface.conf defaults.
// but still fairly early...
PRIORITY_PRELOAD( InitSyslogPreloadWithOptions, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
	InitSyslog( 0 );
}
PRIORITY_PRELOAD( InitSyslogPreloadAllowGroups, DEFAULT_PRELOAD_PRIORITY + 1 )
{
	(*syslog_local).flags.group_ok = 1;
}
//----------------------------------------------------------------------------
CTEXTSTR GetTimeEx( int bUseDay )
{
	/* used by sqlite extension to support now() */
#ifdef _WIN32
#  ifndef WIN32
#    define WIN32 _WIN32
#  endif
#endif
#if defined( WIN32 ) && !defined( __ANDROID__ )
	static TEXTCHAR timebuffer[256];
	SYSTEMTIME st;
	GetLocalTime( &st );
	if( bUseDay )
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d/%02d/%d %02d:%02d:%02d")
		       , st.wMonth, st.wDay, st.wYear
		       , st.wHour, st.wMinute, st.wSecond );
	else
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d:%02d:%02d")
		       , st.wHour, st.wMinute, st.wSecond );
	return timebuffer;
#else
	static char timebuffer[256];
	struct tm *timething;
	time_t timevalnow;
	time(&timevalnow);
	timething = localtime( &timevalnow );
	strftime( timebuffer
				, sizeof( timebuffer )
				, (bUseDay)?"%m/%d/%Y %H:%M:%S":"%H:%M:%S"
			  , timething );
#endif
	return timebuffer;
}
CTEXTSTR GetTime( void )
{
	return GetTimeEx( (*syslog_local).flags.bUseDay );
}
CTEXTSTR GetPackedTime( void )
{
	/* used by sqlite extension to support now() */
#ifdef _WIN32
#  ifndef WIN32
#    define WIN32 _WIN32
#  endif
#endif
#if defined( WIN32 ) && !defined( __ANDROID__ )
	static TEXTCHAR timebuffer[256];
	SYSTEMTIME st;
	GetLocalTime( &st );
	tnprintf( timebuffer, sizeof(timebuffer), WIDE("%04d%02d%02d%02d%02d%02d")
	        , st.wYear
	        , st.wMonth, st.wDay
	        , st.wHour, st.wMinute, st.wSecond );
#else
	static char timebuffer[256];
	struct tm *timething;
	time_t timevalnow;
	time(&timevalnow);
	timething = localtime( &timevalnow );
	strftime( timebuffer
	        , sizeof( timebuffer )
	        , "%Y%m%d%H%M%S"
	        , timething );
#endif
	return timebuffer;
}
//----------------------------------------------------------------------------
 // no gettime of day - no milliseconds
#ifndef BCC16
static TEXTCHAR *GetTimeHigh( void )
{
#  if defined WIN32 && !defined( __ANDROID__ )
	 static TEXTCHAR timebuffer[256];
	static SYSTEMTIME _st;
	SYSTEMTIME st, st_save;
	if( (*syslog_local).flags.bUseDeltaTime )
	{
		GetLocalTime( &st );
		st_save = st;
		if( !_st.wYear )
			_st = st;
		st.wMilliseconds -= _st.wMilliseconds;
		if( st.wMilliseconds & 0x8000 )
		{
			st.wMilliseconds = (st.wMilliseconds+1000) & 0xFFFF;
			st.wSecond--;
		}
		st.wSecond -= _st.wSecond;
		if( st.wSecond & 0x8000 )
		{
			st.wSecond += 60;
			st.wMinute--;
		}
		st.wMinute -= _st.wMinute;
		if( st.wMinute & 0x8000 )
		{
			st.wMinute += 60;
			st.wHour--;
		}
		st.wHour -= _st.wHour;
		if( st.wHour & 0x8000 )
			st.wHour += 24;
		_st = st_save;
	}
	else
		GetLocalTime( &st );
	if( (*syslog_local).flags.bUseDay )
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d/%02d/%d %02d:%02d:%02d.%03d")
		        , st.wMonth, st.wDay, st.wYear
		        , st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
	else
		tnprintf( timebuffer, sizeof(timebuffer), WIDE("%02d:%02d:%02d.%03d")
		        , st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
#  else
	static char timebuffer[256];
	static struct timeval _tv;
	static struct tm _tm;
	struct timeval tv, tv_save;
	struct tm *timething, tm, tm_save;
	int len;
	gettimeofday( &tv, NULL );
	if( (*syslog_local).flags.bUseDeltaTime )
	{
		tv_save = tv;
		timething = localtime( &tv.tv_sec );
		tm = tm_save = *timething;
		if( !_tm.tm_year )
		{
			_tm = *timething;
			_tv = tv;
		}
		tv.tv_usec -= _tv.tv_usec;
		if( tv.tv_usec < 0 )
		{
			tv.tv_usec += 1000000;
			tm.tm_sec--;
		}
		tm.tm_sec -= _tm.tm_sec;
		if( tm.tm_sec < 0 )
		{
			tm.tm_sec += 60;
			tm.tm_min--;
		}
		tm.tm_min -= _tm.tm_min;
		if( tm.tm_min < 0 )
		{
			tm.tm_min += 60;
			tm.tm_hour--;
		}
		tm.tm_hour -= _tm.tm_hour;
		if( tm.tm_hour < 0 )
			tm.tm_hour += 24;
		_tm = tm_save;
		_tv = tv_save;
	}
	else
	{
		timething = localtime( &tv.tv_sec );
		tm = *timething;
	}
	len = strftime( timebuffer
	               , sizeof( timebuffer )
	               , ((*syslog_local).flags.bUseDay)?"%m/%d/%Y %H:%M:%S":"%H:%M:%S"
					  , &tm );
#  undef snprintf
	snprintf( timebuffer + len, 5, ".%03ld", tv.tv_usec / 1000 );
	/*
	// this code is kept in case borland's compiler don't like it.
	{
		time_t timevalnow;
		time(&timevalnow);
		timething = localtime( &timevalnow );
		strftime( timebuffer
		        , sizeof( timebuffer )
		        , WIDE("%m/%d/%Y %H:%M:%S.000")
		        , timething );
	}
	*/
#  endif
	return timebuffer;
}
#else
#  define GetTimeHigh GetTime
#endif
uint32_t ConvertTickToMicrosecond( uint64_t tick )
{
	if( bCPUTickWorks )
	{
		if( !cpu_tick_freq )
			GetCPUFrequency();
		if( !cpu_tick_freq )
			return 0;
		return (uint32_t)(tick / cpu_tick_freq);
	}
	else
		return (uint32_t)tick;
}
void PrintCPUDelta( TEXTCHAR *buffer, size_t buflen, uint64_t tick_start, uint64_t tick_end )
{
#ifdef COMPUTE_CPU_FREQUENCY
	if( !cpu_tick_freq )
		GetCPUFrequency();
	if( cpu_tick_freq )
		tnprintf( buffer, buflen, WIDE("%")_64f WIDE(".%03") _64f
				 , ((tick_end-tick_start) / cpu_tick_freq ) / 1000
				 , ((tick_end-tick_start) / cpu_tick_freq ) % 1000
				 );
	else
#endif
		tnprintf( buffer, buflen, WIDE("%")_64fs, tick_end - tick_start
			    );
}
static TEXTCHAR *GetTimeHighest( void )
{
	uint64_t tick;
	static TEXTCHAR timebuffer[64];
	tick = GetCPUTick();
	if( !(*syslog_local).lasttick2 )
		(*syslog_local).lasttick2 = tick;
	if( (*syslog_local).flags.bUseDeltaTime )
	{
#ifdef UNICODE
		size_t ofs = 0;
		tnprintf( timebuffer, sizeof( timebuffer ), WIDE("%20lld") WIDE(" "), tick );
		ofs += StrLen( timebuffer );
#else
		int ofs = tnprintf( timebuffer, sizeof( timebuffer ), WIDE("%20") _64fs WIDE(" "), tick );
#endif
		PrintCPUDelta( timebuffer + ofs, sizeof( timebuffer ) - ofs, (*syslog_local).lasttick2, tick );
		(*syslog_local).lasttick2 = tick;
	}
	else
		tnprintf( timebuffer, sizeof( timebuffer ), WIDE("%20") _64fs, tick );
	// have to find a generic way to get this from _asm( rdtsc );
	return timebuffer;
}
static CTEXTSTR GetLogTime( void )
{
	if( (*syslog_local).flags.bLogTime )
	{
		if( (*syslog_local).flags.bLogHighTime )
		{
			return GetTimeHigh();
		}
		else if( (*syslog_local).flags.bLogCPUTime )
		{
			return GetTimeHighest();
		}
		else
		{
			return GetTime();
		}
	}
	return WIDE("");
}
//----------------------------------------------------------------------------
#ifndef __DISABLE_UDP_SYSLOG__
#  if !defined( FBSD ) && !defined(__QNX__)
#    if defined( __MAC__ )
static SOCKADDR saLogBroadcast  = { 8, 2, { 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff } };
static SOCKADDR saLog  = { 8, 2, { 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01 } };
static SOCKADDR saBind = { 8, 2, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
#    else
static SOCKADDR saLogBroadcast  = { 2, { 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff } };
static SOCKADDR saLog  = { 2, { 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01 } };
static SOCKADDR saBind = { 2, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };
#    endif
#  else
static SOCKADDR saLogBroadcast  = { 2, 0x02, 0x02, (char)0xff, (char)0xff, (char)0xff, (char)0xff };
static SOCKADDR saLog  = { 2, 0x02, 0x02, 0x7f, 0x00, 0x00, 0x01  };
static SOCKADDR saBind = { 2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00  };
#  endif
static void UDPSystemLog( const TEXTCHAR *message )
{
#ifdef HAVE_IDLE
	while( (*syslog_local).bLogging )
		Idle();
#endif
	(*syslog_local).bLogging = 1;
	if( !(*syslog_local).bStarted )
	{
#ifdef _WIN32
#ifndef MAKEWORD
#define MAKEWORD(a,b) (((a)<<8)|(b))
#endif
  // used to start up the socket services...
		WSADATA ws;
		if( WSAStartup( MAKEWORD(1,1), &ws ) )
		{
			(*syslog_local).bLogging = 0;
			return;
		}
#endif
		(*syslog_local).bStarted = TRUE;
	}
	if( hSock == INVALID_SOCKET )
	{
		LOGICAL bEnable = TRUE;
		hSock = socket(PF_INET,SOCK_DGRAM,0);
		if( hSock == INVALID_SOCKET )
		{
			(*syslog_local).bLogging = 0;
			return;
		}
		if( bind(hSock,&saBind,sizeof(SOCKADDR)) )
		{
			closesocket( hSock );
			hSock = INVALID_SOCKET;
			(*syslog_local). bLogging = 0;
			return;
		}
#ifndef BCC16
		if( setsockopt( hSock, SOL_SOCKET
		              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
		{
			Log( WIDE("Failed to set sock opt - BROADCAST") );
		}
#endif
	}
	{
		//INDEX nSent;
		int nSend;
		static TEXTCHAR realmsg[1024];
 /*"[%s]"*/
		nSend = tnprintf( realmsg, sizeof( realmsg ), WIDE("%s")
				  //, pProgramName
		                , message );
		message = realmsg;
#ifdef __cplusplus_cli
		char *tmp = CStrDup( realmsg );
#  define SENDBUF tmp
#else
#  define SENDBUF message
#endif
		sendto( hSock, (const char *)SENDBUF, nSend, 0
		      , (logtype == SYSLOG_UDPBROADCAST)
		        ? &saLogBroadcast
		        : &saLog
		      , sizeof( SOCKADDR ) );
#ifdef __cplusplus_cli
		Release( tmp );
#endif
		if( logtype != SYSLOG_UDPBROADCAST )
 // allow logging agents time to pick this up...
			Relinquish();
	}
	(*syslog_local).bLogging = 0;
}
#endif
//----------------------------------------------------------------------------
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
#    if !defined( FBSD ) && !defined(__QNX__)
#       if defined( __MAC__ )
static struct sockaddr_un saSyslogdAddr  = { 11, AF_UNIX, "/dev/log" };
#       else
static struct sockaddr_un saSyslogdAddr  = { AF_UNIX, "/dev/log" };
#       endif
#    else
static struct sockaddr_un saSyslogdAddr  = { AF_UNIX, {"/dev/log"} };
#    endif
static void SyslogdSystemLog( const TEXTCHAR *message )
{
	while( (*syslog_local).bSyslogdLogging )
#    ifdef HAVE_IDLE
		Idle();
#    else
		Relinquish();
#    endif
	//fprintf( stderr, "present." );
	(*syslog_local).bSyslogdLogging = 1;
	if( (*syslog_local).hSyslogdSock == INVALID_SOCKET )
	{
		(*syslog_local).hSyslogdSock = socket(AF_UNIX,SOCK_DGRAM,0);
		if( (*syslog_local).hSyslogdSock == INVALID_SOCKET )
		{
			//fprintf( stderr, "failed..." );
			(*syslog_local).bSyslogdLogging = 0;
			return;
		}
		if(connect((*syslog_local).hSyslogdSock,(struct sockaddr *)&saSyslogdAddr,sizeof(saSyslogdAddr)) )
		{
			//fprintf( stderr, "failed..." );
			closesocket( (*syslog_local).hSyslogdSock );
			(*syslog_local).hSyslogdSock = INVALID_SOCKET;
			(*syslog_local).bSyslogdLogging = 0;
			return;
		}
	}
	if( (*syslog_local).hSyslogdSock != INVALID_SOCKET )
	{
		if( send( (*syslog_local).hSyslogdSock, message, StrLen( message ), 0 ) == 0 )
		{
			//fprintf( stderr, "failed..." );
			closesocket( (*syslog_local).hSyslogdSock );
			(*syslog_local).hSyslogdSock = INVALID_SOCKET;
		}
	}
	(*syslog_local).bSyslogdLogging = 0;
}
#  endif
#endif
#ifdef __LINUX__
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
LOGICAL IsBadReadPtr( CPOINTER pointer, uintptr_t len )
{
	static FILE *maps;
	//return FALSE;
	//DebugBreak();
	if( !maps )
		maps = fopen( "/proc/self/maps", "rt" );
	else
		fseek( maps, 0, SEEK_SET );
	//fprintf( stderr, WIDE("Testing a pointer..\n") );
	if( maps )
	{
		uintptr_t ptr = (uintptr_t)pointer;
		char line[256];
		while( fgets( line, sizeof(line)-1, maps ) )
		{
			uintptr_t low, high;
			sscanf( line, "%" cPTRSZVALfx "-%" cPTRSZVALfx, &low, &high );
			//fprintf( stderr, WIDE("%s") WIDE("Find: %08") PTRSZVALfx WIDE(" Low: %08") PTRSZVALfx WIDE(" High: %08") PTRSZVALfx WIDE("\n")
			//		 , line, pointer, low, high );
			if( ptr >= low && ptr <= high )
			{
				return FALSE;
			}
		}
	}
	//fprintf( stderr, WIDE("%p is not valid. %d"), pointer, errno );
	return TRUE;
}
//---------------------------------------------------------------------------
#endif
static void FileSystemLog( CTEXTSTR message )
{
	if( (*syslog_local).file )
	{
#ifdef SUPPORT_LOG_ALLOCATE
		fputs( message, (*syslog_local).file );
		fputs( "\n", (*syslog_local).file );
		fflush( (*syslog_local).file );
#else
#  ifdef UNICODE
		fputws( message, (*syslog_local).file );
		fputws( WIDE("\n"), (*syslog_local).file );
#  else
		sack_fputs( message, (*syslog_local).file );
		sack_fputs( "\n", (*syslog_local).file );
#  endif
		sack_fflush( (*syslog_local).file );
#endif
	}
}
static void BackupFile( const TEXTCHAR *source, int source_name_len, int n )
{
	FILE *testfile;
	INDEX group;
	testfile = sack_fsopenEx( group = GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ), source, WIDE("rt"), _SH_DENYWR, NULL );
	if( testfile )
	{
		TEXTCHAR backup[256];
		sack_fclose( testfile );
		// move file to backup..
		tnprintf( backup, sizeof( backup ), WIDE("%*.*s.%d")
				  , source_name_len
				  , source_name_len
				  , source, n );
		if( n < 10 )
		{
			BackupFile( backup
							, source_name_len
							, n+1 );
		}
		else
			sack_unlink( group, source );
		//lprintf( WIDE( "%s->%s" ), source, backup );
		sack_rename( source, backup );
	}
}
void DoSystemLog( const TEXTCHAR *buffer )
{
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		InitSyslog( 1 );
		if( logtype == SYSLOG_AUTO_FILE && !(*syslog_local).file )
		{
			// cannot log until system log is complete
			return;
		}
		if( ( logtype == SYSLOG_UDPBROADCAST ) || ( logtype == SYSLOG_UDP ) )
			return;
	}
#endif
#ifdef __LINUX__
#  ifndef __DISABLE_SYSLOGD_SYSLOG__
	if( logtype == SYSLOG_SOCKET_SYSLOGD )
		SyslogdSystemLog( buffer );
#  endif
#endif
#ifndef __DISABLE_UDP_SYSLOG__
	if( logtype == SYSLOG_UDP
		|| logtype == SYSLOG_UDPBROADCAST )
		UDPSystemLog( buffer );
#else
	if( 0 )
		;
#endif
	else if( ( logtype == SYSLOG_FILE ) || ( logtype == SYSLOG_AUTO_FILE ) )
	{
		if( logtype == SYSLOG_AUTO_FILE )
		{
			if( !(*syslog_local).file && gFilename )
			{
				int n_retry = 0;
			retry_again:
 // disable logging - internal functions might inadvertantly log something...
				logtype = SYSLOG_NONE;
				if(
#ifdef SUPPORT_LOG_ALLOCATE
					0 &&
#endif
					!(*syslog_local).flags.bOptionsLoaded )
				{
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, WIDE( "wt" ) );
#else
					(*syslog_local).file = sack_fsopen( 0, gFilename, WIDE("wt")
#  ifdef _UNICODE
						WIDE(", ccs=UNICODE")
#  endif
						, _SH_DENYWR );
#endif
				}
				else
				{
					if(
#ifdef SUPPORT_LOG_ALLOCATE
						0 &&
#endif
						(*syslog_local).flags.bLogOpenBackup )
					{
						BackupFile( gFilename, (int)StrLen( gFilename ), 1 );
					}
					else if( (*syslog_local).flags.bLogOpenAppend )
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, WIDE( "at+" ) );
#else
					(*syslog_local).file = sack_fsopen( (*syslog_local).flags.group_ok?GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ):(INDEX)0, gFilename, WIDE("at+")
#  ifdef _UNICODE
						WIDE(", ccs=UNICODE")
#  endif
						, _SH_DENYWR );
#endif
					if( (*syslog_local).file )
						fseek( (*syslog_local).file, 0, SEEK_END );
					else
#ifdef SUPPORT_LOG_ALLOCATE
					(*syslog_local).file = fopen( gFilename, WIDE( "wt" ) );
#else
					(*syslog_local).file = sack_fsopenEx( (*syslog_local).flags.group_ok?GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ):(INDEX)0, gFilename, WIDE("wt")
#  ifdef _UNICODE
							WIDE(", ccs=UNICODE")
#  endif
							, _SH_DENYWR, NULL );
#endif
				}
				//logtype = SYSLOG_AUTO_FILE;
				if( !(*syslog_local).file )
				{
					if( n_retry < 500 )
					{
						TEXTCHAR tmp[10];
						tnprintf( tmp, sizeof( tmp ), WIDE("%d"), n_retry++ );
						SetDefaultName( NULL, NULL, tmp );
						goto retry_again;
					}
					else
						// can't open the logging file, stop trying now, will save us trouble in the future
						logtype = SYSLOG_NONE;
				}
				logtype = SYSLOG_AUTO_FILE;
			}
		}
		FileSystemLog( buffer );
	}
#if defined( _WIN32 ) || defined( __ANDROID__ )
	else if( logtype == SYSLOG_SYSTEM )
	{
#  ifdef __cplusplus_cli
		// requires referenced xperdex.classes... if this doesn't compile, please add the reference
		//xperdex::classes::Log::log( gcnew System::String( buffer ) );
		//System::Console::WriteLine( gcnew System::String( buffer ) );
		//System::Diagnostics::Debug
#  else
#    ifdef __ANDROID__
		{
			static char *program_string;
			char *string = CStrDup( buffer );
			if( !program_string )
				program_string = CStrDup( GetProgramName() );
			if( !program_string )
				program_string = "com.unknown.app";
			__android_log_print( ANDROID_LOG_INFO, program_string, string );
			Release( string );
		}
#    else
		OutputDebugString( buffer );
		OutputDebugString( "\n" );
#    endif
#  endif
	}
	else
#endif
	if( logtype == SYSLOG_CALLBACK )
		(*syslog_local).UserCallback( buffer );
}
	static uint32_t openLock;
	static uint32_t lowLevelLock;
void SystemLogFL( const TEXTCHAR *message FILELINE_PASS )
{
	static TEXTCHAR buffer[4096];
	static TEXTCHAR threadid[32];
	static TEXTCHAR sourcefile[256];
	CTEXTSTR logtime;
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		if( !openLock ) {
			openLock = 1;
			InitSyslog( 1 );
		} else
			return;
		openLock = 0;
	}
#endif
	if( cannot_log )
		return;
	if( !(*syslog_local).flags.group_ok && openLock )
		return;
#ifdef WIN32
	while( InterlockedExchange( (long volatile*)&lowLevelLock, 1 ) ) Relinquish();
#else
	while( LockedExchange( &lowLevelLock, 1 ) ) Relinquish();
#endif
	logtime = GetLogTime();
	if( (*syslog_local).flags.bLogSourceFile && pFile )
	{
#ifndef _LOG_FULL_FILE_NAMES
		CTEXTSTR p;
		for( p = pFile + StrLen(pFile) -1;p > pFile;p-- )
			if( p[0] == '/' || p[0] == '\\' )
			{
				pFile = p+1;break;
			}
#endif
		tnprintf( sourcefile, sizeof( sourcefile ), WIDE("") FILELINE_FILELINEFMT  FILELINE_RELAY );
	}
	else
		sourcefile[0] = 0;
	if( (*syslog_local).flags.bLogThreadID )
		tnprintf( threadid, sizeof( threadid ), WIDE("%012") _64fX WIDE("~"), GetMyThreadID() );
	if( pFile )
		tnprintf( buffer, sizeof( buffer )
				  , WIDE("%s%s%s%s%s%s%s")
				  , logtime, logtime[0]?WIDE("|"):WIDE("")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?(GetProgramName()):WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  , (*syslog_local).flags.bLogSourceFile?sourcefile:WIDE("")
				  , message );
	else
		tnprintf( buffer, sizeof( buffer )
				  , WIDE("%s%s%s%s%s%s")
				  , logtime, logtime[0]?WIDE("|"):WIDE("")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?(GetProgramName()):WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  , message );
	DoSystemLog( buffer );
	lowLevelLock = 0;
}
#undef SystemLogEx
void SystemLogEx ( const TEXTCHAR *message DBG_PASS )
{
#ifdef _DEBUG
	SystemLogFL( message DBG_RELAY );
#else
	SystemLogFL( message FILELINE_NULL );
#endif
}
#undef SystemLog
 void  SystemLog ( const TEXTCHAR *message )
{
	SystemLogFL( message, NULL, 0 );
}
 void  LogBinaryFL ( const uint8_t* buffer, size_t size FILELINE_PASS )
{
	size_t nOut = size;
	const uint8_t* data = buffer;
#ifndef _LOG_FULL_FILE_NAMES
	if( pFile )
	{
		CTEXTSTR p;
		for( p = pFile + (pFile?StrLen(pFile) -1:0);p > pFile;p-- )
			if( p[0] == '/' || p[0] == '\\' )
			{
				pFile = p+1;break;
			}
	}
#endif
	// should make this expression something in signed_usigned_comparison...
	while( nOut && !( nOut & ( ((size_t)1) << ( ( sizeof( nOut ) * CHAR_BIT ) - 1 ) ) ) )
	{
		TEXTCHAR cOut[96];
		size_t ofs = 0;
		size_t x;
		ofs = 0;
		for ( x=0; x<nOut && x<16; x++ )
			ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE("%02X "), (unsigned char)data[x] );
		// space fill last partial buffer
		for( ; x < 16; x++ )
			ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE("   ") );
		for ( x=0; x<nOut && x<16; x++ )
		{
			if( data[x] >= 32 && data[x] < 127 )
				ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE("%c"), (unsigned char)data[x] );
			else
				ofs += tnprintf( cOut+ofs, sizeof(cOut)/sizeof(TEXTCHAR)-ofs, WIDE(".") );
		}
		SystemLogFL( cOut FILELINE_RELAY );
		nOut -= x;
		data += x;
	}
}
#undef LogBinaryEx
 void  LogBinaryEx ( const uint8_t* buffer, size_t size DBG_PASS )
{
#ifdef _DEBUG
	LogBinaryFL( buffer,size DBG_RELAY );
#else
	LogBinaryFL( buffer,size FILELINE_NULL );
#endif
}
#undef LogBinary
 void  LogBinary ( const uint8_t* buffer, size_t size )
{
	LogBinaryFL( buffer,size, NULL, 0 );
}
void  SetSystemLog ( enum syslog_types type, const void *data )
{
	if( (*syslog_local).file && ( logtype != SYSLOG_FILE ) )
	{
		FILE *close_file = (*syslog_local).file;
  // reset this first, in case logging closing.
		(*syslog_local).file = NULL;
		sack_fclose( close_file );
	}
	if( type == SYSLOG_FILE )
	{
		if( data )
		{
			logtype = type;
			(*syslog_local).file = (FILE*)data;
		}
	}
	else if( type == SYSLOG_FILENAME )
	{
		FILE *log;
		log = sack_fsopen( GetFileGroup( WIDE( "system.logs" ), GetProgramPath() ), (CTEXTSTR)data, WIDE("wt")
#ifdef _UNICODE
				WIDE(", ccs=UNICODE")
#endif
				, _SH_DENYWR );
		(*syslog_local).file = log;
		logtype = SYSLOG_FILE;
	}
	else if( type == SYSLOG_CALLBACK )
	{
		(*syslog_local).UserCallback = (UserLoggingCallback)data;
	}
	else
	{
		logtype = type;
	}
	//SystemLog( WIDE("thing is: ") STRSYM( (SYSLOG_EXTERN) ) );
}
 void  SystemLogTime ( LOGICAL enable )
{
	(*syslog_local).flags.bLogTime = FALSE;
	(*syslog_local).flags.bUseDay = FALSE;
	(*syslog_local).flags.bUseDeltaTime = FALSE;
	(*syslog_local).flags.bLogHighTime = FALSE;
	(*syslog_local).flags.bLogCPUTime = FALSE;
	if( enable )
	{
		(*syslog_local).flags.bLogTime = TRUE;
		if( enable & SYSLOG_TIME_HIGH )
			(*syslog_local).flags.bLogHighTime = TRUE;
		if( enable & SYSLOG_TIME_LOG_DAY )
			(*syslog_local).flags.bUseDay = TRUE;
		if( enable & SYSLOG_TIME_DELTA )
			(*syslog_local).flags.bUseDeltaTime = TRUE;
		if( enable & SYSLOG_TIME_CPU )
			(*syslog_local).flags.bLogCPUTime = TRUE;
	}
}
// information for the call to _real_lprintf file and line information...
struct next_lprint_info{
	// please use this enter when resulting a function, and leave from said function.
	// oh - but then we couldn't exist before crit sec code...
	//CRITICALSECTION cs;
	uint32_t nLevel;
	CTEXTSTR pFile;
	int nLine;
};
#define next_lprintf (*_next_lprintf)
static struct next_lprint_info *GetNextInfo( void )
{
	struct next_lprint_info *next;
#ifdef USE_CUSTOM_ALLOCER
#  if defined( WIN32 )
	if( !( next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls ) ) )
		TlsSetValue( (*syslog_local).next_lprintf_tls, next = (struct next_lprint_info*)malloc( sizeof( struct next_lprint_info ) ) );
#  elif defined( __LINUX__ )
	if( !( next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls ) ) )
		pthread_setspecific( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  endif
#else
#  if defined( WIN32 )
	if( !(next = (struct next_lprint_info*)TlsGetValue( (*syslog_local).next_lprintf_tls )) )
		TlsSetValue( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  elif defined( __LINUX__ )
	if( !(next = (struct next_lprint_info*)pthread_getspecific( (*syslog_local).next_lprintf_tls )) )
		pthread_setspecific( (*syslog_local).next_lprintf_tls, next = New( struct next_lprint_info ) );
#  endif
#endif
	return next;
}
static INDEX CPROC _null_vlprintf ( CTEXTSTR format, va_list args )
{
	return 0;
}
static INDEX CPROC _real_vlprintf ( CTEXTSTR format, va_list args )
{
#ifdef _DEBUG
	// this can be used to force logging early to stdout
	struct next_lprint_info *_next_lprintf = GetNextInfo();
#endif
	if( cannot_log )
		return 0;
	if( logtype != SYSLOG_NONE )
	{
		CTEXTSTR logtime = GetLogTime();
		size_t ofs;
		// because of threading concerns... either I dynamically allocate this...
		// or lock it.... or ...
		TEXTCHAR *buffer;
		TEXTCHAR threadid[32];
		cannot_log = 1;
		if( !(*syslog_local).buffers )
		{
			int n;
			(*syslog_local).buffers = CreateLinkQueue();
			for( n = 0; n < 6; n++ )
				EnqueLink( &(*syslog_local).buffers, (POINTER)1 );
			for( n = 0; n < 6; n++ )
				DequeLink( &(*syslog_local).buffers );
		}
		buffer = (TEXTCHAR*)DequeLink( &(*syslog_local).buffers );
		if( !buffer )
		{
			//DoSystemLog( WIDE( "Adding Logging Buffer" ) );
			buffer = NewArray( TEXTCHAR, 4096 );
		}
		// at this point we're not doing internal allocations...
		cannot_log = 0;
		if( logtime[0] )
#ifdef UNDER_CE
		{
			StringCbPrintf( buffer, 4096, WIDE("%s|")
							  , logtime );
			ofs = StrLen( buffer );
		}
#else
			ofs = tnprintf( buffer, 4095, WIDE("%s|")
							  , logtime );
#endif
		else
			ofs = 0;
		// argsize - the program's giving us file and line
		// debug for here or not, this must be used.
		if( (*syslog_local).flags.bLogThreadID )
			tnprintf( threadid, sizeof( threadid ), WIDE("%012") _64fX WIDE("~"), GetMyThreadID() );
#ifdef UNDER_CE
		tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s%s%s")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?GetProgramName():WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  );
		ofs += StrLen( buffer + ofs );
#else
		tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s%s%s")
				  , (*syslog_local).flags.bLogThreadID?threadid:WIDE("")
				  , (*syslog_local).flags.bLogProgram?GetProgramName():WIDE("")
				  , (*syslog_local).flags.bLogProgram?WIDE("@"):WIDE("")
				  );
		ofs += StrLen( buffer + ofs );
#endif
		{
#ifdef _DEBUG
			CTEXTSTR pFile;
#ifndef _LOG_FULL_FILE_NAMES
			CTEXTSTR p;
#endif
			uint32_t nLine;
			if( (*syslog_local).flags.bLogSourceFile && ( pFile = next_lprintf.pFile ) )
			{
				if( (*syslog_local).flags.bProtectLoggedFilenames )
					if( IsBadReadPtr( pFile, 2 ) )
						pFile = WIDE("(Unloaded file?)");
#   ifndef _LOG_FULL_FILE_NAMES
				for( p = pFile + StrLen(pFile) -1;p > pFile;p-- )
					if( p[0] == '/' || p[0] == '\\' )
					{
						pFile = p+1;break;
					}
#   endif
				nLine = next_lprintf.nLine;
#   ifdef UNDER_CE
				tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s(%") _32f WIDE("):")
									, pFile, nLine );
				ofs += StrLen( buffer + ofs );
#   else
				tnprintf( buffer + ofs, 4095 - ofs, WIDE("%s(%") _32f WIDE("):")
									, pFile, nLine );
				ofs += StrLen( buffer + ofs );
#   endif
			}
#endif
#ifdef UNICODE
			vswprintf( buffer + ofs, 4095 - ofs, format, args );
#else
			vsnprintf( buffer + ofs, 4095 - ofs, format, args );
#endif
			// okay, so even the above is unsafe, because Micro$oft has
			// decreed to be stupid.
			buffer[4095] = 0;
		}
		DoSystemLog( buffer );
		{
			cannot_log = 1;
			EnqueLink( &(*syslog_local).buffers, buffer );
			cannot_log = 0;
		}
	}
	//LeaveCriticalSec( &next_lprintf.cs );
	return 0;
}
static INDEX CPROC _real_lprintf( CTEXTSTR f, ... )
{
	va_list args;
	va_start( args, f );
	return _real_vlprintf( f, args );
}
static INDEX CPROC _null_lprintf( CTEXTSTR f, ... )
{
	return 0;
}
RealVLogFunction  _vxlprintf ( uint32_t level DBG_PASS )
{
	struct next_lprint_info *_next_lprintf;
	//EnterCriticalSec( &next_lprintf.cs );
	_next_lprintf = GetNextInfo();
	next_lprintf.nLevel = level;
#if _DEBUG
	next_lprintf.pFile = pFile;
	next_lprintf.nLine = nLine;
#endif
	if( level & LOG_CUSTOM )
	{
		if( !(level & nLogCustom) )
			return _null_vlprintf;
		return _real_vlprintf;
	}
	else if( level <= nLogLevel )
	{
		return _real_vlprintf;
	}
	return _null_vlprintf;
}
RealLogFunction _xlprintf( uint32_t level DBG_PASS )
{
	struct next_lprint_info *_next_lprintf;
	//EnterCriticalSec( &next_lprintf.cs );
#ifndef __STATIC_GLOBALS__
	if( !syslog_local )
	{
		if( !openLock ) {
			openLock = 1;
			InitSyslog( 1 );
		} else
			return _null_lprintf;
		//return _null_lprintf;
		openLock = 0;
	}
#endif
	_next_lprintf = GetNextInfo();
#if _DEBUG
	next_lprintf.pFile = pFile;
	next_lprintf.nLine = nLine;
#endif
	if( level & LOG_CUSTOM )
	{
		if( !(level & nLogCustom) )
			return _null_lprintf;
		next_lprintf.nLevel = level;
		return _real_lprintf;
	}
	else if( level <= nLogLevel )
	{
		next_lprintf.nLevel = level;
		return _real_lprintf;
	}
	return _null_lprintf;
}
#ifdef __WATCOMC__
// # again - WATCOM Compiler warning here, function
// defined, but never referenced.  This is true,
// but when the linker comes around to it, it cares for the
// presense of this function in order to force floating support
// for printf and scanf, since this is module is passed ANY
// format and ANY paramter, it may require floating point.
// no special handling required for GCC, lcc, MSVC
static int f(void )
{
	extern int fltused_;
	return fltused_ + (int)f;
	//int n = fltused_; // force inclusion of math libs...
}
#endif
void ProtectLoggedFilenames( LOGICAL bEnable )
{
	(*syslog_local).flags.bProtectLoggedFilenames = bEnable;
}
void SetSystemLoggingLevel( uint32_t nLevel )
{
	if( nLevel & LOG_CUSTOM )
	{
		nLogCustom |= nLevel & ( LOG_CUSTOM_BITS );
	}
	else if( nLevel & LOG_CUSTOM_DISABLE )
	{
		nLogCustom &= ~( nLevel & ( LOG_CUSTOM_BITS ) );
	}
	else
		nLogLevel = nLevel;
}
void SetSyslogOptions( FLAGSETTYPE *options )
{
	// the mat operations don't turn into valid bitfield operators. (watcom)
 // open for append, else open for write
	(*syslog_local).flags.bLogOpenAppend = TESTFLAG( options, SYSLOG_OPT_OPENAPPEND )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogOpenBackup = TESTFLAG( options, SYSLOG_OPT_OPEN_BACKUP )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogProgram = TESTFLAG( options, SYSLOG_OPT_LOG_PROGRAM_NAME )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogThreadID = TESTFLAG( options, SYSLOG_OPT_LOG_THREAD_ID )?1:0;
 // open for append, else open for write
	(*syslog_local).flags.bLogSourceFile = TESTFLAG( options, SYSLOG_OPT_LOG_SOURCE_FILE )?1:0;
}
#ifdef __cplusplus_cli
static public ref class Log
{
public:
	static void log( System::String^ ouptut )
	{
				pin_ptr<const WCHAR> _output = PtrToStringChars(ouptut);
				TEXTSTR __ouptut = DupWideToText( _output );
		lprintf( WIDE("%s"), __ouptut );
		Release( __ouptut );
	}
};
#endif
#ifdef __cplusplus
LOGGING_NAMESPACE_END
#endif
//---------------------------------------------------------------------------
// $Log: syslog.c,v $
// Revision 1.74  2005/05/30 11:56:36  d3x0r
// various fixes... working on psilib update optimization... various stabilitizations... also extending msgsvr functionality.
//
// < --- CUT ALL LOGGING --- >
//
// Revision 1.56  2003/12/04 10:41:30  panther
// remove watcom compile only option code
//
//
//#define DEBUG_LIBRARY_LOADING
#define NO_UNICODE_C
#define SYSTEM_CORE_SOURCE
#define FIX_RELEASE_COM_COLLISION
#define TASK_INFO_DEFINED
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
#ifdef WIN32
//#undef StrDup
//#undef StrRChr
#endif
#ifdef WIN32
#include <tlhelp32.h>
#include <psapi.h>
#endif
#ifdef __QNX__
#include <devctl.h>
#include <sys/procfs.h>
#endif
#ifdef __LINUX__
#include <sys/wait.h>
extern char **environ;
#  ifndef __MAC__
#    include <elf.h>
#  endif
#endif
#ifdef __cplusplus
using namespace sack::timers;
#endif
//--------------------------------------------------------------------------
struct task_info_tag;
SACK_SYSTEM_NAMESPACE
//typedef void (CPROC*TaskEnd)(uintptr_t, struct task_info_tag *task_ended);
typedef struct handle_info_tag
{
	//struct mydatapath_tag *pdp;
 // partial inputs...
   PTEXT pLine;
   char *name;
	int       bNextNew;
   PTHREAD   hThread;
#ifdef WIN32
   // read/write handle
   HANDLE    handle;
#else
   int       pair[2];
   // read/write handle
   int       handle;
#endif
} HANDLEINFO, *PHANDLEINFO;
//typedef void (CPROC*TaskEnd)(uintptr_t, struct task_info_tag *task_ended);
struct task_info_tag {
	struct {
		BIT_FIELD closed : 1;
		BIT_FIELD process_ended : 1;
		BIT_FIELD bSentIoTerminator : 1;
		BIT_FIELD log_input : 1;
	} flags;
	TaskEnd EndNotice;
	TaskOutput OutputEvent;
	uintptr_t psvEnd;
	HANDLEINFO hStdIn;
	HANDLEINFO hStdOut;
	volatile PTHREAD pOutputThread;
	//HANDLEINFO hStdErr;
#if defined(WIN32)
	HANDLE hReadOut, hWriteOut;
	//HANDLE hReadErr, hWriteErr;
	HANDLE hReadIn, hWriteIn;
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
   DWORD exitcode;
#elif defined( __LINUX__ )
   int hReadOut, hWriteOut;
   //HANDLE hReadErr, hWriteErr;
	int hReadIn, hWriteIn;
   pid_t pid;
   uint32_t exitcode;
#endif
};
typedef struct loaded_function_tag
{
	uint32_t references;
	void (CPROC*function)(void );
	struct loaded_library_tag *library;
	DeclareLink( struct loaded_function_tag );
  // can be an integer value... instead of a string...
	CTEXTSTR name;
 // this is more than 1; allocation pads extra bytes for the name.
	TEXTCHAR _name[1];
} FUNCTION, *PFUNCTION;
#ifdef WIN32
typedef HMODULE HLIBRARY;
#else
typedef void* HLIBRARY;
#endif
typedef struct loaded_library_tag
{
 // when unloading...
	uintptr_t nLibrary;
	HLIBRARY library;
	LOGICAL mapped;
	PFUNCTION functions;
	DeclareLink( struct loaded_library_tag );
 // points into full_name after last slash - just library name
	TEXTCHAR *name;
	int loading;
// this is appended after full_name and is l.library_path
	TEXTCHAR *alt_full_name;
	TEXTCHAR *cur_full_name;
	TEXTCHAR *orig_name;
// this is more than 1; allocation pads extra bytes for the name. prefixed iwth l.load_path
	TEXTCHAR full_name[1];
} LIBRARY, *PLIBRARY;
#ifndef SYSTEM_CORE_SOURCE
extern
#endif
  struct local_systemlib_data {
	CTEXTSTR load_path;
	CTEXTSTR library_path;
	CTEXTSTR common_data_path;
	struct system_local_flags{
		BIT_FIELD bLog : 1;
		BIT_FIELD bInitialized : 1;
	} flags;
  // pointer to just filename part...
	CTEXTSTR filename;
	TEXTCHAR *work_path;
	PLIST system_tasks;
	PLIBRARY libraries;
	PTREEROOT pFunctionTree;
	int nLibrary;
	LOGICAL (CPROC*ExternalLoadLibrary)( const char *filename );
 // please Release or Deallocate the reutrn value
	char * (CPROC*ExternalFindProgram)( const char *filename );
	// on XP this is in PSAPI.DLL later it's in Kernel32.DLL
#ifdef WIN32
	BOOL (WINAPI* EnumProcessModules)( HANDLE hProcess, HMODULE *lphModule
	                                 , DWORD cb, LPDWORD lpcbNeeded );
#endif
} *local_systemlib;
#ifdef l
#   undef l
#endif
#define l (*local_systemlib)
int TryShellExecute( PTASK_INFO task, CTEXTSTR path, CTEXTSTR program, PTEXT cmdline );
#ifdef __MAC__
//sourced from https://github.com/comex/myvmmap/blob/master/myvmmap.c Jan/7/2018
#  include <mach/mach.h>
#  if __IPHONE_OS_VERSION_MIN_REQUIRED
kern_return_t mach_vm_read_overwrite(vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, mach_vm_address_t data, mach_vm_size_t *outsize);
kern_return_t mach_vm_region(vm_map_t target_task, mach_vm_address_t *address, mach_vm_size_t *size, vm_region_flavor_t flavor, vm_region_info_t info, mach_msg_type_number_t *infoCnt, mach_port_t *object_name);
int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);
int proc_regionfilename(int pid, uint64_t address, void * buffer, uint32_t buffersize);
#  else
#    include <mach/mach_vm.h>
#    include <libproc.h>
#  endif
//#include <stdio.h>
#  include <assert.h>
#  include <mach-o/loader.h>
#  include <mach-o/nlist.h>
//#include <string.h>
//#include <stdbool.h>
//#include <stdlib.h>
//#include <setjmp.h>
//#include <sys/queue.h>
//#include <sys/param.h>
#  if !__IPHONE_OS_VERSION_MIN_REQUIRED
#    include <Security/Security.h>
#  endif
#endif
//-------------------------------------------------------------------------
//  Function/library manipulation routines...
//-------------------------------------------------------------------------
typedef struct task_info_tag TASK_INFO;
#ifdef __ANDROID__
static CTEXTSTR program_name;
static CTEXTSTR program_path;
static CTEXTSTR library_path;
static CTEXTSTR working_path;
void SACKSystemSetProgramPath( char *path )
{
	program_path = DupCStr( path );
}
void SACKSystemSetProgramName( char *name )
{
	program_name = DupCStr( name );
}
void SACKSystemSetWorkingPath( char *name )
{
	working_path = DupCStr( name );
}
void SACKSystemSetLibraryPath( char *name )
{
	library_path = DupCStr( name );
}
#endif
#ifdef HAVE_ENVIRONMENT
CTEXTSTR OSALOT_GetEnvironmentVariable(CTEXTSTR name)
{
#ifdef WIN32
	static int env_size;
	static TEXTCHAR *env;
	int size;
	if( size = GetEnvironmentVariable( name, NULL, 0 ) )
	{
		if( size > env_size )
		{
			if( env )
				ReleaseEx( (POINTER)env DBG_SRC );
			env = NewArray( TEXTCHAR, size + 10 );
			env_size = size + 10;
		}
		if( GetEnvironmentVariable( name, env, env_size ) )
			return env;
	}
	return NULL;
#else
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		static TEXTCHAR *result;
		if( result )
			ReleaseEx( result DBG_SRC );
		result = DupCStr( getenv( tmpname ) );
		ReleaseEx( tmpname DBG_SRC );
	}
#else
	return getenv( name );
#endif
#endif
}
void OSALOT_SetEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 ) || defined( __CYGWIN__ )
	SetEnvironmentVariable( name, value );
#else
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		char * tmpvalue = CStrDup( value );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpname DBG_SRC );
		ReleaseEx( tmpvalue DBG_SRC );
	}
#else
	setenv( name, value, TRUE );
#endif
#endif
}
void OSALOT_AppendEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 ) || defined( __CYGWIN__ )
	TEXTCHAR *oldpath;
	TEXTCHAR *newpath;
	uint32_t length;
	{
		int oldlen;
		oldpath = NewArray( TEXTCHAR, oldlen = ( GetEnvironmentVariable( name, NULL, 0 ) + 1 ) );
		GetEnvironmentVariable( name, oldpath, oldlen );
	}
	newpath = NewArray( TEXTCHAR, length = (uint32_t)(StrLen( oldpath ) + 2 + StrLen(value)) );
#  ifdef UNICODE
	snwprintf( newpath, length, WIDE("%s;%s"), oldpath, value );
#  else
	snprintf( newpath, length, WIDE("%s;%s"), oldpath, value );
#  endif
	SetEnvironmentVariable( name, newpath );
	ReleaseEx( newpath DBG_SRC );
	ReleaseEx( oldpath DBG_SRC );
#else
#ifdef UNICODE
	char *tmpname = CStrDup( name );
	char *_oldpath = getenv( tmpname );
	TEXTCHAR *oldpath = DupCStr( _oldpath );
#else
	char *oldpath = getenv( name );
#endif
	TEXTCHAR *newpath;
	size_t maxlen;
	newpath = NewArray( TEXTCHAR, maxlen = ( StrLen( oldpath ) + StrLen( value ) + 2 ) );
	tnprintf( newpath, maxlen, WIDE("%s:%s"), oldpath, value );
#ifdef UNICODE
	{
		char * tmpvalue = CStrDup( newpath );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpvalue DBG_SRC );
	}
	ReleaseEx( oldpath DBG_SRC );
	ReleaseEx( tmpname DBG_SRC );
#else
	setenv( name, newpath, TRUE );
#endif
	ReleaseEx( newpath DBG_SRC );
#endif
}
void OSALOT_PrependEnvironmentVariable(CTEXTSTR name, CTEXTSTR value)
{
#if defined( WIN32 )|| defined( __CYGWIN__ )
	TEXTCHAR *oldpath;
	TEXTCHAR *newpath;
	int length;
	{
		int oldlen;
		oldpath = NewArray( TEXTCHAR, oldlen = ( GetEnvironmentVariable( name, NULL, 0 ) + 1 ) );
		GetEnvironmentVariable( name, oldpath, oldlen );
	}
	newpath = NewArray( TEXTCHAR, length = (uint32_t)(StrLen( oldpath ) + 2 + StrLen(value)) );
#  ifdef UNICODE
	snwprintf( newpath, length, WIDE("%s;%s"), value, oldpath );
#  else
	snprintf( newpath, length, WIDE("%s;%s"), value, oldpath );
#  endif
	SetEnvironmentVariable( name, newpath );
	ReleaseEx( newpath DBG_SRC );
	ReleaseEx( oldpath DBG_SRC );
#else
#ifdef UNICODE
	char *tmpname = CStrDup( name );
	char *_oldpath = getenv( tmpname );
	TEXTCHAR *oldpath = DupCStr( _oldpath );
#else
	char *oldpath = getenv( name );
#endif
	TEXTCHAR *newpath;
	int length;
	newpath = NewArray( TEXTCHAR, length = StrLen( oldpath ) + StrLen( value ) + 1 );
	tnprintf( newpath, length, WIDE("%s:%s"), value, oldpath );
#ifdef UNICODE
	{
		char *tmpname = CStrDup( name );
		char * tmpvalue = CStrDup( newpath );
		setenv( tmpname, tmpvalue, TRUE );
		ReleaseEx( tmpname DBG_SRC );
		ReleaseEx( tmpvalue DBG_SRC );
	}
#else
	setenv( name, newpath, TRUE );
#endif
	ReleaseEx( newpath DBG_SRC );
#endif
}
#endif
#ifdef __MAC__
static bool is_64bit;
static mach_port_t task;
static int pid;
static task_dyld_info_data_t dyld_info;
static jmp_buf recovery_buf;
static int read_from_task(void *p, mach_vm_address_t addr, mach_vm_size_t size) {
    mach_vm_size_t outsize;
    kern_return_t kr = mach_vm_read_overwrite(task, addr, size, (mach_vm_address_t) p, &outsize);
    if(kr || outsize != size) {
#if 0
        fprintf(stderr, "read_from_task(0x%llx, 0x%llx): ", (long long) addr, (long long) size);
        if(kr)
            fprintf(stderr, "kr=%d\n", (int) kr);
        else
            fprintf(stderr, "short read\n");
#endif
				return 0;
        //_longjmp(recovery_buf, 1);
    }
		return 1;
}
static uint64_t read_64(char **pp) {
    return *(*(uint64_t **)pp)++;
}
static uint32_t read_32(char **pp) {
    return *(*(uint32_t **)pp)++;
}
static mach_vm_address_t read_ptr(char **pp) {
    return is_64bit ? read_64(pp) : read_32(pp);
}
static void lookup_dyld_images() {
    char all_images[12], *p = all_images;
    if( !read_from_task(p, dyld_info.all_image_info_addr + 4, 12) )
			return;
    uint32_t info_array_count = read_32(&p);
    mach_vm_address_t info_array = read_ptr(&p);
    if(info_array_count > 10000) {
        fprintf(stderr, "** dyld image info had malformed data.\n");
        return;
    }
    size_t size = (is_64bit ? 24 : 12) * info_array_count;
    char *image_info = NewArray( char, size);
    p = image_info;
    if( !read_from_task(p, info_array, size) )
			return;
    for(uint32_t i = 0; i < info_array_count; i++) {
        mach_vm_address_t
            load_address = read_ptr(&p),
            file_path_addr = read_ptr(&p);
 // file_mod_date
        read_ptr(&p);
        //if(_setjmp(recovery_buf))
        //    continue;
        char path[MAXPATHLEN + 1];
        if( !read_from_task(path, file_path_addr, sizeof(path)) )
				   continue;
        if(strnlen(path, sizeof(path)) == sizeof(path))
            fprintf(stderr, "** dyld image info had malformed data.\n");
        else {
					  AddMappedLibrary( path, dlopen( path, 0 ) );
            //printf( "PATH:%s %p", path, load_address );
            //printf( "  load is %p\n", dlopen( path, 0 ) );
            //if( dlsym( load_address, "dlsym" )) printf( "** FOUND DLSYM**\n");
          }
    }
    return;
}
void loadMacLibraries(struct local_systemlib_data *init_l) {
    bool got_showaddr = false;
    mach_vm_address_t showaddr;
    pid = getpid();
    task = mach_task_self();
    char path[MAXPATHLEN];
    size_t path_size;
    if((path_size = proc_pidpath(pid, path, sizeof(path))))
        path[path_size] = 0;
    else
        strcpy(path, "????");
    //printf("%d: %s\n", pid, path);
    {
				TEXTCHAR *ext, *ext1;
				ext = (TEXTSTR)StrRChr( (CTEXTSTR)path, '.' );
				if( ext )
						ext[0] = 0;
				ext1 = (TEXTSTR)pathrchr( path );
				if( ext1 )
				{
						ext1[0] = 0;
						(*init_l).filename = StrDupEx( ext1 + 1 DBG_SRC );
						(*init_l).load_path = StrDupEx( path DBG_SRC );
				}
				else
				{
						(*init_l).filename = StrDupEx( path DBG_SRC );
						(*init_l).load_path = StrDupEx( WIDE("") DBG_SRC );
				}
		}
    assert(!task_info(task, TASK_DYLD_INFO, (task_info_t) &dyld_info, (mach_msg_type_number_t[]) {TASK_DYLD_INFO_COUNT}));
    is_64bit = dyld_info.all_image_info_addr >= (1ull << 32);
    lookup_dyld_images();
}
#endif
static void CPROC SetupSystemServices( POINTER mem, uintptr_t size )
{
	struct local_systemlib_data *init_l = (struct local_systemlib_data *)mem;
#ifdef _WIN32
	extern void InitCo( void );
	InitCo();
	{
		TEXTCHAR filepath[256];
		TEXTCHAR *ext, *ext1;
		GetModuleFileName( NULL, filepath, sizeof( filepath ) );
		ext = (TEXTSTR)StrRChr( (CTEXTSTR)filepath, '.' );
		if( ext )
			ext[0] = 0;
		ext1 = (TEXTSTR)pathrchr( filepath );
		if( ext1 )
		{
			ext1[0] = 0;
			(*init_l).filename = StrDupEx( ext1 + 1 DBG_SRC );
			(*init_l).load_path = StrDupEx( filepath DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( filepath DBG_SRC );
			(*init_l).load_path = StrDupEx( WIDE("") DBG_SRC );
		}
		GetModuleFileName( LoadLibrary( TARGETNAME ), filepath, sizeof( filepath ) );
		ext1 = (TEXTSTR)pathrchr( filepath );
		if( ext1 )
		{
			ext1[0] = 0;
			if( filepath[0] == '\\' && filepath[1] == '\\' && filepath[2] == '?' && filepath[3] == '\\' )
				(*init_l).library_path = StrDupEx( filepath +4 DBG_SRC );
			else
				(*init_l).library_path = StrDupEx( filepath DBG_SRC );
		}
		else
		{
			(*init_l).load_path = StrDupEx( WIDE("") DBG_SRC );
		}
#ifdef HAVE_ENVIRONMENT
		OSALOT_SetEnvironmentVariable( WIDE("MY_LOAD_PATH"), filepath );
#endif
	}
#else
#  if defined( __QNX__ )
	{
		struct dinfo_s {
			procfs_debuginfo info;
			char pathbuffer[_POSIX_PATH_MAX];
		};
		struct dinfo_s dinfo;
		char buf[256], *pb;
		int proc_fd;
		proc_fd = open("/proc/self/as",O_RDONLY);
		if( proc_fd >= 0 )
		{
			int status;
			status = devctl( proc_fd, DCMD_PROC_MAPDEBUG_BASE, &dinfo, sizeof(dinfo),
								 0 );
			if( status != EOK )
			{
				lprintf( "Error in devctl() call. %s",
						  strerror(status) );
				(*init_l).filename = "FailedToReadFilenaem";
				(*init_l).load_path = ".";
				(*init_l).work_path = ".";
				return;
			}
			close(proc_fd);
		}
		snprintf( buf, 256, "/%s", dinfo.info.path );
		pb = (char*)pathrchr(buf);
		if( pb )
		{
			pb[0]=0;
			(*init_l).filename = StrDupEx( pb + 1 DBG_SRC );
		}
		else
		{
			(*init_l).filename = StrDupEx( buf DBG_SRC );
			buf[0] = '.';
			buf[1] = 0;
		}
		if( StrCmp( buf, WIDE("/.") ) == 0 )
			GetCurrentPath( buf, 256 );
		//lprintf( WIDE("My execution: %s"), buf);
		(*init_l).load_path = StrDupEx( buf DBG_SRC );
		OSALOT_SetEnvironmentVariable( WIDE("MY_LOAD_PATH"), (*init_l).load_path );
		//strcpy( pMyPath, buf );
		GetCurrentPath( buf, sizeof( buf ) );
		OSALOT_SetEnvironmentVariable( WIDE( "MY_WORK_PATH" ), buf );
		(*init_l).work_path = StrDupEx( buf DBG_SRC );
		SetDefaultFilePath( (*init_l).work_path );
	}
#  else
	// this might be clever to do, auto export the LD_LIBRARY_PATH
	// but if we loaded this library, then didn't we already have a good path?
	// use /proc/self to get to cmdline
	// which has the whole invokation of this process.
#    ifdef __ANDROID__
	(*init_l).filename = GetProgramName();
	(*init_l).load_path = GetProgramPath();
	if( !(*init_l).filename || !(*init_l).load_path )
	{
		char buf[256];
		FILE *maps = fopen( "/proc/self/maps", "rt" );
		while( maps && fgets( buf, 256, maps ) )
		{
			unsigned long start;
			unsigned long end;
			sscanf( buf, "%lx", &start );
			sscanf( buf+9, "%lx", &end );
			if( ((unsigned long)SetupSystemServices >= start ) && ((unsigned long)SetupSystemServices <= end ) )
			{
				char *myname;
				char *mypath;
				void *lib;
				char *myext;
				void (*InvokeDeadstart)(void );
				void (*MarkRootDeadstartComplete)(void );
				fclose( maps );
				maps = NULL;
				if( strlen( buf ) > 49 )
				mypath = strdup( buf + 49 );
				myext = strrchr( mypath, '.' );
				myname = strrchr( mypath, '/' );
				if( myname )
				{
					myname[0] = 0;
					myname++;
				}
				else
					myname = mypath;
				if( myext )
				{
					myext[0] = 0;
				}
				//LOGI( "my path [%s][%s]", mypath, myname );
				// do not auto load libraries
				SACKSystemSetProgramPath( mypath );
				(*init_l).load_path =  DupCStr( mypath );
				SACKSystemSetProgramName( myname );
				(*init_l).filename = DupCStr( myname );
				SACKSystemSetWorkingPath( buf );
				break;
			}
		}
	}
#    else
	//if( !(*init_l).filename || !(*init_l).load_path )
	{
		/* #include unistd.h, stdio.h, string.h */
		{
			char buf[256];
#       ifndef __MAC__
			char *pb;
			int n;
			n = readlink("/proc/self/exe",buf,256);
			if( n >= 0 )
			{
 //linux
				buf[n]=0;
				if( !n )
				{
					strcpy( buf, WIDE(".") );
 // fbsd
					buf[ n = readlink( WIDE("/proc/curproc/"),buf,256)]=0;
				}
			}
			else
				strcpy( buf, WIDE(".")) ;
			pb = strrchr(buf,'/');
			if( pb )
				pb[0]=0;
			else
				pb = buf - 1;
			//lprintf( WIDE("My execution: %s"), buf);
			(*init_l).filename = StrDupEx( pb + 1 DBG_SRC );
			(*init_l).load_path = StrDupEx( buf DBG_SRC );
#       endif
			local_systemlib = init_l;
			AddMappedLibrary( "dummy", NULL );
#       ifdef __MAC__
			loadMacLibraries( init_l );
#       endif
			local_systemlib = NULL;
			{
				PLIBRARY library = (*init_l).libraries;
				while( library )
				{
					if( StrCaseCmp( library->name, TARGETNAME ) == 0 )
						break;
					library = library->next;
				}
				if( !library ) {
					lprintf( "FATALITY:Did not manage to find self:%s", TARGETNAME );
					PLIBRARY library = (*init_l).libraries;
					while( library )
					{
						lprintf( "library->name:%s", library->name );
						library = library->next;
					}
				}
				//if( library )
				{
					char *dupname;
					char *path;
					dupname = StrDup( library->full_name );
					path = strrchr( dupname, '/' );
					if( path )
						path[0] = 0;
					(*init_l).library_path = dupname;
				}
			}
			setenv( WIDE("MY_LOAD_PATH"), (*init_l).load_path, TRUE );
			//strcpy( pMyPath, buf );
			GetCurrentPath( buf, sizeof( buf ) );
			setenv( WIDE( "MY_WORK_PATH" ), buf, TRUE );
			(*init_l).work_path = StrDupEx( buf DBG_SRC );
		}
		{
			TEXTCHAR *oldpath;
			TEXTCHAR *newpath;
			oldpath = getenv( "LD_LIBRARY_PATH" );
			if( oldpath )
			{
				newpath = NewArray( char, (uint32_t)((oldpath?StrLen( oldpath ):0) + 2 + StrLen((*init_l).library_path)) );
				sprintf( newpath, WIDE("%s:%s"), (*init_l).library_path
						 , oldpath );
				setenv( WIDE("LD_LIBRARY_PATH"), newpath, 1 );
				ReleaseEx( newpath DBG_SRC );
			}
		}
		{
			TEXTCHAR *oldpath;
			TEXTCHAR *newpath;
			oldpath = getenv( "PATH" );
			if( oldpath )
			{
				newpath = NewArray( char, (uint32_t)((oldpath?StrLen( oldpath ):0) + 2 + StrLen((*init_l).load_path)) );
				sprintf( newpath, WIDE("%s:%s"), (*init_l).load_path
						 , oldpath );
				setenv( WIDE("PATH"), newpath, 1 );
				ReleaseEx( newpath DBG_SRC );
			}
		}
		//<x`int> rathar: main() { char buf[1<<7]; buf[readlink("/proc/self/exe",buf,1<<7)]=0; puts(buf); }
		//<x`int> main() {  }
		//<x`int>
	}
#    endif
#  endif
#endif
}
static void SystemInit( void )
{
	if( !local_systemlib )
	{
		RegisterAndCreateGlobalWithInit( (POINTER*)&local_systemlib, sizeof( *local_systemlib ), WIDE("system"), SetupSystemServices );
#ifdef WIN32
		if( !l.flags.bInitialized )
		{
			TEXTCHAR filepath[256];
			GetCurrentPath( filepath, sizeof( filepath ) );
			l.work_path = StrDupEx( filepath DBG_SRC );
			SetDefaultFilePath( l.work_path );
#ifdef HAVE_ENVIRONMENT
			OSALOT_SetEnvironmentVariable( WIDE( "MY_WORK_PATH" ), filepath );
#endif
			l.flags.bInitialized = 1;
#  ifdef WIN32
			l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction( WIDE("psapi.dll"), WIDE("EnumProcessModules"));
			if( !l.EnumProcessModules )
				l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction(WIDE("kernel32.dll"), WIDE("EnumProcessModules"));
			if( !l.EnumProcessModules )
				l.EnumProcessModules = (BOOL(WINAPI*)(HANDLE,HMODULE*,DWORD,LPDWORD))LoadFunction(WIDE("kernel32.dll"), WIDE("K32EnumProcessModules") );
#  endif
		}
#endif
	}
}
PRIORITY_PRELOAD( SetupPath, OSALOT_PRELOAD_PRIORITY )
{
	SystemInit();
}
#ifndef __NO_OPTIONS__
PRELOAD( SetupSystemOptions )
{
	//lprintf( "SYSTEM OPTION INIT" );
	l.flags.bLog = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/System/Enable Logging" ), 0, TRUE );
	if( SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/System/Auto prepend program location to PATH environment" ), 0, TRUE ) ){
		//lprintf( "Add %s to path", l.load_path );
		OSALOT_PrependEnvironmentVariable( WIDE("PATH"), l.load_path );
	}
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
#ifndef _M_CEE_PURE
static BOOL CALLBACK CheckWindowAndSendKill( HWND hWnd, LPARAM lParam )
{
	uint32_t idThread, idProcess;
	PTASK_INFO task = (PTASK_INFO)lParam;
	idThread = GetWindowThreadProcessId( hWnd, (LPDWORD)&idProcess );
	/*
	{
		TEXTCHAR title[256];
		GetWindowText( hWnd, title, sizeof( title ) );
		lprintf( "Window [%s] = %d %d", title, idProcess, idThread );
	}
	*/
	if( task->pi.dwProcessId == idProcess )
	{
		// found the window to kill...
		PostThreadMessage( idThread, WM_QUIT, 0xD1E, 0 );
		return FALSE;
	}
	return TRUE;
}
#endif
//--------------------------------------------------------------------------
int CPROC EndTaskWindow( PTASK_INFO task )
{
	return EnumWindows( CheckWindowAndSendKill, (LPARAM)task );
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
#if _MSC_VER
#pragma runtime_checks( "sru", off )
#endif
static DWORD STDCALL SendCtrlCThreadProc( void *data )
{
	return GenerateConsoleCtrlEvent( CTRL_BREAK_EVENT, 0 );
}
#if _MSC_VER
#pragma runtime_checks( "sru", restore )
#endif
#endif
LOGICAL CPROC StopProgram( PTASK_INFO task )
{
	task->flags.process_ended = 1;
	if( task->pOutputThread )
		WakeThread( task->pOutputThread );
#ifdef WIN32
#ifndef UNDER_CE
	int error;
	if( !GenerateConsoleCtrlEvent( CTRL_C_EVENT, task->pi.dwProcessId ) )
	{
		error = GetLastError();
		lprintf( WIDE( "Failed to send CTRL_C_EVENT %d" ), error );
		if( !GenerateConsoleCtrlEvent( CTRL_BREAK_EVENT, task->pi.dwProcessId ) )
		{
			error = GetLastError();
			lprintf( WIDE( "Failed to send CTRL_BREAK_EVENT %d" ), error );
		}
	}
	// try and copy some code to it..
	{
		POINTER mem = VirtualAllocEx( task->pi.hProcess, NULL, 4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE );
		DWORD err = GetLastError();
		if( mem ) {
			SIZE_T written;
			if( WriteProcessMemory( task->pi.hProcess, mem,
				(LPCVOID)SendCtrlCThreadProc, 1024, &written ) ) {
				DWORD dwThread;
				HANDLE hThread = CreateRemoteThread( task->pi.hProcess, NULL, 0
					, (LPTHREAD_START_ROUTINE)mem, NULL, 0, &dwThread );
				err = GetLastError();
				if( hThread )
					if( WaitForSingleObject( task->pi.hProcess, 50 ) != WAIT_OBJECT_0 )
						return FALSE;
					else
						return TRUE;
			}
		}
	}
#endif
	if( WaitForSingleObject( task->pi.hProcess, 1 ) != WAIT_OBJECT_0 )
		return FALSE;
	else
		return TRUE;
#else
	//lprintf( "need to send kill() to signal process to stop" );
	kill( task->pid, SIGINT );
#endif
	return FALSE;
}
uintptr_t CPROC TerminateProgram( PTASK_INFO task )
{
	if( task )
	{
#if defined( WIN32 )
		int bDontCloseProcess = 0;
#endif
		if( !task->flags.closed )
		{
			task->flags.closed = 1;
			//lprintf( WIDE( "%ld, %ld %p %p" ), task->pi.dwProcessId, task->pi.dwThreadId, task->pi.hProcess, task->pi.hThread );
#if defined( WIN32 )
			if( WaitForSingleObject( task->pi.hProcess, 0 ) != WAIT_OBJECT_0 )
			{
				int nowait = 0;
				// try using ctrl-c, ctrl-break to end process...
				if( !StopProgram( task ) )
				{
					xlprintf(LOG_LEVEL_DEBUG+1)( WIDE("Program did not respond to ctrl-c or ctrl-break...") );
					// if ctrl-c fails, try finding the window, and sending exit (systray close)
					if( EndTaskWindow( task ) )
					{
						xlprintf(LOG_LEVEL_DEBUG+1)( WIDE("failed to find task window to send postquitmessage...") );
						// didn't find the window - result was continue_enum with no more (1)
						// so didn't find the window - nothing to wait for, fall through
						nowait = 1;
					}
				}
				if( nowait || ( WaitForSingleObject( task->pi.hProcess, 500 ) != WAIT_OBJECT_0 ) )
				{
					xlprintf(LOG_LEVEL_DEBUG+1)( WIDE("Terminating process....") );
					bDontCloseProcess = 1;
					if( !TerminateProcess( task->pi.hProcess, 0xD1E ) )
					{
						HANDLE hTmp;
						lprintf( WIDE("Failed to terminate process... %p %ld : %d (will try again with OpenProcess)"), task->pi.hProcess, task->pi.dwProcessId, GetLastError() );
						hTmp = OpenProcess( SYNCHRONIZE|PROCESS_TERMINATE, FALSE, task->pi.dwProcessId);
						if( !TerminateProcess( hTmp, 0xD1E ) )
						{
							lprintf( WIDE("Failed to terminate process... %p %ld : %d"), task->pi.hProcess, task->pi.dwProcessId, GetLastError() );
						}
						CloseHandle( hTmp );
					}
				}
			}
			if( !task->EndNotice )
			{
				lprintf( WIDE( "Closing handle (no end notification)" ) );
				// task end notice - will get the event and close these...
				CloseHandle( task->pi.hThread );
				task->pi.hThread = 0;
				if( !bDontCloseProcess )
				{
					lprintf( WIDE( "And close process handle" ) );
					CloseHandle( task->pi.hProcess );
					task->pi.hProcess = 0;
				}
				else
					lprintf( WIDE( "Keeping process handle" ) );
			}
//			else
//				lprintf( WIDE( "Would have close handles rudely." ) );
#else
			kill( task->pid, SIGTERM );
			// wait a moment for it to die...
#endif
		}
		//if( !task->EndNotice )
		//{
		//	Release( task );
		//}
		//task = NULL;
	}
	return 0;
}
//--------------------------------------------------------------------------
SYSTEM_PROC( void, SetProgramUserData )( PTASK_INFO task, uintptr_t psv )
{
	if( task )
		task->psvEnd = psv;
}
//--------------------------------------------------------------------------
uint32_t GetTaskExitCode( PTASK_INFO task )
{
	if( task )
		return task->exitcode;
	return 0;
}
uintptr_t CPROC WaitForTaskEnd( PTHREAD pThread )
{
	PTASK_INFO task = (PTASK_INFO)GetThreadParam( pThread );
#ifdef __LINUX__
	while( !task->pid ) {
		Relinquish();
	}
#endif
	// this should be considered the owner of this.
	if( !task->EndNotice )
	{
		// application is dumb, hold the task for him; otherwise
		// the application is aware that after EndNotification the task is no longer valid.
		Hold( task );
	}
	//if( task->EndNotice )
	{
		// allow other people to delete it...
		//Hold( task );
#if defined( WIN32 )
		WaitForSingleObject( task->pi.hProcess, INFINITE );
		GetExitCodeProcess( task->pi.hProcess, &task->exitcode );
#elif defined( __LINUX__ )
		waitpid( task->pid, NULL, 0 );
#endif
		task->flags.process_ended = 1;
		if( task->hStdOut.hThread )
		{
#ifdef _WIN32
			// vista++ so this won't work for XP support...
			static BOOL (WINAPI *MyCancelSynchronousIo)( HANDLE hThread ) = (BOOL(WINAPI*)(HANDLE))-1;
			if( (uintptr_t)MyCancelSynchronousIo == (uintptr_t)-1 )
				MyCancelSynchronousIo = (BOOL(WINAPI*)(HANDLE))LoadFunction( WIDE( "kernel32.dll" ), WIDE( "CancelSynchronousIo" ) );
			if( MyCancelSynchronousIo )
			{
				if( !MyCancelSynchronousIo( GetThreadHandle( task->hStdOut.hThread ) ) )
				{
					// maybe the read wasn't queued yet....
					//lprintf( "Failed to cancel IO on thread %d %d", GetThreadHandle( task->hStdOut.hThread ), GetLastError() );
				}
			}
			else
			{
				static BOOL (WINAPI *MyCancelIoEx)( HANDLE hFile,LPOVERLAPPED ) = (BOOL(WINAPI*)(HANDLE,LPOVERLAPPED))-1;
				if( (uintptr_t)MyCancelIoEx == (uintptr_t)-1 )
					MyCancelIoEx = (BOOL(WINAPI*)(HANDLE,LPOVERLAPPED))LoadFunction( WIDE( "kernel32.dll" ), WIDE( "CancelIoEx" ) );
				if( MyCancelIoEx )
					MyCancelIoEx( task->hStdOut.handle, NULL );
				else
				{
					DWORD written;
					//lprintf( WIDE( "really? You're still using xp or less?" ) );
					task->flags.bSentIoTerminator = 1;
					if( !WriteFile( task->hWriteOut, WIDE( "\x04" ), 1, &written, NULL ) )
					lprintf( WIDE( "write pipe failed! %d" ), GetLastError() );
					//lprintf( "Pipe write was %d", written );
				}
			}
#endif
		}
		// wait for task last output before notification of end of task.
		while( task->pOutputThread )
			Relinquish();
		if( task->EndNotice )
			task->EndNotice( task->psvEnd, task );
#if defined( WIN32 )
		//lprintf( WIDE( "Closing process and thread handles." ) );
		if( task->pi.hProcess )
		{
			CloseHandle( task->pi.hProcess );
			task->pi.hProcess = 0;
		}
		if( task->pi.hThread )
		{
			CloseHandle( task->pi.hThread );
			task->pi.hThread = 0;
		}
#endif
		ReleaseEx( task DBG_SRC );
	}
	//TerminateProgram( task );
	return 0;
}
//--------------------------------------------------------------------------
#ifdef WIN32
static int DumpError( void )
{
#ifdef _DEBUG
	lprintf( WIDE("Failed create process:%d"), GetLastError() );
#endif
	return 0;
}
#endif
#ifdef WIN32
static BOOL CALLBACK EnumDesktopProc( LPTSTR lpszDesktop,
												 LPARAM lParam
												)
{
	lprintf( WIDE( "Desktop found [%s]" ), lpszDesktop );
	return 1;
}
void EnumDesktop( void )
{
	// I'm running on some windows station, right?
	//HWINSTA GetProcessWindowStation();
	if( EnumDesktops( NULL, EnumDesktopProc, (LPARAM)(uintptr_t)0 ) )
	{
		// returned non-zero value from enumdesktopproc?
		// failed to find?
	}
}
static BOOL CALLBACK EnumStationProc( LPTSTR lpszWindowStation, LPARAM lParam )
{
	lprintf( WIDE( "station found [%s]" ), lpszWindowStation );
	return 1;
}
void EnumStations( void )
{
	if( EnumWindowStations( EnumStationProc, 0 ) )
	{
	}
}
void SetDefaultDesktop( void )
{
	//return;
	{
	HDESK lngDefaultDesktop;
	HWINSTA lngWinSta0;
	HWINSTA station = GetProcessWindowStation();
	HDESK desk = GetThreadDesktop( GetCurrentThreadId() );
	DWORD length;
	char buffer[256];
	lprintf( WIDE( "Desktop this is %p %p" ), station, desk );
	GetUserObjectInformation( desk, UOI_NAME, buffer, sizeof( buffer ), &length );
	lprintf( WIDE( "desktop is %s" ), buffer );
	GetUserObjectInformation( station, UOI_NAME, buffer, sizeof( buffer ), &length );
	lprintf( WIDE( "station is %s" ), buffer );
	EnumDesktop();
	EnumStations();
	// these should be const strings, but they're not... add typecast for GCC
	lngWinSta0 = OpenWindowStation( (LPTSTR)WIDE( "WinSta0" ), FALSE, WINSTA_ALL_ACCESS );
	//lngWinSta0 = OpenWindowStation(WIDE( "msswindowstation" ), FALSE, WINSTA_ALL_ACCESS );
	lprintf( WIDE( "sta = %p %d" ), lngWinSta0, GetLastError() );
	if( !SetProcessWindowStation(lngWinSta0) )
		lprintf( WIDE( "Failed station set?" ) );
	// these should be const strings, but they're not... add typecast for GCC
	lngDefaultDesktop = OpenDesktop( (LPTSTR)WIDE( "Default" ), 0, FALSE, 0x10000000);
	//lngDefaultDesktop = OpenDesktop(WIDE( "WinSta0" ), 0, FALSE, 0x10000000);
	lprintf( WIDE( "defa = %p" ), lngDefaultDesktop );
	if( !SetThreadDesktop(lngDefaultDesktop) )
		lprintf( WIDE( "Failed desktop set?" ) );
	}
}
		/*
 HDESK WINAPI OpenInputDesktop(
  __in  DWORD dwFlags,
  __in  BOOL fInherit,
  __in  ACCESS_MASK dwDesiredAccess
);
*/
DWORD GetExplorerProcessID()
{
	static TEXTCHAR process_find[128];
	HANDLE hSnapshot;
	PROCESSENTRY32 pe32;
	DWORD temp = 0;
	ZeroMemory(&pe32,sizeof(pe32));
	if( !process_find[0] )
	{
#ifndef __NO_OPTIONS__
		SACK_GetProfileStringEx( GetProgramName(), WIDE( "SACK/System/Impersonate Process" ), WIDE( "explorer.exe" ), process_find, sizeof( process_find ), TRUE );
#endif
	}
	hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	pe32.dwSize = sizeof(PROCESSENTRY32);
	if(Process32First(hSnapshot,&pe32))
	{
		do
		{
			//lprintf( WIDE( "Thing is %s" ), pe32.szExeFile );
			if(!StrCmp(pe32.szExeFile,process_find))
			{
				//MessageBox(0,pe32.szExeFile,WIDE( "test" ),0);
				temp = pe32.th32ProcessID;
				break;
			}
		}while(Process32Next(hSnapshot,&pe32));
	}
	return temp;
}
void ImpersonateInteractiveUser( void )
{
	HANDLE hToken = NULL;
	HANDLE hProcess = NULL;
	DWORD processID;
	SetDefaultDesktop();
	processID = GetExplorerProcessID();
	//lprintf( WIDE( "Enum EDesktops..." ) );
	//EnumDesktop();
	//lprintf( WIDE( "explorer is %p" ), processID );
	if( processID)
	{
		hProcess =
			OpenProcess(
							PROCESS_ALL_ACCESS,
							TRUE,
							processID );
		if( hProcess)
		{
			//lprintf( WIDE( "Success getting process %p" ), hProcess );
			if( OpenProcessToken(
										hProcess,
										TOKEN_EXECUTE |
										TOKEN_READ |
										TOKEN_QUERY |
										TOKEN_ASSIGN_PRIMARY |
										TOKEN_QUERY_SOURCE |
										TOKEN_WRITE |
										TOKEN_DUPLICATE |
										TOKEN_IMPERSONATE,
										&hToken))
			{
				//lprintf( WIDE( "Sucess opening token" ) );
				if( ImpersonateLoggedOnUser( hToken ) )
					;
				else
					lprintf( WIDE( "Fail impersonate %d" ), GetLastError() );
				CloseHandle( hToken );
			}
			else
				lprintf( WIDE( "Failed opening token %d" ), GetLastError() );
			CloseHandle( hProcess );
		}
		else
			lprintf( WIDE( "Failed open process: %d" ), GetLastError() );
	}
	else
		lprintf( WIDE( "Failed get explorer process: %d" ), GetLastError() );
}
HANDLE GetImpersonationToken( void )
{
	HANDLE hToken = NULL;
	HANDLE hProcess = NULL;
	DWORD processID;
	processID = GetExplorerProcessID();
	//lprintf( WIDE( "Enum EDesktops..." ) );
	//EnumDesktop();
	//lprintf( WIDE( "explorer is %p" ), processID );
	if( processID)
	{
		hProcess =
			OpenProcess(
							PROCESS_ALL_ACCESS,
							TRUE,
							processID );
		if( hProcess)
		{
			//lprintf( WIDE( "Success getting process %p" ), hProcess );
			if( OpenProcessToken(
										hProcess,
										TOKEN_EXECUTE |
										TOKEN_READ |
										TOKEN_QUERY |
										TOKEN_ASSIGN_PRIMARY |
										TOKEN_QUERY_SOURCE |
										TOKEN_WRITE |
										TOKEN_DUPLICATE |
										TOKEN_IMPERSONATE,
										&hToken))
			{
				//lprintf( WIDE( "Sucess opening token" ) );
				//if( ImpersonateLoggedOnUser( hToken ) )
				//   ;
				//else
				//   lprintf( WIDE( "Fail impersonate %d" ), GetLastError() );
				//CloseHandle( hToken );
			}
			else
				lprintf( WIDE( "Failed opening token %d" ), GetLastError() );
			CloseHandle( hProcess );
		}
		else
			lprintf( WIDE( "Failed open process: %d" ), GetLastError() );
	}
	else
		lprintf( WIDE( "Failed get explorer process: %d" ), GetLastError() );
	return hToken;
}
void EndImpersonation( void )
{
	RevertToSelf();
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
int TryShellExecute( PTASK_INFO task, CTEXTSTR path, CTEXTSTR program, PTEXT cmdline )
{
#if 0
#if defined( OLD_MINGW_SUX ) || defined( __WATCOMC__ )
	typedef struct _SHELLEXECUTEINFO {
		DWORD     cbSize;
		ULONG     fMask;
		HWND      hwnd;
 // null default
		LPCTSTR   lpVerb;
		LPCTSTR   lpFile;
		LPCTSTR   lpParameters;
		LPCTSTR   lpDirectory;
		int       nShow;
		HINSTANCE hInstApp;
		LPVOID    lpIDList;
		LPCTSTR   lpClass;
		HKEY      hkeyClass;
		DWORD     dwHotKey;
		union {
			HANDLE hIcon;
			HANDLE hMonitor;
		} DUMMYUNIONNAME;
		HANDLE    hProcess;
	} SHELLEXECUTEINFO, *LPSHELLEXECUTEINFO;
#endif
#endif
	SHELLEXECUTEINFO execinfo;
	MemSet( &execinfo, 0, sizeof( execinfo ) );
	execinfo.cbSize = sizeof( SHELLEXECUTEINFO );
  // need this to get process handle back for terminate later
	execinfo.fMask = SEE_MASK_NOCLOSEPROCESS
		| SEE_MASK_FLAG_NO_UI
		| SEE_MASK_NO_CONSOLE
		//| SEE_MASK_NOASYNC
		;
	execinfo.lpFile = program;
	execinfo.lpDirectory = path;
	{
		TEXTCHAR *params;
		for( params = GetText( cmdline ); params[0] && params[0] != ' '; params++ );
		if( params[0] )
		{
			//lprintf( WIDE( "adding extra parames [%s]" ), params );
			execinfo.lpParameters = params;
		}
	}
	execinfo.nShow = SW_SHOWNORMAL;
	if( ShellExecuteEx( &execinfo ) )
	{
		if( (uintptr_t)execinfo.hInstApp > 32)
		{
			switch( (uintptr_t)execinfo.hInstApp )
			{
			case 42:
#ifdef _DEBUG
				lprintf( WIDE( "No association picked : %p (gle:%d)" ), (uintptr_t)execinfo.hInstApp , GetLastError() );
#endif
				break;
			}
#ifdef _DEBUG
			lprintf( WIDE( "sucess with shellexecute of(%p) %s " ), execinfo.hInstApp, program );
#endif
			task->pi.hProcess = execinfo.hProcess;
			task->pi.hThread = 0;
			return TRUE;
		}
		else
		{
			//switch( (uintptr_t)execinfo.hInstApp )
			{
			//default:
				lprintf( WIDE( "Shell exec error : %p (gle:%d)" ), (uintptr_t)execinfo.hInstApp , GetLastError() );
				//break;
			}
			return FALSE;
		}
	}
	else
		lprintf( WIDE( "Shellexec error %d" ), GetLastError() );
	return FALSE;
}
#endif
//--------------------------------------------------------------------------
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// Use GetTaskExitCode() to get the return code of the process
SYSTEM_PROC( PTASK_INFO, LaunchProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args, TaskEnd EndNotice, uintptr_t psv )
{
	return LaunchPeerProgramExx( program, path, args
						            , LPP_OPTION_DO_NOT_HIDE | LPP_OPTION_NEW_GROUP
										, NULL, EndNotice, psv DBG_SRC );
}
SYSTEM_PROC( PTASK_INFO, LaunchProgram )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args )
{
	return LaunchProgramEx( program, path, args, NULL, 0 );
}
//--------------------------------------------------------------------------
void InvokeLibraryLoad( void )
{
	void (CPROC *f)(void);
	PCLASSROOT data = NULL;
	PCLASSROOT event_root = GetClassRoot( WIDE("SACK/system/library/load_event") );
	CTEXTSTR name;
	for( name = GetFirstRegisteredName( event_root, &data );
		 name;
		  name = GetNextRegisteredName( &data ) )
	{
		f = GetRegisteredProcedureExx( data,(CTEXTSTR)NULL,void,name,(void));
		if( f )
		{
			f();
		}
	}
}
// look for all the libraries that are currently already loaded (so we know to just load them the normal way)
#define Seek(a,b) (((uintptr_t)a)+(b))
static void LoadExistingLibraries( void )
{
#ifdef WIN32
	DWORD n = 256;
	HMODULE *modules = NewArray( HMODULE, 256 );
	DWORD needed;
	if( !l.EnumProcessModules )
	{
		//lprintf( "Failed to load EnumProcessModules" );
		return;
	}
	l.EnumProcessModules( GetCurrentProcess(), modules, sizeof( HMODULE ) * 256, &needed );
	if( needed / sizeof( HMODULE ) == n )
		lprintf( WIDE("loaded module overflow") );
	needed /= sizeof( HMODULE );
	for( n = 0; n < needed; n++ )
	{
		POINTER real_memory = modules[n];
		PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)real_memory;
		PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( real_memory, source_dos_header->e_lfanew );
		PIMAGE_DATA_DIRECTORY dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
		PIMAGE_EXPORT_DIRECTORY exp_dir = (PIMAGE_EXPORT_DIRECTORY)Seek( real_memory, dir[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress );
		const char *dll_name = (const char*) Seek( real_memory, exp_dir->Name );
		if( exp_dir->Name > source_nt_header->OptionalHeader.SizeOfImage )
		{
			dll_name = "Invalid_Name";
		}
#ifdef UNICODE
		{
			TEXTSTR _dll_name = DupCStr( dll_name );
#define dll_name _dll_name
#endif
			AddMappedLibrary( dll_name, modules[n] );
#ifdef UNICODE
			Deallocate( TEXTSTR, _dll_name );
#undef dll_name
		}
#endif
	}
#endif
#ifdef __MAC__
	lookup_dyld_images();
#else
#  ifdef __LINUX__
	{
		FILE *maps;
		char buf[256];
		maps = sack_fopenEx( 0, "/proc/self/maps", "rt", sack_get_mounted_filesystem( "native" ) );
		while( maps && sack_fgets( buf, 256, maps ) )
		{
			char *libpath = strchr( buf, '/' );
			char *split = strchr( buf, '-' );
			if( libpath && split )
			{
				char *dll_name = strrchr( libpath, '/' );
				size_t start, end;
				char perms[8];
				size_t offset;
				int scanned;
				offset = strlen( buf );
				if( offset < 2 )
					continue;
				buf[offset-1] = 0;
				scanned = sscanf( buf, "%zx-%zx %s %zx", &start, &end, perms, &offset );
				//lprintf( "so sscanf said: %d %d", scanned, offset );
				if( scanned == 4 && offset == 0 )
				{
					//lprintf( "Perms:%s", perms );
					if( ( end - start ) > 4 )
						if( ( ((unsigned char*)start)[0] == ELFMAG0 )
						   && ( ((unsigned char*)start)[1] == ELFMAG1 )
						   && ( ((unsigned char*)start)[2] == ELFMAG2 )
							&& ( ((unsigned char*)start)[3] == ELFMAG3 ) )
						{
							//lprintf( "Add library %s %p", dll_name + 1, start );
							AddMappedLibrary( libpath, (POINTER)start );
						}
				}
			}
		}
		sack_fclose( maps );
	}
#  endif
#endif
}
SYSTEM_PROC( LOGICAL, IsMappedLibrary)( CTEXTSTR libname )
{
	PLIBRARY library = l.libraries;
	if( !l.libraries )
	{
		LoadExistingLibraries();
		library = l.libraries;
	}
	while( library )
	{
		if( library->library && StrCaseCmp( library->name, libname ) == 0 )
			break;
		library = library->next;
	}
	if( library )
		return TRUE;
	return FALSE;
}
SYSTEM_PROC( void, AddMappedLibrary)( CTEXTSTR libname, POINTER image_memory )
{
	PLIBRARY library = l.libraries;
	static int loading;
	if( !l.libraries && !loading )
	{
		loading = 1;
		LoadExistingLibraries();
		library = l.libraries;
		loading = 0;
		if( !image_memory )
			return;
	}
	while( library )
	{
		if( StrCaseCmp( library->name, libname ) == 0 )
			break;
		library = library->next;
	}
	// don't really NEED anything else, in case we need to start before deadstart invokes.
	if( !library && image_memory )
	{
		size_t maxlen = StrLen( libname ) + 1;
		library = NewPlus( LIBRARY, sizeof(TEXTCHAR)*((maxlen<0xFFFFFF)?(uint32_t)maxlen:0) );
		library->alt_full_name = NULL;
		StrCpy( library->full_name, libname );
		library->name = (char*)pathrchr( library->full_name );
		if( library->name )
			library->name++;
		else
			library->name = library->full_name;
		library->functions = NULL;
		library->mapped = TRUE;
		library->library = (HLIBRARY)image_memory;
		InvokeLibraryLoad();
		library->nLibrary = ++l.nLibrary;
		LinkThing( l.libraries, library );
	}
}
void DeAttachThreadToLibraries( LOGICAL attach )
{
	PLIBRARY library = l.libraries;
	if( 0 )
	while( library )
	{
		if( library->mapped )
		{
#ifdef WIN32
			PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)library->library;
			PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( library->library, source_dos_header->e_lfanew );
			PIMAGE_DATA_DIRECTORY dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
			void(WINAPI*entry_point)(void*, DWORD, void*) = (void(WINAPI*)(void*,DWORD,void*))Seek( library->library, source_nt_header->OptionalHeader.AddressOfEntryPoint );
			{
				// thread local storage fixup
				PIMAGE_TLS_DIRECTORY tls = (PIMAGE_TLS_DIRECTORY)Seek( library->library, dir[IMAGE_DIRECTORY_ENTRY_TLS].VirtualAddress );
				DWORD n;
				if( dir[IMAGE_DIRECTORY_ENTRY_TLS].Size )
				{
					for( n = 0; n < dir[IMAGE_DIRECTORY_ENTRY_TLS].Size / sizeof( IMAGE_TLS_DIRECTORY ); n++ )
					{
						POINTER data;
						DWORD dwInit;
						size_t size_init = ( tls->EndAddressOfRawData - tls->StartAddressOfRawData );
						size_t size = size_init + tls->SizeOfZeroFill;
						/*
						printf( "something %d\n", dir[IMAGE_DIRECTORY_ENTRY_TLS].Size );
						printf( "%p %p %p(%d) %p\n"
									, tls->AddressOfCallBacks
									, tls->StartAddressOfRawData, tls->EndAddressOfRawData
									, ( tls->EndAddressOfRawData - tls->StartAddressOfRawData ) + tls->SizeOfZeroFill
									, tls->AddressOfIndex );
						*/
						dwInit = (*((DWORD*)tls->AddressOfIndex));
						if( attach )
						{
							data = NewArray( uint8_t, size );
#ifdef _MSC_VER
#  ifdef __64__
#  else
							{
								_asm mov ecx, fs:[2ch];
								_asm mov eax, dwInit;
								_asm mov edx, data;
								_asm mov dword ptr [ecx+eax*4], edx;
							}
#  endif
#endif
							//TlsSetValue( dwInit, data );
							memcpy( data, (POINTER)tls->StartAddressOfRawData, size_init );
							memset( ((uint8_t*)data) + size_init, 0, tls->SizeOfZeroFill );
						}
						else
						{
							data = TlsGetValue( dwInit );
							Deallocate( POINTER, data );
						}
					}
				}
			}
			entry_point( library->library, attach?DLL_THREAD_ATTACH:DLL_THREAD_DETACH, 0 );
#endif
		}
		library = library->next;
	}
}
SYSTEM_PROC( generic_function, LoadFunctionExx )( CTEXTSTR libname, CTEXTSTR funcname, LOGICAL bPrivate  DBG_PASS )
{
	PLIBRARY library;
	SystemInit();
	library = l.libraries;
	if( !l.libraries )
	{
		LoadExistingLibraries();
		library = l.libraries;
	}
	while( library )
	{
		if( StrCaseCmp( library->name, libname ) == 0 )
			break;
		library = library->next;
	}
	// don't really NEED anything else, in case we need to start before deadstart invokes.
	if( !library )
	{
		size_t fullnameLen;
		size_t orignameLen;
		size_t curnameLen;
		TEXTCHAR curPath[MAXPATH];
		size_t maxlen;
		GetCurrentPath( curPath, sizeof( curPath ) );
		maxlen = (fullnameLen = StrLen( l.load_path ) + 1 + StrLen( libname ) + 1)
			+ (orignameLen = StrLen( libname ) + 1)
			+ (curnameLen = StrLen( curPath ) + 1 + StrLen( libname ) + 1)
			+ StrLen( l.library_path ) + 1 + StrLen( libname ) + 1
			;
		library = NewPlus( LIBRARY, sizeof(TEXTCHAR)*((maxlen<0xFFFFFF)?(uint32_t)maxlen:0) );
		library->alt_full_name = library->full_name + fullnameLen;
		//lprintf( "New library %s", libname );
		if( !IsAbsolutePath( libname ) )
		{
			library->orig_name = library->full_name + fullnameLen;
			library->cur_full_name = library->full_name + fullnameLen + orignameLen;
			library->alt_full_name = library->full_name + fullnameLen + orignameLen + curnameLen;
			library->name = library->full_name
				+ tnprintf( library->full_name, maxlen, WIDE("%s/"), l.load_path );
			tnprintf( library->orig_name, maxlen, WIDE( "%s" ), libname );
			tnprintf( library->cur_full_name, maxlen, WIDE( "%s/%s" ), curPath, libname );
			tnprintf( library->alt_full_name, maxlen, WIDE( "%s/%s" ), l.library_path, libname );
			tnprintf( library->name
				, fullnameLen - (library->name-library->full_name)
				, WIDE("%s"), libname );
			//library->long_name = library->name;
			library->name = (char*)pathrchr( library->full_name );
		}
		else
		{
			StrCpy( library->full_name, libname );
			library->orig_name = library->full_name;
			library->cur_full_name = library->full_name;
			library->alt_full_name = library->full_name;
			//library->long_name = library->full_name;
			library->name = (char*)pathrchr( library->full_name );
			library->loading = 0;
			if( library->name )
				library->name++;
			else
				library->name = library->full_name;
		}
		library->library = NULL;
		library->mapped = FALSE;
		library->functions = NULL;
		library->loading++;
		library->nLibrary = ++l.nLibrary;
		LinkThing( l.libraries, library );
#ifdef _WIN32
		// with deadstart suspended, the library can safely register
		// all of its preloads.  Then invoke will release suspend
		// so final initializers in application can run.
		if( l.ExternalLoadLibrary && !library->library )
		{
			PLIBRARY check;
#  ifdef UNICODE
			char *libname = CStrDup( library->name );
#  else
//#        define libname library->name
#  endif
			//lprintf( "trying external load...%s", library->name );
			l.ExternalLoadLibrary( libname );
#  ifdef UNICODE
			Deallocate( char*, libname );
#  else
#        undef libname
#  endif
			// during external load, it will end up adding a library that has
			// a valid handle, this entry is no longer good and we should use that one.
			// THe full name probably won't match.
			for( check = l.libraries; check; check = check->next )
			{
				// result will be in the local list of libraries (duplicating this one)
				// and will reference the same name(or a byte duplicate)
				if( check != library && !check->loading
					&& ( StrCaseCmp( check->full_name, library->full_name ) == 0
						|| StrCaseCmp( check->name, library->name ) == 0 ) )
				{
					UnlinkThing( library );
					Deallocate( PLIBRARY, library );
					library = check;
					// loaded....
					goto get_function_name;
				}
			}
		}
		library->loading--;
	}
	SuspendDeadstart();
	if( !library->library ) {
		library->library = LoadLibrary( library->cur_full_name );
	}
	if( !library->library ) {
#  ifdef DEBUG_LIBRARY_LOADING
		lprintf( "trying load...%s", library->full_name );
#  endif
		library->library = LoadLibrary( library->full_name );
	}
	if( !library->library ) {
		library->library = LoadLibrary( library->alt_full_name );
	}
	if( !library->library ) {
		library->library = LoadLibrary( library->orig_name );
	}
	if( !library->library ) {
#  ifdef DEBUG_LIBRARY_LOADING
		lprintf( "trying load...%s", library->name );
#  endif
		library->library = LoadLibrary( library->name );
	}
	if( !library->library ) {
		if( !library->loading ) {
			if( l.flags.bLog )
				_xlprintf( 2 DBG_RELAY )(WIDE( "Attempt to load %s[%s](%s) failed: %d." ), libname, library->full_name, funcname ? funcname : WIDE( "all" ), GetLastError());
			UnlinkThing( library );
			ReleaseEx( library DBG_SRC );
		}
		ResumeDeadstart();
		return NULL;
	}
#else
	SuspendDeadstart();
#  ifndef __ANDROID__
		// ANDROID This will always fail from the application manager.
#    ifdef UNICODE
		{
			char *tmpname = CStrDup( library->name );
			library->library = dlopen( tmp, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
			Release( tmpname );
		}
#    else
		library->library = dlopen( library->name, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
#    endif
		if( !library->library )
		{
			if( l.flags.bLog )
				_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to load %s%s(%s) failed: %s."), bPrivate?"(local)":"(global)", libname, funcname?funcname:"all", dlerror() );
#  endif
#  ifdef UNICODE
			{
				char *tmpname = CStrDup( library->full_name );
				library->library = dlopen( tmpname, RTLD_LAZY|(bPrivate?RTLD_LOCAL: RTLD_GLOBAL) );
				ReleaseEx( tmpname DBG_SRC );
			}
#  else
			library->library = dlopen( library->full_name, RTLD_LAZY|(bPrivate?RTLD_LOCAL:RTLD_GLOBAL) );
#  endif
			if( !library->library )
			{
				_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to load  %s%s(%s) failed: %s."), bPrivate?WIDE("(local)"):WIDE("(global)"), library->full_name, funcname?funcname:WIDE("all"), dlerror() );
				UnlinkThing( library );
				ReleaseEx( library DBG_SRC );
				ResumeDeadstart();
				return NULL;
			}
#  ifndef __ANDROID__
		}
#  endif
}
#endif
#ifdef __cplusplus_cli
		{
			void (CPROC *f)( void );
			if( l.flags.bLog )
				lprintf( WIDE( "GetInvokePreloads" ) );
			f = (void(CPROC*)(void))GetProcAddress( library->library, "InvokePreloads" );
			if( f )
				f();
		}
#endif
		{
			//DebugBreak();
			ResumeDeadstart();
			// actually bInitialDone will not be done sometimes
			// and we need to force this here.
			InvokeDeadstart();
		}
		InvokeLibraryLoad();
	//}
#ifdef _WIN32
get_function_name:
#endif
	if( funcname )
	{
		PFUNCTION function = library->functions;
		while( function )
		{
			if( ((uintptr_t)function->name & 0xFFFF ) == (uintptr_t)function->name ) {
				if( function->name == funcname )
					break;
			} else
				if( StrCmp( function->name, funcname ) == 0 )
					break;
			function = function->next;
		}
		if( !function )
		{
			int len;
			if( library->mapped )
			{
#ifdef WIN32
				PIMAGE_DOS_HEADER source_dos_header = (PIMAGE_DOS_HEADER)library->library;
				PIMAGE_NT_HEADERS source_nt_header = (PIMAGE_NT_HEADERS)Seek( library->library, source_dos_header->e_lfanew );
				if( source_dos_header->e_magic != IMAGE_DOS_SIGNATURE )
					lprintf( WIDE("Basic signature check failed; not a library") );
				if( source_nt_header->Signature != IMAGE_NT_SIGNATURE )
					lprintf(WIDE("Basic NT signature check failed; not a library") );
				if( source_nt_header->FileHeader.SizeOfOptionalHeader )
					if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
						lprintf(WIDE("Optional header signature is incorrect...") );
				{
					PIMAGE_DATA_DIRECTORY dir;
					PIMAGE_EXPORT_DIRECTORY exp_dir;
					DWORD n;
					int ord;
					dir = (PIMAGE_DATA_DIRECTORY)source_nt_header->OptionalHeader.DataDirectory;
					exp_dir = (PIMAGE_EXPORT_DIRECTORY)Seek( library->library, dir[0].VirtualAddress );
					{
						void (**f)(void) = (void (**)(void))Seek( library->library, exp_dir->AddressOfFunctions );
						char **names = (char**)Seek( library->library, exp_dir->AddressOfNames );
						uint16_t *ords = (uint16_t*)Seek( library->library, exp_dir->AddressOfNameOrdinals );
						if( ( ord = ((uintptr_t)funcname & 0xFFFF ) ) == (uintptr_t)funcname )
						{
							return (generic_function)Seek( library->library, (uintptr_t)f[ord-exp_dir->Base] );
						}
						else
						{
							for( n = 0; n < exp_dir->NumberOfFunctions; n++ )
							{
								char *name = (char*)Seek( library->library, (uintptr_t)names[n] );
								int result;
#  ifdef UNICODE
								TEXTCHAR *_name = DupCStr( name );
#    define name _name
#  endif
								result = StrCmp( name, funcname );
#  ifdef UNICODE
								Deallocate( TEXTCHAR *,_name );
#    undef name _name
#  endif
								if( result == 0 )
								{
									if( ( ((uintptr_t)f[ords[n]] ) < ( dir[0].VirtualAddress + dir[0].Size ) )
										&& ( ((uintptr_t)f[ords[n]] ) > dir[0].VirtualAddress ) )
									{
										char *tmpname;
										char *name = (char*)Seek( library->library, (uintptr_t)f[ords[n]] );
										char *fname = name;
#  ifdef UNICODE
										TEXTCHAR *_tmp_fname;
										TEXTCHAR *_tmp_func;
#  endif
										int len;
										generic_function f;
										while( fname[0] && fname[0] != '.' )
											fname++;
										if( fname[0] )
											fname++;
										tmpname = NewArray( char, len = (int)( fname - name ) + 5 );
										snprintf( tmpname, len, "%*.*s.dll", (int)(fname-name)-1, (int)(fname-name)-1, name );
										//lprintf( "%s:%s = %s:%s", library->name, funcname, tmpname, fname );
#  ifdef UNICODE
										_tmp_fname = DupCStr(tmpname);
										_tmp_func = DupCStr(fname);
#    define tmpname _tmp_fname
#    define fname    _tmp_func
#  endif
										f = LoadFunction( tmpname, fname );
#  ifdef UNICODE
										Deallocate( TEXTCHAR *, _tmp_fname );
										Deallocate( TEXTCHAR *, _tmp_func );
#    undef tmpname
#    undef fname
#  endif
										Deallocate( char *, tmpname );
										return f;
									}
									//lprintf( "%s  %s is %d  %d = %p %p", library->name, name, n, ords[n], f[n], f[ords[n]] );
									return (generic_function)Seek( library->library, (uintptr_t)f[ords[n]] );
								}
							}
						}
					}
				}
#endif
				return NULL;
			}
			else
			{
				if( ( (uintptr_t)funcname & 0xFFFF ) == (uintptr_t)funcname )
				{
					function = NewPlus( FUNCTION, len=0 );
					function->name = funcname;
				}
				else
				{
					function = NewPlus( FUNCTION, (len=(sizeof(TEXTCHAR)*( (uint32_t)StrLen( funcname ) + 1 ) ) ) );
					function->name = function->_name;
					tnprintf( function->_name, len, WIDE( "%s" ), funcname );
				}
			}
			function->library = library;
			function->references = 0;
#ifdef _WIN32
#  ifdef __cplusplus_cli
			char *procname = CStrDup( function->name );
			if( l.flags.bLog )
				lprintf( WIDE( "Get:%s" ), procname );
			if( !(function->function = (generic_function)GetProcAddress( library->library, procname )) )
#  else
#    ifdef _UNICODE
			{
			char *tmp;
#    endif
			  if( l.flags.bLog )
				lprintf( WIDE( "Get:%s" ), (((uintptr_t)function->name&0xFFFF)==(uintptr_t)function->name)?function->name:"ordinal" );
			if( !(function->function = (generic_function)GetProcAddress( library->library
#    ifdef _UNICODE
																						  , tmp = DupTextToChar( function->name )
#    else
																						  , function->name
#    endif
																						  )) )
#  endif
			{
				TEXTCHAR tmpname[128];
#  ifdef UNICODE
				snwprintf( tmpname, sizeof( tmpname ), WIDE("_%s"), funcname );
#  else
				snprintf( tmpname, sizeof( tmpname ), WIDE("_%s"), funcname );
#  endif
#  ifdef __cplusplus_cli
				char *procname = CStrDup( tmpname );
				if( l.flags.bLog )
					lprintf( WIDE( "Get:%s" ), procname );
				function->function = (generic_function)GetProcAddress( library->library, procname );
				ReleaseEx( procname DBG_SRC );
#  else
				if( l.flags.bLog )
					lprintf( WIDE( "Get:%s" ), function->name );
				function->function = (generic_function)GetProcAddress( library->library
#    ifdef _UNICODE
																					  , WcharConvert( tmpname )
#    else
																					  , tmpname
#    endif
																					  );
#  endif
			}
#  ifdef __cplusplus_cli
			ReleaseEx( procname DBG_SRC );
#  else
#    ifdef _UNICODE
			Deallocate( char *, tmp );
			}
#    endif
#  endif
			if( !function->function )
			{
				if( l.flags.bLog )
					_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to get function %s from %s failed. %d"), funcname, libname, GetLastError() );
				ReleaseEx( function DBG_SRC );
				return NULL;
			}
#else
#  ifdef UNICODE
			{
				char *tmpname = CStrDup( function->name );
				library->library = dlsym( library->library, tmpname );
				ReleaseEx( tmpname DBG_SRC );
			}
#  else
			function->function = (generic_function)dlsym( library->library, function->name );
#  endif
			 if( !(function->function) )
			{
				char tmpname[128];
				snprintf( tmpname, 128, "_%s", funcname );
				function->function = (generic_function)dlsym( library->library, tmpname );
			}
			if( !function->function )
			{
				_xlprintf( 2 DBG_RELAY)( WIDE("Attempt to get function %s from %s failed. %s"), funcname, libname, dlerror() );
				ReleaseEx( function DBG_SRC );
				return NULL;
			}
#endif
			if( !l.pFunctionTree )
				l.pFunctionTree = CreateBinaryTree();
			//lprintf( WIDE("Adding function %p"), function->function );
			AddBinaryNode( l.pFunctionTree, function, (uintptr_t)function->function );
			LinkThing( library->functions, function );
		}
		function->references++;
		return function->function;
	}
	else
	{
/*extend precisionfirst*/
 // success, but no function possible.
		return (generic_function)((uintptr_t)library->nLibrary);
	}
	return NULL;
}
SYSTEM_PROC( generic_function, LoadPrivateFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS )
{
	return LoadFunctionExx( libname, funcname, TRUE DBG_RELAY );
}
SYSTEM_PROC( void *, GetPrivateModuleHandle )( CTEXTSTR libname )
{
	PLIBRARY library = l.libraries;
	while( library )
	{
		if( StrCaseCmp( library->name, libname ) == 0 )
			return library->library;
		library = library->next;
	}
	return NULL;
}
SYSTEM_PROC( generic_function, LoadFunctionEx )( CTEXTSTR libname, CTEXTSTR funcname DBG_PASS )
{
	return LoadFunctionExx( libname, funcname, FALSE DBG_RELAY );
}
#undef LoadFunction
SYSTEM_PROC( generic_function, LoadFunction )( CTEXTSTR libname, CTEXTSTR funcname )
{
	return LoadFunctionEx( libname,funcname DBG_SRC);
}
//-------------------------------------------------------------------------
// pass the address of the function pointer - this
// will gracefully erase that reference also.
SYSTEM_PROC( int, UnloadFunctionEx )( generic_function *f DBG_PASS )
{
	if( !f  )
		return 0;
	_xlprintf( 1 DBG_RELAY )( WIDE("Unloading function %p"), *f );
	if( (uintptr_t)(*f) < 1000 )
	{
		// unload library only...
  // invalid result...
		if( !(*f) )
			return 0;
		{
			PLIBRARY library;
			uintptr_t nFind = (uintptr_t)(*f);
			for( library = l.libraries; library; library = NextLink( library ) )
			{
				if( nFind == library->nLibrary )
				{
#ifdef _WIN32
					// should make sure noone has loaded a specific function.
					FreeLibrary ( library->library );
					UnlinkThing( library );
					ReleaseEx( library DBG_SRC );
#else
#endif
				}
			}
		}
	}
	{
		PFUNCTION function = (PFUNCTION)FindInBinaryTree( l.pFunctionTree, (uintptr_t)(*f) );
		PLIBRARY library;
		if( function &&
			 !(--function->references) )
		{
			UnlinkThing( function );
			lprintf( WIDE( "Should remove the node from the tree here... but it crashes intermittantly. (tree list is corrupted)" ) );
			//RemoveLastFoundNode( l.pFunctionTree );
			library = function->library;
			if( !library->functions )
			{
#ifdef _WIN32
				FreeLibrary( library->library );
#else
				dlclose( library->library );
#endif
				UnlinkThing( library );
				ReleaseEx( library DBG_SRC );
			}
			ReleaseEx( function DBG_SRC );
			*f = NULL;
		}
		else
		{
			lprintf( WIDE("function was not found - or ref count = %") _32f WIDE(" (5566 means no function)"), function?function->references:5566 );
		}
	}
	return FALSE;
}
//-------------------------------------------------------------------------
#if !defined( __ANDROID__ )
SYSTEM_PROC( PTHREAD, SpawnProcess )( CTEXTSTR filename, va_list args )
{
	uintptr_t (CPROC *newmain)( PTHREAD pThread );
	newmain = (uintptr_t(CPROC*)(PTHREAD))LoadFunction( filename, WIDE("main") );
	if( newmain )
	{
		// hmm... suppose I should even thread through my own little header here
		// then when the thread exits I can get a positive acknowledgement?
		return ThreadTo( newmain, (uintptr_t)args );
	}
	return NULL;
}
#endif
//---------------------------------------------------------------------------
TEXTSTR GetArgsString( PCTEXTSTR pArgs )
{
	static TEXTCHAR args[256];
	int len = 0, n;
	args[0] = 0;
	// arg[0] should be the same as program name...
	for( n = 1; pArgs && pArgs[n]; n++ )
	{
		int space = (StrChr( pArgs[n], ' ' )!=NULL);
		len += tnprintf( args + len, sizeof( args ) - len * sizeof( TEXTCHAR ), WIDE("%s%s%s%s")
							, n>1?WIDE(" "):WIDE("")
							, space?WIDE("\""):WIDE("")
							, pArgs[n]
							, space?WIDE("\""):WIDE("")
							);
	}
	return args;
}
CTEXTSTR GetProgramName( void )
{
#ifdef __ANDROID__
	return program_name;
#else
	if( !local_systemlib || !l.filename )
	{
		SystemInit();
		if( !l.filename )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.filename;
#endif
}
CTEXTSTR GetProgramPath( void )
{
#ifdef __ANDROID__
	return program_path;
#else
	if( !local_systemlib || l.load_path )
	{
		SystemInit();
		if( !l.load_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.load_path;
#endif
}
CTEXTSTR GetLibraryPath( void )
{
#ifdef __ANDROID__
	return library_path;
#else
	if( !local_systemlib || l.library_path )
	{
		SystemInit();
		if( !l.library_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.library_path;
#endif
}
CTEXTSTR GetStartupPath( void )
{
#ifdef __ANDROID__
	return working_path;
#else
	if( !local_systemlib || l.work_path )
	{
		SystemInit();
		if( !l.work_path )
		{
			DebugBreak();
			return NULL;
		}
	}
	return l.work_path;
#endif
}
LOGICAL IsSystemShuttingDown( void )
{
#ifdef WIN32
	static HANDLE h = INVALID_HANDLE_VALUE;
	if( h == INVALID_HANDLE_VALUE )
		h = CreateEvent( NULL, TRUE, FALSE, WIDE( "Windows Is Shutting Down" ) );
	if( h != INVALID_HANDLE_VALUE )
		if( WaitForSingleObject( h, 0 ) == WAIT_OBJECT_0 )
			return TRUE;
#endif
	return FALSE;
}
void SetExternalLoadLibrary( LOGICAL (CPROC*f)(const char *) )
{
	if( !local_systemlib )
		SystemInit();
	l.ExternalLoadLibrary = f;
}
void SetExternalFindProgram( char * (CPROC*f)(const char *) )
{
	if( !local_systemlib )
		SystemInit();
	l.ExternalFindProgram = f;
}
void SetProgramName( CTEXTSTR filename )
{
	SystemInit();
	l.filename = filename;
}
#undef Seek
SACK_SYSTEM_NAMESPACE_END
#define NO_UNICODE_C
#define TASK_INFO_DEFINED
#ifndef __NO_IDLE__
#endif
#ifdef __LINUX__
#include <sys/poll.h>
extern char **environ;
#endif
//--------------------------------------------------------------------------
SACK_SYSTEM_NAMESPACE
typedef struct task_info_tag TASK_INFO;
//--------------------------------------------------------------------------
#ifdef WIN32
static int DumpErrorEx( DBG_VOIDPASS )
#define DumpError() DumpErrorEx( DBG_VOIDSRC )
{
	_lprintf(DBG_RELAY)( WIDE("Failed create process:%d"), GetLastError() );
	return 0;
}
#endif
//--------------------------------------------------------------------------
extern uintptr_t CPROC WaitForTaskEnd( PTHREAD pThread );
static uintptr_t CPROC HandleTaskOutput(PTHREAD thread )
{
	PTASK_INFO task = (PTASK_INFO)GetThreadParam( thread );
	{
		task->pOutputThread = thread;
		// read input from task, montiro close and dispatch TaskEnd Notification also.
		{
			PHANDLEINFO phi = &task->hStdOut;
			PTEXT pInput = SegCreate( 4096 );
			int done, lastloop;
			Hold( task );
			done = lastloop = FALSE;
			do
			{
				uint32_t dwRead;
				if( done )
					lastloop = TRUE;
				{
						if( task->flags.log_input )
							lprintf( WIDE( "Go to read task's stdout." ) );
#ifdef _WIN32
						if( !task->flags.process_ended &&
							 ReadFile( phi->handle
										, GetText( pInput ), (DWORD)(GetTextSize( pInput ) - 1)
  //read the  pipe
										, (LPDWORD)&dwRead, NULL ) )
						{
#else
							dwRead = read( phi->handle
											 , GetText( pInput )
											 , GetTextSize( pInput ) - 1 );
							if( !dwRead )
							{
#  ifdef _DEBUG
												//lprintf( WIDE( "Ending system thread because of broke pipe! %d" ), errno );
#  endif
#  ifdef WIN32
								continue;
#  else
												//lprintf( WIDE( "0 read = pipe failure." ) );
								break;
#  endif
							}
#endif
							if( task->flags.log_input )
								lprintf( WIDE( "got read on task's stdout: %d" ), dwRead );
							if( task->flags.bSentIoTerminator )
							{
								if( dwRead > 1 )
									dwRead--;
								else
								{
									if( task->flags.log_input )
										lprintf( WIDE( "Finished, no more data, task has ended; no need for once more around" ) );
									lastloop = 1;
 // we're done; task ended, and we got an io terminator on XP
									break;
								}
							}
							//lprintf( WIDE( "result %d" ), dwRead );
							GetText( pInput )[dwRead] = 0;
							pInput->data.size = dwRead;
							//LogBinary( GetText( pInput ), GetTextSize( pInput ) );
							if( task->OutputEvent )
							{
								task->OutputEvent( task->psvEnd, task, GetText( pInput ), GetTextSize( pInput ) );
							}
							pInput->data.size = 4096;
#ifdef _WIN32
						}
						else
						{
							DWORD dwError = GetLastError();
							int32_t dwAvail;
							if( ( dwError == ERROR_OPERATION_ABORTED ) && task->flags.process_ended )
							{
								if( PeekNamedPipe( phi->handle, NULL, 0, NULL, (LPDWORD)&dwAvail, NULL ) )
								{
									if( dwAvail > 0 )
									{
										lprintf( WIDE( "caught data" ) );
										// there is still data in the pipe, just that the process closed
										// and we got the sync even before getting the data.
									}
									else
										break;
								}
							}
						}
#endif
				}
				//allow a minor time for output to be gathered before sending
				// partial gathers...
				if( task->flags.process_ended )
				{
					// Ending system thread because of process exit!
 // do one pass to make sure we completed read
					  done = TRUE;
				}
			}
			while( !lastloop );
			//lprintf( "Exited read loop" );
#ifdef _DEBUG
			if( lastloop )
			{
				//DECLTEXT( msg, WIDE( "Ending system thread because of process exit!" ) );
				//EnqueLink( phi->pdp->&ps->Command->Output, &msg );
			}
			else
			{
				//DECLTEXT( msg, WIDE( "Guess we exited from broken pipe" ) );
				//EnqueLink( phi->pdp->&ps->Command->Output, &msg );
			}
#endif
			LineRelease( pInput );
#ifdef _WIN32
			CloseHandle( task->hReadIn );
			CloseHandle( task->hReadOut );
			CloseHandle( task->hWriteIn );
			CloseHandle( task->hWriteOut );
			//lprintf( WIDE( "Closing process handle %p" ), task->pi.hProcess );
			phi->hThread = 0;
#else
			//close( phi->handle );
			close( task->hStdIn.pair[1] );
			close( task->hStdOut.pair[0] );
			//close( task->hStdErr.pair[0] );
#define INVALID_HANDLE_VALUE -1
#endif
			if( phi->handle == task->hStdIn.handle )
				task->hStdIn.handle = INVALID_HANDLE_VALUE;
			phi->handle = INVALID_HANDLE_VALUE;
			task->pOutputThread = NULL;
			Release( task );
			//WakeAThread( phi->pdp->common.Owner );
			return 0xdead;
		}
	}
}
//--------------------------------------------------------------------------
static int FixHandles( PTASK_INFO task )
{
#ifdef WIN32
	if( task->pi.hProcess )
		CloseHandle( task->pi.hProcess );
	task->pi.hProcess = 0;
	if( task->pi.hProcess )
		CloseHandle( task->pi.hThread );
	task->pi.hThread = 0;
#endif
 // must return 0 so expression continues
	return 0;
}
//--------------------------------------------------------------------------
void ResumeProgram( PTASK_INFO task )
{
#ifdef WIN32
	//DWORD WINAPI ResumeThread(  _In_ HANDLE hThread);
	ResumeThread( task->pi.hThread );
#endif
}
uintptr_t GetProgramAddress( PTASK_INFO task ) {
#ifdef WIN32
	/*
	BOOL WINAPI GetThreadContext(
  _In_	 HANDLE    hThread,
  _Inout_ LPCONTEXT lpContext
  );
  */
	uintptr_t memstart;
	CONTEXT ctx;
#ifdef __64__
	WOW64_CONTEXT ctx64;
	ctx64.ContextFlags = CONTEXT_INTEGER;
	Wow64GetThreadContext( task->pi.hThread, &ctx64 );
	memstart = ctx64.Ebx;
	ctx.ContextFlags = CONTEXT_INTEGER;
	GetThreadContext( task->pi.hThread, &ctx );
	//memstart = ctx.Ebx;
	return memstart;
#else
	GetThreadContext( task->pi.hThread, &ctx );
	memstart = ctx.Ebx;
	return memstart;
#endif
#else
	lprintf( "non-windows system; cannot find program address... yet" );
	return 0;
#endif
}
#if 0
void LoadReadExe( PTASK_INFO task, uintptr_t base )
   //-------------------------------------------------------
// function to process a currently loaded program to get the
// data offset at the end of the executable.
{
#ifdef WIN32
#  define Seek(a,b) (((uintptr_t)a)+(b))
	//uintptr_t source_memory_length = block_len;
	//POINTER source_memory = block;
	{
// = (PIMAGE_DOS_HEADER)source_memory;
		IMAGE_DOS_HEADER source_dos_header;
// = (PIMAGE_NT_HEADERS)Seek( source_memory, source_dos_header->e_lfanew );
		PIMAGE_NT_HEADERS source_nt_header;
		SIZE_T nRead;
		ReadProcessMemory( task->pi.hProcess, (void*)base, (void*)&source_dos_header, sizeof( source_dos_header ), &nRead );
		LogBinary((uint8_t*) &source_dos_header, sizeof( source_dos_header ));
		if( source_dos_header.e_magic != IMAGE_DOS_SIGNATURE ) {
			LoG( "Basic signature check failed; not a library" );
			return ;
		}
/*
		if( source_nt_header->Signature != IMAGE_NT_SIGNATURE ) {
			LoG( "Basic NT signature check failed; not a library" );
			return NULL;
		}
		if( source_nt_header->FileHeader.SizeOfOptionalHeader )
		{
			if( source_nt_header->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC )
			{
				LoG( "Optional header signature is incorrect..." );
				return NULL;
			}
		}
		{
			int n;
			long FPISections = source_dos_header->e_lfanew
				+ sizeof( DWORD ) + sizeof( IMAGE_FILE_HEADER )
				+ source_nt_header->FileHeader.SizeOfOptionalHeader;
			PIMAGE_SECTION_HEADER source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			uintptr_t dwSize = 0;
			uintptr_t newSize;
			source_section = (PIMAGE_SECTION_HEADER)Seek( source_memory, FPISections );
			for( n = 0; n < source_nt_header->FileHeader.NumberOfSections; n++ )
			{
				newSize = (source_section[n].PointerToRawData) + source_section[n].SizeOfRawData;
				if( newSize > dwSize )
					dwSize = newSize;
			}
			dwSize += (BLOCK_SIZE*2)-1; // pad 1 full block, plus all but 1 byte of a full block(round up)
			dwSize &= ~(BLOCK_SIZE-1); // mask off the low bits; floor result to block boundary
			return (POINTER)Seek( source_memory, dwSize );
			}
		*/
	}
#  undef Seek
#else
	// need to get elf size...
	return 0;
#endif
}
#endif
//--------------------------------------------------------------------------
#ifdef WIN32
extern HANDLE GetImpersonationToken( void );
#endif
// Run a program completely detached from the current process
// it runs independantly.  Program does not suspend until it completes.
// No way at all to know if the program works or fails.
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramExx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															  , int flags
															  , TaskOutput OutputHandler
															  , TaskEnd EndNotice
															  , uintptr_t psv
																DBG_PASS
															  )
{
	PTASK_INFO task;
	TEXTSTR expanded_path = ExpandPath( program );
	TEXTSTR expanded_working_path = path?ExpandPath( path ):ExpandPath( WIDE(".") );
	if( program && program[0] )
	{
#ifdef WIN32
		int launch_flags = ( ( flags & LPP_OPTION_NEW_CONSOLE ) ? CREATE_NEW_CONSOLE : 0 )
		                 | ( ( flags & LPP_OPTION_NEW_GROUP ) ? CREATE_NEW_PROCESS_GROUP : 0 )
		                 | ( ( flags & LPP_OPTION_SUSPEND ) ? CREATE_SUSPENDED : 0 )
			;
		PVARTEXT pvt = VarTextCreateEx( DBG_VOIDRELAY );
		PTEXT cmdline;
		TEXTSTR new_path;
		PTEXT final_cmdline;
		LOGICAL needs_quotes;
		int first = TRUE;
		//TEXTCHAR saved_path[256];
		task = (PTASK_INFO)AllocateEx( sizeof( TASK_INFO ) DBG_RELAY );
		MemSet( task, 0, sizeof( TASK_INFO ) );
		task->psvEnd = psv;
		task->EndNotice = EndNotice;
		if( l.ExternalFindProgram ) {
			new_path = l.ExternalFindProgram( expanded_path );
			if( new_path ) {
				Release( expanded_path );
				expanded_path = new_path;
			}
		}
#ifdef _DEBUG
		//xlprintf(LOG_NOISE)( WIDE("%s[%s]"), path, expanded_working_path );
#endif
		if( StrCmp( path, WIDE(".") ) == 0 )
		{
			path = NULL;
			Release( expanded_working_path );
			expanded_working_path = NULL;
		}
		if( expanded_path && StrChr( expanded_path, ' ' ) )
			needs_quotes = TRUE;
		else
			needs_quotes = FALSE;
		if( needs_quotes )
			vtprintf( pvt, WIDE( "\"" ) );
		/*
		if( !IsAbsolutePath( expanded_path ) && expanded_working_path )
		{
			//lprintf( "needs working path too" );
			vtprintf( pvt, WIDE("%s/"), expanded_working_path );
		}
		*/
		vtprintf( pvt, WIDE("%s"), expanded_path );
		if( needs_quotes )
			vtprintf( pvt, WIDE( "\"" ) );
		if( flags & LPP_OPTION_FIRST_ARG_IS_ARG )
			;
		else
		{
// arg[0] is passed with linux programs, and implied with windows.
			if( args && args[0] )
				args++;
		}
		while( args && args[0] )
		{
			if( args[0][0] == 0 )
				vtprintf( pvt, WIDE( " \"\"" ) );
			else if( StrChr( args[0], ' ' ) )
				vtprintf( pvt, WIDE(" \"%s\""), args[0] );
			else
				vtprintf( pvt, WIDE(" %s"), args[0] );
			first = FALSE;
			args++;
		}
		cmdline = VarTextGet( pvt );
		vtprintf( pvt, WIDE( "cmd.exe /c %s" ), GetText( cmdline ) );
		final_cmdline = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		MemSet( &task->si, 0, sizeof( STARTUPINFO ) );
		task->si.cb = sizeof( STARTUPINFO );
#ifdef _DEBUG
		//xlprintf(LOG_NOISE)( WIDE( "quotes?%s path [%s] program [%s]  [cmd.exe (%s)]"), needs_quotes?WIDE( "yes"):WIDE( "no"), expanded_working_path, expanded_path, GetText( final_cmdline ) );
#endif
		/*
		if( path )
		{
			GetCurrentPath( saved_path, sizeof( saved_path ) );
			SetCurrentPath( path );
		}
		*/
		task->OutputEvent = OutputHandler;
		if( OutputHandler )
		{
			SECURITY_ATTRIBUTES sa;
			sa.bInheritHandle = TRUE;
			sa.lpSecurityDescriptor = NULL;
			sa.nLength = sizeof( sa );
			CreatePipe( &task->hReadOut, &task->hWriteOut, &sa, 0 );
			//CreatePipe( &hReadErr, &hWriteErr, &sa, 0 );
			CreatePipe( &task->hReadIn, &task->hWriteIn, &sa, 0 );
			task->si.hStdInput = task->hReadIn;
			task->si.hStdError = task->hWriteOut;
			task->si.hStdOutput = task->hWriteOut;
			task->si.dwFlags |= STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;
			if( !( flags & LPP_OPTION_DO_NOT_HIDE ) )
				task->si.wShowWindow = SW_HIDE;
			else
				task->si.wShowWindow = SW_SHOW;
		}
		else
		{
			task->si.dwFlags |= STARTF_USESHOWWINDOW;
			if( !( flags & LPP_OPTION_DO_NOT_HIDE ) )
				task->si.wShowWindow = SW_HIDE;
			else
				task->si.wShowWindow = SW_SHOW;
		}
		{
			HINSTANCE hShellProcess = 0;
			int success = 0;
#ifdef WIN32
			if( flags & LPP_OPTION_IMPERSONATE_EXPLORER )
			{
				HANDLE hExplorer = GetImpersonationToken();
 //program
				if( ( CreateProcessAsUser( hExplorer, NULL
												 , GetText( cmdline )
												 , NULL, NULL, TRUE
												 , launch_flags | CREATE_NEW_PROCESS_GROUP
												 , NULL
												 , expanded_working_path
												 , &task->si
												 , &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, program
												, GetText( cmdline )
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, program
 // GetText( cmdline )
												, NULL
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcessAsUser( hExplorer, WIDE( "cmd.exe" )
												, GetText( final_cmdline )
												, NULL, NULL, TRUE
												, launch_flags | CREATE_NEW_PROCESS_GROUP
												, NULL
												, expanded_working_path
												, &task->si
												, &task->pi ) || FixHandles(task) || DumpError() )
				  )
				{
					success = 1;
				}
				CloseHandle( hExplorer );
			}
			else
#endif
			{
				if( ( CreateProcess( program
										, GetText( cmdline )
										, NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										, launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
 //program
					( CreateProcess( NULL
										 , GetText( cmdline )
										 , NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										 , launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										 , NULL
										 , expanded_working_path
										 , &task->si
										 , &task->pi ) || FixHandles(task) || DumpError() ) ||
					( CreateProcess( program
 // GetText( cmdline )
										, NULL
										, NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										, launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
					( TryShellExecute( task, expanded_working_path, program, cmdline ) ) ||
//WIDE( "cmd.exe" )
					( CreateProcess( NULL
										, GetText( final_cmdline )
										, NULL, NULL, TRUE
//CREATE_NEW_PROCESS_GROUP
										, launch_flags | ( OutputHandler?CREATE_NO_WINDOW:0 )
										, NULL
										, expanded_working_path
										, &task->si
										, &task->pi ) || FixHandles(task) || DumpError() ) ||
				   0
				  )
				{
					success = 1;
				}
			}
			if( success )
			{
				//CloseHandle( task->hReadIn );
				//CloseHandle( task->hWriteOut );
#ifdef _DEBUG
				//xlprintf(LOG_NOISE)( WIDE("Success running %s[%s] in %s (%p): %d"), program, GetText( cmdline ), expanded_working_path, task->pi.hProcess, GetLastError() );
#endif
				if( OutputHandler )
				{
					task->hStdIn.handle	 = task->hWriteIn;
					task->hStdIn.pLine	 = NULL;
					//task->hStdIn.pdp		 = pdp;
					task->hStdIn.hThread  = 0;
					task->hStdIn.bNextNew = TRUE;
					task->hStdOut.handle	  = task->hReadOut;
					task->hStdOut.pLine	  = NULL;
					//task->hStdOut.pdp		  = pdp;
					task->hStdOut.bNextNew = TRUE;
					task->hStdOut.hThread  = ThreadTo( HandleTaskOutput, (uintptr_t)task );
					ThreadTo( WaitForTaskEnd, (uintptr_t)task );
				}
				else
				{
					//task->hThread =
					ThreadTo( WaitForTaskEnd, (uintptr_t)task );
				}
			}
			else
			{
				xlprintf(LOG_NOISE)( WIDE("Failed to run %s[%s]: %d"), program, GetText( cmdline ), GetLastError() );
				CloseHandle( task->hWriteIn );
				CloseHandle( task->hReadIn );
				CloseHandle( task->hWriteOut );
				CloseHandle( task->hReadOut );
				CloseHandle( task->pi.hProcess );
				CloseHandle( task->pi.hThread );
				Release( task );
				task = NULL;
			}
		}
		LineRelease( cmdline );
		LineRelease( final_cmdline );
		Release( expanded_working_path );
		Release( expanded_path );
		/*
		if( path )
		SetCurrentPath( saved_path );
		*/
		return task;
#endif
#ifdef __LINUX__
		{
			pid_t newpid;
			TEXTCHAR saved_path[256];
			task = (PTASK_INFO)Allocate( sizeof( TASK_INFO ) );
			MemSet( task, 0, sizeof( TASK_INFO ) );
			task->psvEnd = psv;
			task->EndNotice = EndNotice;
			task->OutputEvent = OutputHandler;
			if( OutputHandler )
			{
				if( pipe(task->hStdIn.pair) < 0 ) {
					Release( expanded_working_path );
					Release( expanded_path );
					return NULL;
				}
				task->hStdIn.handle = task->hStdIn.pair[1];
				if( pipe(task->hStdOut.pair) < 0 ) {
					Release( expanded_working_path );
					Release( expanded_path );
					return NULL;
				}
				task->hStdOut.handle = task->hStdOut.pair[0];
			}
			// always have to thread to taskend so waitpid can clean zombies.
			ThreadTo( WaitForTaskEnd, (uintptr_t)task );
			if( path )
			{
				GetCurrentPath( saved_path, sizeof( saved_path ) );
				SetCurrentPath( path );
			}
			if( !( newpid = fork() ) )
			{
				// after fork; check that args has a space for
				// the program name to get filled into.
				// this memory doesn't leak; it's squashed by exec.
				if( flags & LPP_OPTION_FIRST_ARG_IS_ARG ) {
					char ** newArgs;
					int n;
					for( n = 0; args[n]; n++ );
					newArgs = NewArray( char *, n + 2 );
					for( n = 0; args[n]; n++ ) {
						newArgs[n + 1] = (char*)args[n];
					}
					newArgs[n + 1] = (char*)args[n];
					newArgs[0] = (char*)program;
					args = newArgs;
				}
				char *_program = CStrDup( program );
				// in case exec fails, we need to
				// drop any registered exit procs...
				//close( task->hStdIn.pair[1] );
				//close( task->hStdOut.pair[0] );
				//close( task->hStdErr.pair[0] );
				if( OutputHandler ) {
					dup2( task->hStdIn.pair[0], 0 );
					dup2( task->hStdOut.pair[1], 1 );
					dup2( task->hStdOut.pair[1], 2 );
				}
				DispelDeadstart();
				execve( _program, (char *const*)args, environ );
				//lprintf( WIDE( "Direct execute failed... trying along path..." ) );
				{
					char *tmp = strdup( getenv( "PATH" ) );
					char *tok;
					for( tok = strtok( tmp, ":" ); tok; tok = strtok( NULL, ":" ) )
					{
						char fullname[256];
						snprintf( fullname, sizeof( fullname ), "%s/%s", tok, _program );
						lprintf( WIDE( "program:[%s]" ), fullname );
						((char**)args)[0] = fullname;
						execve( fullname, (char*const*)args, environ );
					}
					Release( tmp );
				}
				lprintf( WIDE( "exec failed - and this is ALLL bad... %d" ), errno );
				if( OutputHandler ) {
					close( task->hStdIn.pair[0] );
					close( task->hStdOut.pair[1] );
				}
				//close( task->hWriteErr );
				close( 0 );
				close( 1 );
				close( 2 );
				//DebugBreak();
				// well as long as this runs before
				// the other all will be well...
				task = NULL;
				// shit - what can I do now?!
 // just in case exec fails... need to fault this.
				exit(0);
			}
			else
			{
				if( OutputHandler ) {
					close( task->hStdIn.pair[0] );
					close( task->hStdOut.pair[1] );
				}
			}
			if( OutputHandler )
				ThreadTo( HandleTaskOutput, (uintptr_t)task );
			task->pid = newpid;
			// how can I know if the command failed?
			// well I can't - but the user's callback will be invoked
			// when the above exits.
			if( path )
			{
				// if path is NULL we didn't change the path...
				SetCurrentPath( saved_path );
			}
			Release( expanded_working_path );
			Release( expanded_path );
			return task;
		}
#endif
	}
	Release( expanded_working_path );
	Release( expanded_path );
	return FALSE;
}
SYSTEM_PROC( PTASK_INFO, LaunchPeerProgramEx )( CTEXTSTR program, CTEXTSTR path, PCTEXTSTR args
															 , TaskOutput OutputHandler
															 , TaskEnd EndNotice
															 , uintptr_t psv
                                                DBG_PASS
															  )
{
	return LaunchPeerProgramExx( program, path, args, LPP_OPTION_DO_NOT_HIDE, OutputHandler, EndNotice, psv DBG_RELAY );
}
//------------- System() ---------- simplest form of launch process (with otuput handler, and pprintf support )
struct task_end_notice
{
	PTHREAD thread;
	LOGICAL ended;
	uintptr_t psv_output;
	TaskOutput output_handler;
};
static void CPROC SystemTaskEnd( uintptr_t psvUser, PTASK_INFO task )
{
	struct task_end_notice *end_data = (struct task_end_notice *)psvUser;
	end_data->ended = TRUE;
	WakeThread( end_data->thread );
}
static void CPROC SystemOutputHandler( uintptr_t psvUser, PTASK_INFO Task, CTEXTSTR buffer, size_t len )
{
	struct task_end_notice *end_data = (struct task_end_notice *)psvUser;
	end_data->output_handler( end_data->psv_output, Task, buffer, len );
}
ATEXIT( SystemAutoShutdownTasks )
{
	INDEX idx;
	PTASK_INFO task;
	if( local_systemlib )
		LIST_FORALL( (*local_systemlib).system_tasks, idx, PTASK_INFO, task )
		{
			TerminateProgram( task );
		}
}
SYSTEM_PROC( PTASK_INFO, SystemEx )( CTEXTSTR command_line
															  , TaskOutput OutputHandler
															  , uintptr_t psv
																DBG_PASS
											)
{
	TEXTCHAR *command_line_tmp = StrDup( command_line );
	struct task_end_notice end_notice;
	PTASK_INFO result;
	int argc;
	TEXTSTR *argv;
	end_notice.ended = FALSE;
	end_notice.thread = MakeThread();
	end_notice.psv_output = psv;
	end_notice.output_handler = OutputHandler;
	ParseIntoArgs( command_line_tmp, &argc, &argv );
	Release( command_line_tmp );
	result = LaunchPeerProgramExx( argv[0], NULL, (PCTEXTSTR)argv, 0, OutputHandler?SystemOutputHandler:NULL, SystemTaskEnd, (uintptr_t)&end_notice DBG_RELAY );
	if( result )
	{
		AddLink( &(*local_systemlib).system_tasks, result );
		// we'll get woken when it ends, might as well be infinite.
		while( !end_notice.ended )
		{
#ifndef __NO_IDLE__
			if( !Idle( ) )
				WakeableSleep( 10000 );
			else
				Relinquish();
#else
			WakeableSleep( 25 );
#endif
		}
		DeleteLink( &(*local_systemlib).system_tasks, result );
	}
	{
		POINTER tmp = (POINTER)argv;
		while( argv[0] )
		{
			Release( (POINTER)argv[0] );
			argv++;
		}
		Release( tmp );
	}
	return result;
}
//----------------------- Utility to send to launched task's stdin ----------------------------
int vpprintf( PTASK_INFO task, CTEXTSTR format, va_list args )
{
	PVARTEXT pvt = VarTextCreate();
	PTEXT output;
	vvtprintf( pvt, format, args );
	output = VarTextGet( pvt );
	if(
#ifdef _WIN32
		WaitForSingleObject( task->pi.hProcess, 0 )
#else
		task->pid != waitpid( task->pid, NULL, WNOHANG )
#endif
	  )
	{
#ifdef _WIN32
		DWORD dwWritten;
#endif
		//lprintf( "Allowing write to process pipe..." );
		{
			PTEXT seg = output;
			while( seg )
			{
#ifdef _WIN32
				//LogBinary( GetText( seg )
				//			, GetTextSize( seg ) );
					WriteFile( task->hStdIn.handle
							, GetText( seg )
							, (DWORD)GetTextSize( seg )
							, &dwWritten
							, NULL );
#else
				{
					struct pollfd pfd = { task->hStdIn.handle, POLLHUP|POLLERR, 0 };
					if( poll( &pfd, 1, 0 ) &&
						 pfd.revents & POLLERR )
					{
						Log( WIDE( "Pipe has no readers..." ) );
							break;
					}
					LogBinary( (uint8_t*)GetText( seg ), GetTextSize( seg ) );
					write( task->hStdIn.handle
						 , GetText( seg )
						 , GetTextSize( seg ) );
				}
#endif
				seg = NEXTLINE(seg);
			}
		}
		LineRelease( output );
	}
	else
	{
		lprintf( WIDE("Task has ended, write  aborted.") );
	}
	VarTextDestroy( &pvt );
	return 0;
}
int pprintf( PTASK_INFO task, CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vpprintf( task, format, args );
}
SACK_SYSTEM_NAMESPACE_END
//-------------------------------------------------------------------------
#ifndef SYSTEM_SOURCE
#define SYSTEM_SOURCE
#endif
SACK_SYSTEM_NAMESPACE
SYSTEM_PROC( void, ParseIntoArgs )( TEXTCHAR *lpCmdLine, int *pArgc, TEXTCHAR ***pArgv )
{
	TEXTCHAR *args = lpCmdLine;
	TEXTCHAR  *p;
	TEXTCHAR **pp;
   //TEXTCHAR argc; // result variable, count is a temp counter...
 // result variable, pp is a temp pointer
   TEXTCHAR **argv;
	TEXTCHAR quote = 0;
   int escape = 0;
	int count = 0;
	int lastchar;
 // auto continue spaces...
	lastchar = ' ';
	//lprintf( WIDE("Got args: %s"), args );
	p = args;
	while( p && p[0] )
	{
		//lprintf( WIDE("check character %c %c"), lastchar, p[0] );
		if( escape ) {
			if( p[0] == '\"' || p[0] == '\'' ) {
				escape = 0;
            count++;
			}
			else {
				escape = 0;
            count += 2;
			}
		}
		else if( p[0] == '\\' ) {
			escape = 1;
         count++;
		}
		else if( quote )
		{
			if( p[0] == quote )
			{
				count++;
				quote = 0;
				lastchar = ' ';
			}
		}
		else
		{
			if( p[0] == '\"' || p[0] == '\'' )
				quote = p[0];
			else
			{
 // and there's a space
				if( lastchar != ' ' && p[0] == ' ' )
				{
					count++;
				}
				else if( lastchar == ' ' && p[0] != ' ' )
				{
				}
			}
			lastchar = p[0] ;
		}
		p++;
	}
	if( quote )
 // complete this argument
		count++;
	else if( p != args )
      count++;
	if( count )
	{
		TEXTCHAR *start;
 // auto continue spaces...
		lastchar = ' ';
      //lprintf( "Array is %d (+2?)", count );
		pp = argv = NewArray( TEXTCHAR*, count + 2 );
		//argc = count - 2;
		p = args;
		quote = 0;
		count = 0;
		//pp[count++] = StrDup( pTask->pTask ); // setup arg to equal program (needed for linux stuff)
		start = NULL;
		while( p[0] )
		{
			//lprintf( WIDE("check character %c %c"), lastchar, p[0] );
			if( escape ) {
				escape = 0;
			}
			else if( p[0] == '\\' ) {
				escape = 1;
			}
			else if( quote )
			{
				if( !escape ) {
					if( !start )
						start = p;
					if( p[0] == quote )
					{
						p[0] = 0;
						pp[count++] = StrDup( start );
						p[0] = quote;
						quote = 0;
						start = NULL;
						lastchar = ' ';
					}
				}
			}
			else
			{
				if( !escape ) {
					if( p[0] == '\"' || p[0] == '\'' )
						quote = p[0];
					else
					{
 // and there's a space
						if( lastchar != ' ' && p[0] == ' ' )
						{
							p[0] = 0;
							pp[count++] = StrDup( start );
							start = NULL;
							p[0] = ' ';
						}
						else if( lastchar == ' ' && p[0] != ' ' )
						{
							if( !start )
								start = p;
						}
					}
					lastchar = p[0] ;
				}
			}
			p++;
		}
		//lprintf( WIDE("Setting arg %d to %s"), count, start );
		if( start )
			pp[count++] = StrDup( start );
		pp[count] = NULL;
      if( pArgc )
			(*pArgc) = count;
      if( pArgv )
			(*pArgv) = argv;
	}
	else
	{
      if( pArgc )
			(*pArgc) = 0;
		if( pArgv )
		{
			(*pArgv) = NewArray( TEXTCHAR*, 1 );
			(*pArgv)[0] = NULL;
		}
	}
}
SACK_SYSTEM_NAMESPACE_END
#ifndef __LINUX__
#include <objbase.h>
#ifdef __cplusplus
namespace sack { namespace system{
#endif
void InitCo( void )
{
	CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE);
}
#ifdef __cplusplus
}
}
#endif
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   Adds functionality of timers that run dispatched from a single thread
 *   timer delay is trackable to provide self adjusting reliable frequency dispatch.
 *
 *   RemoveTimer( AddTimer( tick_frequency, timer_callback, user_data ) );
 *
 */
//#define ENABLE_CRITICALSEC_LOGGING
#define NO_UNICODE_C
// this is a cheat to get the critical section
// object... otherwise we'd have had circular
// linking reference between this and sharemem
// which would prefer to implement wakeablesleep
// for critical section waiting...
// must be included before memlib..
//#undef UNICODE
#define MEMORY_STRUCT_DEFINED
#define DEFINE_MEMORY_STRUCT
#define THREAD_STRUCTURE_DEFINED
 // Sleep()
 // SimpleRegisterAndCreateGlobal
// sorry if this causes problems...
// maybe promote this include into stdhdrs when this fails to compile
#ifdef __WATCOMC__
// _beginthread
#undef exit
#undef getenv
// process.h redefines exit
#include <process.h>
#endif
#ifndef __NO_OPTIONS__
#endif
#define DO_LOGGING
// display pause/resume support.
/* <link sack::image::render::PRENDERER, Render> provides a
   method to display images on a screen. It is the interface
   between memory images and the window desktop or frame buffer
   the user is viewing on a monitor.
   Under windows, this is implemented as an HWND and an HBITMAP
   used to allow the application to draw. Updates are done
   directly from the drawable surface to the HWND as appropriate
   for the type of service. This is implemented with Vidlib.dll.
   Under Linux, this is mounted against SDL. SDL, however, does
   not give multiple display surfaces, so a more direct method
   should be used someday, other than SDL does a good job of
   aliasing frame buffer and X display windows to a consistant
   interface. This is implemented wit DisplayLib (as yet outside
   of the documentation). Display lib can interface either
   directly, or be mounted as a service across from a shared
   memory message service, and host multiple applications on a
   single frame buffer surface.
   TODO
   Implement displays as direct X displays, and allow managment
   there under linux.
   Displaylib was a good project, and although suffers from
   code-rot, it is probably still mostly usable. Message
   services were easily transported across a network, but then
   location services started failing.
   Example
   <code lang="c++">
   // get a render display, just a default window of some size
   // extended features are available for more precision.
   Render render = OpenDisplay(0);
   </code>
   A few methods of using this surface are available. One, you
   may register for events, and be called as required.
   <code lang="c++">
   RedrawCallback MyDraw = DrawHandler;
   MouseCallback MyMouse;
   </code>
   <code>
   KeyProc MyKey;
   CloseCallback MyClose;
   </code>
   <code lang="c++">
   // called when the surface is initially shown, or when its surface changes.
   // otherwise, the image drawn by the application is static, and does
   // not get an update event.
   SetRedrawHandler( render, MyDraw, 0 );
   // This will get an event every time a mouse event happens.
   // If no Key handler is specified, key strokes will also be mouse events.
   SetMouseHandler( render, MyMouse, 0 );
   // If the window was closed, get an event.
   SetCloseHandler( render, MyClose, 0 );
   // specify a handler to get keyboard events...
   SetKeyboardHandler( render, MyKey, 0 );
   </code>
   Or, if you don't really care about any events...
   <code lang="c++">
   // load an image
   Image image = LoadImageFile( "sample.jpg" );
   // get the image target of render
   Image display = GetDisplayImage( render );
   // copy the loaded image to the display image
   BlotImage( display, image );
   // and update the display
   UpdateDisplay( render );
   </code>
   <code lang="c++">
   void CPROC DrawHandler( uintptr_t psvUserData, 31~PRENDERER render )
   {
       Image display = GetDisplayImage( render );
       // the display image may change, because of an external resize
       // update the image to display as desired...
       // when done, the draw handler should call UpdateDisplay or...
       UpdateDisplayPortion( render, 0, 0, 100, 100 );
   }
   </code>
   Oh! And most importantly! Have to call this to put the window
   on the screen.
   <code lang="c++">
   UpdateDisplay( render );
   </code>
   Or maybe can pretend it was hidden
   <code lang="c++">
   RestoreDisplay( render );
   </code>                                                                     */
// this shouldprobably be interlocked with
//  display.h or vidlib.h(video.h)
#ifndef RENDER_INTERFACE_INCLUDED
// multiple inclusion protection symbol.
#define RENDER_INTERFACE_INCLUDED
#ifdef __cplusplus
#ifdef _D3D_DRIVER
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d {
#define _RENDER_NAMESPACE namespace render { namespace d3d {
#define RENDER_NAMESPACE_END }}}}
#elif defined( _D3D10_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d10 {
#define _RENDER_NAMESPACE namespace render { namespace d3d10 {
#define RENDER_NAMESPACE_END }}}}
#elif defined( _D3D11_DRIVER )
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render { namespace d3d11 {
#define _RENDER_NAMESPACE namespace render { namespace d3d11 {
#define RENDER_NAMESPACE_END }}}}
#else
#define RENDER_NAMESPACE namespace sack { namespace image { namespace render {
/* <copy render.h>
   \ \             */
#define _RENDER_NAMESPACE namespace render {
#define RENDER_NAMESPACE_END }}}
#endif
#else
#define RENDER_NAMESPACE
#define _RENDER_NAMESPACE
#define RENDER_NAMESPACE_END
#endif
#ifndef KEYBOARD_DEFINITION
#define KEYBOARD_DEFINITION
#ifdef __cplusplus
#define _RENDER_KEYBOARD_NAMESPACE namespace keyboard {
#define _RENDER_KEYBOARD_NAMESPACE_END }
#else
#define _RENDER_KEYBOARD_NAMESPACE
#define _RENDER_KEYBOARD_NAMESPACE_END
#endif
RENDER_NAMESPACE
   _RENDER_KEYBOARD_NAMESPACE
			/* Keyboard state tracking structure... not very optimal...
			   \internal usage might be different.                      */
			enum KeyUpDownState {
KEYISUP   =2,
KEYISDOWN =1
			};
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag KEYBOARD;
/* <combine sack::image::render::keyboard::keyboard_tag>
   \ \                                                   */
typedef struct keyboard_tag *PKEYBOARD;
struct keyboard_tag
{
#define NUM_KEYS 256
   /* one byte index... more than sufficient
      if character in array is '1' key is down, '2' key is up. */
   char keyupdown[NUM_KEYS];
   /* Indicator that the key is a double-tap, not just a single.
      "!! is different that "!" "!                               */
   char keydouble[NUM_KEYS];
   /* time of the last key event */
   unsigned int  keytime[NUM_KEYS];
   /* I'm not sure, maybe it's the printable key char? */
		unsigned char key[NUM_KEYS];
#if 0
	// void (*Proc)(uintptr_t psv)[NUM_KEYS][8];
#endif
};
_RENDER_KEYBOARD_NAMESPACE_END
RENDER_NAMESPACE_END
#ifdef __cplusplus
#  ifdef _D3D_DRIVER
     using namespace sack::image::render::d3d::keyboard;
#  elif defined( _D3D10_DRIVER )
     using namespace sack::image::render::d3d10::keyboard;
#  elif defined( _D3D11_DRIVER )
     using namespace sack::image::render::d3d11::keyboard;
#  else
     using namespace sack::image::render::keyboard;
#  endif
#endif
//#include "vidlib.h"
	// some common things which are specific to this
   // library, and independant of implementation (so far)
#define KEY_MOD_SHIFT 1
#define KEY_MOD_CTRL  2
#define KEY_MOD_ALT   4
// call trigger on release also...
#define KEY_MOD_RELEASE  8
 // application wants both press and release events.
#define KEY_MOD_ALL_CHANGES  16
 // key match must be extended also... (extra arrow keys for instance.. what about SDL)
#define KEY_MOD_EXTENDED 32
#define KEY_PRESSED         0x80000000
#define IsKeyPressed( keycode ) ( (keycode) & 0x80000000 )
#define KEY_ALT_DOWN        0x40000000
#define KEY_CONTROL_DOWN    0x20000000
#define KEY_SHIFT_DOWN      0x10000000
#define KEY_MOD_DOWN (KEY_ALT_DOWN|KEY_CONTROL_DOWN)
#define KEY_ALPHA_LOCK_ON   0x08000000
#define KEY_NUM_LOCK_ON     0x04000000
#define KEY_MOD(key)        ( ( (key) & 0x70000000 ) >> 28 )
#define KEY_REAL_CODE(key)  ( ( (key) & 0x00FF0000 ) >> 16 )
#define KEY_CODE(key)       ( (key) & 0xFF )
#define IsKeyExtended(key)  ( ( (key) & 0x00000100 ) >> 8 )
#if defined( _WIN32 ) || defined( WIN32 ) || defined( __CYGWIN__ ) || defined( USE_WIN32_KEY_DEFINES )
// mirrored KEY_ definitions from allegro.H library....
//#include <windows.h>
#define BIT_7           0x80
#define KEY_TAB          9
#define KEY_CENTER       12
#define KEY_PAD5         12
#define KEY_ENTER        13
#define KEY_LSHIFT       16
#define KEY_SHIFT        16
#define KEY_LEFT_SHIFT   0x10
 // maybe?
#define KEY_RIGHT_SHIFT  0x10
#define KEY_SHIFT_LEFT KEY_LEFT_SHIFT
#define KEY_SHIFT_RIGHT KEY_RIGHT_SHIFT
#define KEY_CTRL         17
#define KEY_CONTROL      17
#define KEY_LEFT_CONTROL  17
#define KEY_RIGHT_CONTROL 17
 // can't get usually under windows?(keyhook!)
#define KEY_ALT          18
#define KEY_LEFT_ALT      18
#define KEY_RIGHT_ALT     18
#define KEY_CAPS_LOCK    20
#define KEY_ESC          27
#define KEY_ESCAPE       27
#define KEY_PGUP         33
#define KEY_PAGE_UP     KEY_PGUP
#define KEY_PGDN         34
#define KEY_PAGE_DOWN   KEY_PGDN
#define KEY_END          35
#define KEY_HOME         36
#define KEY_LEFT         37
#define KEY_UP           38
#define KEY_RIGHT        39
#define KEY_DOWN         40
#define KEY_GRAY_UP  38
#define KEY_GRAY_LEFT   37
#define KEY_GRAY_RIGHT  39
#define KEY_GRAY_DOWN    40
//#define KEY_GRAY_UP      BIT_7+0x48
#define KEY_GRAY_PGUP   BIT_7+0x49
#define KEY_GRAY_MINUS  BIT_7+0x4A
//#define KEY_GRAY_LEFT BIT_7+0x4B
//#define KEY_GRAY_RIGHT   BIT_7+0x4D
#define KEY_GRAY_PLUS   BIT_7+0x4E
#define KEY_GRAY_END    BIT_7+0x4F
#define KEY_PAD_PLUS   BIT_7+0x4E
//#define KEY_GRAY_DOWN BIT_7+0x50
#define KEY_GRAY_PGDN   BIT_7+0x51
#define KEY_GRAY_INS    BIT_7+0x52
#define KEY_GRAY_DEL    BIT_7+0x53
#define KEY_GRAY_DELETE    BIT_7+0x53
#define KEY_GREY_DELETE    BIT_7+0x53
#define KEY_INSERT       45
#define KEY_DEL          46
#define KEY_DELETE       KEY_DEL
#define KEY_PRINT_SCREEN1  VK_PRINT
#define KEY_PRINT_SCREEN2  VK_SNAPSHOT
 // windows keys keys
#define KEY_WINDOW_2     0x50
 // windows keys keys
#define KEY_WINDOW_1     0x5c
#define KEY_GRAY_STAR     0x6a
#define KEY_PLUS_PAD     0x6b
//#define KEY_GRAY_MINUS    0x6d
#define KEY_GRAY_SLASH    VK_OEM_5
//#define KEY_GRAY_PLUS     107
#define KEY_NUM_LOCK      VK_NUMLOCK
#define KEY_SCROLL_LOCK VK_SCROLL
#define KEY_SLASH        VK_OEM_2
#define KEY_BACKSPACE   '\b'
#define KEY_SPACE        ' '
#define KEY_COMMA      0xBC
 // should be some sort of VK_ definitions....
#define KEY_STOP       0xBE
#define KEY_PERIOD     KEY_STOP
#define KEY_A         'A'
#define KEY_B         'B'
#define KEY_C         'C'
#define KEY_D         'D'
#define KEY_E         'E'
#define KEY_F         'F'
#define KEY_G         'G'
#define KEY_H         'H'
#define KEY_I         'I'
#define KEY_J         'J'
#define KEY_K         'K'
#define KEY_L         'L'
#define KEY_F12  VK_F12
#define KEY_F11  VK_F11
#define KEY_F10  VK_F10
#define KEY_F9  VK_F9
#define KEY_F8  VK_F8
#define KEY_F7  VK_F7
#define KEY_F6  VK_F6
#define KEY_F5  VK_F5
#define KEY_F4  VK_F4
#define KEY_F3  VK_F3
#define KEY_F2  VK_F2
#define KEY_F1  VK_F1
#define KEY_M        77
#define KEY_N         78
#define KEY_O         79
#define KEY_P        80
#define KEY_Q         'Q'
#define KEY_R         'R'
#define KEY_S         'S'
#define KEY_T         'T'
#define KEY_U         'U'
#define KEY_V         'V'
#define KEY_W         'W'
#define KEY_X         'X'
#define KEY_Y         'Y'
#define KEY_Z         'Z'
#define KEY_1         '1'
#define KEY_2         '2'
#define KEY_3         '3'
#define KEY_4         '4'
#define KEY_5         '5'
#define KEY_6         '6'
#define KEY_7         '7'
#define KEY_8         '8'
#define KEY_9         '9'
#define KEY_0         '0'
#define KEY_MINUS    KEY_DASH
#ifndef VK_OEM_1
// native windows OEM definitions
#define VK_OEM_1   186
#define VK_OEM_2   191
#define VK_OEM_4   219
#define VK_OEM_5   220
#define VK_OEM_6   221
#define VK_OEM_7   222
#define VK_OEM_MINUS  189
#define VK_OEM_PLUS    187
#endif
#define KEY_SEMICOLON     VK_OEM_1
#define KEY_QUOTE         VK_OEM_7
#define KEY_LEFT_BRACKET  VK_OEM_4
#define KEY_RIGHT_BRACKET VK_OEM_6
#define KEY_BACKSLASH     VK_OEM_5
//'-'
#define KEY_DASH     VK_OEM_MINUS
#define KEY_EQUAL    VK_OEM_PLUS
#define KEY_EQUALS   KEY_EQUAL
#define KEY_ACCENT 192
#define KEY_GRAVE  KEY_ACCENT
#define KEY_APOSTROPHE  KEY_ACCENT
#define KEY_F1  VK_F1
#define KEY_F2  VK_F2
#define KEY_F3  VK_F3
#define KEY_F4  VK_F4
#define KEY_F5  VK_F5
#define KEY_F6  VK_F6
#define KEY_F7  VK_F7
#define KEY_F8  VK_F8
#define KEY_F9  VK_F9
#define KEY_F10  VK_F10
#define KEY_F1  VK_F1
#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define KEY_PAD_MULT VK_MULTIPLY
#define KEY_PAD_DOT VK_DECIMAL
#define KEY_PAD_DIV VK_DIVIDE
#define KEY_PAD_0 VK_NUMPAD0
#define KEY_GREY_INSERT VK_NUMPAD0
#define KEY_PAD_1 VK_NUMPAD1
#define KEY_PAD_2 VK_NUMPAD2
#define KEY_PAD_3 VK_NUMPAD3
#define KEY_PAD_4 VK_NUMPAD4
#define KEY_PAD_5 VK_NUMPAD5
#define KEY_PAD_6 VK_NUMPAD6
#define KEY_PAD_7 VK_NUMPAD7
#define KEY_PAD_8 VK_NUMPAD8
#define KEY_PAD_9 VK_NUMPAD9
#define KEY_PAD_ENTER VK_RETURN
#define KEY_PAD_DELETE VK_SEPARATOR
#define KEY_PAD_MINUS VK_SUBTRACT
#endif
// if any key...
#if !defined( KEY_1 )
#if defined( __ANDROID__ )
#include <android/keycodes.h>
#define KEY_SHIFT        AKEYCODE_SHIFT_LEFT
#define KEY_LEFT_SHIFT   AKEYCODE_SHIFT_LEFT
 // maybe?
#define KEY_RIGHT_SHIFT  AKEYCODE_SHIFT_RIGHT
#ifndef AKEYCODE_CTRL_LEFT
#define AKEYCODE_CTRL_LEFT 113
#endif
#ifndef AKEYCODE_CTRL_RIGHT
#define AKEYCODE_CTRL_RIGHT 114
#endif
#define KEY_CTRL          AKEYCODE_CTRL_LEFT
#define KEY_CONTROL       AKEYCODE_CTRL_LEFT
#define KEY_LEFT_CONTROL  AKEYCODE_CTRL_LEFT
#define KEY_RIGHT_CONTROL AKEYCODE_CTRL_RIGHT
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           AKEYCODE_ALT_LEFT
#define KEY_LEFT_ALT      AKEYCODE_ALT_LEFT
#define KEY_RIGHT_ALT     AKEYCODE_ALT_RIGHT
#ifndef AKEYCODE_CAPS_LOCK
#define AKEYCODE_CAPS_LOCK 115
#endif
#define KEY_CAPS_LOCK     AKEYCODE_CAPS_LOCK
#define KEY_NUM_LOCK      0
#ifndef AKEYCODE_SCROLL_LOCK
#define AKEYCODE_SCROLL_LOCK 116
#endif
 // unsure about this
#define KEY_SCROLL_LOCK   AKEYCODE_SCROLL_LOCK
#ifndef AKEYCODE_ESCAPE
#define AKEYCODE_ESCAPE 111
#endif
#define KEY_ESC           AKEYCODE_ESCAPE
#define KEY_ESCAPE        AKEYCODE_ESCAPE
#ifndef AKEYCODE_MOVE_HOME
#define AKEYCODE_MOVE_HOME 122
#endif
#ifndef AKEYCODE_MOVE_END
#define AKEYCODE_MOVE_END 123
#endif
#define KEY_HOME          AKEYCODE_MOVE_HOME
#define KEY_PAD_HOME      AKEYCODE_MOVE_HOME
#define KEY_PAD_7         0
#define KEY_GREY_HOME     0
#define KEY_UP            AKEYCODE_DPAD_UP
#define KEY_PAD_8         0
#define KEY_PAD_UP        0
#define KEY_GREY_UP       0
#define KEY_PGUP          0
#define KEY_PAD_9         0
#define KEY_PAD_PGUP      0
#define KEY_GREY_PGUP     0
#define KEY_LEFT          AKEYCODE_DPAD_LEFT
#define KEY_PAD_4         0
#define KEY_PAD_LEFT      0
#define KEY_GREY_LEFT     0
#define KEY_CENTER        AKEYCODE_DPAD_CENTER
#define KEY_PAD_5         0
#define KEY_PAD_CENTER    0
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         AKEYCODE_DPAD_RIGHT
#define KEY_PAD_6         0
#define KEY_PAD_RIGHT     0
#define KEY_GREY_RIGHT    0
#define KEY_END           AKEYCODE_MOVE_END
#define KEY_PAD_1         0
#define KEY_PAD_END       0
#define KEY_GREY_END      0
#define KEY_DOWN          AKEYCODE_DPAD_DOWN
#define KEY_PAD_2         0
#define KEY_PAD_DOWN      0
#define KEY_GREY_DOWN     0
#define KEY_PGDN          0
#define KEY_PAD_3         0
#define KEY_PAD_PGDN      0
#define KEY_GREY_PGDN     0
#define KEY_INSERT        0
#define KEY_PAD_0         0
#define KEY_PAD_INSERT    0
#define KEY_GREY_INSERT   0
#define KEY_DELETE        0
#define KEY_PAD_DOT       0
#define KEY_PAD_DELETE    0
#define KEY_GREY_DELETE   0
#define KEY_PLUS          0
#define KEY_PAD_PLUS      0
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0
#define KEY_PAD_MINUS     0
#define KEY_GREY_MINUS    0
#define KEY_MULT          0
#define KEY_PAD_MULT      0
#define KEY_GREY_MULT     0
#define KEY_DIV           0
#define KEY_PAD_DIV       0
#define KEY_GREY_DIV      0
#define KEY_ENTER         AKEYCODE_ENTER
#define KEY_PAD_ENTER     AKEYCODE_ENTER
#define KEY_NORMAL_ENTER  AKEYCODE_ENTER
 // windows keys keys
#define KEY_WINDOW_1      0
 // windows keys keys
#define KEY_WINDOW_2      0
#define KEY_TAB           AKEYCODE_TAB
#define KEY_SLASH         AKEYCODE_SLASH
#define KEY_BACKSPACE     AKEYCODE_DEL
#define KEY_SPACE         AKEYCODE_SPACE
#define KEY_COMMA         AKEYCODE_COMMA
 // should be some sort of VK_ definitions....
#define KEY_STOP          AKEYCODE_PERIOD
#define KEY_PERIOD        AKEYCODE_PERIOD
#define KEY_SEMICOLON     AKEYCODE_SEMICOLON
#define KEY_QUOTE         AKEYCODE_APOSTROPHE
#define KEY_LEFT_BRACKET  AKEYCODE_LEFT_BRACKET
#define KEY_RIGHT_BRACKET AKEYCODE_RIGHT_BRACKET
#define KEY_BACKSLASH     AKEYCODE_BACKSLASH
#define KEY_DASH          AKEYCODE_MINUS
#define KEY_EQUAL         AKEYCODE_EQUALS
#define KEY_ACCENT        AKEYCODE_GRAVE
#define KEY_1         AKEYCODE_1
#define KEY_2         AKEYCODE_2
#define KEY_3         AKEYCODE_3
#define KEY_4         AKEYCODE_4
#define KEY_5         AKEYCODE_5
#define KEY_6         AKEYCODE_6
#define KEY_7         AKEYCODE_7
#define KEY_8         AKEYCODE_8
#define KEY_9         AKEYCODE_9
#define KEY_0         AKEYCODE_0
#define KEY_F1        0
#define KEY_F2        0
#define KEY_F3        0
#define KEY_F4        0
#define KEY_F5        0
#define KEY_F6        0
#define KEY_F7        0
#define KEY_F8        0
#define KEY_F9        0
#define KEY_F10       0
#define KEY_F11       0
#define KEY_F12       0
#define KEY_A   AKEYCODE_A
#define KEY_B   AKEYCODE_B
#define KEY_C   AKEYCODE_C
#define KEY_D   AKEYCODE_D
#define KEY_E   AKEYCODE_E
#define KEY_F   AKEYCODE_F
#define KEY_G   AKEYCODE_G
#define KEY_H   AKEYCODE_H
#define KEY_I   AKEYCODE_I
#define KEY_J   AKEYCODE_J
#define KEY_K   AKEYCODE_K
#define KEY_L   AKEYCODE_L
#define KEY_M   AKEYCODE_M
#define KEY_N   AKEYCODE_N
#define KEY_O   AKEYCODE_O
#define KEY_P   AKEYCODE_P
#define KEY_Q   AKEYCODE_Q
#define KEY_R   AKEYCODE_R
#define KEY_S   AKEYCODE_S
#define KEY_T   AKEYCODE_T
#define KEY_U   AKEYCODE_U
#define KEY_V   AKEYCODE_V
#define KEY_W   AKEYCODE_W
#define KEY_X   AKEYCODE_X
#define KEY_Y   AKEYCODE_Y
#define KEY_Z   AKEYCODE_Z
#elif defined( __LINUX__ )
	  //#define USE_SDL_KEYSYM
// ug - KEYSYMS are too wide...
// so - we fall back to x scancode tables - and translate sym to these
// since the scancodes which come from X are not the same as from console Raw
// but - perhaps we should re-translate these to REAL scancodes... but in either
// case - these fall to under 256 characters, and can therefore be used...
#define USE_X_RAW_SCANCODES
#ifdef USE_X_RAW_SCANCODES
#define KEY_SHIFT        0xFF
#define KEY_LEFT_SHIFT   50
 // maybe?
#define KEY_RIGHT_SHIFT  62
#define KEY_CTRL          0xFE
#define KEY_CONTROL       0xFE
#define KEY_LEFT_CONTROL  37
#define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           0xFD
#define KEY_LEFT_ALT      64
#define KEY_RIGHT_ALT     113
#define KEY_CAPS_LOCK     66
#define KEY_NUM_LOCK      77
 // unsure about this
#define KEY_SCROLL_LOCK   78
#define KEY_ESC           9
#define KEY_ESCAPE        9
#define KEY_HOME          0xFC
#define KEY_PAD_HOME      79
#define KEY_PAD_7         79
#define KEY_GREY_HOME     97
#define KEY_UP            0xFB
#define KEY_PAD_8         80
#define KEY_PAD_UP        80
#define KEY_GREY_UP       98
#define KEY_PGUP          0xFA
#define KEY_PAGE_UP       KEY_PGUP
#define KEY_PAD_9         81
#define KEY_PAD_PGUP      81
#define KEY_GREY_PGUP     99
#define KEY_LEFT          0xF9
#define KEY_PAD_4         83
#define KEY_PAD_LEFT      83
#define KEY_GREY_LEFT     100
#define KEY_CENTER        0xF8
#define KEY_PAD_5         84
#define KEY_PAD_CENTER    84
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         0xF7
#define KEY_PAD_6         85
#define KEY_PAD_RIGHT     85
#define KEY_GREY_RIGHT    102
#define KEY_END           0xF6
#define KEY_PAD_1         87
#define KEY_PAD_END       87
#define KEY_GREY_END      103
#define KEY_DOWN          0xF5
#define KEY_PAD_2         88
#define KEY_PAD_DOWN      88
#define KEY_GREY_DOWN     104
#define KEY_PGDN          0xF4
#define KEY_PAGE_DOWN     KEY_PGDN
#define KEY_PAD_3         89
#define KEY_PAD_PGDN      89
#define KEY_GREY_PGDN     105
#define KEY_INSERT        0xF3
#define KEY_PAD_0         90
#define KEY_PAD_INSERT    90
#define KEY_GREY_INSERT   106
#define KEY_DELETE        0xF2
#define KEY_DEL           KEY_DELETE
#define KEY_PAD_DOT       91
#define KEY_PAD_DELETE    91
#define KEY_GREY_DELETE   107
#define KEY_PLUS          0xF1
#define KEY_PAD_PLUS      86
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0xF0
#define KEY_PAD_MINUS     82
#define KEY_GREY_MINUS    0
#define KEY_MULT          0xEF
#define KEY_PAD_MULT      63
#define KEY_GREY_MULT     0
#define KEY_DIV           0xEE
#define KEY_PAD_DIV       112
#define KEY_GREY_DIV      0
#define KEY_ENTER         0xED
#define KEY_PAD_ENTER     108
#define KEY_NORMAL_ENTER  36
 // windows keys keys
#define KEY_WINDOW_1      115
 // windows keys keys
#define KEY_WINDOW_2      117
#define KEY_TAB           23
#define KEY_SLASH         61
#define KEY_BACKSPACE     22
#define KEY_SPACE         65
#define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#define KEY_STOP          60
#define KEY_PERIOD        KEY_STOP
#define KEY_SEMICOLON     47
#define KEY_QUOTE         48
#define KEY_LEFT_BRACKET  34
#define KEY_RIGHT_BRACKET 35
#define KEY_BACKSLASH     51
#define KEY_DASH          20
#define KEY_EQUAL         21
#define KEY_EQUALS       KEY_EQUAL
#define KEY_ACCENT        49
#define KEY_APOSTROPHE    KEY_QUOTE
#define KEY_GRAVE        KEY_ACCENT
#define KEY_SHIFT_LEFT   KEY_LEFT_SHIFT
#define KEY_SHIFT_RIGHT  KEY_RIGHT_SHIFT
#define KEY_1         10
#define KEY_2         11
#define KEY_3         12
#define KEY_4         13
#define KEY_5         14
#define KEY_6         15
#define KEY_7         16
#define KEY_8         17
#define KEY_9         18
#define KEY_0         19
#define KEY_F1        67
#define KEY_F2        68
#define KEY_F3        69
#define KEY_F4        70
#define KEY_F5        71
#define KEY_F6        72
#define KEY_F7        73
#define KEY_F8        74
#define KEY_F9        75
#define KEY_F10       76
#define KEY_F11       95
#define KEY_F12       96
#define KEY_A         38
#define KEY_B         56
#define KEY_C         54
#define KEY_D         40
#define KEY_E         26
#define KEY_F         41
#define KEY_G         42
#define KEY_H         43
#define KEY_I         31
#define KEY_J         44
#define KEY_K         45
#define KEY_L         46
#define KEY_M         58
#define KEY_N         57
#define KEY_O         32
#define KEY_P         33
#define KEY_Q         24
#define KEY_R         27
#define KEY_S         39
#define KEY_T         28
#define KEY_U         30
#define KEY_V         55
#define KEY_W         25
#define KEY_X         53
#define KEY_Y         29
#define KEY_Z         52
#elif defined( USE_SDL_KEYSYM )
#include <SDL.h>
#define KEY_SHIFT        0xFF
#define KEY_LEFT_SHIFT   SDLK_LSHIFT
#define KEY_RIGHT_SHIFT  SDLK_RSHIFT
#define KEY_CTRL          0xFE
#define KEY_CONTROL       0xFE
#define KEY_LEFT_CONTROL  SDLK_LCTRL
#define KEY_RIGHT_CONTROL SDLK_RCTRL
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           0xFD
#define KEY_LEFT_ALT      SDLK_LALT
#define KEY_RIGHT_ALT     SDLK_RALT
#define KEY_CAPS_LOCK     SDLK_CAPSLOCK
#define KEY_NUM_LOCK      SDLK_NUMLOCK
#define KEY_SCROLL_LOCK   SDLK_SCROLLOCK
#define KEY_ESC           SDLK_ESCAPE
#define KEY_ESCAPE        SDLK_ESCAPE
#define KEY_HOME          0xFC
#define KEY_PAD_HOME      SDLK_KP7
#define KEY_PAD_7         SDLK_KP7
#define KEY_GREY_HOME     SDLK_HOME
#define KEY_UP            0xFB
#define KEY_PAD_8         SDLK_KP8
#define KEY_PAD_UP        SDLK_KP8
#define KEY_GREY_UP       SDLK_UP
#define KEY_PGUP          0xFA
#define KEY_PAD_9         SDLK_KP9
#define KEY_PAD_PGUP      SDLK_KP9
#define KEY_GREY_PGUP     SDLK_PAGEUP
#define KEY_LEFT          0xF9
#define KEY_PAD_4         SDLK_KP4
#define KEY_PAD_LEFT      SDLK_KP4
#define KEY_GREY_LEFT     SDLK_LEFT
#define KEY_CENTER        0xF8
#define KEY_PAD_5         SDLK_KP5
#define KEY_PAD_CENTER    SDLK_KP5
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         0xF7
#define KEY_PAD_6         SDLK_KP6
#define KEY_PAD_RIGHT     SDLK_KP6
#define KEY_GREY_RIGHT    SDLK_RIGHT
#define KEY_END           0xF6
#define KEY_PAD_1         SDLK_KP1
#define KEY_PAD_END       SDLK_KP1
#define KEY_GREY_END      SDLK_END
#define KEY_DOWN          0xF5
#define KEY_PAD_2         SDLK_KP2
#define KEY_PAD_DOWN      SDLK_KP2
#define KEY_GREY_DOWN     SDLK_DOWN
#define KEY_PGDN          0xF4
#define KEY_PAD_3         SDLK_KP3
#define KEY_PAD_PGDN      SDLK_KP3
#define KEY_GREY_PGDN     SDLK_PAGEDN
#define KEY_INSERT        0xF3
#define KEY_PAD_0         SDLK_KP0
#define KEY_PAD_INSERT    SDLK_KP0
#define KEY_GREY_INSERT   SDLK_INSERT
#define KEY_DELETE        0xF2
#define KEY_PAD_DOT       SDLK_KP_PERIOD
#define KEY_PAD_DELETE    SDLK_KP_PERIOD
#define KEY_GREY_DELETE   SDLK_DELETE
#define KEY_PLUS          0xF1
#define KEY_PAD_PLUS      SDLK_KP_PLUS
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0xF0
#define KEY_PAD_MINUS     SDLK_KP_MINUS
#define KEY_GREY_MINUS    0
#define KEY_MULT          0xEF
#define KEY_PAD_MULT      SDLK_KP_MULTIPLY
#define KEY_GREY_MULT     0
#define KEY_DIV           0xEE
#define KEY_PAD_DIV       SDLK_KP_DIVIDE
#define KEY_GREY_DIV      0
#define KEY_ENTER         0xED
#define KEY_PAD_ENTER     SDLK_KP_ENTER
#define KEY_NORMAL_ENTER  SDLK_RETURN
 // windows keys keys
#define KEY_WINDOW_1      115
 // windows keys keys
#define KEY_WINDOW_2      117
#define KEY_TAB           SDLK_TAB
#define KEY_SLASH         SDLK_SLASH
#define KEY_BACKSPACE     SDLK_BACKSPACE
#define KEY_SPACE         SDLK_SPACE
#define KEY_COMMA         SDLK_COMMA
 // should be some sort of VK_ definitions....
#define KEY_STOP          SDLK_PERIOD
#define KEY_PERIOD        KEY_STOP
#define KEY_SEMICOLON     SDLK_SEMICOLON
#define KEY_QUOTE         SDLK_QUOTE
#define KEY_LEFT_BRACKET  SDLK_LEFTBRACKET
#define KEY_RIGHT_BRACKET SDLK_RIGHTBRACKET
#define KEY_BACKSLASH     SDLK_BACKSLASH
#define KEY_DASH          SDLK_MINUS
#define KEY_EQUAL         SDLK_EQUALS
 // grave
#define KEY_ACCENT        SDLK_BACKQUOTE
#define KEY_1         SDLK_1
#define KEY_2         SDLK_2
#define KEY_3         SDLK_3
#define KEY_4         SDLK_4
#define KEY_5         SDLK_5
#define KEY_6         SDLK_6
#define KEY_7         SDLK_7
#define KEY_8         SDLK_8
#define KEY_9         SDLK_9
#define KEY_0         SDLK_0
#define KEY_F1        SDLK_F1
#define KEY_F2        SDLK_F2
#define KEY_F3        SDLK_F3
#define KEY_F4        SDLK_F4
#define KEY_F5        SDLK_F5
#define KEY_F6        SDLK_F6
#define KEY_F7        SDLK_F7
#define KEY_F8        SDLK_F8
#define KEY_F9        SDLK_F9
#define KEY_F10       SDLK_F10
#define KEY_F11       SDLK_F11
#define KEY_F12       SDLK_F12
#define KEY_A         SDLK_A
#define KEY_B         SDLK_B
#define KEY_C         SDLK_C
#define KEY_D         SDLK_D
#define KEY_E         SDLK_E
#define KEY_F         SDLK_F
#define KEY_G         SDLK_G
#define KEY_H         SDLK_H
#define KEY_I         SDLK_I
#define KEY_J         SDLK_J
#define KEY_K         SDLK_K
#define KEY_L         SDLK_L
#define KEY_M         SDLK_M
#define KEY_N         SDLK_N
#define KEY_O         SDLK_O
#define KEY_P         SDLK_P
#define KEY_Q         SDLK_Q
#define KEY_R         SDLK_R
#define KEY_S         SDLK_S
#define KEY_T         SDLK_T
#define KEY_U         SDLK_U
#define KEY_V         SDLK_V
#define KEY_W         SDLK_W
#define KEY_X         SDLK_X
#define KEY_Y         SDLK_Y
#define KEY_Z         SDLK_Z
#elif defined( USE_RAW_SCANCODE )
#error RAW_SCANCODES have not been defined yet.
#define KEY_SHIFT        0xFF
#define KEY_LEFT_SHIFT   50
 // maybe?
#define KEY_RIGHT_SHIFT  62
#define KEY_CTRL          0xFE
#define KEY_CONTROL       0xFE
#define KEY_LEFT_CONTROL  37
#define KEY_RIGHT_CONTROL 109
 // can't get usually under windows?(keyhook!)
#define KEY_ALT           0xFD
#define KEY_LEFT_ALT      64
#define KEY_RIGHT_ALT     113
#define KEY_CAPS_LOCK     66
#define KEY_NUM_LOCK      77
 // unsure about this
#define KEY_SCROLL_LOCK   78
#define KEY_ESC           9
#define KEY_ESCAPE        9
#define KEY_HOME          0xFC
#define KEY_PAD_HOME      79
#define KEY_PAD_7         79
#define KEY_GREY_HOME     97
#define KEY_UP            0xFB
#define KEY_PAD_8         80
#define KEY_PAD_UP        80
#define KEY_GREY_UP       98
#define KEY_PGUP          0xFA
#define KEY_PAD_9         81
#define KEY_PAD_PGUP      81
#define KEY_GREY_PGUP     99
#define KEY_LEFT          0xF9
#define KEY_PAD_4         83
#define KEY_PAD_LEFT      83
#define KEY_GREY_LEFT     100
#define KEY_CENTER        0xF8
#define KEY_PAD_5         84
#define KEY_PAD_CENTER    84
#define KEY_GREY_CENTER   0
#define KEY_RIGHT         0xF7
#define KEY_PAD_6         85
#define KEY_PAD_RIGHT     85
#define KEY_GREY_RIGHT    102
#define KEY_END           0xF6
#define KEY_PAD_1         87
#define KEY_PAD_END       87
#define KEY_GREY_END      103
#define KEY_DOWN          0xF5
#define KEY_PAD_2         88
#define KEY_PAD_DOWN      88
#define KEY_GREY_DOWN     104
#define KEY_PGDN          0xF4
#define KEY_PAD_3         89
#define KEY_PAD_PGDN      89
#define KEY_GREY_PGDN     105
#define KEY_INSERT        0xF3
#define KEY_PAD_0         90
#define KEY_PAD_INSERT    90
#define KEY_GREY_INSERT   106
#define KEY_DELETE        0xF2
#define KEY_PAD_DOT       91
#define KEY_PAD_DELETE    91
#define KEY_GREY_DELETE   107
#define KEY_PLUS          0xF1
#define KEY_PAD_PLUS      86
#define KEY_GREY_PLUS     0
#define KEY_MINUS         0xF0
#define KEY_PAD_MINUS     82
#define KEY_GREY_MINUS    0
#define KEY_MULT          0xEF
#define KEY_PAD_MULT      63
#define KEY_GREY_MULT     0
#define KEY_DIV           0xEE
#define KEY_PAD_DIV       112
#define KEY_GREY_DIV      0
#define KEY_ENTER         0xED
#define KEY_PAD_ENTER     108
#define KEY_NORMAL_ENTER  36
 // windows keys keys
#define KEY_WINDOW_1      115
 // windows keys keys
#define KEY_WINDOW_2      117
#define KEY_TAB           23
#define KEY_SLASH         61
#define KEY_BACKSPACE     22
#define KEY_SPACE         65
#define KEY_COMMA         59
 // should be some sort of VK_ definitions....
#define KEY_STOP          60
#define KEY_PERIOD        KEY_STOP
#define KEY_SEMICOLON     47
#define KEY_QUOTE         48
#define KEY_LEFT_BRACKET  34
#define KEY_RIGHT_BRACKET 35
#define KEY_BACKSLASH     51
#define KEY_DASH          20
#define KEY_EQUAL         21
#define KEY_ACCENT        49
#define KEY_1         10
#define KEY_2         11
#define KEY_3         12
#define KEY_4         13
#define KEY_5         14
#define KEY_6         15
#define KEY_7         16
#define KEY_8         17
#define KEY_9         18
#define KEY_0         19
#define KEY_F1        67
#define KEY_F2        68
#define KEY_F3        69
#define KEY_F4        70
#define KEY_F5        71
#define KEY_F6        72
#define KEY_F7        73
#define KEY_F8        74
#define KEY_F9        75
#define KEY_F10       76
#define KEY_F11       95
#define KEY_F12       96
#define KEY_A         38
#define KEY_B         56
#define KEY_C         54
#define KEY_D         40
#define KEY_E         26
#define KEY_F         41
#define KEY_G         42
#define KEY_H         43
#define KEY_I         31
#define KEY_J         44
#define KEY_K         45
#define KEY_L         46
#define KEY_M         58
#define KEY_N         57
#define KEY_O         32
#define KEY_P         33
#define KEY_Q         24
#define KEY_R         27
#define KEY_S         39
#define KEY_T         28
#define KEY_U         30
#define KEY_V         55
#define KEY_W         25
#define KEY_X         53
#define KEY_Y         29
#define KEY_Z         52
#endif
#endif
#endif
#elif defined( DEFINE_HARDWARE_SCANCODES )
#ifndef KBD_HPP
#define KBD_HPP
#define KBD_INT            9
#define KBD_EXTENDED_CODE     0xE0
#define LOW_ASCII(asc)     (asc&0x7F)
#define NUM_KEYS        256
#ifdef WIN32
//#define KEY_ESC       27
//#define KEY_LEFT      37
//#define KEY_CENTER    KB_CENTER
//#define KEY_RIGHT     39
//#define KEY_DOWN      40
//#define KEY_GRAY_UP   38
//#define KEY_GRAY_LEFT 37
//#define KEY_GRAY_RIGHT   39
//#define KEY_GRAY_DOWN    40
//#define KEY_LEFT_SHIFT   16
//#define KEY_RIGHT_SHIFT  16
//#define KEY_GRAY_PGUP 33
//#define KEY_GRAY_PGDN 34
//#define KEY_GRAY_INS  45
//#define KEY_GRAY_DEL  46
//#define KEY_P         80
//#define KEY_M         77
#else
#define KEY_ESC       0x01
#define KEY_1         0x02
#define KEY_2         0x03
#define KEY_3         0x04
#define KEY_4         0x05
#define KEY_5         0x06
#define KEY_6         0x07
#define KEY_7         0x08
#define KEY_8         0x09
#define KEY_9         0x0A
#define KEY_0         0x0B
#define KEY_MINUS     0x0C
#define KEY_PLUS         0x0D
#define  KEY_BKSP        0x0E
#define KEY_TAB       0x0F
#define KEY_Q         0x10
#define KEY_W         0x11
#define KEY_E         0x12
#define KEY_R         0x13
#define KEY_T         0x14
#define KEY_Y         0x15
#define KEY_U         0x16
#define KEY_I         0x17
#define  KEY_O        0x18
#define KEY_P         0x19
#define KEY_BRACK_OPEN   0x1A
#define KEY_BRACK_CLOSE  0x1B
#define KEY_ENTER     0x1C
#define KEY_LEFT_CTRL 0x1D
#define KEY_A         0x1E
#define KEY_S         0x1F
#define KEY_D         0x20
#define KEY_F         0x21
#define KEY_X         0x2D
#define KEY_C         0x2E
#define KEY_V         0x2F
#define KEY_B         0x30
#define KEY_N         0x31
#define KEY_M         0x32
#define KEY_GRAY_SLASH   0x35
#define KEY_RIGHT_SHIFT  0x36
#define KEY_GRAY_STAR 0x37
#define KEY_LEFT_ALT     0x38
#define KEY_SPACE     0x39
#define KEY_CAPS         0x3A
#define KEY_F1        0x3B
#define KEY_F2        0x3C
#define KEY_F3        0x3D
#define KEY_F4        0x3E
#define KEY_F5        0x3F
#define KEY_F6        0x40
#define KEY_F7        0x41
#define KEY_F8        0x42
#define KEY_F9        0x43
#define KEY_F10       0x44
#define KEY_UP        0x48
#define KEY_LEFT      0x4B
#define KEY_CENTER    0x4C
#define KEY_RIGHT     0x4D
#define KEY_DOWN      0x50
#define KEY_DEL       0x53
#define KEY_F11       0x57
#define KEY_F12       0x58
#define KEY_RIGHT_CTRL   BIT_7+0x1D
#define KEY_RIGHT_ALT BIT_7+0x38
#define KEY_GRAY_UP      BIT_7+0x48
#define KEY_GRAY_PGUP BIT_7+0x49
#define KEY_GRAY_MINUS   BIT_7+0x4A
#define KEY_GRAY_LEFT BIT_7+0x4B
#define KEY_GRAY_RIGHT   BIT_7+0x4D
#define KEY_GRAY_PLUS BIT_7+0x4E
#define KEY_GRAY_END     BIT_7+0x4F
#define KEY_GRAY_DOWN BIT_7+0x50
#define KEY_GRAY_PGDN BIT_7+0x51
#define KEY_GRAY_INS     BIT_7+0x52
#define KEY_GRAY_DEL     BIT_7+0x53
#endif
#endif
#endif
// $Log: keybrd.h,v $
// Revision 1.16  2004/08/11 11:41:06  d3x0r
// Begin seperation of key and render
//
// Revision 1.15  2004/06/01 21:53:43  d3x0r
// Fix PUBLIC dfeinitions from Windoze-centric to system nonspecified
//
// Revision 1.14  2004/04/27 04:58:16  d3x0r
// Forgot to macro a function..
//
// Revision 1.13  2004/04/27 03:06:16  d3x0r
// Define F1-F10
//
// Revision 1.12  2004/03/05 23:33:21  d3x0r
// Missing keydefs - may be wrong.
//
// Revision 1.11  2003/03/25 08:38:11  panther
// Add logging
//
/* Crafted by Jim Buckeyne (c)1999-2006++ Freedom Collective
   Image building tracking, and simple manipulations.        */
// if the library is to have it's own idea of what
// an image is - then it should have included
// the definition for 'SFTFont', and 'Image' before
// including this... otherwise, it is assumed to
// be a client, and therefore does not need the information
// if a custom structure is used - then it MUST define
// it's ACTUAL x,y,width,height as the first 4 int32_t bit values.
#ifndef IMAGE_H
// multiple inclusion protection symbol
#define IMAGE_H
#if defined( _MSC_VER ) && defined( SACK_BAG_EXPORTS ) && 0
#define HAS_ASSEMBLY
#endif
#ifndef __NO_INTERFACES__
#endif
# ifndef SECOND_IMAGE_LEVEL
#  define SECOND_IMAGE_LEVEL _2
/* This is a macro used for building name changes for
   interfaces.                                        */
#  define PASTE(sym,name) name
# else
#  define PASTE2(sym,name) sym##name
#  define PASTE(sym,name) PASTE2(sym,name)
# endif
/* Macro to do symbol concatenation. */
#define _PASTE2(sym,name) sym##name
/* A second level paste macro so macro substitution is done on
   \parameters.                                                */
#define _PASTE(sym,name) _PASTE2(sym,name)
/* Define the default call type of image routines. CPROC is
   __cdecl.                                                 */
#define IMAGE_API CPROC
#     ifdef IMAGE_LIBRARY_SOURCE
#        define IMAGE_PROC  EXPORT_METHOD
// this sometimes needs an extra 'extern'
//#           ifdef IMAGE_MAIN
//#        define IMAGE_PROC_D EXPORT_METHOD
//#           else
//#        define IMAGE_PROC_D extern EXPORT_METHOD
//#           endif
#     else
/* Define the linkage type of the routine... probably
   __declspec(dllimport) if not building the library. */
#        define IMAGE_PROC IMPORT_METHOD
// this sometimes needs an extra 'extern'
//#        define IMAGE_PROC_D  IMPORT_METHOD
#     endif
#if defined( _WIN32 ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER ) && !defined( _D3D10_DRIVER ) && !defined( _D3D11_DRIVER )
#define _INVERT_IMAGE
#endif
#ifdef __cplusplus
/* Define the namespace of image routines, when building under
   C++.                                                        */
#ifdef _D3D_DRIVER
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#elif defined( _D3D10_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d10 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d10 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#elif defined( _D3D11_DRIVER )
#  define IMAGE_NAMESPACE namespace sack { namespace image { namespace d3d11 {
#  define _IMAGE_NAMESPACE namespace image { namespace d3d11 {
#  define BASE_IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}}
#else
#  define BASE_IMAGE_NAMESPACE namespace image {
#  define IMAGE_NAMESPACE namespace sack { namespace image {
#  define _IMAGE_NAMESPACE namespace image {
/* Define the namespace of image routines, when building under
   C++. This ends a namespace.                                 */
#  define IMAGE_NAMESPACE_END }}
#endif
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE extern "C" {
/* Define the namespace of image routines, when building under
   C++. This ends the namespace. Assembly routines only have the
   ability to export C names, so extern"c" { } is used instead
   of namespace ___ { }.                                         */
#define ASM_IMAGE_NAMESPACE_END }
#else
#define BASE_IMAGE_NAMESPACE
#define IMAGE_NAMESPACE
#define _IMAGE_NAMESPACE
#define IMAGE_NAMESPACE_END
#define ASM_IMAGE_NAMESPACE
 /* Defined Image API.
   See Also
   <link sack::image::Image, Image>
   <link sack::image::SFTFont, SFTFont>
   <link Colors>
                                    */
#define ASM_IMAGE_NAMESPACE_END
#endif
SACK_NAMESPACE
/* Deals with images and image processing.
   Image is the primary type of this.
   SFTFont is a secondary type for putting text on images.
   render namespace is contained in image, because without
   image, there could be no render. see PRENDERER.         */
	_IMAGE_NAMESPACE
/* A fixed point decimal number (for freetype font rendering) */
typedef int64_t fixed;
//#ifndef IMAGE_STRUCTURE_DEFINED
//#define IMAGE_STRUCTURE_DEFINED
// consider minimal size - +/- 32000 should be enough for display purposes.
// print... well that's another matter.
   typedef int32_t IMAGE_COORDINATE;
   /* Represents the width and height of an image (unsigned values) */
   typedef uint32_t  IMAGE_SIZE_COORDINATE;
   /* An array of 2 IMAGE_COORDINATES - [0] = x, [1] = y */
   typedef IMAGE_COORDINATE IMAGE_POINT[2];
   /* An unsigned value coordinate pair to track the size of
      images.                                                */
   typedef IMAGE_SIZE_COORDINATE IMAGE_EXTENT[2];
   /* Pointer to an <link sack::image::IMAGE_POINT, IMAGE_POINT> */
   typedef IMAGE_COORDINATE *P_IMAGE_POINT;
   /* Pointer to a <link sack::image::IMAGE_EXTENT, IMAGE_EXTENT> */
   typedef IMAGE_SIZE_COORDINATE *P_IMAGE_EXTENT;
#ifdef HAVE_ANONYMOUS_STRUCTURES
typedef struct boundry_rectangle_tag
{
   union {
      IMAGE_POINT position;
      struct {
         IMAGE_COORDINATE x, y;
      };
   };
   union {
      IMAGE_EXTENT size;
      struct {
         IMAGE_SIZE_COORDINATE width, height;
      };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#else
/* Defines the coordinates of a rectangle. */
/* Pointer to an image rectangle.  */
typedef struct boundry_rectangle_tag
{
   /* anonymous union containing position information. */
   union {
      /* An anonymous structure containing x,y and width,height of a
         rectangle.                                                  */
      struct {
         /* the left coordinate of a rectangle. */
         /* the top coordinate of a rectangle */
         IMAGE_COORDINATE x, y;
         /* The Y span of the rectangle */
         /* the X Span of the rectangle */
         IMAGE_SIZE_COORDINATE width, height;
      };
      /* Anonymous structure containing position (x,y) and size
         (width,height).                                        */
      struct {
         /* The location of a rectangle (upper left x, y) */
         IMAGE_POINT position;
         /* the size of a rectangle (width and height) */
         IMAGE_EXTENT size;
      };
   };
} IMAGE_RECTANGLE, *P_IMAGE_RECTANGLE;
#endif
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_H(ImagePoint) ((ImagePoint)[0])
/* A macro for accessing vertical (Y) information of an <link sack::image::IMAGE_POINT, IMAGE_POINT>. */
#define IMAGE_POINT_V(ImagePoint) ((ImagePoint)[1])
// the image at exactly this position and size
// is the one being referenced, the actual size and position
// may vary depending on use (a sub-image outside the
// boundry of its parent).
#define ImageData union {                                 struct {                                               IMAGE_COORDINATE x, y;                              IMAGE_SIZE_COORDINATE width, height;             };                                                  struct {                                               IMAGE_POINT position;                               IMAGE_EXTENT size;                               };                                               }
/* One of the two primary types that the image library works
   with.
   Example
   <code lang="c++">
   void LoadImage( char *name )
   {
       Image image = LoadImageFile( name );
       if( image )
       {
          // the image file loaded successfully.
       }
   }
   </code>                                                   */
typedef struct ImageFile_tag *Image;
typedef struct SlicedImageFile *SlicedImage;
#if defined( IMAGE_STRUCTURE_DEFINED )
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
IMAGE_PROC  PCDATA IMAGE_API ImageAddress( Image image, int32_t x, int32_t y );
#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#endif
#endif
#if defined( __cplusplus )
IMAGE_NAMESPACE_END
#endif
#ifndef IMAGE_STRUCTURE_DEFINED
#ifdef _D3D_DRIVER
#include <d3d9.h>
#endif
#ifdef _D3D10_DRIVER
#include <D3D10_1.h>
#include <D3D10.h>
#endif
#ifdef _D3D11_DRIVER
#include <D3D11.h>
#endif
#ifdef _VULKAN_DRIVER
#  ifdef _WIN32
#    define VK_USE_PLATFORM_WIN32_KHR
#  endif
#  include <vulkan/vulkan.h>
#endif
// one day I'd like to make a multidimensional library
// but for now - 3D is sufficient - it can handle everything
// under 2D ignoring the Z axis... although it would be more
// efficient to do 2D implementation alone...
// but without function overloading the names of all the functions
// become much too complex.. well perhaps - maybe I can
// make all the required functions with a suffix - and
// supply defines to choose the default based on the dimension number
#ifndef ROTATE_DECLARATION
// vector multiple inclusion protection
#define ROTATE_DECLARATION
#if !defined(__STATIC__) && !defined(__LINUX__)
#  ifdef VECTOR_LIBRARY_SOURCE
#    define MATHLIB_EXPORT EXPORT_METHOD
#    if defined( __WATCOMC__ ) || defined( _MSC_VER )
// data requires an extra extern to generate the correct code *boggle*
#      define MATHLIB_DEXPORT extern EXPORT_METHOD
#    else
#      define MATHLIB_DEXPORT EXPORT_METHOD
#    endif
#  else
#    define MATHLIB_EXPORT IMPORT_METHOD
#    if ( defined( __WATCOMC__ ) || defined( _MSC_VER ) || defined( __GNUC__ ) ) && !defined( __ANDROID__ )
// data requires an extra extern to generate the correct code *boggle*
#      ifndef __cplusplus_cli
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      else
#        define MATHLIB_DEXPORT extern IMPORT_METHOD
#      endif
#    else
#      define MATHLIB_DEXPORT IMPORT_METHOD
#    endif
#  endif
#else
#ifndef VECTOR_LIBRARY_SOURCE
#define MATHLIB_EXPORT extern
#define MATHLIB_DEXPORT extern
#else
#define MATHLIB_EXPORT
#define MATHLIB_DEXPORT
#endif
#endif
#define DIMENSIONS 3
#if( DIMENSIONS > 0 )
   #define vRight   0
   #define _1D(exp)  exp
   #if( DIMENSIONS > 1 )
      #define vUp      1
      #define _2D(exp)  exp
      #if( DIMENSIONS > 2 )
         #define vForward 2
         #define _3D(exp)  exp
         #if( DIMENSIONS > 3 )
  // 4th dimension 'IN'/'OUT' since projection is scaled 3d...
            #define vIn      3
            #define _4D(exp)  exp
         #else
            #define _4D(exp)
         #endif
      #else
         #define _3D(exp)
         #define _4D(exp)
      #endif
   #else
      #define _2D(exp)
      #define _3D(exp)
      #define _4D(exp)
   #endif
#else
   // print out a compiler message can't perform zero-D transformations...
#endif
#if defined( _D3D_DRIVER ) || defined( _D3D10_DRIVER )
#  ifndef MAKE_RCOORD_SINGLE
#    define MAKE_RCOORD_SINGLE
#  endif
#endif
#ifdef __cplusplus
#  ifndef MAKE_RCOORD_SINGLE
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { namespace Double {
#    define _VECTOR_NAMESPACE namespace vector { namespace Double {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Double;
#  else
#    define VECTOR_NAMESPACE SACK_NAMESPACE namespace math { namespace vector { namespace Float {
#    define _MATH_VECTOR_NAMESPACE namespace math { namespace vector { Float {
#    define _VECTOR_NAMESPACE namespace vector { namespace Float {
#    define USE_VECTOR_NAMESPACE using namespace sack::math::vector::Float;
#  endif
#  define _MATH_NAMESPACE namespace math {
#  define VECTOR_NAMESPACE_END } } } SACK_NAMESPACE_END
#else
#  define VECTOR_NAMESPACE
#  define _MATH_VECTOR_NAMESPACE
#  define _MATH_NAMESPACE
#  define _VECTOR_NAMESPACE
#  define VECTOR_NAMESPACE_END
#  define USE_VECTOR_NAMESPACE
#endif
#ifdef MAKE_RCOORD_SINGLE
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##f args;
#  define EXTERNAL_NAME(n)  n##f
#else
#  define VECTOR_METHOD(r,n,args) MATHLIB_EXPORT r n##d args;
#  define EXTERNAL_NAME(n)  n##d
#endif
#ifndef VECTOR_TYPES_DEFINED
#define VECTOR_TYPES_DEFINED
// this file merely defines the basic calculation unit...
// more types are defined in VECTLIB.H which has the number
// of dimensions defined...
#include <math.h>
#include <float.h>
SACK_NAMESPACE
	_MATH_NAMESPACE
   _VECTOR_NAMESPACE
   // requires C++ to make RCOORD single - otherwise it is a double.
#ifndef MAKE_RCOORD_SINGLE
/* Define that an RCOORD is represented by the basic type
   'double' for platforms with smaller fast floating point
   types, this could be float.                             */
#define RCOORD_IS_DOUBLE 1
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef double RCOORD;
/* <combine sack::math::vector::double::RCOORD>
   \ \                                  */
	typedef double *PRCOORD;
#else
	/* basic type that Vectlib is based on.
	 This specifies a 'real' (aka float) coordinate.
	 Combinations of coordinates create vectors and points.  */
typedef float RCOORD;
/* <combine sack::math::vector::float::RCOORD>
   \ \                                  */
typedef float *PRCOORD;
#endif
// these SHOULD be dimension relative, but we lack much code for that...
typedef RCOORD MATRIX[4][4];
typedef MATRIX *PMatrix;
/* Describes the rotation matrix for a PTRANSFORM. */
typedef RCOORD PMATRIX[][4];
typedef RCOORD RQUATERNION[4];
typedef RCOORD PRQUATERNION[4];
#ifdef RCOORD_IS_DOUBLE
#define RCOORDBITS(v)  (*(uint64_t*)&(v))
#else
/* A macro to get the literal bits into an unsigned value of the
   same size. Shift and binary operators do not apply to
   floating point values, but floating point values are fields
   of bits that represent fractional parts of integers. This
   gets the bits so the fields can be tested.                    */
#define RCOORDBITS(v)  (*(uint32_t*)&(v))
#endif
/* a symbol which is effectively the largest negative value of
   the space, anything less than this is untrackable, and is the
   same as infinity.                                             */
#define NEG_INFINITY ((RCOORD)-9999999999.0)
/* a symbol which is effectively the largest value of the space,
   anything more than this is untrackable, and is the same as
   infinity.                                                     */
#define POS_INFINITY ((RCOORD)9999999999.0)
/* This is 'epsilon' that is used with by NearZero comparison
   macro.                                                     */
#define e1 (0.00001)
/* Checks to see if a coordinate is 0 or near 0. */
#define NearZero( n ) (fabs(n)<e1)
#ifndef __cplusplus
#endif
#ifdef RCOORD_IS_DOUBLE
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 16
#ifdef _MSC_VER
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000I64 ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000I64 ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000I64 ) >> (20+32)) - 1024)))
#else
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x4000000000000000LL ) ?                       (( RCOORDBITS(f) &  0x3FF0000000000000LL ) >> (20+32)) :                        ((( RCOORDBITS(f) & 0x3FF0000000000000LL ) >> (20+32)) - 1024)))
#endif
#else
// THRESHOLD may be any number more than 1.
// eveything 0 or more makes pretty much every number
// which is anything like another number equal...
// threshold is in count of bits...
// therefore for 1millionth digit accuracy that would be 20 bits.
// 10 bits is thousanths different are near
// 0 bits is if the same magnitude of number... but may be
//   quite different
// -10 bits is thousands different are near
// 1 == 1.5
// 1 == 1.01
#define THRESHOLD 10
/* Macro to extract the exponent part of a RCOORD.
                                                   */
#define EXPON(f) ((int)(( RCOORDBITS(f) & 0x40000000L ) ?                       (( RCOORDBITS(f) & 0x3F800000L ) >> 23) :                        ((( RCOORDBITS(f) & 0x3F800000L ) >> 23) - 128)))
#endif
#ifdef NEED_VECTLIB_COMPARE
//cpg26Dec2006 c:\work\sack\include\vectypes.h(75): Warning! W202: Symbol 'COMPARE' has been defined, but not referenced
static int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD tmp1, tmp2;
	int compare_result;
	tmp1=n1-n2;
	//lprintf( WIDE("exponents %ld %ld"), EXPON( n1 ), EXPON( n2 ) );
	 //lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n1),(n2),(tmp1)
	//		 ,!RCOORDBITS(n1)?"zero":"    ",!RCOORDBITS(n2)?"zero":"    "
	  //	 ,EXPON(n1)-THRESHOLD
	//	    ,EXPON(n2)-THRESHOLD
	//		 ,EXPON(tmp1) );
	tmp2=n2-n1;
	//lprintf("%9.9g-%9.9g=%9.9g %s %s %ld %ld %ld"
	//		 , (n2),(n1),(tmp2)
	//		 ,!RCOORDBITS(n2)?"zero":"    ",!RCOORDBITS(n1)?"zero":"    "
	//		 ,EXPON(n2)-THRESHOLD,EXPON(n1)-THRESHOLD,EXPON(tmp2));
	compare_result = ( ( !RCOORDBITS(n1) )?( (n2) <  0.0000001 &&
														 (n2) > -0.0000001 )?1:0
							:( !RCOORDBITS(n2) )?( (n1) <  0.0000001 &&
														 (n1) > -0.0000001 )?1:0
							:( (n1) == (n2) )?1
							:( ( EXPON(n1) - THRESHOLD ) >=
							  ( EXPON( tmp1 ) ) ) &&
							( ( EXPON(n2) - THRESHOLD ) >=
							 ( EXPON( tmp2) ) ) ? 1 : 0
						  );
	return compare_result;
}
/*
static RCOORD CompareTemp1, CompareTemp2;
#define COMPARE( n1, n2 ) ( RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1 )
*/
/*
                           ( ( ( RCOORDBITS(n1) & 0x80000000 ) !=                                      ( RCOORDBITS(n2) & 0x80000000 ) )                                       ? ( NearZero(n1)                                                           && ( ( RCOORDBITS(n1)&0x7FFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0x7FFFFFF0 ) ) )                               : ( ( RCOORDBITS(n1)&0xFFFFFFF0 ) ==                                        ( RCOORDBITS(n2)&0xFFFFFFF0 ) ) )
*/
#if 1
#else
inline int COMPARE( RCOORD n1, RCOORD n2 )
{
	RCOORD CompareTemp1, CompareTemp2;
   return  RCOORDBITS(n1)                                            ? ( CompareTemp1 = (n1)+(n1),                                 CompareTemp2 = (n1)+(n2),                   (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                     (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                         : RCOORDBITS(n2)                                              ? ( CompareTemp1 = (n2)+(n1),                                   CompareTemp2 = (n2)+(n2),                                  (RCOORDBITS(CompareTemp1)&0xFFFFFFF0)==                                   (RCOORDBITS(CompareTemp2)&0xFFFFFFF0) )                                                  : 1;
}
#endif
#endif
VECTOR_NAMESPACE_END
#endif
// $Log: vectypes.h,v $
// Revision 1.12  2005/01/27 08:21:39  panther
// Linux cleaned.
//
// Revision 1.11  2004/02/08 05:42:29  d3x0r
// associate comparetemp1, 2 with routine which needs it.
//
// Revision 1.10  2003/11/28 00:10:39  panther
// fix compare function...
//
// Revision 1.9  2003/11/23 08:42:41  panther
// Toying with the nearness floating point operator
//
// Revision 1.8  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.7  2003/08/29 10:26:17  panther
// Checkpoint - converted vectlib to be native double
//
// Revision 1.6  2003/08/29 02:07:41  panther
// Fixed logging, and nearness comparison
//
// Revision 1.5  2003/08/27 07:56:40  panther
// Replace COMPARE macro with one that works a little better
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
SACK_NAMESPACE
	_MATH_NAMESPACE
	/* Vector namespace contains methods for operating on vectors. Vectors
	   are multi-dimensional scalar quantities, often used to
	   represent coordinates and directions in space.                      */
   _VECTOR_NAMESPACE
//#include "../src/vectlib/vecstruc.h"
typedef RCOORD _POINT4[4];
typedef RCOORD _POINT[DIMENSIONS];
/* pointer to a point. */
typedef RCOORD *P_POINT;
/* pointer to a constant point. */
typedef const RCOORD *PC_POINT;
/* A vector type. Contains 3 values by default, library can
   handle 4 dimensional transformations(?)                  */
typedef _POINT VECTOR;
/* pointer to a vector. */
typedef P_POINT PVECTOR;
/* pointer to a constant vector. */
typedef PC_POINT PCVECTOR;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type *PRAY;
/* <combine sack::math::vector::RAY@1>
   \ \                                 */
typedef struct vectlib_ray_type RAY;
/* A ray is a type that has an origin and a direction. (It is a
   pair of vectors actually)                                    */
struct vectlib_ray_type {
 // origin
   _POINT o;
 // normal
   _POINT n;
};
/* <combinewith sack::math::vector::lineseg_tag>
   \ \                                           */
typedef struct lineseg_tag  LINESEG;
/* <combine sack::math::vector::lineseg_tag>
   \ \                                       */
typedef struct lineseg_tag *PLINESEG;
/* This is a pure abstraction of a Line. It is used in the basis
   of 3d graphics.                                               */
struct lineseg_tag {
   /* a ray type that is the origin and slope of the line. */
	RAY r;
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = end           */
	/* scalar along direction vector that indicates where the line
	   segment ends. (origin + (direction * dTo) ) = start         */
	RCOORD dFrom, dTo;
};
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag ORTHOAREA;
/* <combine sack::math::vector::orthoarea_tag>
   \ \                                         */
typedef struct orthoarea_tag *PORTHOAREA;
/* A representation of a rectangular 2 dimensional area. */
struct orthoarea_tag {
    /* x coorindate of a rectangular area. */
    /* y coordinate of a rectangular area. */
    RCOORD x, y;
    /* height (y + h = area end). height may be negative. */
    /* with (x + w = area end). with may be negative. */
    RCOORD w, h;
} ;
// relics from fixed point math dayz....
#define ZERO (0.0f)
/* Special symbol that is the unit quantity. */
#define ONE  (1.0f)
#ifndef M_PI
/* symbol to define a double precision value for PI if it
   doesn't exist in the compiler.                         */
#ifdef MAKE_RCOORD_SINGLE
#  define M_PI (3.1415926535f)
#else
#  define M_PI (3.1415926535)
#endif
#endif
/* a hard coded define that represents a 5 degree angle in
   radians.                                                */
#define _5  (RCOORD)((5.0/180.0)*M_PI )
/* a hard coded define that represents a 15 degree angle in
   radians.                                                 */
#define _15 (RCOORD)((15.0/180.0)*M_PI )
/* a hard coded define that represents a 30 degree angle in
   radians.                                                 */
#define _30 (RCOORD)((30.0/180.0)*M_PI )
/* a hard coded define that represents a 45 degree angle in
   radians.                                                 */
#define _45 (RCOORD)((45.0/180.0)*M_PI )
#define SetPoint( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2] )
#define SetPoint4( d, s ) ( (d)[0] = (s)[0], (d)[1]=(s)[1], (d)[2]=(s)[2], (d)[3]=(s)[3] )
/* Inverts a vector. that is vector * -1. (a,b,c) = (-a,-b,-c)
   <b>Parameters</b>
                                                               */
VECTOR_METHOD( P_POINT, Invert, ( P_POINT a ) );
/* Macro which can be used to make a vector's direction be
   exactly opposite of what it is now.                     */
#define InvertVector( a ) ( a[0] = -a[0], a[1]=-a[1], a[2]=-a[2] )
/* Logs the vector and leader to log. the leader is called
   lpName, cause it was inteded to be used by just the vector
   name.
   Parameters
   lpName :  text leader to print before the vector.
   v :       vector to log
   Example
   <code lang="c++">
   PrintVector( _X );
   // expands to
   PrintVectorEx( "_X", _X DBG_SRC );
   </code>                                                    */
VECTOR_METHOD( void, PrintVectorEx, ( CTEXTSTR lpName, PCVECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorEx@CTEXTSTR@PCVECTOR v>
   \ \                                                               */
#define PrintVector(v) PrintVectorEx( WIDE(#v), v DBG_SRC )
/* Same as PrintVectorEx, but prints to standard output using
   printf.                                                    */
VECTOR_METHOD( void, PrintVectorStdEx, ( CTEXTSTR lpName, VECTOR v DBG_PASS ) );
/* <combine sack::math::vector::PrintVectorStdEx@CTEXTSTR@VECTOR v>
   \ \                                                                */
#define PrintVectorStd(v) PrintVectorStd( WIDE(#v), v DBG_SRC )
/* Dumps to syslog a current matrix. Shows both matrix content,
   and the cross products between the matrix that cross1 should
   be row 0, cross2 should be row 1 and cross3 should be row2.
   Pass a text name to identify this matrix from others.
   Parameters
   lpName :    Name to write into the log.
   m :         the matrix to dump.
   DBG_PASS :  standard debug paramters
   Remarks
   A PTRANSFORM is not a MATRIX; there is a matrix in a
   transform, and is the first member, so a ptransform can be
   cast to a matrix and logged with this function.              */
VECTOR_METHOD( void, PrintMatrixEx, ( CTEXTSTR lpName, MATRIX m DBG_PASS ) );
/* <combine sack::math::vector::PrintMatrixEx@CTEXTSTR@MATRIX m>
   \ \                                                             */
#define PrintMatrix(m) PrintMatrixEx( WIDE(#m), m DBG_SRC )
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag *PTRANSFORM;
/* <combine sack::math::vector::TransformationMatrix>
   \ \                                                */
typedef struct transform_tag	 TRANSFORM;
/* Pointer to a constant transform. */
typedef const TRANSFORM *PCTRANSFORM;
/* Constant pointer to a constant transform. For things like _I
   transformation which is the identity translation.            */
typedef const PCTRANSFORM *CPCTRANSFORM;
#define VectorConst_0 EXTERNAL_NAME(VectorConst_0)
#define VectorConst_X EXTERNAL_NAME(VectorConst_X)
#define VectorConst_Y EXTERNAL_NAME(VectorConst_Y)
#define VectorConst_Z EXTERNAL_NAME(VectorConst_Z)
#define VectorConst_I EXTERNAL_NAME(VectorConst_I)
//------ Constants for origin(0,0,0), and axii
#ifndef VECTOR_LIBRARY_SOURCE
MATHLIB_DEXPORT const PC_POINT VectorConst_0;
/* Specifies the coordinate system's X axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT const PC_POINT VectorConst_X;
/* Specifies the coordinate system's Y axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT const PC_POINT VectorConst_Y;
/* Specifies the coordinate system's Z axis direction. static
   constant.                                                  */
MATHLIB_DEXPORT const PC_POINT VectorConst_Z;
/* This is a static constant identity matrix, which can be used
   to initialize a matrix transform (internally).               */
MATHLIB_DEXPORT const PCTRANSFORM VectorConst_I;
#define _0 ((PC_POINT)VectorConst_0)
#  ifndef _X
#    define _X ((PC_POINT)VectorConst_X)
#  else
#  endif
#define _Y ((PC_POINT)VectorConst_Y)
#define _Z ((PC_POINT)VectorConst_Z)
#define _I ((PC_POINT)VectorConst_I)
#endif
/* compares two vectors to see if they are near each other. Boundary
   \conditions exist around 0, when the values are on opposite
   sides, but it's pretty good.                                      */
#define Near( a, b ) ( COMPARE(a[0],b[0]) && COMPARE( a[1], b[1] ) && COMPARE( a[2], b[2] ) )
/* Add two vectors together. (a1,b1,c1) + (a2,b2,c2) =
   (a1+a2,b1+b2,c1+c2)
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, add, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* subtracts two vectors and stores the result in another
   vector.
   Remarks
   The result vector may be the same as one of the source
   vectors.                                               */
VECTOR_METHOD( P_POINT, sub, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* Scales a vector by a scalar
   Parameters
   pr :   \result vector
   pv1 :  vector to scale
   k :    constant scalar to apply to vector
   Example
   <code lang="c#">
   VECTOR result;
   VECTOR start;
   SetPoint( start, _X );
   scale( result, start, 3 );
   </code>                                   */
VECTOR_METHOD( P_POINT, scale, ( P_POINT pr, PC_POINT pv1, RCOORD k ) );
/* Adds a vector scaled by a scalar to another vector, results
   in a third vector.
   Parameters
   pr :   pointer to a result vector
   pv1 :  pointer to vector 1
   pv2 :  pointer to vector 2
   k :    scalar quantity to apply to vector 2 when adding to
          vector 1.
   Remarks
   The pointer to the result vector may be the same vector as
   vector 1 or vector 2.
   Example
   <code lang="c++">
   _POINT result;
   P_POINT v1 = _X;
   P_POINT v2 = _Y;
   RCOORD k = 1.414;
   addscaled( result, v1, v2, k );
   // result is ( 1, 1.414, 0 )
   </code>                                                     */
VECTOR_METHOD( P_POINT, addscaled, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2, RCOORD k ) );
/* Normalizes a non-zero vector. That is the resulting length of
   the vector is 1.0. Modifies the vector in place.              */
VECTOR_METHOD( void, normalize, ( P_POINT pv ) );
VECTOR_METHOD( void, crossproduct, ( P_POINT pr, PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the sin of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                     */
VECTOR_METHOD( RCOORD, SinAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
/* \Returns the cos (cosine) of the angle between two vectors.
   Parameters
   pv1 :  one vector
   pv2 :  another vector
   Remarks
   If the length of either vector is 0, then a divide by zero
   exception will happen.                                      */
VECTOR_METHOD( RCOORD, CosAngle, ( PC_POINT pv1, PC_POINT pv2 ) );
VECTOR_METHOD( RCOORD, dotproduct, ( PC_POINT pv1, PC_POINT pv2 ) );
// result is the projection of project onto onto
VECTOR_METHOD( P_POINT, project, ( P_POINT pr, PC_POINT onto, PC_POINT project ) );
/* \Returns the scalar length of a vector. */
VECTOR_METHOD( RCOORD, Length, ( PC_POINT pv ) );
/* \Returns the distance between two points.
   Parameters
   v1 :  some point
   v2 :  another point
   Returns
   The distance between the two points.      */
VECTOR_METHOD( RCOORD, Distance, ( PC_POINT v1, PC_POINT v2 ) );
/* \Returns the distance a point is as projected on another
   vector. The result is the distance along that vector from the
   origin.
   Parameters
   pvOn :  Vector to project on
   pvOf :  vector to get projection length of.                   */
VECTOR_METHOD( RCOORD, DirectedDistance, ( PC_POINT pvOn, PC_POINT pvOf ) );
/* copies the value of a ray into another ray
   Parameters
   ray to set :   target value
   ray to copy :  value to copy.
   Example
   <code>
   RAY ray;
   RAY ray2;
   // set ray to ray2
   SetRay( ray, ray2 );
   </code>                                    */
#define SetRay( pr1, pr2 ) { SetPoint( (pr1)->o, (pr2)->o ),                               SetPoint( (pr1)->n, (pr2)->n ); }
		/* Allocates and initializes a new transform for the user.
		 if name is NULL, allocates an unnamed transform; otherwise
       the transform is created in a known namespace that can be browsed.
		 */
VECTOR_METHOD( PTRANSFORM, CreateNamedTransform, ( CTEXTSTR name ) );
#define CreateTransform() CreateNamedTransform( NULL )
VECTOR_METHOD( PTRANSFORM, CreateTransformMotion, ( PTRANSFORM pt ) );
VECTOR_METHOD( PTRANSFORM, CreateTransformMotionEx, ( PTRANSFORM pt, int rocket ) );
VECTOR_METHOD( void, DestroyTransform     , ( PTRANSFORM pt ) );
/* Resets a transform back to initial conitions. */
VECTOR_METHOD( void, ClearTransform       , ( PTRANSFORM pt ) );
/* Badly named function.
   InvertTransform turns a transform sideways, that is takes
   axis-normal transforms and turns them for sending to other
   graphic systems.
   <code lang="c++">
     \+-         -+
     | 0   1   2 |
     | 3   4   5 |
     | 6   7   8 |
     \+-         -+
   becomes
     \+-         -+
     | 0   3   6 |
     | 1   4   7 |
     | 2   5   8 |
     \+-         -+
   Not entirely useful at all :)
   </code>                                                    */
VECTOR_METHOD( void, InvertTransform        , ( PTRANSFORM pt ) );
VECTOR_METHOD( void, Scale                 , ( PTRANSFORM pt, RCOORD sx, RCOORD sy, RCOORD sz ) );
VECTOR_METHOD( void, Translate             , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateV            , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, TranslateRel          , ( PTRANSFORM pt, RCOORD tx, RCOORD ty, RCOORD tz ) );
VECTOR_METHOD( void, TranslateRelV         , ( PTRANSFORM pt, PC_POINT t ) );
VECTOR_METHOD( void, RotateAbs, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
VECTOR_METHOD( void, RotateAbsV, ( PTRANSFORM pt, PC_POINT ) );
/* Updates the current rotation matrix of a transform by a
   relative amount. Amounts to rotate about the x, y and z axii
   are given in radians.
   Parameters
   pt :  transform to rotate
   rx :  amount around the x axis to rotate (pitch)(positive is
         clockwise looking at the object from the right, axis up is
         moved towards forward )
   ry :  amount around the y axis to rotate (yaw) (positive is
         counter clockwise, moves right to forward)
   rz :  amount around the z axis to rotate (roll) (positive is
         clockwise, moves up towards right )
   See Also
   RotateRelV                                                       */
VECTOR_METHOD( void, RotateRel, ( PTRANSFORM pt, RCOORD rx, RCOORD ry, RCOORD rz ) );
/* Update a transformation matrix by relative degress about the
   x axix, y axis and z axis.
   Parameters
   pt :  transform to update
   v :   vector containing x,y and z relative roll coordinate.  */
VECTOR_METHOD( void, RotateRelV, ( PTRANSFORM pt, PC_POINT ) );
/* Rotates a transform around some arbitrary axis. (any line may
   be used to rotate the transformation's rotation matrix)
   Parameters
   pt :      transform to update
   p :       P defines an axis around which the rotation portion
             of the matrix is rotated by an amount. Can be any
             arbitrary axis.
   amount :  an amount to rotate by.
   Note
   coded from
   http://www.mines.edu/~gmurray/ArbitraryAxisRotation/ArbitraryAxisRotation.html
   and
   http://www.siggraph.org/education/materials/HyperGraph/modeling/mod_tran/3drota.htm
   and http://astronomy.swin.edu.au/~pbourke/geometry/rotate/.
                                                                                       */
VECTOR_METHOD( void, RotateAround, ( PTRANSFORM pt, PC_POINT p, RCOORD amount ) );
/* Sets the current 'up' axis of a transformation. The forward
   axis is adjusted so that it remains perpendicular to the mast
   axis vs the right axis. After the forward axis is updated,
   the right axis is adjusted to be perpendicular to up and
   forward.
   Parameters
   pt :   transform to set the up direction of
   vup :  new direction for 'up'
   Remarks
   RotateMast is based on the idea that your current frame is
   something like a boat. As the boat moves along a surface,
   it's version of 'up' may change depending on the landscape. This
   keeps up up. (Actually, the computation was used for an
   object running along the interior of a sphere, and this
   normalizes their 'up' to the center of the sphere.               */
VECTOR_METHOD( void, RotateMast, ( PTRANSFORM pt, PCVECTOR vup ) );
/* Rotates around the 'up' of the current rotation matrix. Same
   as a yaw rotation.
   Parameters
   pt :     transformation to rotate
   angle :  angle to rotate \- positive should be clockwise,
            looking from top down.                              */
VECTOR_METHOD( void, RotateAroundMast, ( PTRANSFORM pt, RCOORD angle ) );
/* Recovers a transformation state from a file.
   Parameters
   pt :        transform to read into
   filename :  filename with the transform in it. */
VECTOR_METHOD( void, LoadTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
/* Provides a way to save a matrix ( direct binary file dump)
   Parameters
   pt :        transform matrix to save
   filename :  \file to save the transformation in.           */
VECTOR_METHOD( void, SaveTransform, ( PTRANSFORM pt, CTEXTSTR filename ) );
VECTOR_METHOD( void, RotateTo, ( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright ) );
VECTOR_METHOD( void, RotateRight, ( PTRANSFORM pt, int A1, int A2 ) );
VECTOR_METHOD( void, Apply           , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyR          , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyT          , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// I know this was a result - unsure how it was implented...
//void ApplyT              (PTRANFORM pt, PTRANSFORM pt1, PTRANSFORM pt2 );
VECTOR_METHOD( void, ApplyInverse    , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseR   , ( PCTRANSFORM pt, PRAY dest, PRAY src ) );
VECTOR_METHOD( void, ApplyInverseT   , ( PCTRANSFORM pt, PTRANSFORM dest, PCTRANSFORM src ) );
// again note there was a void ApplyInverseT
VECTOR_METHOD( void, ApplyRotation        , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyRotationT       , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseRotation , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseRotationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyTranslation     , ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyTranslationT    , ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
VECTOR_METHOD( void, ApplyInverseTranslation, ( PCTRANSFORM pt, P_POINT dest, PC_POINT src ) );
VECTOR_METHOD( void, ApplyInverseTranslationT, ( PCTRANSFORM pt, PTRANSFORM ptd, PCTRANSFORM pts ) );
// after Move() these callbacks are invoked.
typedef void (*MotionCallback)( uintptr_t, PTRANSFORM );
/* When Move is called on the transform, these callbacks are
   invoked so user code can get even update for motion.
   Parameters
   pt :        PTRANSFORM transform matrix to hook to
   callback :  user callback routine
   psv :       pointer size value data to be passed to user
               callback routine.                             */
VECTOR_METHOD( void, AddTransformCallback, ( PTRANSFORM pt, MotionCallback callback, uintptr_t psv ) );
/* Set the speed vector used when Move is applied to a
   PTRANSFORM.
   Parameters
   pt :  transform to set the current speed of.
   s :   the speed vector to set.                      */
VECTOR_METHOD( PC_POINT, SetSpeed, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetSpeed, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the acceleration applied to the speed when Move is
   called.                                                 */
VECTOR_METHOD( PC_POINT, SetAccel, ( PTRANSFORM pt, PC_POINT s ) );
VECTOR_METHOD( P_POINT, GetAccel, ( PTRANSFORM pt, P_POINT s ) );
/* Sets the forward direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Forward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveForward, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveRight, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( void, MoveUp, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the up direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Up, ( PTRANSFORM pt, RCOORD distance ) );
/* Sets the right direction speed in a PTRANSFORM.
   Parameters
   pt :        Transform to set the right speed of.
   distance :  How far it should go in the next time interval. */
VECTOR_METHOD( void, Right, ( PTRANSFORM pt, RCOORD distance ) );
VECTOR_METHOD( PC_POINT, SetRotation, ( PTRANSFORM pt, PC_POINT r ) );
VECTOR_METHOD( P_POINT, GetRotation, ( PTRANSFORM pt, P_POINT r ) );
VECTOR_METHOD( PC_POINT, SetRotationAccel, ( PTRANSFORM pt, PC_POINT r ) );
/* Set how long it takes, in milliseconds, to move 1 unit of
   speed vector or rotate 1 unit of rotation vector when Move is
   called. Each matrix maintains a last tick. If many thousands
   of matrixes were used, probably a batch move could be
   implemented that would maintain tick counts for a group of
   matrixes... don't know how long it takes to compute move, but
   timeGetTime will slow it down a lot.
   Parameters
   pt :                 transform to set the time interval on.
   speed_interval :     what the time interval should be for
                        speed.
   rotation_interval :  what the time interval should be for
                        rotation.
   Remarks
   A default interval of 1000 is used. So it will take 1000
   milliseconds to move one unit of speed. This could be set to
   3600000 and then it would take one hour to move one unit of
   speed. (miles per hour)
   Rotation has its own interval that affects rotation the same
   way; If your rotation was set to roll 2*pi radians, then it
   would revolve one full rotation in the said time.
                                                                 */
VECTOR_METHOD( void, SetTimeInterval, ( PTRANSFORM pt, RCOORD speed_interval, RCOORD rotation_interval ) );
/* Updates a transform by it's current speed and rotation
   assuming speed and rotation are specified in x per 1 second.
   Applies the fraction of time between now and the prior time
   move was called and scales speed and rotation by that when
   applying it.
   Parameters
   pt :  Pointer to a transform to update.
   See Also
   <link sack::math::vector::SetTimeInterval@PTRANSFORM@RCOORD@RCOORD, SetTimeInterval> */
VECTOR_METHOD( LOGICAL, Move, ( PTRANSFORM pt ) );
#if 0
	VECTOR_METHOD( void, Unmove, ( PTRANSFORM pt ) );
#endif
VECTOR_METHOD( void, showstdEx, ( PTRANSFORM pt, char *header ) );
VECTOR_METHOD( void, ShowTransformEx, ( PTRANSFORM pt, char *header DBG_PASS ) );
/* <combine sack::math::vector::ShowTransformEx@PTRANSFORM@char *header>
   \ \                                                                   */
#define ShowTransform( n ) ShowTransformEx( n, #n DBG_SRC )
VECTOR_METHOD( void, showstd, ( PTRANSFORM pt, char *header ) );
VECTOR_METHOD( void, GetOriginV, ( PTRANSFORM pt, P_POINT o ) );
VECTOR_METHOD( PC_POINT, GetOrigin, ( PTRANSFORM pt ) );
VECTOR_METHOD( void, GetAxisV, ( PTRANSFORM pt, P_POINT a, int n ) );
VECTOR_METHOD( PC_POINT, GetAxis, ( PTRANSFORM pt, int n ) );
VECTOR_METHOD( void, SetAxis, ( PTRANSFORM pt, RCOORD a, RCOORD b, RCOORD c, int n ) );
VECTOR_METHOD( void, SetAxisV, ( PTRANSFORM pt, PC_POINT a, int n ) );
// matrix is suitable to set as the first matrix for opengl rendering.
// it is an inverse application that uses the transform's origin as camera origin
// and the rotation matrix as what to look at.
VECTOR_METHOD( void, GetGLCameraMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, GetGLMatrix, ( PTRANSFORM pt, PMATRIX out ) );
VECTOR_METHOD( void, SetGLMatrix, ( PMATRIX in, PTRANSFORM pt ) );
VECTOR_METHOD( void, SetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
VECTOR_METHOD( void, GetRotationMatrix, ( PTRANSFORM pt, RCOORD *quat ) );
  // line m, b
VECTOR_METHOD( RCOORD, IntersectLineWithPlane, (PCVECTOR Slope, PCVECTOR Origin,
  // plane n, o
	PCVECTOR n, PCVECTOR o,
	RCOORD *time) );
VECTOR_METHOD( RCOORD, PointToPlaneT, (PCVECTOR n, PCVECTOR o, PCVECTOR p) );
#if !defined( VECTOR_LIBRARY_SOURCE ) && !defined( NO_AUTO_VECTLIB_NAMES )
#define add EXTERNAL_NAME(add)
#define sub EXTERNAL_NAME(sub)
#define scale EXTERNAL_NAME(scale)
#define Scale EXTERNAL_NAME(Scale)
#define Invert EXTERNAL_NAME(Invert)
#define GetOrigin EXTERNAL_NAME(GetOrigin)
#define GetOriginV EXTERNAL_NAME(GetOriginV)
#define GetAxis EXTERNAL_NAME(GetAxis)
#define GetAxisV EXTERNAL_NAME(GetAxisV)
#define GetGLCameraMatrix EXTERNAL_NAME(GetGLCameraMatrix)
#define ApplyInverse EXTERNAL_NAME(ApplyInverse)
#define Move EXTERNAL_NAME(Move)
#define MoveForward EXTERNAL_NAME(MoveForward)
#define MoveRight EXTERNAL_NAME(MoveRight)
#define MoveUp EXTERNAL_NAME(MoveUp)
#define Forward EXTERNAL_NAME(Forward)
#define Right EXTERNAL_NAME(Right)
#define Up EXTERNAL_NAME(Up)
#define PrintVectorEx EXTERNAL_NAME(PrintVectorEx)
#define PrintMatrixEx EXTERNAL_NAME(PrintMatrixEx)
#define ShowTransformEx EXTERNAL_NAME(ShowTransformEx)
#define addscaled EXTERNAL_NAME(addscaled)
#define Length EXTERNAL_NAME(Length)
#define PointToPlaneT EXTERNAL_NAME(PointToPlaneT)
#define normalize EXTERNAL_NAME(normalize)
#define Translate EXTERNAL_NAME(Translate)
#define TranslateV EXTERNAL_NAME(TranslateV)
#define Apply EXTERNAL_NAME(Apply)
#define ApplyR EXTERNAL_NAME(ApplyR)
#define ApplyT EXTERNAL_NAME(ApplyT)
#define ApplyTranslation EXTERNAL_NAME(ApplyTranslation)
#define ApplyTranslationR EXTERNAL_NAME(ApplyTranslationR)
#define ApplyTranslationT EXTERNAL_NAME(ApplyTranslationT)
#define ApplyInverseRotation EXTERNAL_NAME(ApplyInverseRotation)
#define ApplyInverseR EXTERNAL_NAME(ApplyInverseR)
#define ApplyRotation EXTERNAL_NAME(ApplyRotation)
#define ApplyRotationT EXTERNAL_NAME(ApplyRotationT)
#define RotateAround EXTERNAL_NAME(RotateAround)
#define RotateRel EXTERNAL_NAME(RotateRel)
#define SetRotation EXTERNAL_NAME(SetRotation)
#define GetRotation EXTERNAL_NAME(GetRotation)
#define SetRotationAccel EXTERNAL_NAME(SetRotationAccel)
#define RotateRight EXTERNAL_NAME(RotateRight)
#define dotproduct EXTERNAL_NAME(dotproduct)
#define DestroyTransform EXTERNAL_NAME(DestroyTransform)
#define SinAngle EXTERNAL_NAME(SinAngle)
#define CosAngle EXTERNAL_NAME(CosAngle)
#define crossproduct EXTERNAL_NAME(crossproduct)
#define CreateTransformMotion EXTERNAL_NAME(CreateTransformMotion)
#define CreateTransformMotionEx EXTERNAL_NAME(CreateTransformMotionEx)
#define CreateNamedTransform EXTERNAL_NAME(CreateNamedTransform)
#define ClearTransform EXTERNAL_NAME(ClearTransform)
#define RotateTo EXTERNAL_NAME(RotateTo)
#define SetSpeed EXTERNAL_NAME(SetSpeed)
#define SetAccel EXTERNAL_NAME(SetAccel)
#define TranslateRel EXTERNAL_NAME( TranslateRel )
#define TranslateRelV EXTERNAL_NAME( TranslateRelV )
#define RotateAbs EXTERNAL_NAME(RotateAbs)
#define RotateAbsV EXTERNAL_NAME(RotateAbsV)
#define GetRotationMatrix EXTERNAL_NAME(GetRotationMatrix)
#define SetRotationMatrix EXTERNAL_NAME(SetRotationMatrix)
#endif
#ifdef __cplusplus
#if 0
#include "../src/vectlib/vectstruc.h"
class TransformationMatrix {
private:
#ifndef TRANSFORM_STRUCTURE
	//char data[32*4 + 4];
//   // requires [4][4] for use with opengl
//   MATRIX m;       // s*rcos[0][0]*rcos[0][1] sin sin   (0)
//                   // sin s*rcos[1][0]*rcos[1][1] sin   (0)
//                   // sin sin s*rcos[2][0]*rcos[2][0]   (0)
//                   // tx  ty  tz                        (1)
//
//   RCOORD s[3];
//        // [x][0] [x][1] = partials... [x][2] = multiplied value.
//
//   RCOORD speed[3]; // speed right, up, forward
//   RCOORD rotation[3]; // pitch, yaw, roll delta
//   int nTime; // rotation stepping for consistant rotation
	struct transform_tag data;
#else
	struct transform_tag data;
#endif
public:
	TransformationMatrix() {
  //	 clear();
	}
 // no result.
	~TransformationMatrix() {}
	inline void Translate( PC_POINT o )
   {	TranslateV( &data, o );	}
	inline void TranslateRel( PC_POINT o )
	{	TranslateRelV( &data, o );	}
	inline void Translate( RCOORD x, RCOORD y, RCOORD z )
	{	TranslateV( &data, &x );	}
	inline void _RotateTo( PC_POINT forward, PC_POINT right )
	//extern void RotateTo( PTRANSFORM pt, PCVECTOR vforward, PCVECTOR vright );
	{
		RotateTo( &data, forward, right );
	}
	inline void RotateRel( RCOORD up, RCOORD right, RCOORD forward )
	{
		RotateRelV( &data, &up );
	}
	inline void RotateRel( PC_POINT p )
	{
		RotateRelV( &data, p );
	}
#if 0
	inline void Apply( P_POINT dest, PC_POINT src )
	//void Apply( PTRANSFORM pt, P_POINT dest, PC_POINT src );
	{
		Apply( &data, dest, src );
	}
	inline void ApplyRotation( P_POINT dest, PC_POINT src )
	//void ApplyRotation( PTRANSFORM pt, P_POINT dest, PC_POINT src );
	{
		ApplyRotation( &data, dest, src );
	}
	inline void Apply( PRAY dest, PRAY src )
	//void ApplyR( PTRANSFORM pt, PRAY dest, PRAY src );
	{
		ApplyR( &data, dest, src );
	}
	inline void ApplyInverse( P_POINT dest, PC_POINT src )
 // void ApplyInverse( PTRANSFORM pt, P_POINT dest, PC_POINT src );
	{
		ApplyInverse( &data, dest, src );
	}
	inline void ApplyInverse( PRAY dest, PRAY src )
	{	void ApplyInverseR( PTRANSFORM pt, PRAY dest, PRAY src );
		ApplyInverseR( &data, dest, src );
	}
	inline void ApplyInverseRotation( P_POINT dest, PC_POINT src )
	{	void ApplyInverseRotation( PTRANSFORM pt, P_POINT dest, PC_POINT src );
		ApplyInverseRotation( &data, dest, src );
	}
	inline void SetSpeed( RCOORD x, RCOORD y, RCOORD z )
	{	sack::math::vector::SetSpeed( &data, &x );
	}
	inline void SetSpeed( PC_POINT p )
	{	sack::math::vector::SetSpeed( &data, p );
	}
	inline void SetRotation( PC_POINT p )
	{	sack::math::vector::SetRotation( &data, p );
	}
	inline LOGICAL Move( void )
	{
		void Move( PTRANSFORM pt );
		return sack::math::vector::Move( &data );
	}
	inline void Unmove( void )
	{
		void Unmove( PTRANSFORM pt );
		sack::math::vector::Unmove( &data );
	}
	inline void clear( void )
	{
		sack::math::vector::ClearTransform( &data );
	}
	inline void RotateAbs( RCOORD x, RCOORD y, RCOORD z )
	{
		sack::math::vector::RotateAbsV( (PTRANSFORM)&data, &x );
	}
#endif
	inline void _GetAxis( P_POINT result, int n )
	{
		GetAxisV( (PTRANSFORM)&data, result, n );
	}
	inline PC_POINT _GetAxis( int n )
	{
		return GetAxis( (PTRANSFORM)&data, n);
	}
	PC_POINT _GetOrigin( void )
	{	return GetOrigin( (PTRANSFORM)&data );
	}
	void _GetOrigin( P_POINT p )
	{	GetOriginV( &data, p );
	}
	void show( char *header )
	{
		ShowTransformEx( &data, header DBG_SRC );
	}
	void _RotateRight( int a, int b )
	{
		RotateRight( (PTRANSFORM)&data, a, b );
	}
};
#endif
#endif
VECTOR_NAMESPACE_END
USE_VECTOR_NAMESPACE
#endif
// $Log: vectlib.h,v $
// Revision 1.13  2004/08/22 09:56:41  d3x0r
// checkpoint...
//
// Revision 1.12  2004/02/02 22:43:35  d3x0r
// Add lineseg type and orthoarea (min/max box)
//
// Revision 1.11  2004/01/11 23:24:15  panther
// Fix type warnings, conflicts, fix const issues
//
// Revision 1.10  2004/01/11 23:11:49  panther
// Fix const typings
//
// Revision 1.9  2004/01/11 23:10:38  panther
// Include keyboard to avoid windows errors
//
// Revision 1.8  2004/01/04 20:54:18  panther
// Use PCTRANSFORM for prototypes
//
// Revision 1.7  2003/12/29 08:10:18  panther
// Added more functions for applying transforms
//
// Revision 1.6  2003/11/22 23:27:11  panther
// Fix type passed to printvector
//
// Revision 1.5  2003/09/01 20:04:37  panther
// Added OpenGL Interface to windows video lib, Modified RCOORD comparison
//
// Revision 1.4  2003/03/25 08:38:11  panther
// Add logging
//
#if defined( _WIN32 ) && !defined( _INVERT_IMAGE ) && !defined( _OPENGL_DRIVER ) && !defined( _D3D_DRIVER )
#define _INVERT_IMAGE
#endif
#define WILL_DEFINE_IMAGE_STRUCTURE
#define IMAGE_STRUCTURE_DEFINED
IMAGE_NAMESPACE
#ifdef __cplusplus
	namespace Interface
{
	struct image_interface_tag;
}
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
#ifndef PSPRITE_METHOD
#define PSPRITE_METHOD PSPRITE_METHOD
/* pointer to a structure defining a sprite draw method this should be defined in render namespace...*/
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	/* Flags which may be combined in <link sack::image::ImageFile_tag::flags, Image.flags> */
	enum ImageFlags {
 // this has been freed - but contains sub images
IF_FLAG_FREE   =0x00001,
 // moved beyond parent image's bound
IF_FLAG_HIDDEN =0x00002,
 // built with a *image from external sources
IF_FLAG_EXTERN_COLORS =0x00004,
 // pay attention to (clips) array.
IF_FLAG_HAS_CLIPS     =0x00008,
// with no _X_STRING flag - characters are shown as literal character glyph.
 // strings on this use 'c' processing
IF_FLAG_C_STRING       = 0x00010,
 // strings on this use menu processing ( &underline )
IF_FLAG_MENU_STRING    = 0x00020,
 // strings use control chars (newline, tab)
IF_FLAG_CONTROL_STRING = 0x00040,
 // this has been freed - but contains sub images
IF_FLAG_OWN_DATA       = 0x00080,
  // image is inverted (standard under windows, but this allows images to be configured dynamically - a hack to match SDL lameness )
IF_FLAG_INVERTED       = 0x00100,
// DisplayLib uses this flag - indicates panel root
 // please #define user flag to this
IF_FLAG_USER1          = 0x10000,
// DisplayLib uses this flag - indicates is part of a displayed panel
IF_FLAG_USER2          = 0x20000,
IF_FLAG_USER3          = 0x40000,
 // output should render to opengl target (with transform); also used with proxy
IF_FLAG_FINAL_RENDER   = 0x00200,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_UPDATED        = 0x00400,
 // set when a operation has changed the surface of a local image; requires update to remote device(s)
IF_FLAG_HAS_PUTSTRING  = 0x00800,
 // is an in-memory image; that is the surface can be written to directly with pixel ops (putstring)
IF_FLAG_IN_MEMORY      = 0x01000,
	};
//#define _DRAWPOINT_X 0
//#define _DRAWPOINT_Y 1
struct ImageFile_tag
{
#if defined( IMAGE_LIBRARY_SOURCE ) || defined( NEED_REAL_IMAGE_STRUCTURE )
	int real_x;
	int real_y;
   // desired height and width may not be actual cause of
	int real_width;
  // resizing of parent image....
	int real_height;
# ifdef HAVE_ANONYMOUS_STRUCTURES
	IMAGE_RECTANGLE;
# else
 // need this for sub images - otherwise is irrelavent
	int x;
	int y;
  /// Width of image.
	int width;
 /// Height of image.
	int height;
# endif
#else
	/* X coordinate of the image within another image. */
	int x;
	/* Y coordinate of an image within another image. */
	int y;
   // desired height and width may not be actual cause of
	int width;
  // resizing of parent image....
	int height;
 // need this for sub images - otherwise is irrelavent
	int actual_x;
	int actual_y;
  // Width of image.
	int actual_width;
 // Height of image.
	int actual_height;
#endif
 // width of real physical layer
	int pwidth;
	// The image data.
	PCOLOR image;
	/* a combination of <link ImageFlags, IF_FLAG_> (ImageFile Flag)
	   which apply to this image.                                    */
	int flags;
	/* This points to a peer image that existed before this one. If
	   NULL, there is no elder, otherwise, contains the next peer
	   image in the same parent image.                              */
	/* Points to the parent image of a sub-image. (The parent image
	   contains this image)                                         */
	/* Pointer to the youngest child sub-image. If there are no sub
	   images pChild will be NULL. Otherwise, pchild points at the
	   first of one or more sub images. Other sub images in this one
	   are found by following the pElder link of the pChild.         */
	/* This points at a more recently created sub-image. (another
	   sub image within the same parent, but younger)             */
	struct ImageFile_tag *pParent, *pChild, *pElder, *pYounger;
	   // effective x - clipped by reality real coordinate.
	           // (often eff_x = -real_x )
	int eff_x;
	/* this is used internally for knowing what the effective y of
	   the image is. If the sub-image spans a boundry of a parent
	   image, then the effective Y that will be worked with is only
	   a part of the subimage.                                      */
	int eff_y;
		// effective max - maximum coordinate...
	int eff_maxx;
		// effective maximum Y
	int eff_maxy;
		/* An extra rectangle that can be used to carry additional
		 information like update region.                         */
	IMAGE_RECTANGLE auxrect;
	// fonts need a way to output the font character subimages to the real image...
	// or for 3D; to reverse scale appropriately
	struct image_interface_tag  *reverse_interface;
 // what the interface thinks this is...
	POINTER reverse_interface_instance;
	void (*extra_close)( struct ImageFile_tag *);
//DOM-IGNORE-BEGIN
#if defined( __3D__ )
	PTRANSFORM transform;
#endif
#ifdef _OPENGL_DRIVER
	/* gl context? */
	LOGICAL depthTest;
	PLIST glSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int glActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
#endif
#ifdef _D3D10_DRIVER
	PLIST Surfaces;
	ID3D10Texture2D *pActiveSurface;
#endif
#ifdef _D3D11_DRIVER
	PLIST Surfaces;
	ID3D11Texture2D *pActiveSurface;
#endif
#ifdef _D3D_DRIVER
	/* gl context? */
	PLIST Surfaces;
	IDirect3DBaseTexture9 *pActiveSurface;
#endif
#ifdef _VULKAN_DRIVER
	LOGICAL depthTest;
	PLIST vkSurface;
 // most things will still use this, since reload image is called first, reload will set active
	int vkActiveSurface;
  // updated with SetTransformRelation, otherwise defaults to image size.
	VECTOR coords[4];
#endif
#ifdef __cplusplus
 // watcom limits protections in structs to protected and public
#ifndef __WATCOMC__
private:
#endif
#endif
//DOM-IGNORE-END
};
enum SlicedImageSection {
	SLICED_IMAGE_TOP_LEFT,
	SLICED_IMAGE_TOP,
	SLICED_IMAGE_TOP_RIGHT,
	SLICED_IMAGE_LEFT,
	SLICED_IMAGE_CENTER,
	SLICED_IMAGE_RIGHT,
	SLICED_IMAGE_BOTTOM_LEFT,
	SLICED_IMAGE_BOTTOM,
	SLICED_IMAGE_BOTTOM_RIGHT,
};
struct SlicedImageFile {
	struct ImageFile_tag *image;
	struct ImageFile_tag *slices[9];
	uint32_t left, right, top, bottom;
	uint32_t center_w, center_h;
	uint32_t right_w;
	uint32_t bottom_h;
	LOGICAL output_center;
	LOGICAL extended_slice;
};
/* The basic structure. This is referenced by applications as '<link sack::image::Image, Image>'
	This is the primary type that the image library works with.
	This is the internal definition.
	This is a actual data content, Image is (ImageFile *).                                        */
typedef struct ImageFile_tag ImageFile;
/* A simple wrapper to add dynamic changing position and
	orientation to an image. Sprites can be output at any angle. */
struct sprite_tag
{
	/* Current location of the sprite's origin. */
	/* Current location of the sprite's origin. */
  // current x and current y for placement on image.
	int32_t curx, cury;
  // int of bitmap hotspot... centers cur on hot
	int32_t hotx, hoty;
	Image image;
	// curx,y are kept for moving the sprite independantly
	fixed scalex, scaley;
	// radians from 0 -> 2*pi.  there is no negative...
 // radians for now... (used internally, set by blot rotated sprite)
	float angle;
	// should consider keeping the angle of rotation
	// and also should cosider keeping velocity/acceleration
	// but then limits would have to be kept also... so perhaps
	// the game module should keep such silly factors... but then couldn't
	// it also keep curx, cury ?  though hotx hoty is the actual
	// origin to rotate this image about, and to draw ON curx 0 cury 0
	// int orgx, orgy;  // rotated origin of bitmap.
	// after being drawn the min(x,y) and max(x,y) are set.
 // after draw, these are the extent of the sprite.
	int32_t minx, maxx;
 // after draw, these are the extent of the sprite.
	int32_t miny, maxy;
	PSPRITE_METHOD pSpriteMethod;
};
/* A Sprite type. Adds position and rotation and motion factors
	to an image. Hooks into the render system to get an update to
	draw on a temporary layer after the base rendering is done.   */
typedef struct sprite_tag SPRITE;
#ifdef _INVERT_IMAGE
// inversion does not account for eff_y - only eff_maxy
// eff maxy - eff_minY???
/*+((i)->eff_y)*/
#define INVERTY(i,y)     ( (((i)->eff_maxy) - (y)))
#else
/* This is a macro is used when image data is inverted on a
	platform. (Windows images, the first row of data is the
	bottom of the image, all Image operations are specified from
	the top-left as 0,0)                                         */
#define INVERTY(i,y)     ((y) - (i)->eff_y)
#endif
/*+((i)->eff_y)*/
#define INVERTY_INVERTED(i,y)     ( (((i)->eff_maxy) - (y)))
#define INVERTY_NON_INVERTED(i,y)     ((y) - (i)->eff_y)
#if defined(__cplusplus_cli ) && !defined( IMAGE_SOURCE )
//IMAGE_PROC( PCDATA, ImageAddress )( Image image, int32_t x, int32_t y );
//#define IMG_ADDRESS(i,x,y) ImageAddress( i,x,y )
#else
#define IMG_ADDRESS(i,x,y)    ((CDATA*)	                             ((i)->image + (( (x) - (i)->eff_x )	 +(((i)->flags&IF_FLAG_INVERTED)?(INVERTY_INVERTED( (i), (y) ) * (i)->pwidth ):(INVERTY_NON_INVERTED( (i), (y) ) * (i)->pwidth ))	                             ))										   )
#endif
#if 0
#if defined( __arm__ ) && defined( IMAGE_LIBRARY_SOURCE ) && !defined( DISPLAY_SOURCE )
extern unsigned char AlphaTable[256][256];
static CDATA DOALPHA( CDATA over, CDATA in, uint8_t a )
{
	int r, g, b, aout;
	if( !a )
		return over;
	if( a > 255 )
		a = 255;
	if( a == 255 )
 // force alpha full on.
		return (in | 0xFF000000);
	aout = AlphaTable[a][AlphaVal( over )] << 24;
	r = ((((RedVal(in))  *(a+1)) + ((RedVal(over))  *(256-(a)))) >> 8 );
	if( r > (255) ) r = (255);
	g = (((GreenVal(in))*(a+1)) + ((GreenVal(over))*(256-(a)))) >> 8;
	if( g > (255) ) g = (255);
	b = ((((BlueVal(in)) *(a+1)) + ((BlueVal(over)) *(256-(a)))) >> 8 );
	if( b > 255 ) b = 255;
	return aout|(r<<16)|(g<<8)|b;
	//return AColor( r, g, b, aout );
}
#endif
#endif
IMAGE_NAMESPACE_END
// end if_not_included
#endif
// $Log: imagestruct.h,v $
// Revision 1.2  2005/04/05 11:56:04  panther
// Adding sprite support - might have added an extra draw callback...
//
// Revision 1.1  2004/06/21 07:38:39  d3x0r
// Move structures into common...
//
// Revision 1.20  2003/10/14 20:48:55  panther
// Tweak mmx a bit - no improvement visible but shorter
//
// Revision 1.19  2003/10/14 16:36:45  panther
// Oops doalpha was outside of known inclusion frame
//
// Revision 1.18  2003/10/14 00:43:03  panther
// Arm optimizations.  Looks like I'm about maxed.
//
// Revision 1.17  2003/09/15 17:06:37  panther
// Fixed to image, display, controls, support user defined clipping , nearly clearing correct portions of frame when clearing hotspots...
//
// Revision 1.16  2003/04/25 08:33:09  panther
// Okay move the -1's back out of IMG_ADDRESS
//
// Revision 1.15  2003/04/21 23:33:09  panther
// fix certain image ops - should check blot direct...
//
// Revision 1.14  2003/03/30 18:39:03  panther
// Update image blotters to use IMG_ADDRESS
//
// Revision 1.13  2003/03/30 16:11:03  panther
// Clipping images works now... blat image untested
//
// Revision 1.12  2003/03/30 06:24:56  panther
// Turns out I had badly implemented clipping...
//
// Revision 1.11  2003/03/25 08:45:51  panther
// Added CVS logging tag
//
#if defined( __cplusplus )
IMAGE_NAMESPACE
#endif
/* pointer to a sprite type. */
typedef struct sprite_tag *PSPRITE;
//#endif
// at some point, it may be VERY useful
// to have this structure also have a public member.
//
#ifndef NO_FONT
typedef struct simple_font_tag {
 // all characters same height
   uint16_t height;
 // number of characters in the set
   uint16_t characters;
 // open ended array size characters...
   uint8_t char_width[1];
} FontData;
/* Contains information about a font for drawing and rendering
   from a font file.                                           */
typedef struct font_tag *SFTFont;
#endif
/* A definition of a block structure to transport font and image
   data across message queues.                                   */
/* Type of buffer used to transfer data across message queues. */
typedef struct data_transfer_state_tag {
   /* size of this block of data. */
   uint32_t size;
   /* offset of the data in the total message. Have to break up
      large buffers into smaller chunks for transfer.           */
   uint32_t offset;
   /* buffer containing the data to transfer. */
   CDATA buffer;
} *DataState;
//-----------------------------------------------------
enum string_behavior {
   // every character assumed to have a glyph-including '\0'
   STRING_PRINT_RAW
 // control characters perform 'typical' actions - newline, tab, backspace...
   ,STRING_PRINT_CONTROL
  // c style escape characters are handled \n \b \x## - literal text
   ,STRING_PRINT_C
   ,STRING_PRINT_MENU
 /* &amp; performs an underline, also does C style handling. \\&amp;
                         == &amp;                                                         */
};
/* Definitions of symbols to pass to <link SetBlotMethod> to
   specify optimization method.                              */
enum blot_methods {
    /* A Symbol to pass to <link SetBlotMethod> to specify using C
      coded primitives. (for shading and alpha blending).         */
    BLOT_C
   , BLOT_ASM
/* A Symbol to pass to <link SetBlotMethod> to specify using
      primitives with assembly optimization (for shading and alpha
      blending).                                                   */
						,
                  /* A Symbol to pass to <link SetBlotMethod> to specify using
      primitives with MMX optimization (for shading and alpha
      blending).                                                */
    BLOT_MMX
};
// specify the method that pixels are copied from one image to another
enum BlotOperation {
   /* copy the pixels from one image to another with no color transform*/
 BLOT_COPY = 0,
   // copy the pixels from one image to another with no color transform, scaling by a single color
 BLOT_SHADED = 1,
   // copy the pixels from one image to another with no color transform, scaling independant R, G and B color channels to a combination of an R Color, B Color, G Color
 BLOT_MULTISHADE = 2,
   /* copy the pixels from one image to another with simple color inversion transform*/
 BLOT_INVERTED = 3,
 /* orientation blots for fonts to 3D and external displays */
 BLOT_ORIENT_NORMAL = 0x00,
 BLOT_ORIENT_INVERT = 0x04,
 BLOT_ORIENT_VERTICAL = 0x08,
 BLOT_ORIENT_VERTICAL_INVERT = 0x0C,
 BLOT_ORIENTATTION = 0x0C,
};
/* Transparency parameter definition
   0 : no transparency - completely opaque
   1 (TRUE): 0 colors (absolute transparency) only
   2-255 : 0 color transparent, plus transparency factor applied
   to all 2 - mostly almost completely transparent 255 not
   transparent (opaque)
   257-511 : alpha transparency in pixel plus transparency value
   \- 256 0 pixels will be transparent 257 - slightly more
   opaquen than the original 511 - image totally opaque - alpha
   will be totally overriden no addition 511 nearly completely
   transparent 512-767 ; the low byte of this is subtracted from
   the alpha of the image ; this allows images to be more
   transparent than they were originally 512 - no modification
   alpha imge normal 600 - mid range... more transparent 767 -
   totally transparent any value of transparent greater than the
   max will be clipped to max this will make very high values
   opaque totally...                                             */
enum AlphaModifier {
   /* Direct alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will increase the base opacity by that much */
	ALPHA_TRANSPARENT = 0x100,
   // Inverse alpha copy - whatever the alpha is is what the output will be.  Adding a value of 0-255 here will decrease the base opacity by that much
ALPHA_TRANSPARENT_INVERT = 0x200,
   // more than this clips to total transparency
	// for line, plot more than 255 will
// be total opaque... this max only
	// applies to blotted images
ALPHA_TRANSPARENT_MAX = 0x2FF
};
/* library global changes. string behavior cannot be tracked per
   image. string behavior should, for all strings, be the same
   usage for an application... so behavior is associated with
   the particular stream and/or image family. does not modify
   character handling behavior - only strings.
   See Also
   <link sack::image::string_behavior, String Behaviors>         */
   IMAGE_PROC  void IMAGE_API  SetStringBehavior( Image pImage, uint32_t behavior );
   /* Specify the optimized code to draw with. There are 3 levels,
      C - routines coded in C, ASM - assembly optimization (32bit
      NASM), MMX assembly but taking advantage of MMX features.    */
   IMAGE_PROC  void IMAGE_API  SetBlotMethod    ( uint32_t method );
   /* This routine can be used to generically scale to any point
      between two colors.
      Parameters
      Color 1 :   CDATA color to scale from
      Color 2 :   CDATA color to scale to
      distance :  How from from 0 to max distance to scale.
      max :       How wide the scalar is.
      Remarks
      Max is the scale that distance can go from. Distance 0 is the
      first color, Distance == max is the second color. The
      distance from 0 to max proportionately scaled the color....
      Example
      <code lang="c++">
      CDATA green = BASE_COLOR_GREEN;
      CDATA blue = BASE_COLOR_BLUE;
      CDATA red = BASE_COLOR_RED;
      </code>
      Compute a color that is halfway from blue to green. (if the
      total distance is 100, then 50 is half way).
      <code lang="c++">
      CDATA blue_green = ColorAverage( blue, green, 50, 100 );
      </code>
      Compute a color that's mostly red.
      <code lang="c++">
      CDATA red_blue_green = ColorAverage( blue_green, red, 240, 255 );
      </code>
      Iterate through a whole scaled range...
      <code lang="c++">
      int n;
      for( n = 0; n \< 100; n++ )
      {
          CDATA scaled = ColorAverage( BASE_COLOR_WHITE, BASE_COLOR_BLACK, n, 100 );
          // as n increases, the color slowly goes from WHITE to BLACK.
      }
      </code>                                                                        */
   IMAGE_PROC  CDATA ColorAverage( CDATA c1, CDATA c2, int d, int max );
   /* Creates an image from user defined parts. The buffer used is
      from the user. This was used by the video library, but
      RemakeImage accomplishes this also.
      Parameters
      pc :      the color buffer to use for the image.
      width :   how wide the color buffer is
      height :  How tall the color buffer is                       */
   IMAGE_PROC  Image IMAGE_API BuildImageFileEx ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* <combine sack::image::MakeImageFile>
      Adds <link sack::DBG_PASS, DBG_PASS> parameter. */
   /* Creates an Image with a specified width and height. The
      image's color is undefined to start.
      Parameters
      Width :     how wide to make the image. Cannot be negative.
      Height :    how tall to make the image. Cannot be negative.
      DBG_PASS :  _nt_
      Example
      See <link sack::image::Image, Image>                        */
   IMAGE_PROC  Image IMAGE_API MakeImageFileEx  (uint32_t Width, uint32_t Height DBG_PASS);
   /* Creates a sub image region on an image. Sub-images may be
      used like any other image. There are two uses for this sort
      of thing. OH, the sub image shares the exact data of the
      parent image, and is not a copy.
      Parameters
      pImage :  image to make the sub image in
      x :       signed location of the top side of the sub\-image
      y :       signed location of the left side of the sub\-image
      width :   how wide to make the sub\-image
      height :  how tall to make the sub\-image
      Returns
      NULL if the input image is NULL.
      Otherwise returns an Image.
      Example
      Use 1: An image might contain a grid of symbols or
      characters, each exactly the same size. These may be token
      peices used in a game or a special graphic font.
      <code lang="c++">
      Image peices_image = LoadImageFile( "Game Peices.image" );
      PLIST peices = NULL;
      int x, y;
      \#define PEICE_WIDTH 32
      \#define PEICE_HEIGHT 32
      for( x = 0; x \< 10; x++ )
         for( y = 0; y \< 2; y++ )
         {
             AddLink( &amp;peices, MakeSubImage( peices_image
                                           , x * PEICE_WIDTH, y * PEICE_HEIGHT
                                           , PEICE_WIDTH, PEICE_HEIGHT );
         }
      // at this point there we have a list with all the tokens,
      // which were 32x32 pixels each.
      // Any of these peice images may be output using a scaled or direct blot.
      </code>
      Use 2: Partitioning views on an image for things like
      controls and other clipped regions.
      <code lang="c++">
      Image image = MakeImageFile( 1024, 768 );
      Image clock = MakeSubImage( image, 32, 32, 150, 16 );
      DrawString( clock, 0, 0, BASE_COLOR_WHITE, BASE_COLOR_BLACK, "Current Time..." );
      </code>                                                                           */
   IMAGE_PROC  Image IMAGE_API MakeSubImageEx   ( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
   /* Adds an image as a sub-image of another image. The image
      being added as a sub image must not already have a parent.
      Sub-images are like views into the parent, and share the same
      pixel buffer that the parent has.
      Parameters
      pFoster :  This is the parent image to received the new
                 subimage
      pOrphan :  this is the subimage to be added                   */
   IMAGE_PROC  void IMAGE_API  AdoptSubImage    ( Image pFoster, Image pOrphan );
   /* Removes a sub-image (child image) from a parent image. The
      sub image my then be moved to another image with
      AdoptSubImage.
      Parameters
      pImage :  the sub\-image to orphan.                        */
   IMAGE_PROC  void IMAGE_API  OrphanSubImage   ( Image pImage );
   /* Create or recreate an image using the specified color buffer,
      and size. All sub-images have their color data reference
      updated.
      Example
      <code>
      Image image = NULL;
      POINTER data = NewArray( CDATA, 100* 100 );
      image = RemakeImage( image, data, 100, 100 );
      </code>
      Remarks
      If the source image is NULL, a new image will be built using
      the color buffer and size specified.
      Image.flags has IF_FLAG_EXTERN_COLORS set if made this way,
      since the color buffer is an external resource. This causes
      UnmakeImage() to not attempt to free the color buffer.
      If the original image does exist, its color buffer is swapped
      for the one specified, and coordinates are updated. The video
      system uses this to create an image that has the color data
      surface the surface of the display.
      See Also
      <link sack::image::BuildImageFile, BuildImageFile>
      GetDisplayImage
      Parameters
      data :    Pointer to a buffer of 32 bit color data. ARGB and
                ABGR available via compile option.
      width :   the width of the data in pixels.
      height :  the height of the data in pixels.
      Returns
      \Returns the original image if not NULL, otherwise results
      with an image who's color plane is defined by a user defined
      buffer of width by height size. The user must have allocated
      this buffer appropriately, and is responsible for its
      destruction.                                                  */
   IMAGE_PROC  Image IMAGE_API RemakeImageEx    ( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
   /* Load an image file. Today we support PNG, JPG, GIF, BMP.
      Tomorrow consider tapping into that FreeImage project on
      sourceforge, that combines all readers into one.
      Parameters
      name :      Filename to read from. Opens in 'Current Directory'
                  if not an absolute path.
      DBG_PASS :  _nt_
      Example
      See <link sack::image::Image, Image>                            */
	IMAGE_PROC  Image IMAGE_API LoadImageFileEx  ( CTEXTSTR name DBG_PASS );
	/* <combinewith sack::image::LoadImageFileEx@CTEXTSTR name>
	   Extended load image file. This allows specifying a file group
	   to load from. (Groups were added for platforms without
	   support of current working directory).
	   Parameters
	   group :  Group to load the file from
	   _nt_ :   _nt_                                                 */
	IMAGE_PROC Image  IMAGE_API LoadImageFileFromGroupEx ( INDEX group, CTEXTSTR filename DBG_PASS );
   /* Decodes a block of memory into an image. This is used
      internally so, LoadImageFile() opens the file and reads it
      into a buffer, which it then passes to DecodeMemoryToImage().
      Images stored in custom user structures may be passed for
      decoding also.
      Parameters
      buf :   Pointer to bytes of data to decode
      size :  the size of the buffer to decode
      Returns
      NULL is returned if the data does not decode as an image.
      an Image is returned otherwise.
      Example
      This pretends that you have a FILE* open to some image
      already, and that the image is tiny (less than 4k bytes).
      <code lang="c#">
      char buffer[4096];
      int length;
      length = fread( buffer, 1, 4096, some_file );
      Image image = DecodeMemoryToImage( buffer, length );
      if( image )
      {
         // buffer decoded okay.
      }
      </code>                                                       */
			IMAGE_PROC  Image IMAGE_API  DecodeMemoryToImage ( uint8_t* buf, size_t size );
#ifdef __cplusplus
		namespace loader{
#endif
	IMAGE_PROC  LOGICAL IMAGE_API  PngImageFile ( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC  LOGICAL IMAGE_API  JpgImageFile ( Image image, uint8_t* *buf, size_t *size, int Q );
#ifdef __cplusplus
		}
#endif
      /* direct hack for processing clipboard data... probably does some massaging of the databefore calling DecodeMemoryToImage */
   IMAGE_PROC  Image IMAGE_API  ImageRawBMPFile (uint8_t* ptr, uint32_t filesize);
	/* Releases an image, has extra debug parameters.
	   Parameters
	   Image :     the Image to release.
	   DBG_PASS :  Adds <link sack::DBG_PASS, DBG_PASS> parameter for
	               the release memory tracking.                       */
	IMAGE_PROC  void IMAGE_API UnmakeImageFileEx ( Image pif DBG_PASS );
   /* Sets the active image rectangle to the bounding rectangle
      specified. This can be used to limit artificially drawing
      onto an image. (It is easier to track to create a subimage in
      the location to draw instead of masking with a bound rect,
      which has problems restoring back to initial conditions)
      Parameters
      pImage :  Image to set the drawing clipping rectangle.
      bound :   a pointer to an IMAGE_RECTANGLE to set the image
                boundaries to.                                      */
   IMAGE_PROC  void  IMAGE_API SetImageBound    ( Image pImage, P_IMAGE_RECTANGLE bound );
// reset clip rectangle to the full image (subimage part )
// Some operations (move, resize) will also reset the bound rect,
// this must be re-set afterwards.
// ALSO - one SHOULD be nice and reset the rectangle when done,
// otherwise other people may not have checked this.
/* Change the size of an image, reallocating the color buffer as
   necessary.
   <b>Parameters</b>
   <b>Remarks</b>
   If the image is a sub image (located within a parent), the
   subimage view on the parent image is updated to the new width
   and height. The color buffer remains the parent's buffer.
   If the image is a parent, a new buffer is allocated. If the
   previous buffer was specified by the user in RemakeImage,
   that buffer is not freed, but a new buffer is still created.
   <b>Bugs</b>
   If the image is a parent image, the child images are not
   updated to the newly allocated buffer. Resize works really
   well for subimages though.                                    */
   IMAGE_PROC  void IMAGE_API ResizeImageEx     ( Image pImage, int32_t width, int32_t height DBG_PASS);
   /* Moves an image within a parent image. Top level images and
      images which have a user color buffer do not move.
      Parameters
      pImage :  The image to move.
      x :       the new X coordinate of the image.
      y :       the new Y coordinate of the image.               */
   IMAGE_PROC  void IMAGE_API MoveImage         ( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
   IMAGE_PROC  void IMAGE_API BlatColor         ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* Blat is the sound a trumpet makes when it spews forth
      noise... so Blat color is just fill a rectangle with a color,
      quickly. Apply alpha transparency of the color specified.
      Parameters
      pifDest :  The destination image to fill the rectangle on
      x :        left coordinate of the rectangle
      y :        right coordinate of the rectangle
      w :        width of the rectangle
      h :        height of the rectangle
      color :    color to fill the rectangle with. The alpha of this
                 color will be applied.                              */
   IMAGE_PROC  void IMAGE_API BlatColorAlpha    ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
   /* \ \
      Parameters
      pDest :         destination image (the one to copy to)
      pIF :           source image
      x :             destination top coordinate
      y :             destination left coordinate
      nTransparent :  <link sack::image::AlphaModifier, Alpha Operation>
      method :        <link sack::image::blot_methods, Blot Method>
      _nt_ :          _nt_                                               */
   IMAGE_PROC  void IMAGE_API BlotImageEx       ( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
   /* Copies an image from one image onto another. The copy is done
      directly and no scaling is applied. If a width or height
      larget than the image to copy is specified, only the amount
      of the image that is valid is copied.
      Parameters
      pDest :         Destination image
      pIF :           Image file to copy
      x :             X position to put copy at
      y :             Y position to put copy at
      xs :            X position to copy from.
      ys :            Y position to copy from.
      wd :            how much of the image horizontally to copy
      ht :            how much of the image vertically to copy
      nTransparent :  <link sack::image::AlphaModifier, Alpha Transparency method>
      method :        <link sack::image::blot_methods, BlotMethods>
      <b>Method == BLOT_SHADED extra parameters</b>
      red :    Color to use the red channel to output the scale from
               black to color
      green :  Color to use the red channel to output the scale from
               black to color
      blue :   Color to use the red channel to output the scale from
               black to color
      <b>Method == BLOT_SHADED extra parameters</b>
      shade :  _nt_
      See Also                                                                     */
   IMAGE_PROC  void IMAGE_API BlotImageSizedEx  ( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
   /* Copies some or all of an image to a destination image of
      specified width and height. This does linear interpolation
      scaling.
      There are simple forms of this function as macros, since
      commonly you want to output the entire image, a macro which
      automatically sets (0,0),(width,height) as the source
      \parameters to output the whole image exists.
      Parameters
      \ \
      pifDest :       Destination image
      pifSrc :        image to copy from
      xd :            destination x coordinate
      yd :            destination y coordinate
      wd :            destination width (source image width will be
                      scaled to this)
      hd :            destination height (source image height will
                      be scaled to this)
      xs :            source x coordinate (where to copy from)
      ys :            source y coordinate (where to copy from)
      ws :            source width (how much of the image to copy)
      hs :            source height (how much of the image to copy)
      nTransparent :  Alpha method...
      method :        specifies how the source color data is
                      transformed if at all. See BlotMethods
      ... :           possible extra parameters depending on method
      <b>Method == BLOT_MULTISHADE extra parameters</b>
      red :    Color to use the red channel to output the scale from
               black to color
      green :  Color to use the red channel to output the scale from
               black to color
      blue :   Color to use the red channel to output the scale from
               black to color
      <b>Method == BLOT_SHADED extra parameters</b>
      shade :  _nt_
      See Also
      <link sack::image::AlphaModifier, Alpha Methods>
      <link sack::image::blot_methods, Blot Methods>
      <link sack::image::BlotScaledImage, BlotScaledImage>
      <link sack::image::BlotScaledImageShaded, BlotScaledImageShaded>
      <link sack::image::BlotScaledImageShadedAlpha, BlotScaledImageShadedAlpha>
                                                                                 */
   IMAGE_PROC  void IMAGE_API BlotScaledImageSizedEx( Image pifDest, Image pifSrc
                                   , int32_t xd, int32_t yd
                                   , uint32_t wd, uint32_t hd
                                   , int32_t xs, int32_t ys
                                   , uint32_t ws, uint32_t hs
                                   , uint32_t nTransparent
                                   , uint32_t method, ... );
/* Your basic PLOT functions (Image.C, plotasm.asm)
   A function pointer to the function which sets a pixel in an
   image at a specified x, y coordinate.
   Parameters
   Image :  The image to get the pixel from
   X :      x coordinate to get pixel color
   Y :      y coordinate to get pixel color
   Color :  color to put at the coordinate. image will be set
            exactly to this color, and whatever the alpha of the
            color is.                                            */
   IMAGE_PROC  void plot       ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which sets a pixel in an
      image at a specified x, y coordinate.
      Parameters
      Image :  The image to get the pixel from
      X :      x coordinate to get pixel color
      Y :      y coordinate to get pixel color
      Color :  color to put at the coordinate. Alpha blending will be
               done.                                                  */
   IMAGE_PROC  void plotalpha  ( Image pi, int32_t x, int32_t y, CDATA c );
   /* A function pointer to the function which gets a pixel from an
      image at a specified x, y coordinate.
      Parameters
      Image :  The image to get the pixel from
      X :      x coordinate to get pixel color
      Y :      y coordinate to get pixel color
      Returns
      CDATA color in the Image at the specified coordinate.         */
   IMAGE_PROC  CDATA getpixel  ( Image pi, int32_t x, int32_t y );
//-------------------------------
// Line functions  (lineasm.asm) // should include a line.c ... for now core was assembly...
//-------------------------------
  // d is color data...
   IMAGE_PROC  void do_line      ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
  // d is color data...
   IMAGE_PROC  void do_lineAlpha ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
   /* This is a function pointer that references a function to do
      optimized horizontal lines. The function pointer is updated
      when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      Y :       the y coordinate of the line (how far down from top to
                draw it)
      x_from :  X coordinate to draw from
      x_to :    X coordinate to draw to
      color :   the color of the line. This color will be set to the
                surface, the alpha result will be the alpha of this
                color.                                                 */
   IMAGE_PROC  void do_hline      ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized vertical lines. The function pointer is updated
      when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      X :       the x coordinate of the line (how far over to draw
                it)
      y_from :  Y coordinate to draw from
      y_to :    Y coordinate to draw to
      color :   the color of the line. This color will be set to the
                surface, the alpha result will be the alpha of this
                color.                                               */
   IMAGE_PROC  void do_vline      ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized horizontal lines with alpha blending. The function
      pointer is updated when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      Y :       the Y coordinate of the line (how far down from top
                of image to draw it)
      x_from :  X coordinate to draw from
      x_to :    X coordinate to draw to
      color :   the color of the line (alpha component of the color
                will be applied)                                    */
   IMAGE_PROC  void do_hlineAlpha ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
   /* This is a function pointer that references a function to do
      optimized vertical lines with alpha blending. The function
      pointer is updated when SetBlotMethod() is called.
      Parameters
      Image :   the image to draw to
      X :       the x coordinate of the line (how far over to draw
                it)
      y_from :  Y coordinate to draw from
      y_to :    Y coordinate to draw to
      color :   the color of the line (alpha component of the color
                will be applied)                                    */
   IMAGE_PROC  void do_vlineAlpha ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
	/* routine which iterates through the points along a lone from
	   x,y to xto,yto, calling a user function at each point.
	   Parameters
	   Image :  the image to pretend to draw on
	   x :      draw from this x coordinate
	   y :      draw from this y coordinate
	   xto :    draw to this x coordinate
	   yto :    draw to this y coordinate
	   d :      userdata (color data)
	   func :   user callback function to a function of type...<p />void
	            func( Image pif, int32_t x, int32_t y, int d ) ;
	   Remarks
	   The Image passed does not HAVE to be an Image, it can be any
	   user POINTER.
	   The data passed is limited to 32 bits, and will not hold a
	   pointer if built for 64 bit platform.
	   Example
	   <code lang="c++">
	   Image image;
	   void MyPlotter( Image image, int32_t x, int32_t y, CDATA color )
	   {
	       // do something with the image at x,y
	   }
	   void UseMyPlotter( Image image )
	   {
	       do_lineExV( image, 10, 10, 80, 80, BASE_COLOR_BLACK, MyPlotter );
	   }
	   </code>                                                               */
	IMAGE_PROC  void do_lineExV    ( Image pImage, int32_t x, int32_t y
									, int32_t xto, int32_t yto, uintptr_t color
		                            , void (*func)( Image pif, int32_t x, int32_t y, uintptr_t d ) );
   /* \Returns the correct SFTFont pointer to the default font. In all
      font functions, NULL may be used as the font, and this is the
      font that will be used.
      Parameters
      None.
      Example
      <code lang="c++">
      SFTFont font = GetDefaultFont();
      </code>                                                       */
   IMAGE_PROC  SFTFont IMAGE_API GetDefaultFont ( void );
   /* \Returns the height of a font for purposes of spacing between
      lines. Characters may render outside of this height.
      Parameters
      SFTFont :  SFTFont to get the height of. if NULL returns an internal
              font's height.
      Returns
      the height of the font.                                        */
   IMAGE_PROC  uint32_t  IMAGE_API GetFontHeight  ( SFTFont );
   /* \Returns the approximate rectangle that would be used for a
      string. It only counts using the line measurement. Newlines
      in strings count to wrap text to subsequent lines and start
      recounting the width, returning the maximum length of string
      horizontally.
      Parameters
      pString :  The string to measure
      len :      the length of characters to count in string
      width :    a pointer to a uint32_t to receive the width of the
                 string
      height :   a pointer to a uint32_t to receive the height of the
                 string
      UseFont :  A SFTFont to use.
      Returns
      \Returns the width parameter. If NULL are passed for width
      and height, this is OK. One of the simple macros just passes
      the string and gets the return - this is for how wide the
      string would be.                                             */
   IMAGE_PROC  uint32_t  IMAGE_API GetStringSizeFontEx( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
   /* Fill the width and height with the actual size of the string
      as it is drawn. (may be above or below the original
      rectangle)
      Parameters
      pString :     the string to measure
      nLen :        the number of characters in the string
      width :       a pointer to a 32 bit value to get resulting
                    width
      height :      a pointer to a 32 bit value to get resulting
                    height
      charheight :  the actual height of the characters (as reports
                    by line)
      UseFont :     a SFTFont to use. If NULL use a default internal
                    font.                                           */
   IMAGE_PROC  uint32_t IMAGE_API  GetStringRenderSizeFontEx ( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
// background of color 0,0,0 is transparent - alpha component does not
// matter....
   IMAGE_PROC  void IMAGE_API PutCharacterFont              ( Image pImage
                                                  , int32_t x, int32_t y
                                                  , CDATA color, CDATA background,
                                                   TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point.
      the point becomes the bottom left of the rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      c :           the character to output
      font :        the font to use. NULL use an internal default
                    font.                                          */
   IMAGE_PROC  void IMAGE_API PutCharacterVerticalFont      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point to the left, with the
      characters aligned with the top to the left; it goes up from
      the point. the point becomes the bottom left of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                           */
   IMAGE_PROC  void IMAGE_API PutCharacterInvertFont        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a character in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point. the
      point becomes the bottom left of the rectangle output.
      Parameters
                                                                       */
   IMAGE_PROC  void IMAGE_API PutCharacterVerticalInvertFont( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn right side up and godes from left to
      right. The point becomes the top left of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                         */
   IMAGE_PROC  void IMAGE_API PutStringFontEx              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* justification 0 is left, 1 is right, 2 is center */
   IMAGE_PROC  void IMAGE_API PutStringFontExx              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font, int justication, uint32_t _width );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point down, with the characters
      aligned with the top to the right; it goes down from the
      point. the point becomes the top right of the rectangle
      \output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                           */
   IMAGE_PROC  void IMAGE_API PutStringVerticalFontEx      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn upside down, and goes to the left from
      the point. the point becomes the bottom right of the
      rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                         */
   IMAGE_PROC  void IMAGE_API PutStringInvertFontEx        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   /* Outputs a string in the specified font, from the specified
      point, text is drawn from the point up, with the characters
      aligned with the top to the left; it goes up from the point. the
      point becomes the bottom left of the rectangle output.
      Parameters
      pImage :      image to draw string into
      x :           x position of the string
      y :           y position of the string
      color :       color of the data drawn in the font
      background :  color of the data not drawn in the font
      pc :          pointer to constant text
      nLen :        length of text to output
      font :        the font to use. NULL use an internal default
                    font.                                              */
   IMAGE_PROC  void IMAGE_API PutStringInvertVerticalFontEx( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
   //uint32_t (*PutMenuStringFontEx)            ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   //uint32_t (*PutCStringFontEx)               ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, SFTFont font );
   IMAGE_PROC  uint32_t IMAGE_API  GetMaxStringLengthFont  ( uint32_t width, SFTFont UseFont );
   /* Used as a proper accessor method to get an image's width and
      height. Decided to allow the image structure to be mostly
      public, so the first 4 members are the images x,y, width and
      height, and are immediately accessable by the Image pointer.
      Parameters
      pImage :  image to get the size of
      width :   pointer to a 32 bit unsigned value to result with the
                width, if NULL ignored.
      height :  pointer to a 32 bit unsigned value to result with the
                height, if NULL ignored.                              */
   IMAGE_PROC  void IMAGE_API  GetImageSize            ( Image pImage, uint32_t *width, uint32_t *height );
   /* \Returns the pointer to the color buffer currently used
      \internal to the image.
      Parameters
      pImage :  Image to get the surface of.
      Example
      <code lang="c#">
      Image image = MakeImageFile( 100, 100 );
      PCDATA pointer_color_data = GetImageSurface( image );
      </code>
      Note
      This might be used to do an optimized output routine. Drawing
      to the image with plot and line are not necessarily the best
      for things like circles. Provides ability for user to output
      directly to the color buffer.                                 */
   IMAGE_PROC  PCDATA IMAGE_API  GetImageSurface        ( Image pImage );
   // would seem silly to load fonts - but for server implementations
   // the handle received is not the same as the font sent.
   IMAGE_PROC  SFTFont IMAGE_API  LoadFont                ( SFTFont font );
   /* Destroys a font, releasing all resources associated with
      character data and font rendering.                       */
   IMAGE_PROC  void IMAGE_API  UnloadFont              ( SFTFont font );
	/* This is a function used to synchronize image operations when
	   the image interface is across a message server.              */
	IMAGE_PROC  void IMAGE_API  SyncImage                  ( void );
	// intersect rectangle, results with the overlapping portion of R1 and R2
   // into R ...
   IMAGE_PROC  int IMAGE_API  IntersectRectangle ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* Merges two image rectangles. The resulting rectangle is a
      rectangle that includes both rectangles.
      Parameters
      r :   Pointer to an IMAGE_RECTANGLE for the result.
      r1 :  PIMAGE_RECTANGLE one rectangle.
      r2 :  PIMAGE_RECTANGLE the other rectangle.               */
   IMAGE_PROC  int IMAGE_API  MergeRectangle ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* User applications may use an aux rect attatched to an image. The
      'Display' render library used this itself however, making
      this mostly an internal feature.
      Parameters
      pImage :  image to get the aux rect of.
      pRect :   pointer to an IMAGE_RECTANGLE to get the aux
                rectangle data in.                                     */
   IMAGE_PROC  void IMAGE_API  GetImageAuxRect    ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* User applications may use an aux rect attatched to an image.
      The 'Display' render library used this itself however, making
      this mostly an internal feature.
      Parameters
      pImage :  image to set the aux rect of.
      pRect :   pointer to an IMAGE_RECTANGLE to set the aux
                rectangle to.                                       */
   IMAGE_PROC  void IMAGE_API  SetImageAuxRect    ( Image pImage, P_IMAGE_RECTANGLE pRect );
	/* \ \
	   Parameters
	   Filename :  \file name of image to load. Converts image into
	               sprite automatically, resulting with a sprite.
	   DBG_PASS :  See <link sack::DBG_PASS, DBG_PASS>              */
		IMAGE_PROC  PSPRITE IMAGE_API  MakeSpriteImageFileEx ( CTEXTSTR fname DBG_PASS );
      /* create a sprite from an Image */
	IMAGE_PROC  PSPRITE IMAGE_API  MakeSpriteImageEx ( Image image DBG_PASS );
	/* Release a Sprite. */
	IMAGE_PROC  void IMAGE_API  UnmakeSprite ( PSPRITE sprite, int bForceImageAlso );
	// angle is a fixed scaled integer with 0x1 0000 0000 being the full circle.
	IMAGE_PROC  void IMAGE_API  rotate_scaled_sprite (Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height );
   /* output a rotated sprite to destination image, using and angle specified.  The angle is represented as 0x1 0000 0000 is 360 degrees */
	IMAGE_PROC  void IMAGE_API  rotate_sprite (Image bmp, PSPRITE sprite, fixed angle);
   /* output a sprite at its current location */
	IMAGE_PROC  void IMAGE_API  BlotSprite ( Image pdest, PSPRITE ps );
/* Sets the point on a sprite which is the 'hotspot' the hotspot
   is the point that is drawn at the specified coordinate when
   outputting a sprite.
   Parameters
   sprite :  The PSPRITE to set the hotspot of.
   x :       x coordinate in the sprite's image that becomes the
             hotspot.
   y :       y coordinate in the sprite's image that becomes the
             hotspot.                                            */
IMAGE_PROC  PSPRITE IMAGE_API  SetSpriteHotspot ( PSPRITE sprite, int32_t x, int32_t y );
/* This function sets the current location of a sprite. When
   asked to render, the sprite will draw itself here.
   Parameters
   sprite :  the sprite to move
   x :       the new x coordinate of the parent image to draw at
   y :       the new y coordinate of the parent image to draw at */
IMAGE_PROC  PSPRITE IMAGE_API  SetSpritePosition ( PSPRITE sprite, int32_t x, int32_t y );
/* Use a font file to get a font that can be used for outputting
   characters and strings.
   Parameters
   file\ :    Filename of a font to render.
   nWidth :   desired width in pixels to render the font.
   nHeight :  desired height in pixels to render the font.
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.  */
IMAGE_PROC  SFTFont IMAGE_API  InternalRenderFontFile ( CTEXTSTR file
																		, int32_t nWidth
																		, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																		, uint32_t flags
																		);
/* Rerender the current font with a new size. */
IMAGE_PROC void IMAGE_API RerenderFont( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
	/* Dumps the whole cache to log file, shows family, style, path and filename.
    Is the same sort of dump that OpenFontFile uses.
	 */
IMAGE_PROC void IMAGE_API DumpFontCache( void );
#ifndef INTERNAL_DUMP_FONT_FILE
/* takes a font and dumps a header-file formatted file; then the font can be
 statically built into code. */
IMAGE_PROC void IMAGE_API DumpFontFile( CTEXTSTR name, SFTFont font_to_dump );
#endif
/* Creates a font based on indexes from the internal font cache.
   This is used by the FontPicker dialog to choose a font. The
   data the dialog used to render the font is available to the
   application, and may be passed back for rendering a font
   without knowing specifically what the values mean.
   Parameters
   nFamily :  The number of the family in the cache.
   nStyle :   The number of the style in the cache.
   nFile :    The number of the file in the cache.
   nWidth :   the width to use for rendering characters (in
              pixels)
   nHeight :  the height to use for rendering characters (in
              pixels)
   flags :    0 = render mono. 2=render 2 bits, 3=render 8 bit.
   Returns
   A SFTFont which can be used to output. If the file exists. NULL
   on failure.
   Example
   Used internally for FontPicker dialog, see <link sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t, InternalRenderFontFile> */
IMAGE_PROC  SFTFont IMAGE_API  InternalRenderFont ( uint32_t nFamily
																  , uint32_t nStyle
																  , uint32_t nFile
																  , int32_t nWidth
																  , int32_t nHeight
																  , PFRACTION width_scale
																  , PFRACTION height_scale
																  , uint32_t flags
																  );
/* Releases all resources for a SFTFont.  */
IMAGE_PROC  void IMAGE_API  DestroyFont( SFTFont *font );
/* Get the global font data structure. This is an internal
   structure, and it's definition may not be exported. Currently
   the definition is in documentation.
   See Also
   <link sack::image::FONT_GLOBAL, SFTFont Global>                  */
IMAGE_PROC  struct font_global_tag * IMAGE_API  GetGlobalFonts( void );
// types of data which may result...
typedef struct font_data_tag *PFONTDATA;
/* Information to render a font from a file to memory. */
typedef struct render_font_data_tag *PRENDER_FONTDATA;
/* Recreates a SFTFont based on saved FontData. The resulting font
   may be scaled from its original size.
   Parameters
   pfd :           pointer to font data.
   width_scale :   FRACTION to scale the original font height
                   \description by. if NULL uses the original
                   font's size.
   height_scale :  FRACTION to scale the original font height
                   \description by.  if NULL uses the original
                   font's size.
   Example
   <code lang="c++">
   POINTER some_loaded_data; // pretend it is initialized to something valid
   SFTFont font = RenderScaledFontData( some_loaded_data, NULL, NULL );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font );
   </code>
   Or, maybe your original designed screen was 1024x768, and
   it's now showing on 1600x1200, for the text to remain the
   same...
   <code lang="c++">
   FRACTION width_scale;
   FRACTION height_scale;
   uint32_t w, h;
   GetDisplaySize( &amp;w, &amp;h );
   SetFraction( width_scale, w, 1024 );
   SetFraction( height_scale, h, 768 );
   SFTFont font2 = RenderScaledFontData( some_loaded_data, &amp;width_scale, &amp;height_scale );
   PutStringFont( image, 0, 0, BASE_COLOR_WHITE, 0, "Hello World", font2 );
   </code>                                                                                     */
IMAGE_PROC  SFTFont IMAGE_API  RenderScaledFontData( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
#define RenderFontData(pfd) RenderScaledFontData( pfd,NULL,NULL )
/* <combinewith sack::image::RenderScaledFontEx@CTEXTSTR@uint32_t@uint32_t@PFRACTION@PFRACTION@uint32_t@size_t *@POINTER *, sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                                                                                                                        */
IMAGE_PROC SFTFont IMAGE_API RenderScaledFontEx( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* Renders a font with a FRACTION scalar for the X and Y sizes.
   Parameters
   name :          Name of the font (file).
   width :         Original width (in pels) to make the font.
   height :        Original height (in pels) to make the font.
   width_scale :   scalar to apply to the width
   height_scale :  scalar to apply to the height
   flags :         Flags specifying how many bits to render the
                   font with (and other info?) See enum
                   FontFlags.                                   */
IMAGE_PROC SFTFont IMAGE_API RenderScaledFont( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
#define RenderScaledFont(n,w,h,ws,hs) RenderScaledFontEx(n,w,h,ws,hs,NULL,NULL)
/* Renders a font file and returns a SFTFont. The font can then be
   used in string output functions to images.
   Parameters
   file\ :           \File name of a font to render. Any font
                     that freetype supports.
   width :           width of characters to render in.
   height :          height of characters to render.
   flags :           if( ( flags &amp; 3 ) == 3 )<p /> font\-\>flags
                     = FONT_FLAG_8BIT;<p /> else if( ( flags &amp;
                     3 ) == 2 )<p /> font\-\>flags =
                     FONT_FLAG_2BIT;<p /> else<p /> font\-\>flags
                     = FONT_FLAG_MONO;<p />
   pnFontDataSize :  optional pointer to a 32 bit value to
                     receive the size of rendered data.
   pFontData :       The render data. This data can be used to
                     recreate this font.                             */
IMAGE_PROC  SFTFont IMAGE_API  RenderFontFileScaledEx ( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
#define RenderFontFile(file,w,h,flags) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,NULL,NULL)
#define RenderFontFileEx(file,w,h,flags,a,b) RenderFontFileScaledEx(file,w,h,NULL,NULL,flags,a,b )
		/* This can be used to get the internal description of a font,
		   which the user may then save, and use later to recreate the
		   font the same way.
		   Parameters
		   font :         SFTFont to get the render description from.
		   fontdata :     a pointer to a pointer which will be filled
		                  with a pointer buffer that has the font data.
		   fontdatalen :  a pointer to 32 bit value to receive the length
		                  of data.                                        */
		IMAGE_PROC  int IMAGE_API  GetFontRenderData ( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
// exported for the PSI font chooser to set the data for the font
// to be retreived later when only the font handle remains.
IMAGE_PROC  void IMAGE_API  SetFontRendererData ( SFTFont font, POINTER pResult, size_t size );
#ifndef PSPRITE_METHOD
/* <combine sack::image::PSPRITE_METHOD>
   \ \                                   */
#define PSPRITE_METHOD PSPRITE_METHOD
	typedef struct sprite_method_tag *PSPRITE_METHOD;
#endif
	// provided for display rendering portion to define this method for sprites to use.
   // deliberately out of namespace... please do not move this up.
IMAGE_PROC  void IMAGE_API  SetSavePortion ( void (CPROC*_SavePortion )( PSPRITE_METHOD psm, uint32_t x, uint32_t y, uint32_t w, uint32_t h ) );
/* \Returns the red channel of the color
   Parameters
   color :  Color to get the red channel of.
   Returns
   The COLOR_CHANNEL (byte) of the red channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetRedValue( CDATA color ) ;
/* \Returns the green channel of the color
   Parameters
   color :  Color to get the green channel of.
   Returns
   The COLOR_CHANNEL (byte) of the green channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetGreenValue( CDATA color );
/* \Returns the blue channel of the color
   Parameters
   color :  Color to get the blue channel of.
   Returns
   The COLOR_CHANNEL (byte) of the blue channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetBlueValue( CDATA color );
/* \Returns the alpha channel of the color
   Parameters
   color :  Color to get the alpha channel of.
   Returns
   The COLOR_CHANNEL (byte) of the alpha channel in the color. */
IMAGE_PROC COLOR_CHANNEL IMAGE_API GetAlphaValue( CDATA color );
/* Sets the red channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new red channel value         */
IMAGE_PROC CDATA IMAGE_API SetRedValue( CDATA color, COLOR_CHANNEL r ) ;
/* Sets the green channel in a color value.
   Parameters
   color :  Original color to modify
   g :      new green channel value         */
IMAGE_PROC CDATA IMAGE_API SetGreenValue( CDATA color, COLOR_CHANNEL green );
/* Sets the blue channel in a color value.
   Parameters
   color :  Original color to modify
   b :      new blue channel value         */
IMAGE_PROC CDATA IMAGE_API SetBlueValue( CDATA color, COLOR_CHANNEL b );
/* Sets the alpha channel in a color value.
   Parameters
   color :  Original color to modify
   a :      new alpha channel value         */
IMAGE_PROC CDATA IMAGE_API SetAlphaValue( CDATA color, COLOR_CHANNEL a );
/* Makes a CDATA color from the RGB components. Sets the alpha
   as 100% opaque.
   Parameters
   r :      red channel of new color
   green :  green channel of new color
   b :      blue channel of new color                          */
IMAGE_PROC CDATA IMAGE_API MakeColor( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
/* Create a CDATA color from components.
   Parameters
   r :      Red channel value
   green :  green channel value
   b :      blue channel value
   a :      alpha channel value
   Returns
   A CDATA representing the color specified. */
IMAGE_PROC CDATA IMAGE_API MakeAlphaColor( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
/* With 3d renderer, images have a transformation matrix. This
   function allows you to get the transformation matrix.
   Parameters
   pImage :  image to get the transformation matrix of.        */
IMAGE_PROC  PTRANSFORM IMAGE_API GetImageTransformation( Image pImage );
enum image_translation_relation
{
   IMAGE_TRANSFORM_RELATIVE_CENTER = 0,
   IMAGE_TRANSFORM_RELATIVE_LEFT,
   IMAGE_TRANSFORM_RELATIVE_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_TOP,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM,
   IMAGE_TRANSFORM_RELATIVE_TOP_LEFT,
   IMAGE_TRANSFORM_RELATIVE_TOP_RIGHT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_LEFT,
   IMAGE_TRANSFORM_RELATIVE_BOTTOM_RIGHT,
 // only mode that uses the 'aux' parameter of SetImageTransformRelation
   IMAGE_TRANSFORM_RELATIVE_OTHER
};
/*
 This sets flags on the image, so when it's called for rendering to the screen
 this is how
    */
IMAGE_PROC  void IMAGE_API SetImageTransformRelation( Image pImage, enum image_translation_relation relation, PRCOORD aux );
/*
 This just draws the image into the current 3d context.
 This is a point-sprite engine too....
 It does not setup anything about rendering this, just generates the texture at the right coords.
 Parameters
 render_pixel_scaled : when drawing, reverse compute from the angle of the view, and the depth of the thing to scale orthagonal, but at depth.  (help 3d vision)
 */
IMAGE_PROC  void IMAGE_API Render3dImage( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC  void IMAGE_API Render3dText( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
/*
  Utilized by fonts with images with reverse_interface set to transfer child images;
  may be generally useful; but had to be exposed through interface
  Might be a shallow move....
 */
IMAGE_PROC  void IMAGE_API TransferSubImages( Image pImageTo, Image pImageFrom );
IMAGE_PROC  LOGICAL IMAGE_API IsImageTargetFinal( Image image );
/* These flags are used in SetImageRotation and RotateImageAbout
   functions - these are part of the 3D driver interface
   extension. They allow for controlling how the rotation is
   performed.                                                    */
enum image_rotation_flags {
 // relative to center of image (center if not left, right, top or bottom )
	IMAGE_ROTATE_FLAG_CENTER = 0,
 // relative to top edge (center if not left or right)
   IMAGE_ROTATE_FLAG_TOP,
 // relative to left edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_LEFT,
 // relative to right edge (center if not top or bottom)
   IMAGE_ROTATE_FLAG_RIGHT,
 // relative to bottom edge (center if not left or right )
   IMAGE_ROTATE_FLAG_BOTTOM,
 // use the offset relative to the image orientation
	IMAGE_ROTATE_FLAG_ADD_CUSTOM_OFFSET
};
/* Sets the rotation matrix of an image to an arbitrary
   yaw/pitch/roll coordinate.
   Parameters
   pImage :     Image to rotate
   edge_flag :  what edge the rotation is relative to
   offset_x :   offset from the edge to get the center
   offset_y :   offset from the edge to get the center
   rx :         rotation about x axis (horizontal)
   ry :         rotation about y axis (vertical)
   rz :         rotation about z axis (into screen)     */
IMAGE_PROC void IMAGE_API SetImageRotation( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
/* Allows arbitrary rotation of an image in 3d render mode.
   Parameters
   pImage :     image to rotate
   edge_flag :  see enum image_rotation_flags
   offset_x :   offset from top left of image to center the
                rotation
   offset_y :   offset from top left of image to center the
                rotation
   vAxis :      axis to rotate around, can be any arbitrary
                direction
   angle :      angle of rotation around the axis.
   Remarks
   \See Also <link sack::image::image_rotation_flags, image_rotation_flags Enumeration> */
IMAGE_PROC void IMAGE_API RotateImageAbout( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC void IMAGE_API MarkImageDirty( Image pImage );
_INTERFACE_NAMESPACE
/* Defines a pointer member of the interface structure. */
#define IMAGE_PROC_PTR(type,name) type (CPROC*_##name)
/* Macro to build function pointer entries in the image
   interface.                                           */
//#define DIMAGE_PROC_PTR(type,name) type (CPROC**_##name)
/* This defines the interface call table. each function
   available in the API is reflected in this interface. It
   provdes a function table so applications don't have to be
   directly linked to the image API. This allows replacing the
   image API.                                                  */
typedef struct image_interface_tag
{
/* <combine sack::image::SetStringBehavior@Image@uint32_t>
   Internal
   Interface index 4                                  */
 IMAGE_PROC_PTR( void, SetStringBehavior) ( Image pImage, uint32_t behavior );
/* <combine sack::image::SetBlotMethod@uint32_t>
   \ \
   Internal
   Interface index 5                        */
 IMAGE_PROC_PTR( void, SetBlotMethod)     ( uint32_t method );
/*
   Internal
   Interface index 6*/
   IMAGE_PROC_PTR( Image,BuildImageFileEx) ( PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t Height>
   Internal
   Interface index 7*/
  IMAGE_PROC_PTR( Image,MakeImageFileEx)  (uint32_t Width, uint32_t Height DBG_PASS);
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t height>
   Internal
   Interface index 8                                                                    */
   IMAGE_PROC_PTR( Image,MakeSubImageEx)   ( Image pImage, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t height>
   \ \
   <b>Internal</b>
   Interface index 9                                                */
   IMAGE_PROC_PTR( Image,RemakeImageEx)    ( Image pImage, PCOLOR pc, uint32_t width, uint32_t height DBG_PASS);
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   Internal
   Interface index 10                                                   */
  IMAGE_PROC_PTR( Image,LoadImageFileEx)  ( CTEXTSTR name DBG_PASS );
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Internal
   Interface index 11                                                 */
  IMAGE_PROC_PTR( void,UnmakeImageFileEx) ( Image pif DBG_PASS );
#define UnmakeImageFile(pif) UnmakeImageFileEx( pif DBG_SRC )
//-----------------------------------------------------
/* <combine sack::image::ResizeImageEx@Image@int32_t@int32_t height>
   Internal
   Interface index 14                                                          */
  IMAGE_PROC_PTR( void,ResizeImageEx)     ( Image pImage, int32_t width, int32_t height DBG_PASS);
/* <combine sack::image::MoveImage@Image@int32_t@int32_t>
   Internal
   Interface index 15                                               */
   IMAGE_PROC_PTR( void,MoveImage)         ( Image pImage, int32_t x, int32_t y );
//-----------------------------------------------------
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 16                                                             */
   IMAGE_PROC_PTR( void,BlatColor)     ( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlatColorAlpha@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   Internal
   Interface index 17                                                                  */
   IMAGE_PROC_PTR( void,BlatColorAlpha)( Image pifDest, int32_t x, int32_t y, uint32_t w, uint32_t h, CDATA color );
/* <combine sack::image::BlotImageEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 18*/
   IMAGE_PROC_PTR( void,BlotImageEx)     ( Image pDest, Image pIF, int32_t x, int32_t y, uint32_t nTransparent, uint32_t method, ... );
 /* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   Internal
	Interface index 19*/
   IMAGE_PROC_PTR( void,BlotImageSizedEx)( Image pDest, Image pIF, int32_t x, int32_t y, int32_t xs, int32_t ys, uint32_t wd, uint32_t ht, uint32_t nTransparent, uint32_t method, ... );
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
  Internal
   Interface index  20                                                                                                        */
   IMAGE_PROC_PTR( void,BlotScaledImageSizedEx)( Image pifDest, Image pifSrc
                                   , int32_t xd, int32_t yd
                                   , uint32_t wd, uint32_t hd
                                   , int32_t xs, int32_t ys
                                   , uint32_t ws, uint32_t hs
                                   , uint32_t nTransparent
                                   , uint32_t method, ... );
/*Internal
   Interface index 21*/
   IMAGE_PROC_PTR( void,plot)      ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 22*/
   IMAGE_PROC_PTR( void,plotalpha) ( Image pi, int32_t x, int32_t y, CDATA c );
/*Internal
   Interface index 23*/
   IMAGE_PROC_PTR( CDATA,getpixel) ( Image pi, int32_t x, int32_t y );
/*Internal
   Interface index 24*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_line)     ( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color );
/*Internal
   Interface index 25*/
  // d is color data...
   IMAGE_PROC_PTR( void,do_lineAlpha)( Image pBuffer, int32_t x, int32_t y, int32_t xto, int32_t yto, CDATA color);
/*Internal
   Interface index 26*/
   IMAGE_PROC_PTR( void,do_hline)     ( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 27*/
   IMAGE_PROC_PTR( void,do_vline)     ( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/*Internal
   Interface index 28*/
   IMAGE_PROC_PTR( void,do_hlineAlpha)( Image pImage, int32_t y, int32_t xfrom, int32_t xto, CDATA color );
/*Internal
   Interface index 29*/
   IMAGE_PROC_PTR( void,do_vlineAlpha)( Image pImage, int32_t x, int32_t yfrom, int32_t yto, CDATA color );
/* <combine sack::image::GetDefaultFont>
   Internal
   Interface index 30                    */
   IMAGE_PROC_PTR( SFTFont,GetDefaultFont) ( void );
/* <combine sack::image::GetFontHeight@SFTFont>
   Internal
   Interface index 31                                        */
   IMAGE_PROC_PTR( uint32_t ,GetFontHeight)  ( SFTFont );
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   Internal
   Interface index 32                                                          */
   IMAGE_PROC_PTR( uint32_t ,GetStringSizeFontEx)( CTEXTSTR pString, size_t len, uint32_t *width, uint32_t *height, SFTFont UseFont );
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@uint32_t@SFTFont>
   Internal
   Interface index 33                                                           */
   IMAGE_PROC_PTR( void,PutCharacterFont)              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 34                                                                                        */
   IMAGE_PROC_PTR( void,PutCharacterVerticalFont)      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 35                                                                                      */
   IMAGE_PROC_PTR( void,PutCharacterInvertFont)        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Internal
   Interface index 36                                                                                              */
   IMAGE_PROC_PTR( void,PutCharacterVerticalInvertFont)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, TEXTCHAR c, SFTFont font );
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 37                                                                                   */
   IMAGE_PROC_PTR( void,PutStringFontEx)              ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 38                                                                                           */
   IMAGE_PROC_PTR( void,PutStringVerticalFontEx)      ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 39                                                                                         */
   IMAGE_PROC_PTR( void,PutStringInvertFontEx)        ( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   Internal
   Interface index 40                                                                                                 */
   IMAGE_PROC_PTR( void,PutStringInvertVerticalFontEx)( Image pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, size_t nLen, SFTFont font );
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   Internal
   Interface index 41                                     */
   IMAGE_PROC_PTR( uint32_t, GetMaxStringLengthFont )( uint32_t width, SFTFont UseFont );
/* <combine sack::image::GetImageSize@Image@uint32_t *@uint32_t *>
   Internal
   Interface index 42                                                    */
   IMAGE_PROC_PTR( void, GetImageSize)                ( Image pImage, uint32_t *width, uint32_t *height );
/* <combine sack::image::LoadFont@SFTFont>
   Internal
   Interface index 43                                   */
   IMAGE_PROC_PTR( SFTFont, LoadFont )                   ( SFTFont font );
         /* <combine sack::image::UnloadFont@SFTFont>
            \ \                                    */
         IMAGE_PROC_PTR( void, UnloadFont )                 ( SFTFont font );
/* Internal
   Interface index 44
   This is used by internal methods to transfer image and font
   data to the render agent.                                   */
   IMAGE_PROC_PTR( DataState, BeginTransferData )    ( uint32_t total_size, uint32_t segsize, CDATA data );
/* Internal
   Interface index 45
   Used internally to transfer data to render agent. */
   IMAGE_PROC_PTR( void, ContinueTransferData )      ( DataState state, uint32_t segsize, CDATA data );
/* Internal
   Interface index 46
   Command issues at end of data transfer to decode the data
   into an image.                                            */
   IMAGE_PROC_PTR( Image, DecodeTransferredImage )    ( DataState state );
/* After a data transfer decode the information as a font.
   Internal
   Interface index 47                                      */
   IMAGE_PROC_PTR( SFTFont, AcceptTransferredFont )     ( DataState state );
/*Internal
   Interface index 48*/
   IMAGE_PROC_PTR( CDATA, ColorAverage )( CDATA c1, CDATA c2
                                              , int d, int max );
/* <combine sack::image::SyncImage>
   Internal
   Interface index 49               */
   IMAGE_PROC_PTR( void, SyncImage )                 ( void );
         /* <combine sack::image::GetImageSurface@Image>
            \ \                                          */
         IMAGE_PROC_PTR( PCDATA, GetImageSurface )       ( Image pImage );
         /* <combine sack::image::IntersectRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
            \ \                                                                                             */
         IMAGE_PROC_PTR( int, IntersectRectangle )      ( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::MergeRectangle@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *@IMAGE_RECTANGLE *>
      \ \                                                                                         */
   IMAGE_PROC_PTR( int, MergeRectangle )( IMAGE_RECTANGLE *r, IMAGE_RECTANGLE *r1, IMAGE_RECTANGLE *r2 );
   /* <combine sack::image::GetImageAuxRect@Image@P_IMAGE_RECTANGLE>
      \ \                                                            */
   IMAGE_PROC_PTR( void, GetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::SetImageAuxRect@Image@P_IMAGE_RECTANGLE>
      \ \                                                            */
   IMAGE_PROC_PTR( void, SetImageAuxRect )   ( Image pImage, P_IMAGE_RECTANGLE pRect );
   /* <combine sack::image::OrphanSubImage@Image>
      \ \                                         */
   IMAGE_PROC_PTR( void, OrphanSubImage )  ( Image pImage );
   /* <combine sack::image::AdoptSubImage@Image@Image>
      \ \                                              */
   IMAGE_PROC_PTR( void, AdoptSubImage )   ( Image pFoster, Image pOrphan );
	/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
	   \ \                                                         */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageFileEx )( CTEXTSTR fname DBG_PASS );
	/* <combine sack::image::MakeSpriteImageEx@Image image>
	   \ \                                                  */
	IMAGE_PROC_PTR( PSPRITE, MakeSpriteImageEx )( Image image DBG_PASS );
	/* <combine sack::image::rotate_scaled_sprite@Image@PSPRITE@fixed@fixed@fixed>
	   \ \                                                                         */
	IMAGE_PROC_PTR( void   , rotate_scaled_sprite )(Image bmp, PSPRITE sprite, fixed angle, fixed scale_width, fixed scale_height);
	/* <combine sack::image::rotate_sprite@Image@PSPRITE@fixed>
	   \ \                                                      */
	IMAGE_PROC_PTR( void   , rotate_sprite )(Image bmp, PSPRITE sprite, fixed angle);
 /* <combine sack::image::BlotSprite@Image@PSPRITE>
	 Internal
   Interface index 61                                              */
		IMAGE_PROC_PTR( void   , BlotSprite )( Image pdest, PSPRITE ps );
    /* <combine sack::image::DecodeMemoryToImage@uint8_t*@uint32_t>
       \ \                                                */
    IMAGE_PROC_PTR( Image, DecodeMemoryToImage )( uint8_t* buf, size_t size );
   /* <combine sack::image::InternalRenderFontFile@CTEXTSTR@int32_t@int32_t@uint32_t>
      \returns a SFTFont                                                      */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFontFile )( CTEXTSTR file
																 , int32_t nWidth
																 , int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
																 , uint32_t flags
																 );
   /* <combine sack::image::InternalRenderFont@uint32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t>
      requires knowing the font cache....                                 */
	IMAGE_PROC_PTR( SFTFont, InternalRenderFont )( uint32_t nFamily
															, uint32_t nStyle
															, uint32_t nFile
															, int32_t nWidth
															, int32_t nHeight
																		, PFRACTION width_scale
																		, PFRACTION height_scale
															, uint32_t flags
															);
/* <combine sack::image::RenderScaledFontData@PFONTDATA@PFRACTION@PFRACTION>
   \ \                                                                       */
IMAGE_PROC_PTR( SFTFont, RenderScaledFontData)( PFONTDATA pfd, PFRACTION width_scale, PFRACTION height_scale );
/* <combine sack::image::RenderFontFileEx@CTEXTSTR@uint32_t@uint32_t@uint32_t@uint32_t*@POINTER *>
   \ \                                                                         */
IMAGE_PROC_PTR( SFTFont, RenderFontFileScaledEx )( CTEXTSTR file, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *size, POINTER *pFontData );
/* <combine sack::image::DestroyFont@SFTFont *>
   \ \                                       */
IMAGE_PROC_PTR( void, DestroyFont)( SFTFont *font );
/* <combine sack::image::GetGlobalFonts>
   global_font_data in interface is really a global font data. Don't
   have to call GetGlobalFont to get this.                           */
struct font_global_tag *_global_font_data;
/* <combine sack::image::GetFontRenderData@SFTFont@POINTER *@uint32_t *>
   \ \                                                           */
IMAGE_PROC_PTR( int, GetFontRenderData )( SFTFont font, POINTER *fontdata, size_t *fontdatalen );
/* <combine sack::image::SetFontRendererData@SFTFont@POINTER@uint32_t>
   \ \                                                         */
IMAGE_PROC_PTR( void, SetFontRendererData )( SFTFont font, POINTER pResult, size_t size );
/* <combine sack::image::SetSpriteHotspot@PSPRITE@int32_t@int32_t>
   \ \                                                       */
IMAGE_PROC_PTR( PSPRITE, SetSpriteHotspot )( PSPRITE sprite, int32_t x, int32_t y );
/* <combine sack::image::SetSpritePosition@PSPRITE@int32_t@int32_t>
   \ \                                                        */
IMAGE_PROC_PTR( PSPRITE, SetSpritePosition )( PSPRITE sprite, int32_t x, int32_t y );
	/* <combine sack::image::UnmakeImageFileEx@Image pif>
	   \ \                                                */
	IMAGE_PROC_PTR( void, UnmakeSprite )( PSPRITE sprite, int bForceImageAlso );
/* <combine sack::image::GetGlobalFonts>
   \ \                                   */
IMAGE_PROC_PTR( struct font_global_tag *, GetGlobalFonts)( void );
/* <combinewith sack::image::GetStringRenderSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@uint32_t *@SFTFont, sack::image::GetStringRenderSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                                                                                                                     */
IMAGE_PROC_PTR( uint32_t, GetStringRenderSizeFontEx )( CTEXTSTR pString, size_t nLen, uint32_t *width, uint32_t *height, uint32_t *charheight, SFTFont UseFont );
IMAGE_PROC_PTR( Image, LoadImageFileFromGroupEx )( INDEX group, CTEXTSTR filename DBG_PASS );
IMAGE_PROC_PTR( SFTFont, RenderScaledFont )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags );
IMAGE_PROC_PTR( SFTFont, RenderScaledFontEx )( CTEXTSTR name, uint32_t width, uint32_t height, PFRACTION width_scale, PFRACTION height_scale, uint32_t flags, size_t *pnFontDataSize, POINTER *pFontData );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetRedValue )( CDATA color ) ;
IMAGE_PROC_PTR( COLOR_CHANNEL, GetGreenValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetBlueValue )( CDATA color );
IMAGE_PROC_PTR( COLOR_CHANNEL, GetAlphaValue )( CDATA color );
IMAGE_PROC_PTR( CDATA, SetRedValue )( CDATA color, COLOR_CHANNEL r ) ;
IMAGE_PROC_PTR( CDATA, SetGreenValue )( CDATA color, COLOR_CHANNEL green );
IMAGE_PROC_PTR( CDATA, SetBlueValue )( CDATA color, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, SetAlphaValue )( CDATA color, COLOR_CHANNEL a );
IMAGE_PROC_PTR( CDATA, MakeColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b );
IMAGE_PROC_PTR( CDATA, MakeAlphaColor )( COLOR_CHANNEL r, COLOR_CHANNEL green, COLOR_CHANNEL b, COLOR_CHANNEL a );
IMAGE_PROC_PTR( PTRANSFORM, GetImageTransformation )( Image pImage );
IMAGE_PROC_PTR( void, SetImageRotation )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, RCOORD rx, RCOORD ry, RCOORD rz );
IMAGE_PROC_PTR( void, RotateImageAbout )( Image pImage, int edge_flag, RCOORD offset_x, RCOORD offset_y, PVECTOR vAxis, RCOORD angle );
IMAGE_PROC_PTR( void, MarkImageDirty )( Image pImage );
IMAGE_PROC_PTR( void, DumpFontCache )( void );
IMAGE_PROC_PTR( void, RerenderFont )( SFTFont font, int32_t width, int32_t height, PFRACTION width_scale, PFRACTION height_scale );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadTexture )( Image child_image, int option );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadShadedTexture )( Image child_image, int option, CDATA color );
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
IMAGE_PROC_PTR( int, ReloadMultiShadedTexture )( Image child_image, int option, CDATA red, CDATA green, CDATA blue );
IMAGE_PROC_PTR( void, SetImageTransformRelation )( Image pImage, enum image_translation_relation relation, PRCOORD aux );
IMAGE_PROC_PTR( void, Render3dImage )( Image pImage, PCVECTOR o, LOGICAL render_pixel_scaled );
IMAGE_PROC_PTR( void, DumpFontFile )( CTEXTSTR name, SFTFont font_to_dump );
IMAGE_PROC_PTR( void, Render3dText )( CTEXTSTR string, int characters, CDATA color, SFTFont font, PCVECTOR o, LOGICAL render_pixel_scaled );
// transfer all sub images to new image using appropriate methods
// extension for internal fonts to be utilized by external plugins...
IMAGE_PROC_PTR( void, TransferSubImages )( Image pImageTo, Image pImageFrom );
// when using reverse interfaces, need a way to get the real image
// from the fake image (proxy image)
IMAGE_PROC_PTR( Image, GetNativeImage )( Image pImageTo );
// low level support for proxy; this exposes some image_common.c routines
IMAGE_PROC_PTR( Image, GetTintedImage )( Image child_image, CDATA color );
IMAGE_PROC_PTR( Image, GetShadedImage )( Image child_image, CDATA red, CDATA green, CDATA blue );
// test for IF_FLAG_FINAL_RENDER (non physical surface/prevent local copy-restore)
IMAGE_PROC_PTR( LOGICAL, IsImageTargetFinal )( Image image );
// use image data to create a clone of the image for the new application instance...
// this is used when a common image resource is used for all application instances
// it should be triggered during onconnect.
// it is a new image instance that should be used for future app references...
IMAGE_PROC_PTR( Image, ReuseImage )( Image image );
IMAGE_PROC_PTR( void, PutStringFontExx )( Image pImage
											 , int32_t x, int32_t y
											 , CDATA color, CDATA background
											 , CTEXTSTR pc, size_t nLen, SFTFont font, int justification, uint32_t _width );
// sometimes it's not possible to use blatcolor to clear an imate...
// sometimes its parent is not redrawn?
IMAGE_PROC_PTR( void, ResetImageBuffers )( Image image, LOGICAL image_only );
	IMAGE_PROC_PTR(  LOGICAL, PngImageFile )( Image image, uint8_t* *buf, size_t *size );
	IMAGE_PROC_PTR(  LOGICAL, JpgImageFile )( Image image, uint8_t* *buf, size_t *size, int Q );
	IMAGE_PROC_PTR(  void, SetFontBias )( SFTFont font, int32_t x, int32_t y );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImage )( Image source, uint32_t left, uint32_t right, uint32_t top, uint32_t bottom, LOGICAL output_center );
	IMAGE_PROC_PTR( SlicedImage, MakeSlicedImageComplex )( Image source
										, uint32_t top_left_x, uint32_t top_left_y, uint32_t top_left_width, uint32_t top_left_height
										, uint32_t top_x, uint32_t top_y, uint32_t top_width, uint32_t top_height
										, uint32_t top_right_x, uint32_t top_right_y, uint32_t top_right_width, uint32_t top_right_height
										, uint32_t left_x, uint32_t left_y, uint32_t left_width, uint32_t left_height
										, uint32_t center_x, uint32_t center_y, uint32_t center_width, uint32_t center_height
										, uint32_t right_x, uint32_t right_y, uint32_t right_width, uint32_t right_height
										, uint32_t bottom_left_x, uint32_t bottom_left_y, uint32_t bottom_left_width, uint32_t bottom_left_height
										, uint32_t bottom_x, uint32_t bottom_y, uint32_t bottom_width, uint32_t bottom_height
										, uint32_t bottom_right_x, uint32_t bottom_right_y, uint32_t bottom_right_width, uint32_t bottom_right_height
										, LOGICAL output_center );
	IMAGE_PROC_PTR( void, UnmakeSlicedImage )( SlicedImage image );
	IMAGE_PROC_PTR( void, BlotSlicedImageEx )( Image dest, SlicedImage source, int32_t x, int32_t y, uint32_t width, uint32_t height, int alpha, enum BlotOperation op, ... );
} IMAGE_INTERFACE, *PIMAGE_INTERFACE;
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using.                                    */
#define PROC_ALIAS(name) ((USE_IMAGE_INTERFACE)->_##name)
/* Method to define automatic name translation from standard
   names Like BlatColorAlphaEx to the interface the user has
   specified to be using. For function pointers.             */
#define PPROC_ALIAS(name) (*(USE_IMAGE_INTERFACE)->_##name)
#ifdef DEFINE_DEFAULT_IMAGE_INTERFACE
//static PIMAGE_INTERFACE always_defined_interface_that_makes_this_efficient;
#  define USE_IMAGE_INTERFACE GetImageInterface()
#endif
#if defined( FORCE_NO_INTERFACE ) && !defined( ALLOW_IMAGE_INTERFACES )
#  undef USE_IMAGE_INTERFACE
#else
#  define GetImageInterface() (PIMAGE_INTERFACE)GetInterface( WIDE("image") )
/* <combine sack::image::DropImageInterface@PIMAGE_INTERFACE>
   \ \                                                        */
#  define DropImageInterface(x) DropInterface( WIDE("image"), NULL )
#endif
#ifdef USE_IMAGE_INTERFACE
#define GetRedValue                          PROC_ALIAS(GetRedValue )
#define GetBlueValue                          PROC_ALIAS(GetBlueValue )
#define GetGreenValue                          PROC_ALIAS(GetGreenValue )
#define GetAlphaValue                          PROC_ALIAS(GetAlphaValue )
#define SetRedValue                          PROC_ALIAS(SetRedValue )
#define SetBlueValue                          PROC_ALIAS(SetBlueValue )
#define SetGreenValue                          PROC_ALIAS(SetGreenValue )
#define SetAlphaValue                          PROC_ALIAS(SetAlphaValue )
#define MakeColor                          PROC_ALIAS(MakeColor )
#define MakeAlphaColor                          PROC_ALIAS(MakeAlphaColor )
#define MarkImageDirty                    PROC_ALIAS(MarkImageDirty)
#define GetStringRenderSizeFontEx          PROC_ALIAS(GetStringRenderSizeFontEx )
#define LoadImageFileFromGroupEx          PROC_ALIAS(LoadImageFileFromGroupEx )
#define SetStringBehavior                  PROC_ALIAS(SetStringBehavior )
                      //PROC_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   PROC_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    PROC_ALIAS(MakeImageFileEx )
#define MakeSubImageEx                     PROC_ALIAS(MakeSubImageEx )
#define RemakeImageEx                      PROC_ALIAS(RemakeImageEx )
#define ResizeImageEx                      PROC_ALIAS(ResizeImageEx )
#define MoveImage                          PROC_ALIAS(MoveImage )
#define LoadImageFileEx                    PROC_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                PROC_ALIAS(DecodeMemoryToImage )
#define UnmakeImageFileEx                  PROC_ALIAS(UnmakeImageFileEx )
#define BlatColor                          PROC_ALIAS(BlatColor )
#define BlatColorAlpha                     PROC_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   PROC_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        PROC_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             PROC_ALIAS(BlotScaledImageSizedEx )
#define plot                               PPROC_ALIAS(plot )
#define plotalpha                          PPROC_ALIAS(plotalpha )
#define getpixel                           PPROC_ALIAS(getpixel )
#define do_line                            PPROC_ALIAS(do_line )
#define do_lineAlpha                       PPROC_ALIAS(do_lineAlpha )
#define do_hline                           PPROC_ALIAS(do_hline )
#define do_vline                           PPROC_ALIAS(do_vline )
#define do_hlineAlpha                      PPROC_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      PPROC_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     PROC_ALIAS(GetDefaultFont )
#define GetFontHeight                      PROC_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                PROC_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   PROC_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           PROC_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             PROC_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     PROC_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontExx                   PROC_ALIAS(PutStringFontExx)
#define PutStringFontEx                    PROC_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            PROC_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              PROC_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      PROC_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             PROC_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       PROC_ALIAS(GetImageSize )
#define LoadFont                           PROC_ALIAS(LoadFont )
#define UnloadFont                         PROC_ALIAS(UnloadFont )
#define ColorAverage                       PPROC_ALIAS(ColorAverage)
#define TransferSubImages                  PROC_ALIAS(TransferSubImages)
#define SyncImage                          PROC_ALIAS(SyncImage )
#define IntersectRectangle                 PROC_ALIAS(IntersectRectangle)
#define MergeRectangle                     PROC_ALIAS(MergeRectangle)
#define GetImageSurface                    PROC_ALIAS(GetImageSurface)
#define SetImageAuxRect                    PROC_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    PROC_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     PROC_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     PROC_ALIAS(GetGlobalFonts)
#define GetTintedImage                     PROC_ALIAS(GetTintedImage)
#define GetShadedImage                     PROC_ALIAS(GetShadedImage)
#define AdoptSubImage                      PROC_ALIAS(AdoptSubImage)
#define MakeSpriteImageFileEx   PROC_ALIAS(MakeSpriteImageFileEx)
#define MakeSpriteImageEx       PROC_ALIAS(MakeSpriteImageEx)
#define UnmakeSprite            PROC_ALIAS(UnmakeSprite )
#define rotate_scaled_sprite    PROC_ALIAS(rotate_scaled_sprite)
#define rotate_sprite           PROC_ALIAS(rotate_sprite)
#define BlotSprite              PROC_ALIAS(BlotSprite)
#define SetSpritePosition  PROC_ALIAS(  SetSpritePosition )
#define SetSpriteHotspot  PROC_ALIAS(  SetSpriteHotspot )
#define InternalRenderFont          PROC_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      PROC_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              PROC_ALIAS(RenderScaledFontData)
//#define RenderScaledFont              PROC_ALIAS(RenderScaledFont)
#define RenderScaledFontEx              PROC_ALIAS(RenderScaledFontEx)
#define DumpFontCache              PROC_ALIAS(DumpFontCache)
#define RerenderFont              PROC_ALIAS(RerenderFont)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadTexture              PROC_ALIAS(ReloadTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadShadedTexture              PROC_ALIAS(ReloadShadedTexture)
// option(1) == use GL_RGBA_EXT; option(2)==clamp; option(4)==repeat
#define ReloadMultiShadedTexture              PROC_ALIAS(ReloadMultiShadedTexture)
#define DestroyFont              PROC_ALIAS(DestroyFont)
#define GetFontRenderData              PROC_ALIAS(GetFontRenderData)
#define SetFontRendererData              PROC_ALIAS(SetFontRendererData)
#define RenderFontFileScaledEx              PROC_ALIAS(RenderFontFileScaledEx)
#define GetImageTransformation              PROC_ALIAS(GetImageTransformation)
#define SetImageTransformRelation      PROC_ALIAS( SetImageTransformRelation )
#define Render3dImage                  PROC_ALIAS( Render3dImage )
#define Render3dText                   PROC_ALIAS( Render3dText )
#define DumpFontFile                   PROC_ALIAS( DumpFontFile )
#define IsImageTargetFinal                   PROC_ALIAS( IsImageTargetFinal )
#define ReuseImage                      if((USE_IMAGE_INTERFACE)->_ReuseImage) PROC_ALIAS( ReuseImage )
#define ResetImageBuffers                      if((USE_IMAGE_INTERFACE)->_ResetImageBuffers) PROC_ALIAS( ResetImageBuffers )
#define PngImageFile                    PROC_ALIAS( PngImageFile )
#define JpgImageFile                    PROC_ALIAS( JpgImageFile )
#define SetFontBias                     PROC_ALIAS( SetFontBias )
#define MakeSlicedImage                 PROC_ALIAS( MakeSlicedImage )
#define MakeSlicedImageComplex          PROC_ALIAS( MakeSlicedImageComplex )
#define UnmakeSlicedImage                 PROC_ALIAS( UnmakeSlicedImage )
#define BlotSlicedImageEx               PROC_ALIAS( BlotSlicedImageEx )
//#define global_font_data         (*PROC_ALIAS(global_font_data))
#endif
/* <combine sack::image::GetMaxStringLengthFont@uint32_t@SFTFont>
   \ \                                                    */
#define GetMaxStringLength(w) GetMaxStringLengthFont(w, NULL )
#ifdef DEFINE_IMAGE_PROTOCOL
//#include <msgprotocol.h>
// need to define BASE_IMAGE_MESSAGE_ID before hand to determine what the base message is.
//#define MSG_ID(method)  ( ( offsetof( struct image_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_IMAGE_MESSAGE_ID + MSG_EventUser )
#define MSG_SetStringBehavior                  MSG_ID( SetStringBehavior )
#define MSG_SetBlotMethod                      MSG_ID( SetBlotMethod )
#define MSG_BuildImageFileEx                   MSG_ID( BuildImageFileEx )
#define MSG_MakeImageFileEx                    MSG_ID( MakeImageFileEx )
#define MSG_MakeSubImageEx                     MSG_ID( MakeSubImageEx )
#define MSG_RemakeImageEx                      MSG_ID( RemakeImageEx )
#define MSG_UnmakeImageFileEx                  MSG_ID( UnmakeImageFileEx )
#define MSG_ResizeImageEx                      MSG_ID( ResizeImageEx )
#define DecodeMemoryToImage                    MSG_ID( DecodeMemoryToImage )
#define MSG_MoveImage                          MSG_ID( MoveImage )
#define MSG_BlatColor                          MSG_ID( BlatColor )
#define MSG_BlatColorAlpha                     MSG_ID( BlatColorAlpha )
#define MSG_BlotImageSizedEx                   MSG_ID( BlotImageSizedEx )
#define MSG_BlotImageEx                        MSG_ID( BlotImageEx )
#define MSG_BlotScaledImageSizedEx             MSG_ID( BlotScaledImageSizedEx )
#define MSG_plot                               MSG_ID( plot )
#define MSG_plotalpha                          MSG_ID( plotalpha )
#define MSG_getpixel                           MSG_ID( getpixel )
#define MSG_do_line                            MSG_ID( do_line )
#define MSG_do_lineAlpha                       MSG_ID( do_lineAlpha )
#define MSG_do_hline                           MSG_ID( do_hline )
#define MSG_do_vline                           MSG_ID( do_vline )
#define MSG_do_hlineAlpha                      MSG_ID( do_hlineAlpha )
#define MSG_do_vlineAlpha                      MSG_ID( do_vlineAlpha )
#define MSG_GetDefaultFont                     MSG_ID( GetDefaultFont )
#define MSG_GetFontHeight                      MSG_ID( GetFontHeight )
#define MSG_GetStringSizeFontEx                MSG_ID( GetStringSizeFontEx )
#define MSG_PutCharacterFont                   MSG_ID( PutCharacterFont )
#define MSG_PutCharacterVerticalFont           MSG_ID( PutCharacterVerticalFont )
#define MSG_PutCharacterInvertFont             MSG_ID( PutCharacterInvertFont )
#define MSG_PutCharacterVerticalInvertFont     MSG_ID( PutCharacterVerticalInvertFont )
#define MSG_PutStringFontEx                    MSG_ID( PutStringFontEx )
#define MSG_PutStringVerticalFontEx            MSG_ID( PutStringVerticalFontEx )
#define MSG_PutStringInvertFontEx              MSG_ID( PutStringInvertFontEx )
#define MSG_PutStringInvertVerticalFontEx      MSG_ID( PutStringInvertVerticalFontEx )
#define MSG_GetMaxStringLengthFont             MSG_ID( GetMaxStringLengthFont )
#define MSG_GetImageSize                       MSG_ID( GetImageSize )
#define MSG_ColorAverage                       MSG_IC( ColorAverage )
// these messages follow all others... and are present to handle
// LoadImageFile
// #define MSG_LoadImageFile (no message)
// #define MSG_LoadFont      (no message)
#define MSG_UnloadFont                         MSG_ID( UnloadFont )
#define MSG_BeginTransferData                  MSG_ID( BeginTransferData )
#define MSG_ContinueTransferData               MSG_ID( ContinueTransferData )
#define MSG_DecodeTransferredImage             MSG_ID( DecodeTransferredImage )
#define MSG_AcceptTransferredFont              MSG_ID( AcceptTransferredFont )
#define MSG_SyncImage                          MSG_ID( SyncImage )
#define MSG_IntersectRectangle                 MSG_ID( IntersectRectangle )
#define MSG_MergeRectangle                     MSG_ID( MergeRectangle)
#define MSG_GetImageSurface                    MSG_ID( GetImageSurface )
#define MSG_SetImageAuxRect                    MSG_ID(SetImageAuxRect)
#define MSG_GetImageAuxRect                    MSG_ID(GetImageAuxRect)
#define MSG_OrphanSubImage                     MSG_ID(OrphanSubImage)
#define MSG_GetGlobalFonts                     MSG_ID(GetGlobalFonts)
#define MSG_AdoptSubImage                      MSG_ID(AdoptSubImage)
#define MSG_MakeSpriteImageFileEx   MSG_ID(MakeSpriteImageFileEx)
#define MSG_MakeSpriteImageEx       MSG_ID(MakeSpriteImageEx)
#define MSG_UnmakeSprite            MSG_ID(UnmakeSprite )
#define MSG_rotate_scaled_sprite    MSG_ID(rotate_scaled_sprite)
#define MSG_rotate_sprite           MSG_ID(rotate_sprite)
#define MSG_BlotSprite              MSG_ID(BlotSprite)
#define MSG_SetSpritePosition  MSG_ID(  SetSpritePosition )
#define MSG_SetSpriteHotspot  MSG_ID(  SetSpriteHotspot )
#define MSG_InternalRenderFont          MSG_ID(InternalRenderFont)
#define MSG_InternalRenderFontFile      MSG_ID(InternalRenderFontFile)
#define MSG_RenderScaledFontData              MSG_ID(RenderScaledFontData)
#define MSG_RenderScaledFont              MSG_ID(RenderScaledFont)
#define MSG_RenderFontData              MSG_ID(RenderFontData)
#define MSG_DestroyFont              MSG_ID(DestroyFont)
#define MSG_GetFontRenderData              MSG_ID(GetFontRenderData)
#define MSG_SetFontRendererData              MSG_ID(SetFontRendererData)
#endif
#ifdef USE_IMAGE_LEVEL
#define PASTELEVEL(level,name) level##name
#define LEVEL_ALIAS(name)      PASTELEVEL(USE_IMAGE_LEVEL,name)
#  ifdef STUPID_NO_DATA_EXPORTS
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,_PASTE(_,name)))
#  else
#define PLEVEL_ALIAS(name)      (*PASTELEVEL(USE_IMAGE_LEVEL,name))
#  endif
#define SetStringBehavior                  LEVEL_ALIAS(SetStringBehavior )
                      //LEVEL_ALIAS(SetBlotMethod )
#define SetBlotMethod
#define BuildImageFileEx                   LEVEL_ALIAS(BuildImageFileEx )
#define MakeImageFileEx                    LEVEL_ALIAS(MakeImageFileEx )
#define MakeSubImageEx                     LEVEL_ALIAS(MakeSubImageEx )
#define RemakeImageEx                      LEVEL_ALIAS(RemakeImageEx )
#define ResizeImageEx                      LEVEL_ALIAS(ResizeImageEx )
#define MoveImage                          LEVEL_ALIAS(MoveImage )
#define LoadImageFileEx                    LEVEL_ALIAS(LoadImageFileEx )
#define DecodeMemoryToImage                LEVEL_ALIAS(DecodeMemoryToImage )
#define UnmakeImageFileEx                  LEVEL_ALIAS(UnmakeImageFileEx )
#define BlatColor                          LEVEL_ALIAS(BlatColor )
#define BlatColorAlpha                     LEVEL_ALIAS(BlatColorAlpha )
#define BlotImageSizedEx                   LEVEL_ALIAS(BlotImageSizedEx )
#define BlotImageEx                        LEVEL_ALIAS(BlotImageEx )
#define BlotScaledImageSizedEx             LEVEL_ALIAS(BlotScaledImageSizedEx )
#define plot                               LEVEL_ALIAS(plot )
#define plotalpha                          LEVEL_ALIAS(plotalpha )
#error 566
#define getpixel                           LEVEL_ALIAS(getpixel )
#define do_line                            LEVEL_ALIAS(do_line )
#define do_lineAlpha                       LEVEL_ALIAS(do_lineAlpha )
#define do_hline                           LEVEL_ALIAS(do_hline )
#define do_vline                           LEVEL_ALIAS(do_vline )
#define do_hlineAlpha                      LEVEL_ALIAS(do_hlineAlpha )
#define do_vlineAlpha                      LEVEL_ALIAS(do_vlineAlpha )
#define GetDefaultFont                     LEVEL_ALIAS(GetDefaultFont )
#define GetFontHeight                      LEVEL_ALIAS(GetFontHeight )
#define GetStringSizeFontEx                LEVEL_ALIAS(GetStringSizeFontEx )
#define PutCharacterFont                   LEVEL_ALIAS(PutCharacterFont )
#define PutCharacterVerticalFont           LEVEL_ALIAS(PutCharacterVerticalFont )
#define PutCharacterInvertFont             LEVEL_ALIAS(PutCharacterInvertFont )
#define PutCharacterVerticalInvertFont     LEVEL_ALIAS(PutCharacterVerticalInvertFont )
#define PutStringFontEx                    LEVEL_ALIAS(PutStringFontEx )
#define PutStringVerticalFontEx            LEVEL_ALIAS(PutStringVerticalFontEx )
#define PutStringInvertFontEx              LEVEL_ALIAS(PutStringInvertFontEx )
#define PutStringInvertVerticalFontEx      LEVEL_ALIAS(PutStringInvertVerticalFontEx )
#define GetMaxStringLengthFont             LEVEL_ALIAS(GetMaxStringLengthFont )
#define GetImageSize                       LEVEL_ALIAS(GetImageSize )
#define LoadFont                           LEVEL_ALIAS(LoadFont )
#define UnloadFont                         LEVEL_ALIAS(UnloadFont )
#define ColorAverage                       LEVEL_ALIAS(ColorAverage)
#define SyncImage                          LEVEL_ALIAS(SyncImage )
#define IntersectRectangle                 LEVEL_ALIAS( IntersectRectangle )
#define MergeRectangle                     LEVEL_ALIAS(MergeRectangle)
#define GetImageSurface                    LEVEL_ALIAS(GetImageSurface)
#define SetImageAuxRect                    LEVEL_ALIAS(SetImageAuxRect)
#define GetImageAuxRect                    LEVEL_ALIAS(GetImageAuxRect)
#define OrphanSubImage                     LEVEL_ALIAS(OrphanSubImage)
#define GetGlobalFonts                     LEVEL_ALIAS(GetGlobalFonts)
#define AdoptSubImage                      LEVEL_ALIAS(AdoptSubImage)
#define InternalRenderFont          LEVEL_ALIAS(InternalRenderFont)
#define InternalRenderFontFile      LEVEL_ALIAS(InternalRenderFontFile)
#define RenderScaledFontData              LEVEL_ALIAS(RenderScaledFontData)
#define RenderFontData              LEVEL_ALIAS(RenderFontData)
#define RenderFontFileScaledEx              LEVEL_ALIAS(RenderFontFileScaledEx)
#endif
_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::d3d11::Interface;
#else
	using namespace sack::image::Interface;
#endif
#endif
// these macros provide common extensions for
// commonly used shorthands of the above routines.
// no worry - one way or another, the extra data is
// created, and the base function called, it's a sad
// truth of life, that one codebase is easier to maintain
// than a duplicate copy for each minor case.
// although - special forwards - such as DBG_SRC will just dissappear
// in certain compilation modes (NON_DEBUG)
/* <combine sack::image::BuildImageFileEx@PCOLOR@uint32_t@uint32_t>
   \ \                                                           */
#define BuildImageFile(p,w,h) BuildImageFileEx( p,w,h DBG_SRC )
/* <combine sack::image::MakeImageFileEx@uint32_t@uint32_t>
   \ \                                                   */
#define MakeImageFile(w,h) MakeImageFileEx( w,h DBG_SRC )
/* <combine sack::image::MakeSubImageEx@Image@int32_t@int32_t@uint32_t@uint32_t>
   \ \                                                                  */
#define MakeSubImage( image, x, y, w, h ) MakeSubImageEx( image, x, y, w, h DBG_SRC )
/* <combine sack::image::RemakeImageEx@Image@PCOLOR@uint32_t@uint32_t>
   \ \                                                              */
#define RemakeImage(p,pc,w,h) RemakeImageEx(p,pc,w,h DBG_SRC)
/* <combine sack::image::ResizeImageEx@Image@uint32_t@uint32_t>
   \ \                                                              */
#define ResizeImage( p,w,h) ResizeImageEx( p,w,h DBG_SRC )
/* <combine sack::image::UnmakeImageFileEx@Image pif>
   Destroys an image. Does not automatically destroy child
   images created on the image.
   Parameters
   Image :  an image to destroy
   Example
   <code lang="c++">
   Image image = MakeImageFile( 100, 100 );
   UnmakeImageFile( image );
   </code>                                                 */
#define UnmakeImageFile(pif) UnmakeImageFileEx( pif DBG_SRC )
/* <combine sack::image::MakeSpriteImageEx@Image image>
   \ \                                                  */
#define MakeSpriteImage(image) MakeSpriteImageEx(image DBG_SRC)
/* <combine sack::image::MakeSpriteImageFileEx@CTEXTSTR fname>
   \ \                                                         */
#define MakeSpriteImageFile(file) MakeSpriteImageFileEx( image DBG_SRC )
/* This function flips an image top to bottom. This if for
   building windows compatible images. Internally images are
   kept in platform-native direction. If an image is created
   from another source, this might be a method to flip the image
   top-to-bottom if required.
   Parameters
   pImage :                           Image to flip.
   <link sack::DBG_PASS, DBG_PASS> :  _nt_
   Note
   There has been a warning around flip image for a while, it
   does its job right now (reversing jpeg images on windows),
   but not necessarily suited for the masses.                    */
IMAGE_PROC  void IMAGE_API  FlipImageEx ( Image pif DBG_PASS );
/* <combine sack::image::FlipImageEx@Image pif>
   \ \                                          */
#define FlipImage(pif) FlipImageEx( pif DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFile(file) LoadImageFileEx( file DBG_SRC )
/* <combine sack::image::LoadImageFileEx@CTEXTSTR name>
   \ \                                                  */
#define LoadImageFileFromGroup(group,file) LoadImageFileFromGroupEx( group, file DBG_SRC )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImageTo(img,color) BlatColor(img,0,0,(img)->width,(img)->height, color )
/* <combine sack::image::BlatColor@Image@int32_t@int32_t@uint32_t@uint32_t@CDATA>
   \ \                                                            */
#define ClearImage(img) BlatColor(img,0,0,(img)->width,(img)->height, 0 )
/* Copy one image to another. Copies the source from 0,0 to the
   destination 0,0 of the minimum width and height of the
   smaller of the source or destination.
   Parameters
   pifDest :  Image to copy to
   pifSrc :   Image to copy from
   X :        left coordinate to copy image to
   Y :        upper coordinate to copy image to
   Example
   This creates an image to write to, creates an image to copy
   (a 64 by 64 square that is filled with 50% green color). And
   copies the image to the output buffer.
   <code>
   Image output = MakeImageFile( 1024, 768 );
   Image source = MakeImageFile( 64, 64 );
   // 50% transparent
   ClearImageTo( source, SetAlpha( BASE_COLOR_GREEN, 128 ) );
   ClearImage( output );
   BlotImage( output, source, 100, 100 );
   BlotImageAlpha( output, source, 200, 200 );
   </code>                                                      */
#define BlotImage( pd, ps, x, y ) BlotImageEx( pd, ps, x, y, 0, BLOT_COPY )
/* Output a sliced image to an image surface
  sliced images scale center portions, but copy output corner images
  */
#define BlotSlicedImage( pd, ps, x, y, w, h ) BlotSlicedImageEx( pd, ps, x, y, w, h, ALPHA_TRANSPARENT, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to <link sack::image::AlphaModifier, Alpha>
                  \: Specify how to write the alpha                            */
#define BlotImageAlpha( pd, ps, x, y, a ) BlotImageEx( pd, ps, x, y, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSized( pd, ps, x, y, w, h ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, TRUE, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedAlpha( pd, ps, x, y, w, h, a ) BlotImageSizedEx( pd, ps, x, y, 0, 0, w, h, a, BLOT_COPY )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageSizedTo( pd, ps, xd, yd, xs, ys, w, h )  BlotImageSizedEx( pd, ps, xd, yd, xs, ys, w, h, TRUE, BLOT_COPY )
/* Copy one image to another at the specified coordinate in the
   destination. Shade the image on copy with a color.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   Color :        color to multiply the source color by to shade
                  on copy.                                       */
#define BlotImageShaded( pd, ps, xd, yd, c ) BlotImageEx( pd, ps, xd, yd, TRUE, BLOT_SHADED, c )
/* <combine sack::image::BlotImageSizedEx@Image@Image@int32_t@int32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                         */
#define BlotImageShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, c ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_SHADED, c )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShaded( pd, ps, xd, yd, r, g, b ) BlotImageEx( pd, ps, xd, yd, ALPHA_TRANSPARENT, BLOT_MULTISHADE, r, g, b )
/* Copy one image to another at the specified coordinate in the
   destination. Scale RGB channels to specified colors.
   Parameters
   Destination :  Image to output to
   Source :       Image to copy
   X :            Location to copy to
   Y :            Location to copy to
   X_source :     the left coordinate of the image source
   Y_source :     the top coordinate of the image source
   Width :        How wide to copy the image
   Height :       How wide to copy the image
   color :        color mutiplier to shade the image.           */
#define BlotImageMultiShadedSized( pd, ps, xd, yd, xs, ys, ws, hs, r, g, b ) BlotImageSizedEx( pd, ps, xd, yd, xs, ys, ws, hs, TRUE, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSized( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedMultiShaded( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs,r,g,b ) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, xs, ys, ws, hs, 0, BLOT_MULTISHADE,r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedTo( pd, ps, xd, yd, wd, hd) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToAlpha( pd, ps, xd, yd, wd, hd, a) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShaded( pd, ps, xd, yd, wd, hd,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToShadedAlpha( pd, ps, xd, yd, wd, hd,a,shade) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShaded( pd, ps, xd, yd, wd, hd,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, 0,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageSizedToMultiShadedAlpha( pd, ps, xd, yd, wd, hd,a,r,g,b) BlotScaledImageSizedEx( pd, ps, xd, yd, wd, hd, 0, 0, (ps)->width, (ps)->height, a,BLOT_MULTISHADE, r,g,b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageAlpha( pd, ps, t ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShadedAlpha( pd, ps, t, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShadedAlpha( pd, ps, t, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, t, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImage( pd, ps ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_COPY )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageShaded( pd, ps, shade ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_SHADED, shade )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageMultiShaded( pd, ps, r, g, b ) BlotScaledImageSizedEx( pd, ps, 0, 0, (pd)->width, (pd)->height, 0, 0, (ps)->width, (ps)->height, 0, BLOT_MULTISHADE, r, g, b )
/* <combine sack::image::BlotScaledImageSizedEx@Image@Image@int32_t@int32_t@uint32_t@uint32_t@int32_t@int32_t@uint32_t@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                                                       */
#define BlotScaledImageTo( pd, ps )  BlotScaledImageToEx( pd, ps, FALSE, BLOT_COPY )
/* now why would we need an inverse line? I don't get it....
   anyhow this would draw from the end to the start... basically
   this accounts for rounding errors on the orward way.          */
#define do_inv_line(pb,x,y,xto,yto,d) do_line( pb,y,x,yto,xto,d)
/* <combine sack::image::PutCharacterFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                               */
#define PutCharacter(i,x,y,fore,back,c)               PutCharacterFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   Passes default font if not specified.                                                     */
#define PutCharacterVertical(i,x,y,fore,back,c)       PutCharacterVerticalFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                     */
#define PutCharacterInvert(i,x,y,fore,back,c)         PutCharacterInvertFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVertical(i,x,y,fore,back,c) PutCharacterInvertVerticalFont(i,x,y,fore,back,c,NULL )
/* <combine sack::image::PutCharacterVerticalInvertFont@Image@int32_t@int32_t@CDATA@CDATA@TEXTCHAR@SFTFont>
   \ \                                                                                             */
#define PutCharacterInvertVerticalFont(i,x,y,fore,back,c,f) PutCharacterVerticalInvertFont(i,x,y,fore,back,c,f )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutString(pi,x,y,fore,back,pc) PutStringFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringEx(pi,x,y,color,back,pc,len) PutStringFontEx( pi, x, y, color,back,pc,len,NULL )
/* <combine sack::image::PutStringFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                  */
#define PutStringFont(pi,x,y,fore,back,pc,font) PutStringFontEx(pi,x,y,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVertical(pi,x,y,fore,back,pc) PutStringVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalEx(pi,x,y,color,back,pc,len) PutStringVerticalFontEx( pi, x, y, color,back,pc,len,NULL )
/* <combine sack::image::PutStringVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                          */
#define PutStringVerticalFont(pi,x,y,fore,back,pc,font) PutStringVerticalFontEx(pi,x,y,fore,back,pc,StrLen(pc), font )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvert( pi, x, y, fore, back, pc ) PutStringInvertFontEx( pi, x, y, fore, back, pc,StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                        */
#define PutStringInvertEx( pi, x, y, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   The non Ex Version doesn't pass the string length.                                         */
#define PutStringInvertFont( pi, x, y, fore, back, pc, nLen ) PutStringInvertFontEx( pi, x, y, fore, back, pc, StrLen(pc), font )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVertical( pi, x, y, fore, back, pc ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalEx( pi, x, y, fore, back, pc, nLen ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, nLen, NULL )
/* <combine sack::image::PutStringInvertVerticalFontEx@Image@int32_t@int32_t@CDATA@CDATA@CTEXTSTR@uint32_t@SFTFont>
   \ \                                                                                                */
#define PutStringInvertVerticalFont( pi, x, y, fore, back, pc, font ) PutStringInvertVerticalFontEx( pi, x, y, fore, back, pc, StrLen(pc), font )
//IMG_PROC uint32_t PutMenuStringFontEx        ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutMenuStringFont(img,x,y,fore,back,string,font) PutMenuStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutMenuString(img,x,y,fore,back,str)           PutMenuStringFont(img,x,y,fore,back,str,NULL)
//
//IMG_PROC uint32_t PutCStringFontEx           ( ImageFile *pImage, int32_t x, int32_t y, CDATA color, CDATA background, CTEXTSTR pc, uint32_t nLen, PFONT font );
//#define PutCStringFont(img,x,y,fore,back,string,font) PutCStringFontEx( img,x,y,fore,back,string,StrLen(string),font)
//#define PutCString( img,x,y,fore,back,string) PutCStringFont(img,x,y,fore,back,string,NULL )
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeEx(s,len,pw,ph) GetStringSizeFontEx( (s),len,pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@size_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                         */
#define GetStringSize(s,pw,ph)       GetStringSizeFontEx( (s),StrLen(s),pw,ph,NULL)
/* <combine sack::image::GetStringSizeFontEx@CTEXTSTR@uint32_t@uint32_t *@uint32_t *@SFTFont>
   \ \                                                                      */
#define GetStringSizeFont(s,pw,ph,f) GetStringSizeFontEx( (s),StrLen(s),pw,ph,f )
#ifdef __cplusplus
IMAGE_NAMESPACE_END
#ifdef _D3D_DRIVER
using namespace sack::image::d3d;
#elif defined( _D3D10_DRIVER )
using namespace sack::image::d3d10;
#elif defined( _D3D11_DRIVER )
using namespace sack::image::d3d11;
#else
using namespace sack::image;
#endif
#endif
#endif
/*   */
#ifndef __NO_INTERFACES__
   // for interface, can omit if no interfaces
#endif
#ifndef __NO_MSGSVR__
  // for interface across the message service
#ifndef MESSAGE_SERVICE_PROTOCOL
#define MESSAGE_SERVICE_PROTOCOL
#ifdef __cplusplus
using namespace sack;
#endif
#ifdef __cplusplus
#define _MSG_NAMESPACE  namespace msg {
#define _PROTOCOL_NAMESPACE namespace protocol {
#define MSGPROTOCOL_NAMESPACE namespace sack { _MSG_NAMESPACE _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END }} }
#else
#define _MSG_NAMESPACE
#define _PROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE
#define MSGPROTOCOL_NAMESPACE_END
#endif
SACK_NAMESPACE
	/* This namespace contains an implmentation of inter process
	   communications using a set of message queues which result
	   from 'msgget' 'msgsnd' and 'msgrcv'. This are services
	   available under a linux kernel. Reimplemented a version to
	   service for windows. This is really a client/service
	   registration and message routing system, it is not the
	   message queue itself. See <link sack::containers::message, message>
	   for the queue implementation (again, under linux, does not
	   use this custom queue).
	   See Also
	   RegisterService
	   LoadService                                                         */
	_MSG_NAMESPACE
/* Defines structures and methods for receiving and sending
	   messages. Also defines some utility macros for referencing
		message ID from a user interface structure.                */
	_PROTOCOL_NAMESPACE
#define MSGQ_ID_BASE WIDE("Srvr")
// this is a fun thing, in order to use it,
// undefine MyInterface, and define your own to your
// library's interface structure name (the tag of the structure)
#define MSG_ID(method)  BASE_MESSAGE_ID,( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) +  MSG_EventUser )
#define MSG_OFFSET(method)  ( ( offsetof( struct MyInterface, _##method ) / sizeof( void(*)(void) ) ) + MSG_EventUser )
#define INTERFACE_METHOD(type,name) type (CPROC*_##name)
// this is the techincal type of SYSV IPC MSGQueues
#define MSGIDTYPE long
#ifdef __64__
#  ifdef __LINUX__
#    define _MsgID_f  _64fs
#  else
#    define _MsgID_f  _32fs
#  endif
#else
#  define _MsgID_f  _32fs
#endif
// this will determine the length of parameter list
// based on the first and last parameters.
#define ParamLength( first, last ) ( ((uintptr_t)((&(last))+1)) - ((uintptr_t)(&(first))) )
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef PREFIX_PACKED struct buffer_len_tag {
	CPOINTER buffer;
	size_t len;
} PACKED BUFFER_LENGTH_PAIR;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// Dispach Pending - particularly display mouse event messages
//                   needed to be accumulated before being dispatched
//                   this event is generated when no more messages
//                   have been received.
#define MSG_EventDispatchPending   0
#define MSG_DispatchPending   MSG_EventDispatchPending
// these are event message definitions.
// server events come through their function table, clients
// register an event handler... these are low numbered since
// they are guaranteed from the client/server respectively.
// Mate ended - for the client, this means that the server
//              has become defunct.  For the server, this
//              means that a client is no longer present.
//              also issued when a client volentarily leaves
//              which in effect is the same as being discovered gone.
//    param[0] = Process ID of client disconnecting
//  result_length = INVALID_INDEX - NO RESULT DATA, PLEASE!
#define MSG_MateEnded         MSG_ServiceUnload
#define MSG_ServiceUnload     0
//#define MSG_ServiceClose    MSG_ServiceUnload
//#define MSG_ServiceUnload        MSG_MateEnded
// finally - needed to define a way for the service
// to actually know when a client connects... so that
// it may validate commands as being froma good source.
// also, a multiple service server may want this to know which
// service is being loaded.
//     params + 0 = text string of the service to load
//  on return result[1] is the number of messages this routine
//  expects.
//     result[0] is the number of events this service may generate
#define MSG_MateStarted      1
#define MSG_ServiceLoad      MSG_MateStarted
// Service is about to be unloaded - here's a final chance to
// cleanup before being yanked from existance.
// Last reference to the service is now gone, going to do the unload.
#define MSG_UndefinedMessage2      2
// no defined mesasage fo this
#define MSG_UndefinedMessage3       3
// Other messages may be filled in here...
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventUser       MSG_UserServiceMessages
#define MSG_UserServiceMessages 16
// skip a couple messages so we don't have to recompile everything
// very soon...
#define MSG_EventInternal       MSG_InternalServiceMessages
#define MSG_InternalServiceMessages 4
enum server_event_messages {
	// these messages are sent to client's event channel
	// within the space of core service requests (0-256?)
	// it's on top of client event user - cause the library
	// may also receive client_disconnect/connect messages
   //
	MSG_SERVICE_DATA = MSG_EventInternal
 // end of list - zero or more MSG_SERVICE_DATA mesasges will preceed this.
      , MSG_SERVICE_NOMORE
	, MSG_SERVICE_MAX_ID
};
enum server_failure_messages {
	CLIENT_UNKNOWN
									  , MESSAGE_UNKNOWN
 // sending server(sourced) messages to server
									  , MESSAGE_INVALID
 // could not find a service for the message.
									  , SERVICE_UNKNOWN
									  , UNABLE_TO_LOAD
};
enum service_messages {
 // no message ID 0 ever.
	INVALID_MESSAGE  = 0
 // server responce to clients - failure
							 , SERVER_FAILURE   = 0x80000000
							 // failure may result for the above reasons.
 // server responce to clients - success
							 , SERVER_SUCCESS   = 0x40000000
 // server needs more time to complete...
							 , SERVER_NEED_TIME = 0x20000000
 // server had no method to process the message
							 , SERVER_UNHANDLED = 0x10000000
 // client requests a service (load by name)
							 , CLIENT_LOAD_SERVICE = 1
 // client no longer needs a service (unload msgbase)
							 , CLIENT_UNLOAD_SERVICE
       // new client wants to connect
							 , CLIENT_CONNECT
    // client disconnects (no responce)
							 , CLIENT_DISCONNECT
             // server/client message to other requesting status
							 , RU_ALIVE
             // server/client message to other responding status
							 , IM_ALIVE
 // client register service (name, serivces, callback table.)
							 , CLIENT_REGISTER_SERVICE
 // client requests a list of services (optional param partial filter?)
                      , CLIENT_LIST_SERVICES
   // Service needs more time, and passes back a millisecond delay-reset
                      , IM_TARDY
};
#define LOWEST_BASE_MESSAGE 0x100
typedef struct ServiceRoute_tag SERVICE_ROUTE;
typedef struct ServiceRoute_tag *PSERVICE_ROUTE;
typedef struct ServiceEndPoint_tag SERVICE_ENDPOINT, *PSERVICE_ENDPOINT;
// this is part of the message structure
//
// this structure is avaialble at ((PSERVICE_ROUTE)(((uint32_t*)params)-1)[-1])
// (to explain that, the first uint32_t back is the MsgID... to get JUST the route tag
//  have to go back one Dword then back a service_route struct...
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
PREFIX_PACKED struct ServiceEndPoint_tag
{
   // remote process ID
	MSGIDTYPE process_id;
   // service (either served or connected as client) remote id
	MSGIDTYPE service_id;
}PACKED;
PREFIX_PACKED struct ServiceRoute_tag
{
   SERVICE_ENDPOINT dest;
	//MSGIDTYPE process_id;   // remote process ID
   //MSGIDTYPE service_id;   // service (either served or connected as client) remote id
   SERVICE_ENDPOINT source;
   //uint32_t source_process_id; // need this defined here anyway; so this can be used in receivers
	//uint32_t source_service_id;  // the service this is connected to, or is a connection for local ID
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
#define GetServiceRoute(data)   ((PSERVICE_ROUTE)(((uint32_t*)data)-1)-1)
// server functions will return TRUE if no failure
// server functions will return FALSE on failure
// FAILURE or SUCCESS will be returned to the client,
//   along with any result data set.
// native mode (unspecified... one would assume
// stack passing, but the world is bizarre and these are
// probably passed by registers.
typedef int (CPROC *server_message_handler)( PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
														 , uint32_t *params, size_t param_length
														 , uint32_t *result, size_t *result_length );
typedef int (CPROC *server_message_handler_ex)( uintptr_t psv
															 , PSERVICE_ROUTE SourceRouteID, uint32_t MsgID
															 , uint32_t *params, size_t param_length
															 , uint32_t *result, size_t *result_length );
// params[-1] == Source Process ID
// params[-2] == Source Route ID
typedef int (CPROC *server_function)( PSERVICE_ROUTE route, uint32_t *params, size_t param_length
										 , uint32_t *result, size_t *result_length );
typedef struct server_function_entry_tag{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR name;
#endif
	server_function function;
} SERVER_FUNCTION;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#define ServerFunctionEntry(name) { _WIDE(#name), name }
#else
#define ServerFunctionEntry(name) { name }
#endif
typedef SERVER_FUNCTION *server_function_table;
// MsgID will be < MSG_EventUser if it's a system message...
// MsgID will be service msgBase + Remote ID...
//    so the remote needs to specify a unique base... so ...
//    entries must still be used...
typedef int (CPROC*EventHandlerFunction)( MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionEx)( PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID, uint32_t*params, size_t paramlen);
typedef int (CPROC*EventHandlerFunctionExx)( uintptr_t psv, PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID
														 , uint32_t*params, size_t paramlen);
// result of EventHandlerFunction shall be one fo the following values...
//   EVENT_HANDLED
// 0 - no futher action required
//   EVENT_WAIT_DISPATCH
// 1 - when no further events are available, please send event_dispatched.
//     this Event was handled by an internal queuing for later processing.
enum EventResult {
	EVENT_HANDLED = 0,
	EVENT_WAIT_DISPATCH = 1
};
//------------------- Begin Server Message Structs ----------------
#ifdef _MSC_VER
#pragma pack (push, 1)
#endif
typedef struct MsgSvr_RegisterRequest_msg MsgSvr_RegisterRequest;
PREFIX_PACKED struct MsgSvr_RegisterRequest_msg
{
	MSGIDTYPE RouteID;
  // service_id...
   MSGIDTYPE ClientID;
}PACKED;
typedef struct MsgSrv_ReplyServiceLoad_msg MsgSrv_ReplyServiceLoad;
PREFIX_PACKED struct MsgSrv_ReplyServiceLoad_msg
{
	MSGIDTYPE ServiceID;
 // if this is a local service, it's dispatched this way?
	THREAD_ID thread;
}PACKED;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
MSGPROTOCOL_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::msg::protocol;
#endif
#endif
#endif
#ifndef SECOND_RENDER_LEVEL
#define SECOND_RENDER_LEVEL
#define PASTE(sym,name) name
#else
#define PASTE2(sym,name) sym##name
#define PASTE(sym,name) PASTE2(sym,name)
#endif
#        ifdef RENDER_LIBRARY_SOURCE
#           define RENDER_PROC(type,name) EXPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,name)
#        else
#           define RENDER_PROC(type,name) IMPORT_METHOD type CPROC PASTE(SECOND_RENDER_LEVEL,name)
#        endif
SACK_NAMESPACE
/* <copy render.h>
   \ \             */
BASE_IMAGE_NAMESPACE
/* PRENDERER is the primary object this namespace deals with.
   See Also
   <link render.h>                                            */
_RENDER_NAMESPACE
/* Application layer abstract structure to handle displays. This
 is the type returned by OpenDisplay.                          */
typedef struct HVIDEO_tag *PRENDERER;
typedef struct key_function  KEY_FUNCTION;
typedef struct key_function *PKEY_FUNCTION;
// disable this functionality, it was never fully implemented, and is a lot to document.
#if ACTIVE_MESSAGE_IMPLEMENTED
// Message IDs 0-99 are reserved for
// very core level messages.
// Message IDs 100-999 are for general purpose window input/output
// Message ID 1000+ Usable by applications to transport messages via
//                  the image's default message loop.
enum active_msg_id {
    // Message ID 0 - contains a active image to respond to
   ACTIVE_MSG_PING
    // Message ID 0 - contains a active image to respond to
   , ACTIVE_MSG_PONG
   , ACTIVE_MSG_MOUSE = 100
   , ACTIVE_MSG_GAIN_FOCUS
   , ACTIVE_MSG_LOSE_FOCUS
   , ACTIVE_MSG_DRAG
   , ACTIVE_MSG_KEY
   , ACTIVE_MSG_DRAW
   , ACTIVE_MSG_CREATE
   , ACTIVE_MSG_DESTROY
   , ACTIVE_MSG_USER = 1000
};
typedef struct {
   enum active_msg_id ID;
 // the size of the cargo potion of the message. (mostly data.raw)
   uint32_t  size;
   union {
  //--------------------
      struct {
         PRENDERER respondto;
      } ping;
  //--------------------
      struct {
         int x, y, b;
      } mouse;
  //--------------------
      struct {
         PRENDERER lose;
      } gain_focus;
  //--------------------
      struct {
         PRENDERER gain;
      } lose_focus;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } draw;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } close;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } create;
  //--------------------
      struct {
         uint8_t no_informaiton;
      } destroy;
  //--------------------
      struct {
         uint32_t key;
      } key;
  //--------------------
      uint8_t raw[1];
   } data;
} ACTIVEMESSAGE, *PACTIVEMESSAGE;
#endif
// Event Message ID's CANNOT be 0
// Message Event ID (base+0) is when the
// server teriminates, and ALL client resources
// are lost.
// Message Event ID (base+1) is when the
// final message has been received, and any
// pending events collected should be dispatched.
#ifndef __NO_MSGSVR__
enum {
   /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_CloseMethod = MSG_EventUser,
  /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_MouseMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_LoseFocusMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_KeyMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_GeneralMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_RedrawFractureMethod
 ,
 /* These are internal messages to pass to the display handling
    thread. most are unimplemented.                             */
 MSG_ThreadEventPost
};
#endif
#ifdef __WATCOMC__
#if ( __WATCOMC__ < 1291 )
#define NO_TOUCH
#endif
#endif
#ifndef WIN32
#define NO_TOUCH
#endif
#if defined( __LINUX__ )
#define NO_TOUCH
#endif
#if defined( __ANDROID__ )
// definately IS touch
#undef NO_TOUCH
#define MINGW_SUX
#endif
// static void OnBeginShutdown( "Unique Name" )( void ) { /* run shutdown code */ }
#define OnBeginShutdown(name)	 __DefineRegistryMethod(WIDE("SACK"),BeginShutdown,WIDE("System"),WIDE("Begin Shutdown"),name WIDE("_begin_shutdown"),void,(void),__LINE__)
/* function signature for the close callback  which can be specified to handle events to close the display.  see SetCloseHandler. */
typedef void (CPROC*CloseCallback)( uintptr_t psvUser );
/* function signature to define hide/restore callback, it just gets the user data of the callback... */
typedef void (CPROC*HideAndRestoreCallback)( uintptr_t psvUser );
/* function signature for the redraw callback  which can be specified to handle events to redraw the display.  see SetRedrawHandler. */
typedef void (CPROC*RedrawCallback)( uintptr_t psvUser, PRENDERER self );
/* function signature for the mouse callback  which can be specified to handle events from mouse motion on the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.*/
typedef uintptr_t  (CPROC*MouseCallback)( uintptr_t psvUser, int32_t x, int32_t y, uint32_t b );
typedef struct input_point
{
   //
	RCOORD x, y;
	struct {
  // set on first down, clear on subsequent events
		BIT_FIELD new_event : 1;
 // set on first up, clear on first down,
		BIT_FIELD end_event : 1;
	} flags;
} *PINPUT_POINT;
#ifndef NO_TOUCH
#if defined( MINGW_SUX )
/*
 * Touch input mask values (TOUCHINPUT.dwMask)
 */
  // the dwTime field contains a system generated value
#define TOUCHINPUTMASKF_TIMEFROMSYSTEM  0x0001
  // the dwExtraInfo field is valid
#define TOUCHINPUTMASKF_EXTRAINFO       0x0002
  // the cxContact and cyContact fields are valid
#define TOUCHINPUTMASKF_CONTACTAREA     0x0004
#ifndef __ANDROID__
typedef HANDLE HTOUCHINPUT;
#endif
#define WM_TOUCH 0x0240
#define TWF_FINETOUCH 0x00000001
#define TWF_WANTPALM 0x00000002
#endif
 // added to flags as touches are used.  Controls may use some of the touches but not all.
#define TOUCHEVENTF_USED 0x8000
/* function signature for the touch callback  which can be specified to handle events from touching the display.  see SetMouseHandler.
  would be 'wise' to retun 0 if ignored, 1 if observed (perhaps not used), but NOT ignored.  Return 1 if some of the touches are used.
  This will trigger a check to see if there are unused touches to continue sending... oh but on renderer there's only one callback, more
  important as a note of the control touch event handerer.
  */
typedef int  (CPROC*TouchCallback)( uintptr_t psvUser, PINPUT_POINT pTouches, int nTouches );
#endif
/* function signature for the close callback  which can be specified to handle events to redraw the display.  see SetLoseFocusHandler. */
typedef void (CPROC*LoseFocusCallback)( uintptr_t dwUser, PRENDERER pGain );
// without a keyproc, you will still get key notification in the mousecallback
// if KeyProc returns 0 or is NULL, then bound keys are checked... otherwise
// priority is given to controls with focus that handle keys.
typedef int (CPROC*KeyProc)( uintptr_t dwUser, uint32_t keycode );
// without any other proc, you will get a general callback message.
#if ACTIVE_MESSAGE_IMPLEMENTED
typedef void (CPROC*GeneralCallback)( uintptr_t psvUser
                                     , PRENDERER image
												, PACTIVEMESSAGE msg );
#endif
typedef void (CPROC*RenderReadCallback)(uintptr_t psvUser, PRENDERER pRenderer, TEXTSTR buffer, INDEX len );
// called before redraw callback to update the background on the scene...
typedef void (CPROC*_3DUpdateCallback)( uintptr_t psvUser );
//----------------------------------------------------------
//   Mouse Button definitions
//----------------------------------------------------------
// the prefix of these may either be interpreted as MAKE - as in
// a make/break state of a switch.  Or may be interpreted as
// MouseKey.... such as KB_ once upon a time stood for KeyBoard,
// and not Keebler as some may have suspected.
enum ButtonFlags {
#ifndef MK_LBUTTON
 // left mouse button  MouseKey_ ?
	MK_LBUTTON = 0x01,
#endif
#ifndef MK_MBUTTON
  // right mouse button MouseKey_ ?
	MK_RBUTTON = 0x02,
#endif
#ifndef MK_RBUTTON
  // middle mouse button MouseKey_ ?
	MK_MBUTTON = 0x10,
#endif
#ifndef MK_CONTROL
  // the control key on the keyboard
  MK_CONTROL = 0x08,
#endif
#ifndef MK_ALT
   // the alt key on the keyboard
  MK_ALT = 0x20,
#endif
#ifndef MK_SHIFT
   // the shift key on the keyboard
  MK_SHIFT = 0x40,
#endif
  // scroll wheel click down
  MK_SCROLL_DOWN  = 0x100,
  // scroll wheel click up
  MK_SCROLL_UP    = 0x200,
  // scroll wheel click left
  MK_SCROLL_LEFT  = 0x400,
  // scroll wheel click right
  MK_SCROLL_RIGHT = 0x800,
#ifndef MK_NO_BUTTON
// used to indicate that there is
// no known button information available.  The mouse
// event which triggered this was beyond the realm of
// this mouse handler, but it is entitled to know that
// it now knows nothing.
  MK_NO_BUTTON = 0xFFFFFFFF,
#endif
// this bit will NEVER NEVER NEVER be set
// for ANY reason whatsoever. ( okay except when it's in MK_NO_BUTTON )
  MK_INVALIDBUTTON = 0x80000000,
// One or more other buttons were pressed.  These
// buttons are available by querying the keyboard state.
 // any other button (keyboard)
  MK_OBUTTON = 0x80,
 // any other button (keyboard) went up
  MK_OBUTTON_UP = 0x1000
};
// mask to test to see if some button (physical mouse, not logical)
// is currently pressed...
#define MK_SOMEBUTTON       (MK_LBUTTON|MK_RBUTTON|MK_MBUTTON)
// test to see if any button is clicked */
#define MAKE_SOMEBUTTONS(b)     ((b)&(MK_SOMEBUTTON))
// test to see if a specific button is clicked
#define BUTTON_STILL_DOWN(b,button)     ((b)&(button))
// test a button variable to see if no buttons are currently pressed
// NOBUTTON, NOBUTTONS may be confusing, consider renaming these....
#define MAKE_NOBUTTONS(b)     ( !((b) & MK_SOMEBUTTON ) )
// break of some button
#define BREAK_NEWBUTTON(b,_b) ((((b)^(_b))&(_b))&MK_SOMEBUTTON)
// break a specific button (the last up of the button)
#define BREAK_A_BUTTON(b,_b,button) ((((b)^(_b))&(_b))&(button))
// make of some button (the first down of a button)
#define MAKE_NEWBUTTON(b,_b) ((((b)^(_b))&(b))&MK_SOMEBUTTON)
// make a specific button (the first down of the button)
#define MAKE_A_BUTTON(b,_b,button) ((((b)^(_b))&(b))&(button))
// test current b vs prior _b to see if the  last button pressed is
// now not pressed...
#define BREAK_LASTBUTTON(b,_b)  ( BREAK_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(b) )
// test current b vs prior _b to see if there is now some button pressed
// when previously there were no buttons pressed...
#define MAKE_FIRSTBUTTON(b,_b) ( MAKE_NEWBUTTON(b,_b) && MAKE_NOBUTTONS(_b) )
// these button states may reflect the current
// control, alt, shift key states.  There may be further
// definitions (meta?) And as of the writing of this comment
// these states may not be counted on, if you care about these
// please do validate that the code gives them to you all the way
// from the initial mouse message through all layers to the final
// application handler.
//----------------------------------------------------------
enum DisplayAttributes {
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_ALPHA    = 0x10000,
   /* when used by the Display Lib manager, this describes how to manage the subsurface */
  PANEL_ATTRIBUTE_HOLEY    = 0x20000,
// when used by the Display Lib manager, this describes how to manage the subsurface
// focus on this window excludes any of it's parent/sibling panels
// from being able to focus.
  PANEL_ATTRIBUTE_EXCLUSIVE = 0x40000,
// when used by the Display Lib manager, this describes how to manage the subsurface
// child attribute affects the child is contained within this parent
  PANEL_ATTRIBUTE_INTERNAL  = 0x88000,
    // open the window as layered - allowing full transparency.
  DISPLAY_ATTRIBUTE_LAYERED = 0x0100,
    // window will not be in alt-tab list
  DISPLAY_ATTRIBUTE_CHILD = 0x0200,
    // set to WS_EX_TRANSPARENT - all mouse is passed, regardless of alpha/shape
  DISPLAY_ATTRIBUTE_NO_MOUSE = 0x0400,
    // when created, the display does not attempt to set itself into focus, otherwise we try to focus self.
  DISPLAY_ATTRIBUTE_NO_AUTO_FOCUS = 0x0800,
  // when created, set topmost as soon as possible
  DISPLAY_ATTRIBUTE_TOPMOST = 0x1000,
};
 // does not HAVE to be called but may
    RENDER_PROC( int , InitDisplay) (void);
	 // this generates a mouse event though the mouse system directly
    // there is no queuing, and the mouse is completed before returning.
    RENDER_PROC( void, GenerateMouseRaw)( int32_t x, int32_t y, uint32_t b );
	 /* Create mouse events to self?
	    Parameters
	    x :  x of the mouse
	    y :  y of the mouse
	    b :  buttons of the mouse    */
	 RENDER_PROC( void, GenerateMouseDeltaRaw )( int32_t x, int32_t y, uint32_t b );
    /* Sets the title of the application window. Once upon a time,
       applications only were able to make a SINGLE window. Internally,
       all windows are mounted against a hidden application window,
       and this appilcation window gets the title.
       Parameters
       title :  Title for the application                               */
    RENDER_PROC( void , SetApplicationTitle) (const TEXTCHAR *title );
    /* Sets the title of the window (shows up in windows when
       alt-tabbing). Also shows up on the task tray icon (if there
       is one)
       Parameters
       render :  display to set the title of
       title :   new text for the title.                           */
    RENDER_PROC( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
    /* Sets the icon to show for the application's window.
       Parameters
       Icon :  this really has to be an HICON I think... it's for
               setting the icon on Windows' windows.              */
    RENDER_PROC( void , SetApplicationIcon)  (Image Icon);
    /* Gets the size of the default desktop screen.
       Parameters
       width :   pointer to a 32 value for the display's width.
       height :  pointer to a 32 value for the display's height.
       Example
       <code lang="c++">
       uint32_t w, h;
       GetDisplaySize( &amp;w, &amp;h );
       </code>
       See Also
       <link sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *, GetDisplaySizeEx> */
    RENDER_PROC( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
	 /* \ \
	    Parameters
	    nDisplay :  display to get the coordinates of. 0 is the
	                default display from GetDesktopWindow(). 1\-n are
	                displays for multiple display systems, 1,2,3,4
	                etc..
	    x :         left screen coordinate of this display
	    y :         top screen coordinate of this display
	    width :     how wide this display is
	    height :    how tall this display is
	    Example
	    <code lang="c#">
	    int32_t x, y;
	    uint32_t w, h;
	    GetDisplaySizeEx( 1, &amp;x, &amp;y, &amp;w, &amp;h );
	    </code>                                                       */
	 RENDER_PROC (void, GetDisplaySizeEx) ( int nDisplay
													  , int32_t *x, int32_t *y
													  , uint32_t *width, uint32_t *height);
    /* Sets the first displayed physical window to a certain size. This
       should actually adjust the screen size. Like GetDisplaySize
       \returns the size of the actual display, this should set the
       size of the actual display.
       Parameters
       width :   new width of the screen
       height :  new height of the screen.                              */
    RENDER_PROC( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
#ifdef WIN32
    /* Enable logging when updates happen to the real display.
       Parameters
       bEnable :  TRUE to enable, FALSE to disable.            */
    RENDER_PROC (void, EnableLoggingOutput)( LOGICAL bEnable );
	 /* A method to promote any arbitrary HWND to a PRENDERER. This
	    can be used to put SACK display surfaces in .NET
	    applications.
	    Parameters
	    hWnd :  HWND to make into a renderer.
	    Returns
	    PRENDERER new renderer that uses HWND to update to.         */
	 RENDER_PROC (PRENDERER, MakeDisplayFrom) (HWND hWnd);
#endif
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display                                         */
    RENDER_PROC( PRENDERER, OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.                                               */
    RENDER_PROC( PRENDERER, OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* This opens a display for output. It is opened hidden, so the
       application might draw to its surface before it is shown.
       This is not the most capable creation routine, but it is the
       most commonly aliased.
       Parameters
       attributes :  one or more <link sack::image::render::DisplayAttributes, DisplayAttributes>
                     or'ed togeteher.
       width :       width of the display
       height :      height of the display
       x :           x position of left the display
       y :           y position of the top of the display
       above :       display to put this one above.
       below :       display to put this one under. (for building
                     behind a cover window)                                                       */
    RENDER_PROC( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	 /* Sets the alpha level of the overall display window.
	    Parameters
	    hVideo :  display to set the overall fade level on
	    level :   the level of fade from 0 (transparent) to 255
	              (opaque)
	    Example
	    <code lang="c++">
	    PRENDERER render = OpenDisplay( 0 );
	    int i;
	    UpdateDisplay( render );
	    </code>
	    <code>
	    // the window will slowly fade out
	    for( i = 255; i \> 0; i-- )
	    </code>
	    <code lang="c++">
	        SetDisplayFade( render, i );
	    CloseDisplay( render );  // Hiding the display works too, if it is to be reused.
	    </code>                                                                          */
	 RENDER_PROC( void, SetDisplayFade )( PRENDERER hVideo, int level );
    /* closes a display, releasing all resources assigned to it.
       Parameters
       hDisplay :  Render display to close.                      */
    RENDER_PROC( void         , CloseDisplay) ( PRENDERER );
    /* Updates just a portion of a display window. Minimizing the
       size required for screen output greatly increases efficiency.
       Also on vista+, this will update just a portion of a
       transparent display.
       Parameters
       hVideo :  the display to update
       x :       the left coordinate of the region to update
       y :       the top coordinate of the region to update
       width :   the width of the region to update
       height :  the height of the region to update
       DBG_PASS information is used to track who is doing updates
       when update logging is enabled.                               */
    RENDER_PROC( void , UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
/* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
   \ \                                                                                      */
#define UpdateDisplayPortion(r,x,y,w,h) UpdateDisplayPortionEx(r,x,y,w,h DBG_SRC )
	 /* Updates the entire surface of a display.
	    Parameters
	    display :  display to update
	    DBG_PASS information is passed for logging writing to
	    physical display.
	                                                          */
	 RENDER_PROC( void , UpdateDisplayEx)        ( PRENDERER DBG_PASS );
#define UpdateDisplay(r) UpdateDisplayEx(r DBG_SRC)
/* Gets the current location and size of a display.
       Parameters
       hVideo :  display to get the position of
       x :       pointer to a signed 32 bit value to get the left
                 edge of the display.
       y :       pointer to a signed 32 bit value to get the top edge
                 of the display.
       width :   pointer to a unsigned 32 bit value to get the width.
       height :  pointer to a unsigned 32 bit value to get the
                 height.                                              */
    RENDER_PROC( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* Moves a display to an absolute position.
       Parameters
       render :  the display to move
       x :       new X coordinate for the left of the display
       y :       new Y coordinate for the top of the display  */
    RENDER_PROC( void , MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* Moves a display relative to its current position.
       Parameters
       render :  the display to move
       delx :    a signed amount to add to its X coordiante
       dely :    a signed amount ot add to its Y coordinate. ( bigger
                 values go down the screen )                          */
    RENDER_PROC( void , MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* Sets the display's current size. If it is different than
       before, will invoke render's redraw callback.
       Parameters
       display :  the display to set the size of
       w :        new width of the display
       h :        new height of the display                     */
    RENDER_PROC( void , SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* Sets the display's current size relative to what it currently
       is. If it is different than before, will invoke render's
       redraw callback.
       Parameters
       display :  the display to set the size of
       w :        signed value to add to current width
       h :        signed value to add to current height              */
    RENDER_PROC( void , SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
   /* Change the position and size of a display.
      Parameters
      hVideo :  display to move and size
      x :       new left coordinate of the display
      y :       new top coordinate of the display
      w :       new width of the display
      h :       new height of the display          */
   RENDER_PROC( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* Moves and changes the display size relative to its current
      size. All parameters are relative to current.
      Parameters
      hVideo :  display to move and change the size of
      delx :    amount to modify the left coordinate by
      dely :    amount to modify the top coordinate by
      delw :    amount to change the width by
      delh :    amount to change the height by                   */
   RENDER_PROC( void, MoveSizeDisplayRel )( PRENDERER hVideo
                                        , int32_t delx, int32_t dely
                                        , int32_t delw, int32_t delh );
		/* Put the display above another display. This makes sure that
		   the displays are stacked at least in this order.
		   Parameters
		   this_display :  the display to put above another
		   that_display :  the display that will be on the bottom.     */
		RENDER_PROC( void , PutDisplayAbove)      ( PRENDERER this_display, PRENDERER that_display );
      /* put this in container
	   Parameters
	   hVideo :      Display to put into another display surface
	   hContainer :  The new parent window of the hVideo.
	   Example
	   <code lang="c#">
	   Render render = OpenDisplay( 0 );
	   Render parent = OpenDisplay( 0 );
	   PutDisplayIn( render, parent );
	   </code>                                                   */
	 RENDER_PROC (void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
    /* Gets the Image from the Render.
       Parameters
       renderer :  the display window to get the surface of.
       Returns
       Image that is the surface of the window to draw to.   */
    RENDER_PROC( Image , GetDisplayImage)     ( PRENDERER );
    /* Sets the close handler callback. Called when a window is
       closed externally.
       Parameters
       hVideo :     display to set the close handler for
       callback :   close method to call when the display is called
       user_data :  user data passed to close method when invoked.  */
    RENDER_PROC( void , SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* Specifies the mouse event handler for a display.
       Parameters
       hVideo :     display to set the mouse handler for
       callback :   the routine to call when a mouse event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* Specifies the hide event handler for a display.
       Parameters
       hVideo :     display to set the hide handler for
       callback :   the routine to call when a hide event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* Specifies the restore event handler for a display.
       Parameters
       hVideo :     display to set the restore handler for
       callback :   the routine to call when a restore event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
    RENDER_PROC( void , SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
#ifndef NO_TOUCH
    /* Specifies the touch event handler for a display.
       Parameters
       hVideo :     display to set the touch handler for
       callback :   the routine to call when a touch event happens.
       user_data :  this value is passed to the callback routine when
                    it is called.                                     */
	   RENDER_PROC( void , SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
	 /* Sets the function to call when a redraw event is required.
	    Parameters
	    hVideo :     display to set the handler for
	    callback :   function to call when a redraw is required (or
	                 requested).
	    user_data :  this value is passed to the redraw callback.
	    Example
	    See <link render.h>
	    See Also
	    <link sack::image::render::Redraw@PRENDERER, Redraw>        */
	 RENDER_PROC( void , SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
	 // call this to call the callback registered. as appropriate.  Said callback
    // should never be directly called by application.
    RENDER_PROC( void, Redraw )( PRENDERER hVideo );
    /* Sets the keyboard handler callback for a display
       Parameters
       hVideo :     display to receive key events for.
       callback :   callback invoked when a key event happens.
       user_data :  user data passed to the callback when invoked.
       Remarks
       the keyboard handler may make use of the scan code itself for
       PKEYDEFINE structures. There are also a variety of methods
       for checking the 32 bit key value. The value passed to the
       keyboard handler contains most all of the information about
       the state of the keyboard and specific key.                   */
    RENDER_PROC( void , SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* Sets a callback handler called when focus is gained or lost
       by the display.
       Parameters
       hVideo :     display to set the event on
       callback :   the user callback to call when focus is lost or
                    gained.
       user_data :  user data passed to the callback when invoked.
       Note
       When the LoseFocusCallback is called, the renderer is the one
       that is getting the focus. This may be you, may be NULL
       (everyone losing focus) or may be another PRENDERER in your
       application.                                                  */
    RENDER_PROC( void , SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* Undefined */
    RENDER_PROC( void, SetRenderReadCallback )( PRENDERER pRenderer, RenderReadCallback callback, uintptr_t psv );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( void , SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#endif
    /* Receives the current global mouse state, and position in
       screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse X position.
       y :  pointer to a signed 32 bit value for the mouse Y position.
       b :  current state of mouse buttons. See <link sack::image::render::ButtonFlags, ButtonFlags>. */
    RENDER_PROC( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
    /* Gets the current mouse position in screen coordinates.
       Parameters
       x :  pointer to a signed 32 bit value for the mouse position
       y :  pointer to a signed 32 bit value for the mouse position
       Example
       <code lang="c++">
       int32_t x, y;
       GetMousePosition( &amp;x, &amp;y );
       </code>                                                      */
    RENDER_PROC( void , GetMousePosition)     ( int32_t *x, int32_t *y );
    /* Sets the mouse pointer at the specified display coordinates.
       Parameters
       hDisplay :  display to use to where to position the mouse. Will
                   fault if NULL is passed.
       x :         x relative to the display to set the mouse
       y :         y relative to the display to set the mouse          */
    RENDER_PROC( void , SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* Test a display to see if it is focused.
       Parameters
       hVideo :  display to check to see if it has focus. (keyboard
                 \input)
       Returns
       TRUE if focused, else FALSE.                                 */
    RENDER_PROC( LOGICAL , HasFocus)          ( PRENDERER );
#if ACTIVE_MESSAGE_IMPLEMENTED
    RENDER_PROC( int, SendActiveMessage)     ( PRENDERER dest, PACTIVEMESSAGE msg );
    RENDER_PROC( PACTIVEMESSAGE , CreateActiveMessage) ( int ID, int size, ... );
#endif
    /* Translates a key's scancode into text. Handles things like
       capslock, shift...
       Parameters
       key :  KEY_ to translate
       Returns
       char that the key represents. (should implement a method to
       get back the UNICODE character).                            */
    RENDER_PROC( const TEXTCHAR *, GetKeyText)             ( int key );
    /* Simple check to see if a key is in a pressed state.
       Parameters
       display :  display to check the key state in
       key :      KEY_ symbol to check.                    */
    RENDER_PROC( uint32_t, IsKeyDown )              ( PRENDERER display, int key );
    /* \ \
       Parameters
       display :  display to test the key status in
       key :      KEY_ symbol to check if the key is pressed
       Returns
       TRUE if the key is down, else FALSE.                  */
    RENDER_PROC( uint32_t, KeyDown )                ( PRENDERER display, int key );
    /* Sometimes displays can be closed by external forces (the
       close button on most windows). This tests to see if a display
       is still valid, or if it has been closed externally.
       Returns
       TRUE if display is still okay. FALSE if the display is no
       longer able to be used.
       Parameters
       display :  the display to check the validity of.              */
    RENDER_PROC( LOGICAL, DisplayIsValid )     ( PRENDERER display );
    /* Assigns all mouse input to a window. This allows the window
       to process messages which are outside of itself normally.
       Parameters
       display :  which window wants to own the mouse
       own :      1 to own, 0 to release ownership.                */
    RENDER_PROC( void, OwnMouseEx )            ( PRENDERER display, uint32_t bOwn DBG_PASS );
    /* Proprietary routine for reading touch screen serial devices
       directly and performing self calibration. Should rely on
       system driver and it's calibration instead.                 */
    RENDER_PROC( int, BeginCalibration )       ( uint32_t points );
    /* Used when display is accessed via a remote message pipe, this
       allows all render operations to be flushed and processed.
       Parameters
       display :  display to flush                                   */
    RENDER_PROC( void, SyncRender )            ( PRENDERER display );
/* Makes a display topmost. There isn't a way to un-topmost a
   window.
   Parameters
   hVideo :  display to make topmost
   Note
   Windows maintains at least two distinct stacks of windows. Normal
   windows in the normal window stack, and a set of windows that
   are above all other windows (except other windows that are
   also topmost).                                                    */
RENDER_PROC( void, MakeTopmost )( PRENDERER hVideo );
/* This makes the display topmost, but more so, any window that
   gets put over it it will attempt put itself over it.
   Parameters
   hVideo :  display to make top top most.                      */
RENDER_PROC (void, MakeAbsoluteTopmost) (PRENDERER hVideo);
/* Tests a display to see if it is set as topmost.
   Parameters
   hVideo :  display to inquire if it's topmost.
   Returns
   TRUE if display is topmost, else FALSE.         */
RENDER_PROC( int, IsTopmost )( PRENDERER hVideo );
/* Hides a display. That is, the content no longer shows on the
   users display.
   Parameters
   hVideo :  the handle of the Render to hide.
   See Also
   <link sack::image::render::RestoreDisplay@PRENDERER, RestoreDisplay> */
RENDER_PROC( void, HideDisplay )( PRENDERER hVideo );
/* Puts a display back on the screen. This is used in
   conjunction with HideDisplay().
   Parameters
   hVideo :  display to restore                       */
RENDER_PROC( void, RestoreDisplay )( PRENDERER hVideo );
	RENDER_PROC( void, RestoreDisplayEx )( PRENDERER hVideo DBG_PASS );
#define RestoreDisplay(n) RestoreDisplayEx( n DBG_SRC )
/* A check to see if HideDisplay has been applied to the
   display.
   Returns
   TRUE if the display is hidden, otherwise FALSE.
   Parameters
   video :  the display to check if hidden               */
RENDER_PROC( LOGICAL, IsDisplayHidden )( PRENDERER video );
// set focus to display, no events are generated if display already
// has the focus.
RENDER_PROC( void, ForceDisplayFocus )( PRENDERER display );
// display set as topmost within it's group (normal/bottommost/topmost)
RENDER_PROC( void, ForceDisplayFront )( PRENDERER display );
// display is force back one layer... or forced to bottom?
// alt-n pushed the display to the back... alt-tab is different...
RENDER_PROC( void, ForceDisplayBack )( PRENDERER display );
/* Not implemented on windows native, is for getting back
   display information over message service abstraction.
   if a readcallback is enabled, then this will be no-wait, and
   one will expect to receive the read data in the callback.
   Otherwise this will return any data which is present already,
   also non wait. Returns length read, INVALID_INDEX if no data
   read.
   If there IS a read callback, return will be 1 if there was no
   previous read queued, and 0 if there was already a read
   pending there may be one and only one read queued (for now)
   In either case if the read could not be queued, it will be
   0..
   If READLINE is true - then the result of the read will be a
   completed line. if there is no line present, and no callback
   defined, this will return INVALID_INDEX characters... 0
   characters is a n only (in line mode) 0 will be returned for
   no characters in non line mode...
   it will not have the end of line terminator (as generated by
   a non-bound enter key) I keep thinking there must be some
   kinda block mode read one can do, but no, uhh no, there's no
   way to get the user to put in X characters exactly....?
   Parameters
   pRenderer :  display to read from
   buffer :     buffer to read into
   maxlen :     maximum length of buffer to read
   bReadLine :  ???                                              */
RENDER_PROC( uint32_t, ReadDisplayEx )( PRENDERER pRenderer, TEXTSTR buffer, uint32_t maxlen, LOGICAL bReadLine );
/* Unused. Incomplete. */
#define ReadDisplay(r,b,len)      ReadDisplayEx(r,b,len,FALSE)
/* Unused. Incomplete. */
#define ReadDisplayLine(r,b,len)  ReadDisplayEx(r,b,len,TRUE)
/* Issues an update to a layered (transparent) window. This does
   the update directly, and does not have to be done within the
   redraw event.
   Parameters
   hVideo :    display to update a part of
   bContent :  TRUE is only the passed rectangle should update
   x :         left coordinate of the region to update to
               physical display
   y :         top coordinate of the region to update to physical
               display
   w :         width of the region to update to physical display
   h :         height of the region to update to physical display */
RENDER_PROC( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
#ifndef KEY_STRUCTURE_DEFINED
typedef LOGICAL (CPROC*KeyTriggerHandler)(uintptr_t,uint32_t keycode);
typedef struct KeyDefine *PKEYDEFINE;
#endif
/* Can create an external key binder to store key event
   bindings. One of these is available per display.
   Example
   <code lang="c++">
   void Alt_A_Pressed(uintptr_t user_data,uint32_t keycode)
   {
       // do something when alt-a is pressed.
   }
   {
      PKEYDEFINE my_key_events = CreateKeyBinder();
      BindKeyToEventEx( my_key_events, KEY_A, KEY_MOD_ALT, Alt_A_Pressed, 0 );
   }
   // then later, in a KeyProc handler...
   HandleKeyEvents( my_key_events, keycode );
   </code>                                                                     */
RENDER_PROC( PKEYDEFINE, CreateKeyBinder )( void );
/* Destroyes a PKEYDEFINE previously created with
   CreateKeyBinder.
   Parameters
   pKeyDef :  key binder to destroy.              */
RENDER_PROC( void, DestroyKeyBinder )( PKEYDEFINE pKeyDef );
/* Evaluates a key against the key defines to trigger possible
   events.
   Parameters
   KeyDefs :  PKEYDEFINE keystate which has keys bound to it.
   keycode :  the keycode passed to a KeyProc handler.         */
RENDER_PROC( int, HandleKeyEvents )( PKEYDEFINE KeyDefs, uint32_t keycode );
/* Assigns a callback routine to a key event.
   Parameters
   KeyDefs :   pointer to key table to set event in
   scancode :  scancode of the key \- this is a KEY_ code from
               keybrd.h
   modifier :  specific modifiers pressed for this event (control,
               alt, shift)
   trigger :   the trigger function to invoke when the key is
               pressed
   psv :       a uintptr_t user data passed to the trigger function
               when invoked.                                       */
RENDER_PROC( int, BindEventToKeyEx )( PKEYDEFINE KeyDefs, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Binds a key to a display.
   Parameters
   pRenderer :  display to set the event in (each display has a
                PKEYDEFINE internally. If this is NULL, then the
                event is bound to global events, an applies for
                any display window that gets a key input.
   scancode :   key scancode (a KEY_ identifier from keybrd.h)
   modifier :   key state modifier to apply to match the trigger
                on (control, alt, shift)
   trigger :    callback to invoke when the key combination is
                pressed
   psv :        user data to pass to the trigger when invoked.   */
RENDER_PROC( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
/* Remove a previous binding to a key.
   Parameters
   pRenderer :  renderer to remove the key bind from
   scancode :   key scancode to stop checking
   modifier :   key modifier to stop checking        */
RENDER_PROC( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
/* A way to test to see if the current input device is a touch
   display. This can affect how mouse clicks are handles for
   things like buttons.
   Parameters
   None.
   Returns
   0.                                                          */
RENDER_PROC( int, IsTouchDisplay )( void );
// static void OnInputTouch( "Touch Handler" )(
#define OnSurfaceInput(name)	 __DefineRegistryMethod(WIDE("sack/render"),SurfaceInput,WIDE("surface input"),WIDE("SurfaceInput"),name,void,( int nInputs, PINPUT_POINT pInputs ),__LINE__)
#ifndef PSPRITE_METHOD
/* Unused. Incomplete. */
#define PSPRITE_METHOD PSPRITE_METHOD
RENDER_NAMESPACE_END
IMAGE_NAMESPACE
   /* define sprite draw method structure */
	typedef struct sprite_method_tag *PSPRITE_METHOD;
IMAGE_NAMESPACE_END
RENDER_NAMESPACE
#endif
/* Adds a sprite rendering method to the display. Just before
   updating to the display, the display is saved, and sprite
   update callbacks are issued. then the resulting display is
   \output. Sprite data only exists on the output image just
   before it is put on the physical display.
   Parameters
   render :    the display to attach a sprite render method to
   callback :  callback to draw sprites
   psv :       user data passed to callback when it is called
   Returns
   Pointer to a SpriteMethod that can be used in SavePortion...
   uhmm
   Note
   Has fallen into disrepair, and may need work before sprites
   work this way.                                               */
RENDER_PROC( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
/* signature for callback method to pass to
   WinShell_AcceptDroppedFiles.             */
typedef LOGICAL (CPROC*dropped_file_acceptor)(uintptr_t psv, CTEXTSTR filename, int32_t x, int32_t y );
/* Adds a callback to call when a file is dropped. Each callback
   can return 0 that it did not accept the file, or 1 that it
   did. once the file is accepted by a handler, it is not passed
   to any other handlers.
   Parameters
   renderer :  display to handle dropped files for
   f :         callback to acceptor
   psvUser :   user data passed to acceptor when it is invoked   */
RENDER_PROC( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
/* Enables a timer on the mouse to hide the cursor after a
   second that the mouse is not being moved.
   Parameters
   hVideo :   display to hide the mouse automatically for
   bEnable :  enable automatic hiding. After a few seconds, the
              mouse goes away until it moves(not click).        */
RENDER_PROC (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
/* Sets whether the display wants to get any mouse events at
   all.
   Parameters
   hVideo :    display to set the property for
   bNoMouse :  if 1, disables any mouse events. if 0, enables mouse
               events to the display.                               */
RENDER_PROC( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
#ifdef WIN32
	/* \returns the native handle used to output to. this can be an
	   SDL_Screen or HWND depending on platform.
	   Parameters
	   video :  display to get the native handle for
	   Returns
	   the system handle of the display object being used to output. */
	RENDER_PROC( HWND, GetNativeHandle )( PRENDERER video );
#endif
/* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
   \ \                                                          */
#define OwnMouse(d,o) OwnMouseEx( d, o DBG_SRC )
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplay(a)            OpenDisplaySizedAt(a,-1,-1,-1,-1)
/* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
   \ \                                                                     */
#define OpenDisplaySized(a,w,h)   OpenDisplaySizedAt(a,w,h,-1,-1)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAbove(p,a)            OpenDisplayAboveSizedAt(p,-1,-1,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
   \ \                                                                                    */
#define OpenDisplayAboveSized(p,a,w,h)   OpenDisplayAboveSizedAt(p,w,h,-1,-1,a)
/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
   \ \                                                                                                   */
#define OpenDisplayUnderSizedAt(p,a,w,h,x,y) OpenDisplayAboveUnderSizedAt(a,w,h,x,y,NULL,p)
/* Lock the renderer for this thread to use. */
RENDER_PROC( void, LockRenderer )( PRENDERER render );
/* Unlock the renderer for other threads to use. */
RENDER_PROC( void, UnlockRenderer )( PRENDERER render );
/* Function to check if the draw mode of the renderer requires
   an ALL update (opengl/direct3d) every frame the whole display
   must be drawn.                                                */
RENDER_PROC( LOGICAL, RequiresDrawAll )( void );
RENDER_PROC( void, MarkDisplayUpdated )( PRENDERER );
#ifndef __NO_INTERFACES__
/* Interface defines the functions that are exported from the
   render library. This interface may be retrieved with
   LoadInterface( "\<appropriate name" ).                     */
_INTERFACE_NAMESPACE
/* Macro to define exports for render.h */
#define RENDER_PROC_PTR(type,name) type  (CPROC*_##name)
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag RENDER_INTERFACE;
/* <combine sack::image::render::render_interface_tag>
	\ \                                                 */
typedef struct render_interface_tag *PRENDER_INTERFACE;
/* This is a function table interface to the video library. Allows
   application to not be linked to the video portion directly,
   allowing dynamic replacement.                                   */
struct render_interface_tag
{
      /* <combine sack::image::render::InitDisplay>
         \ \                                        */
       RENDER_PROC_PTR( int , InitDisplay) (void);
       /* <combine sack::image::render::SetApplicationTitle@TEXTCHAR *>
          \ \                                                           */
			 RENDER_PROC_PTR( void , SetApplicationTitle) (const TEXTCHAR *title );
          /* <combine sack::image::render::SetApplicationIcon@Image>
                                                    \ \                                                     */
       RENDER_PROC_PTR( void , SetApplicationIcon)  (Image Icon);
    /* <combine sack::image::render::GetDisplaySize@uint32_t *@uint32_t *>
       \ \                                                       */
    RENDER_PROC_PTR( void , GetDisplaySize)      ( uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::SetDisplaySize@uint32_t@uint32_t>
       \ \                                                   */
    RENDER_PROC_PTR( void , SetDisplaySize)      ( uint32_t width, uint32_t height );
    /* <combine sack::image::render::OpenDisplaySizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t>
       \ \                                                                     */
    RENDER_PROC_PTR( PRENDERER , OpenDisplaySizedAt)     ( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y );
    /* <combine sack::image::render::OpenDisplayAboveSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER>
       \ \                                                                                    */
    RENDER_PROC_PTR( PRENDERER , OpenDisplayAboveSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above );
    /* <combine sack::image::render::CloseDisplay@PRENDERER>
       \ \                                                   */
    RENDER_PROC_PTR( void        , CloseDisplay) ( PRENDERER );
    /* <combine sack::image::render::UpdateDisplayPortionEx@PRENDERER@int32_t@int32_t@uint32_t@uint32_t height>
       \ \                                                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayPortionEx) ( PRENDERER, int32_t x, int32_t y, uint32_t width, uint32_t height DBG_PASS );
    /* <combine sack::image::render::UpdateDisplayEx@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( void, UpdateDisplayEx)        ( PRENDERER DBG_PASS);
    /* <combine sack::image::render::GetDisplayPosition@PRENDERER@int32_t *@int32_t *@uint32_t *@uint32_t *>
       \ \                                                                                   */
    RENDER_PROC_PTR( void, GetDisplayPosition)   ( PRENDERER, int32_t *x, int32_t *y, uint32_t *width, uint32_t *height );
    /* <combine sack::image::render::MoveDisplay@PRENDERER@int32_t@int32_t>
       \ \                                                            */
    RENDER_PROC_PTR( void, MoveDisplay)          ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::MoveDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, MoveDisplayRel)       ( PRENDERER, int32_t delx, int32_t dely );
    /* <combine sack::image::render::SizeDisplay@PRENDERER@uint32_t@uint32_t>
       \ \                                                          */
    RENDER_PROC_PTR( void, SizeDisplay)          ( PRENDERER, uint32_t w, uint32_t h );
    /* <combine sack::image::render::SizeDisplayRel@PRENDERER@int32_t@int32_t>
       \ \                                                               */
    RENDER_PROC_PTR( void, SizeDisplayRel)       ( PRENDERER, int32_t delw, int32_t delh );
    /* <combine sack::image::render::MoveSizeDisplayRel@PRENDERER@int32_t@int32_t@int32_t@int32_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, MoveSizeDisplayRel )  ( PRENDERER hVideo
                                                 , int32_t delx, int32_t dely
                                                 , int32_t delw, int32_t delh );
    RENDER_PROC_PTR( void, PutDisplayAbove)      ( PRENDERER, PRENDERER );
 /* <combine sack::image::render::PutDisplayAbove@PRENDERER@PRENDERER>
                                                              \ \                                                                */
    /* <combine sack::image::render::GetDisplayImage@PRENDERER>
       \ \                                                      */
    RENDER_PROC_PTR( Image, GetDisplayImage)     ( PRENDERER );
    /* <combine sack::image::render::SetCloseHandler@PRENDERER@CloseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetCloseHandler)      ( PRENDERER, CloseCallback, uintptr_t );
    /* <combine sack::image::render::SetMouseHandler@PRENDERER@MouseCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetMouseHandler)      ( PRENDERER, MouseCallback, uintptr_t );
    /* <combine sack::image::render::SetRedrawHandler@PRENDERER@RedrawCallback@uintptr_t>
       \ \                                                                               */
    RENDER_PROC_PTR( void, SetRedrawHandler)     ( PRENDERER, RedrawCallback, uintptr_t );
    /* <combine sack::image::render::SetKeyboardHandler@PRENDERER@KeyProc@uintptr_t>
       \ \                                                                          */
    RENDER_PROC_PTR( void, SetKeyboardHandler)   ( PRENDERER, KeyProc, uintptr_t );
    /* <combine sack::image::render::SetLoseFocusHandler@PRENDERER@LoseFocusCallback@uintptr_t>
       \ \                                                                                     */
    RENDER_PROC_PTR( void, SetLoseFocusHandler)  ( PRENDERER, LoseFocusCallback, uintptr_t );
    /* <combine sack::image::render::SetDefaultHandler@PRENDERER@GeneralCallback@uintptr_t>
       \ \                                                                                 */
#if ACTIVE_MESSAGE_IMPLEMENTED
			 RENDER_PROC_PTR( void, SetDefaultHandler)    ( PRENDERER, GeneralCallback, uintptr_t );
#else
       POINTER junk1;
#endif
    /* <combine sack::image::render::GetMousePosition@int32_t *@int32_t *>
		 \ \                                                           */
    RENDER_PROC_PTR( void, GetMousePosition)     ( int32_t *x, int32_t *y );
    /* <combine sack::image::render::SetMousePosition@PRENDERER@int32_t@int32_t>
       \ \                                                                 */
    RENDER_PROC_PTR( void, SetMousePosition)     ( PRENDERER, int32_t x, int32_t y );
    /* <combine sack::image::render::HasFocus@PRENDERER>
       \ \                                               */
    RENDER_PROC_PTR( LOGICAL, HasFocus)          ( PRENDERER );
    /* <combine sack::image::render::GetKeyText@int>
       \ \                                           */
    RENDER_PROC_PTR( const TEXTCHAR *, GetKeyText)           ( int key );
    /* <combine sack::image::render::IsKeyDown@PRENDERER@int>
       \ \                                                    */
    RENDER_PROC_PTR( uint32_t, IsKeyDown )        ( PRENDERER display, int key );
    /* <combine sack::image::render::KeyDown@PRENDERER@int>
       \ \                                                  */
    RENDER_PROC_PTR( uint32_t, KeyDown )         ( PRENDERER display, int key );
    /* <combine sack::image::render::DisplayIsValid@PRENDERER>
       \ \                                                     */
    RENDER_PROC_PTR( LOGICAL, DisplayIsValid )  ( PRENDERER display );
    /* <combine sack::image::render::OwnMouseEx@PRENDERER@uint32_t bOwn>
       \ \                                                          */
    RENDER_PROC_PTR( void, OwnMouseEx )            ( PRENDERER display, uint32_t Own DBG_PASS);
    /* <combine sack::image::render::BeginCalibration@uint32_t>
       \ \                                                 */
    RENDER_PROC_PTR( int, BeginCalibration )       ( uint32_t points );
    /* <combine sack::image::render::SyncRender@PRENDERER>
       \ \                                                 */
    RENDER_PROC_PTR( void, SyncRender )            ( PRENDERER pDisplay );
    /* DEPRICATED; left in structure for compatibility.  Removed define and export definition. */
	 /* <combine sack::image::render::MoveSizeDisplay@PRENDERER@int32_t@int32_t@int32_t@int32_t>
	    \ \                                                                          */
	 RENDER_PROC_PTR( void, MoveSizeDisplay )( PRENDERER hVideo
                                        , int32_t x, int32_t y
                                        , int32_t w, int32_t h );
   /* <combine sack::image::render::MakeTopmost@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, MakeTopmost )    ( PRENDERER hVideo );
   /* <combine sack::image::render::HideDisplay@PRENDERER>
      \ \                                                  */
   RENDER_PROC_PTR( void, HideDisplay )      ( PRENDERER hVideo );
   /* <combine sack::image::render::RestoreDisplay@PRENDERER>
      \ \                                                     */
   RENDER_PROC_PTR( void, RestoreDisplay )   ( PRENDERER hVideo );
	/* <combine sack::image::render::ForceDisplayFocus@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFocus )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayFront@PRENDERER>
	   \ \                                                        */
	RENDER_PROC_PTR( void, ForceDisplayFront )( PRENDERER display );
	/* <combine sack::image::render::ForceDisplayBack@PRENDERER>
	   \ \                                                       */
	RENDER_PROC_PTR( void, ForceDisplayBack )( PRENDERER display );
	/* <combine sack::image::render::BindEventToKey@PRENDERER@uint32_t@uint32_t@KeyTriggerHandler@uintptr_t>
	   \ \                                                                                        */
	RENDER_PROC_PTR( int, BindEventToKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier, KeyTriggerHandler trigger, uintptr_t psv );
	/* <combine sack::image::render::UnbindKey@PRENDERER@uint32_t@uint32_t>
	   \ \                                                        */
	RENDER_PROC_PTR( int, UnbindKey )( PRENDERER pRenderer, uint32_t scancode, uint32_t modifier );
	/* <combine sack::image::render::IsTopmost@PRENDERER>
	   \ \                                                */
	RENDER_PROC_PTR( int, IsTopmost )( PRENDERER hVideo );
	/* Used as a point to sync between applications and the message
	   display server; Makes sure that all draw commands which do
	   not have a response are done.
	   Waits until all commands are processed; which is wait until
	   this command is processed.                                   */
	RENDER_PROC_PTR( void, OkaySyncRender )            ( void );
   /* <combine sack::image::render::IsTouchDisplay>
      \ \                                           */
   RENDER_PROC_PTR( int, IsTouchDisplay )( void );
	/* <combine sack::image::render::GetMouseState@int32_t *@int32_t *@uint32_t *>
	   \ \                                                              */
	RENDER_PROC_PTR( void , GetMouseState )        ( int32_t *x, int32_t *y, uint32_t *b );
	/* <combine sack::image::render::EnableSpriteMethod@PRENDERER@void__cdecl*RenderSpritesPTRSZVAL psv\, PRENDERER renderer\, int32_t x\, int32_t y\, uint32_t w\, uint32_t h@uintptr_t>
	   \ \                                                                                                                                                               */
	RENDER_PROC_PTR ( PSPRITE_METHOD, EnableSpriteMethod )(PRENDERER render, void(CPROC*RenderSprites)(uintptr_t psv, PRENDERER renderer, int32_t x, int32_t y, uint32_t w, uint32_t h ), uintptr_t psv );
	/* <combine sack::image::render::WinShell_AcceptDroppedFiles@PRENDERER@dropped_file_acceptor@uintptr_t>
	   \ \                                                                                                 */
	RENDER_PROC_PTR( void, WinShell_AcceptDroppedFiles )( PRENDERER renderer, dropped_file_acceptor f, uintptr_t psvUser );
	/* <combine sack::image::render::PutDisplayIn@PRENDERER@PRENDERER>
	   \ \                                                             */
	RENDER_PROC_PTR(void, PutDisplayIn) (PRENDERER hVideo, PRENDERER hContainer);
#ifdef WIN32
	/* <combine sack::image::render::MakeDisplayFrom@HWND>
	   \ \                                                 */
			RENDER_PROC_PTR (PRENDERER, MakeDisplayFrom) (HWND hWnd) ;
#else
      POINTER junk4;
#endif
	/* <combine sack::image::render::SetRendererTitle@PRENDERER@TEXTCHAR *>
	   \ \                                                                  */
	RENDER_PROC_PTR( void , SetRendererTitle) ( PRENDERER render, const TEXTCHAR *title );
	/* <combine sack::image::render::DisableMouseOnIdle@PRENDERER@LOGICAL>
	   \ \                                                                 */
	RENDER_PROC_PTR (void, DisableMouseOnIdle) (PRENDERER hVideo, LOGICAL bEnable );
	/* <combine sack::image::render::OpenDisplayAboveUnderSizedAt@uint32_t@uint32_t@uint32_t@int32_t@int32_t@PRENDERER@PRENDERER>
	   \ \                                                                                                   */
	RENDER_PROC_PTR( PRENDERER, OpenDisplayAboveUnderSizedAt)( uint32_t attributes, uint32_t width, uint32_t height, int32_t x, int32_t y, PRENDERER above, PRENDERER under );
	/* <combine sack::image::render::SetDisplayNoMouse@PRENDERER@int>
	   \ \                                                            */
	RENDER_PROC_PTR( void, SetDisplayNoMouse )( PRENDERER hVideo, int bNoMouse );
	/* <combine sack::image::render::Redraw@PRENDERER>
	   \ \                                             */
	RENDER_PROC_PTR( void, Redraw )( PRENDERER hVideo );
	/* <combine sack::image::render::MakeAbsoluteTopmost@PRENDERER>
	   \ \                                                          */
	RENDER_PROC_PTR(void, MakeAbsoluteTopmost) (PRENDERER hVideo);
	/* <combine sack::image::render::SetDisplayFade@PRENDERER@int>
	   \ \                                                         */
	RENDER_PROC_PTR( void, SetDisplayFade )( PRENDERER hVideo, int level );
	/* <combine sack::image::render::IsDisplayHidden@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( LOGICAL, IsDisplayHidden )( PRENDERER video );
#ifdef WIN32
	/* <combine sack::image::render::GetNativeHandle@PRENDERER>
	   \ \                                                      */
	RENDER_PROC_PTR( HWND, GetNativeHandle )( PRENDERER video );
#endif
		 /* <combine sack::image::render::GetDisplaySizeEx@int@int32_t *@int32_t *@uint32_t *@uint32_t *>
		    \ \                                                                           */
		 RENDER_PROC_PTR (void, GetDisplaySizeEx) ( int nDisplay
														  , int32_t *x, int32_t *y
														  , uint32_t *width, uint32_t *height);
	/* Locks a video display. Applications shouldn't be locking
	   this, but if for some reason they require it; use this
	   function.                                                */
	RENDER_PROC_PTR( void, LockRenderer )( PRENDERER render );
	/* Release renderer lock critical section. Applications
	   shouldn't be locking this surface.                   */
	RENDER_PROC_PTR( void, UnlockRenderer )( PRENDERER render );
	/* Provides a way for applications to cause the window to flush
	   to the display (if it's a transparent window)                */
	RENDER_PROC_PTR( void, IssueUpdateLayeredEx )( PRENDERER hVideo, LOGICAL bContent, int32_t x, int32_t y, uint32_t w, uint32_t h DBG_PASS );
	/* Check to see if the render mode is always redraw; changes how
	   smudge works in PSI. If always redrawn, then the redraw isn't
	   done during the smudge, and instead is delayed until a draw
	   is triggered at which time all controls are drawn.
	   Returns
	   TRUE if full screen needs to be drawn during a draw,
	   otherwise partial updates may be done.                        */
	RENDER_PROC_PTR( LOGICAL, RequiresDrawAll )( void );
#ifndef NO_TOUCH
		/* <combine sack::image::render::SetTouchHandler@PRENDERER@fte inc asdfl;kj
		 fteTouchCallback@uintptr_t>
       \ \                                                                             */
			RENDER_PROC_PTR( void, SetTouchHandler)      ( PRENDERER, TouchCallback, uintptr_t );
#endif
    RENDER_PROC_PTR( void, MarkDisplayUpdated )( PRENDERER );
    /* <combine sack::image::render::SetHideHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetHideHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
    /* <combine sack::image::render::SetRestoreHandler@PRENDERER@HideAndRestoreCallback@uintptr_t>
       \ \                                                                             */
    RENDER_PROC_PTR( void, SetRestoreHandler)      ( PRENDERER, HideAndRestoreCallback, uintptr_t );
		 RENDER_PROC_PTR( void, RestoreDisplayEx )   ( PRENDERER hVideo DBG_PASS );
		 /* added for android extensions; call to enable showing the keyboard in the correct thread
        ; may have applications for windows tablets
		  */
       RENDER_PROC_PTR( void, SACK_Vidlib_ShowInputDevice )( void );
		 /* added for android extensions; call to enable hiding the keyboard in the correct thread
		  ; may have applications for windows tablets */
       RENDER_PROC_PTR( void, SACK_Vidlib_HideInputDevice )( void );
	/* Check to see if the render mode is allows updates from any thread.
	   If supported can simplify updates (requiring less scheduling queues).
	   If it is not supported (such as an X display where only a single thread
	   can write to the server, otherwise the socket state gets confused) then
	   Redraw() should be used to dispatch appriorately.  PSI Implements this
	   internally, so smudge() on a control will behave appriopriately.
	   If RequiresDrawAll() this is irrelavent.
	   Returns
	   TRUE if any thread is allowed to generate UpdateDisplayPortion().
	   otherwise must call Redraw() on the surface to get a event in the
	   correct thread.*/
			 RENDER_PROC_PTR( LOGICAL, AllowsAnyThreadToUpdate )( void );
		/* This method takes the renderer and either A) resizes it to the display
		 and issues a redraw; or it sets the screen to the size of the renderer
		 and scales the image direct to the display.  Pass NULL or another window
		 to clear the current fullscreen app.
		 Second paramter is the display to show full on; 0 is 'default'...
		 1, 2, 3, etc... will be absolute number... if not supported will be same a 0 */
		RENDER_PROC_PTR( void, SetDisplayFullScreen )( PRENDERER renderer, int nDisplay );
		/* like full screen, some applications may want to
       enable owning the screen... (media player) */
      RENDER_PROC_PTR( void, SuspendSystemSleep )( int bool_suspend_enable );
	RENDER_PROC_PTR( LOGICAL, RenderIsInstanced )( void );
	RENDER_PROC_PTR( LOGICAL, VidlibRenderAllowsCopy )( void );
	RENDER_PROC_PTR( void, SetDisplayCursor )( CTEXTSTR nCursor );
	RENDER_PROC_PTR( LOGICAL, IsDisplayRedrawForced )( PRENDERER renderer );
 // only valid during a headless display event....
	RENDER_PROC_PTR( void, ReplyCloseDisplay )( void );
};
#ifdef DEFINE_DEFAULT_RENDER_INTERFACE
#define USE_RENDER_INTERFACE GetDisplayInterface()
#endif
#ifdef FORCE_NO_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#ifdef FORCE_NO_RENDER_INTERFACE
#undef USE_RENDER_INTERFACE
#endif
#if !defined(FORCE_NO_RENDER_INTERFACE)
/* RENDER_PROC( PRENDER_INTERFACE, GetDisplayInterface )( void
 );
   Gets the interface the proper way - by name.
   Returns
   Pointer to the render interface.                            */
#  define GetDisplayInterface() (PRENDER_INTERFACE)GetInterface( WIDE("render") )
/* RENDER_PROC( void, DropDisplayInterface )( PRENDER_INTERFACE interface );
   release the interface (could be cleanup, most are donothing....
   parameters
   interface   - Pointer to the render interface.                            */
#  define DropDisplayInterface(x) DropInterface( WIDE("render"), x )
#endif
#ifdef USE_RENDER_INTERFACE
typedef int check_this_variable;
// these methods are provided for backwards compatibility
// these should not be used - but rather use the interface defined below
// (the ones not prefixed by ActImage_ - except for ActImage_Init, which
// may(should) be called before any other function.
#define REND_PROC_ALIAS(name) ((USE_RENDER_INTERFACE)->_##name)
#define REND_PROC_ALIAS_VOID(name) if(USE_RENDER_INTERFACE)(USE_RENDER_INTERFACE)->_##name
#define SetApplicationTitle       REND_PROC_ALIAS(SetApplicationTitle)
#define SetRendererTitle       REND_PROC_ALIAS(SetRendererTitle)
#define SetApplicationIcon        REND_PROC_ALIAS(SetApplicationIcon)
#define GetDisplaySize            REND_PROC_ALIAS(GetDisplaySize)
#define GetDisplaySizeEx            REND_PROC_ALIAS(GetDisplaySizeEx)
#define MarkDisplayUpdated            REND_PROC_ALIAS(MarkDisplayUpdated)
#define SetDisplaySize            REND_PROC_ALIAS(SetDisplaySize)
#define GetDisplayPosition        REND_PROC_ALIAS(GetDisplayPosition)
#define IssueUpdateLayeredEx      REND_PROC_ALIAS(IssueUpdateLayeredEx)
#define MakeDisplayFrom        REND_PROC_ALIAS(MakeDisplayFrom)
#define OpenDisplaySizedAt        REND_PROC_ALIAS(OpenDisplaySizedAt)
#define OpenDisplayAboveSizedAt   REND_PROC_ALIAS(OpenDisplayAboveSizedAt)
#define OpenDisplayAboveUnderSizedAt   REND_PROC_ALIAS(OpenDisplayAboveUnderSizedAt)
#define CloseDisplay              REND_PROC_ALIAS(CloseDisplay)
#define UpdateDisplayPortionEx    REND_PROC_ALIAS(UpdateDisplayPortionEx)
#define UpdateDisplayEx             REND_PROC_ALIAS(UpdateDisplayEx)
#define SetMousePosition          REND_PROC_ALIAS(SetMousePosition)
#define GetMousePosition          REND_PROC_ALIAS(GetMousePosition)
#define GetMouseState          REND_PROC_ALIAS(GetMouseState)
#define EnableSpriteMethod          REND_PROC_ALIAS(EnableSpriteMethod)
#define WinShell_AcceptDroppedFiles REND_PROC_ALIAS(WinShell_AcceptDroppedFiles)
#define MoveDisplay               REND_PROC_ALIAS(MoveDisplay)
#define MoveDisplayRel            REND_PROC_ALIAS(MoveDisplayRel)
#define SizeDisplay               REND_PROC_ALIAS(SizeDisplay)
#define Redraw               REND_PROC_ALIAS(Redraw)
#define RequiresDrawAll()        (USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RequiresDrawAll()):0
#define SizeDisplayRel            REND_PROC_ALIAS(SizeDisplayRel)
#define MoveSizeDisplay        REND_PROC_ALIAS(MoveSizeDisplay)
#define MoveSizeDisplayRel        REND_PROC_ALIAS(MoveSizeDisplayRel)
#define PutDisplayAbove           REND_PROC_ALIAS(PutDisplayAbove)
#define PutDisplayIn           REND_PROC_ALIAS(PutDisplayIn)
#define GetDisplayImage           REND_PROC_ALIAS(GetDisplayImage)
#define LockRenderer              REND_PROC_ALIAS(LockRenderer)
#define UnlockRenderer              REND_PROC_ALIAS(UnlockRenderer)
#define SetCloseHandler           REND_PROC_ALIAS(SetCloseHandler)
#define SetMouseHandler           REND_PROC_ALIAS(SetMouseHandler)
#define SetHideHandler           REND_PROC_ALIAS(SetHideHandler)
#define SetRestoreHandler           REND_PROC_ALIAS(SetRestoreHandler)
#define AllowsAnyThreadToUpdate()          ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate)?(USE_RENDER_INTERFACE)->_AllowsAnyThreadToUpdate():1:1)
#define VidlibRenderAllowsCopy()        ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy)?(USE_RENDER_INTERFACE)->_VidlibRenderAllowsCopy():1:1)
#ifndef __LINUX__
#define SetTouchHandler           REND_PROC_ALIAS(SetTouchHandler)
#endif
#define SetRedrawHandler          REND_PROC_ALIAS(SetRedrawHandler)
#define SetKeyboardHandler        REND_PROC_ALIAS(SetKeyboardHandler)
#define SetLoseFocusHandler       REND_PROC_ALIAS(SetLoseFocusHandler)
#define SetDefaultHandler         REND_PROC_ALIAS(SetDefaultHandler)
#define GetKeyText                REND_PROC_ALIAS(GetKeyText)
#define HasFocus                  REND_PROC_ALIAS(HasFocus)
#define SACK_Vidlib_ShowInputDevice REND_PROC_ALIAS( SACK_Vidlib_ShowInputDevice )
#define SACK_Vidlib_HideInputDevice REND_PROC_ALIAS( SACK_Vidlib_HideInputDevice )
#define CreateMessage             REND_PROC_ALIAS(CreateMessage)
#define SendActiveMessage         REND_PROC_ALIAS(SendActiveMessage)
#define IsKeyDown                 REND_PROC_ALIAS(IsKeyDown)
#define KeyDown                   REND_PROC_ALIAS(KeyDown)
#define DisplayIsValid            REND_PROC_ALIAS(DisplayIsValid)
#define OwnMouseEx                REND_PROC_ALIAS(OwnMouseEx)
#define BeginCalibration          REND_PROC_ALIAS(BeginCalibration)
#define SyncRender                REND_PROC_ALIAS(SyncRender)
#define OkaySyncRender                REND_PROC_ALIAS(OkaySyncRender)
#define HideDisplay               REND_PROC_ALIAS(HideDisplay)
#define IsDisplayHidden               REND_PROC_ALIAS(IsDisplayHidden)
/* <combine sack::image::render::GetNativeHandle@PRENDERER>
   \ \                                                      */
#define GetNativeHandle             REND_PROC_ALIAS(GetNativeHandle)
//#define RestoreDisplay             REND_PROC_ALIAS(RestoreDisplay)
#define RestoreDisplayEx             REND_PROC_ALIAS(RestoreDisplayEx)
#define MakeTopmost               REND_PROC_ALIAS_VOID(MakeTopmost)
#define MakeAbsoluteTopmost               REND_PROC_ALIAS_VOID(MakeAbsoluteTopmost)
#define IsTopmost               REND_PROC_ALIAS(IsTopmost)
#define SetDisplayFade               REND_PROC_ALIAS(SetDisplayFade)
#define ForceDisplayFocus         REND_PROC_ALIAS(ForceDisplayFocus)
#define ForceDisplayFront       REND_PROC_ALIAS(ForceDisplayFront)
#define ForceDisplayBack          REND_PROC_ALIAS(ForceDisplayBack)
#define BindEventToKey          REND_PROC_ALIAS(BindEventToKey)
#define UnbindKey               REND_PROC_ALIAS(UnbindKey)
#define IsTouchDisplay          REND_PROC_ALIAS(IsTouchDisplay)
#define DisableMouseOnIdle      REND_PROC_ALIAS(DisableMouseOnIdle )
#define SetDisplayNoMouse      REND_PROC_ALIAS(SetDisplayNoMouse )
#define SetTouchHandler        REND_PROC_ALIAS(SetTouchHandler)
#define ReplyCloseDisplay      if(USE_RENDER_INTERFACE) if((USE_RENDER_INTERFACE)->_ReplyCloseDisplay) (USE_RENDER_INTERFACE)->_ReplyCloseDisplay
#define SetDisplayFullScreen    REND_PROC_ALIAS_VOID( SetDisplayFullScreen )
#define SuspendSystemSleep      REND_PROC_ALIAS_VOID( SuspendSystemSleep )
#define RenderIsInstanced()       ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_RenderIsInstanced)?(USE_RENDER_INTERFACE)->_RenderIsInstanced():0:0)
#define SetDisplayCursor(n)           {if((USE_RENDER_INTERFACE)&&(USE_RENDER_INTERFACE)->_SetDisplayCursor)REND_PROC_ALIAS(SetDisplayCursor)(n);}
#define IsDisplayRedrawForced(r)    ((USE_RENDER_INTERFACE)?((USE_RENDER_INTERFACE)->_IsDisplayRedrawForced)?(USE_RENDER_INTERFACE)->_IsDisplayRedrawForced(r):0:0)
#endif
	_INTERFACE_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d::Interface;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10::Interface;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11::Interface;
#else
	using namespace sack::image::render::Interface;
#endif
#endif
#endif
#ifndef __NO_MSGSVR__
#ifdef DEFINE_RENDER_PROTOCOL
  // offsetof
// need to define BASE_RENDER_MESSAGE_ID before including this.
//#define MSG_ID(method)  ( ( offsetof( struct render_interface_tag, _##method ) / sizeof( void(*)(void) ) ) + BASE_RENDER_MESSAGE_ID + MSG_EventUser )
#define MSG_DisplayClientClose        MSG_ID(DisplayClientClose)
#define MSG_SetApplicationTitle       MSG_ID(SetApplicationTitle)
#define MSG_SetRendererTitle       MSG_ID(SetRendererTitle)
#define MSG_SetApplicationIcon        MSG_ID(SetApplicationTitle)
#define MSG_GetDisplaySize            MSG_ID(GetDisplaySize)
#define MSG_SetDisplaySize            MSG_ID(SetDisplaySize)
#define MSG_GetDisplayPosition        MSG_ID(GetDisplayPosition)
#define MSG_OpenDisplaySizedAt        MSG_ID(OpenDisplaySizedAt)
#define MSG_OpenDisplayAboveSizedAt   MSG_ID(OpenDisplayAboveSizedAt)
#define MSG_CloseDisplay              MSG_ID(CloseDisplay)
#define MSG_UpdateDisplayPortionEx    MSG_ID(UpdateDisplayPortionEx)
#define MSG_UpdateDisplay             MSG_ID(UpdateDisplayEx)
#define MSG_SetMousePosition          MSG_ID(SetMousePosition)
#define MSG_GetMousePosition          MSG_ID(GetMousePosition)
#define MSG_GetMouseState             MSG_ID(GetMouseState )
#define MSG_Redraw               MSG_ID(Redraw)
#define MSG_EnableSpriteMethod             MSG_ID(EnableSpriteMethod )
#define MSG_WinShell_AcceptDroppedFiles    MSG_ID(WinShell_AcceptDroppedFiles )
#define MSG_MoveDisplay               MSG_ID(MoveDisplay)
#define MSG_MoveDisplayRel            MSG_ID(MoveDisplayRel)
#define MSG_SizeDisplay               MSG_ID(SizeDisplay)
#define MSG_SizeDisplayRel            MSG_ID(SizeDisplayRel)
#define MSG_MoveSizeDisplay           MSG_ID(MoveSizeDisplay)
#define MSG_MoveSizeDisplayRel        MSG_ID(MoveSizeDisplayRel)
#define MSG_PutDisplayAbove           MSG_ID(PutDisplayAbove)
#define MSG_GetDisplayImage           MSG_ID(GetDisplayImage)
#define MSG_SetCloseHandler           MSG_ID(SetCloseHandler)
#define MSG_SetMouseHandler           MSG_ID(SetMouseHandler)
#define MSG_SetRedrawHandler          MSG_ID(SetRedrawHandler)
#define MSG_SetKeyboardHandler        MSG_ID(SetKeyboardHandler)
#define MSG_SetLoseFocusHandler       MSG_ID(SetLoseFocusHandler)
#define MSG_SetDefaultHandler         MSG_ID(SetDefaultHandler)
// -- all other handlers - client side only
#define MSG_HasFocus                  MSG_ID(HasFocus)
#define MSG_SendActiveMessage         MSG_ID(SendActiveMessage)
#define MSG_GetKeyText                MSG_ID(GetKeyText)
#define MSG_IsKeyDown                 MSG_ID(IsKeyDown)
#define MSG_KeyDown                   MSG_ID(KeyDown)
#define MSG_DisplayIsValid            MSG_ID(DisplayIsValid)
#define MSG_OwnMouseEx                 MSG_ID(OwnMouseEx)
#define MSG_BeginCalibration           MSG_ID(BeginCalibration)
#define MSG_SyncRender                 MSG_ID(SyncRender)
#define MSG_OkaySyncRender                 MSG_ID(OkaySyncRender)
#define MSG_HideDisplay               MSG_ID(HideDisplay)
#define MSG_IsDisplayHidden               MSG_ID(IsDisplayHidden)
#define MSG_RestoreDisplay             MSG_ID(RestoreDisplay)
#define MSG_MakeTopmost               MSG_ID(MakeTopmost)
#define MSG_BindEventToKey          MSG_ID(BindEventToKey)
#define MSG_UnbindKey               MSG_ID(UnbindKey)
#define MSG_IsTouchDisplay          MSG_ID(IsTouchDisplay )
#define MSG_GetNativeHandle             MSG_ID(GetNativeHandle)
#endif
#endif
// static void OnDisplayChangedSize( WIDE("") )( PRENDERER, int nDisplay, uint32_t x, uint32_t y, uint32_t width, uint32_t height )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplaySizeChange(name)	 __DefineRegistryMethod(WIDE("sack/render"),OnDisplaySizeChange,WIDE("display"),name,WIDE("on_display_size_change"),void,( uintptr_t psv_redraw, int nDisplay, int32_t x, int32_t y, uint32_t width, uint32_t height ),__LINE__)
// static void OnDisplayPause( WIDE("") )( void )
	// OnDisplayPause is called on systems that allow the application to suspend its display.
	// Sleep mode may also trigger such an event, allows application to save state
   // a media player, for instance, may recover unplayed buffers to prepare for resume
#define OnDisplayPause(name)	 __DefineRegistryMethod(WIDE("sack/render/android"),OnDisplayPause,WIDE("display"),name,WIDE("on_display_pause"),void,(void),__LINE__)
// static void OnDisplayResume( WIDE("") )( void )
	// OnDisplayResume is called on systems that allow the application to suspend its display.
	// Wake from sleep mode may also trigger such an event, allows application to restore saved state
   // a media player, for instance, may continue playing ( it might be good to wait just a little longer than 'now')
#define OnDisplayResume(name)	 __DefineRegistryMethod(WIDE("sack/render/android"),OnDisplayResume,WIDE("display"),name,WIDE("on_display_resume"),void,(void),__LINE__)
	struct display_app;
	struct display_app_local;
	// static void OnDisplayConnect( WIDE("") )( struct display_app*app, struct display_app_local ***pppLocal )
	//  app is a unique handle to the display instance.  Can be used as a key to locate resources for the display
	//  pppLocal is ... ugly.
	//  ThreadLocal struct instance_local *_thread_local;
	//  static void OnDisplayConnect( WIDE("") )( struct display_app*app, struct display_app_local ***pppLocal )
	//  {
	//	    _thread_local = New( struct instance_local );
	//      MemSet( option_thread, 0, sizeof( option_thread ) );
	//      (*local) = (struct display_app_local**)&option_thread;
	//       //... init local here
	//  }
	//
#define OnDisplayConnect(name)	 __DefineRegistryMethod(WIDE("/sack/render/remote display"),OnDisplayConnect,WIDE("connect"),name,WIDE("new_display_connect"),void,(struct display_app*app, struct display_app_local ***),__LINE__)
	// unimplemented.
#define OnDisplayConnected(name)	 __DefineRegistryMethod(WIDE("/sack/render/remote display"),OnDisplayConnect,WIDE("connect"),name,WIDE("new_display_connected"),void,(struct display_app*app),__LINE__)
RENDER_NAMESPACE_END
#ifdef __cplusplus
#ifdef _D3D_DRIVER
	using namespace sack::image::render::d3d;
#elif defined( _D3D10_DRIVER )
	using namespace sack::image::render::d3d10;
#elif defined( _D3D11_DRIVER )
	using namespace sack::image::render::d3d11;
#else
	using namespace sack::image::render;
#endif
#endif
#endif
// : $
// $Log: render.h,v $
// Revision 1.48  2005/05/25 16:50:09  d3x0r
// Synch with working repository.
//
// Revision 1.10  2003/03/25 08:38:11  panther
// Add logging
//
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
// If you change this structure please change the public
// reference of this structure, and please, do hand-count
// the bytes to set there... so not include this file
// to get the size.  The size there should be the worst
// case - debug or release mode.
#ifdef NO_PRIVATE_DEF
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	volatile uint32_t dwUpdating;
	volatile uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
	//PDATAQUEUE pPriorWaiters;
#ifdef DEBUG_CRITICAL_SECTIONS
	uint32_t bCollisions ;
	CTEXTSTR pFile;
	uint32_t  nLine;
#endif
};
typedef struct critical_section_tag CRITICALSECTION;
#endif
#ifdef __cplusplus
	};
};
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
PREFIX_PACKED struct malloc_chunk_tag
{
   // if 0 - block is free
	uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
	uint16_t dwPad;
#ifdef __64__
	uint32_t pad;
#endif
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
PREFIX_PACKED struct heap_chunk_tag
{
            // if 0 - block is free
	uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
	uint16_t dwPad;
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag * pRoot;
	DeclareLink( struct heap_chunk_tag );
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	};
};
#endif
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace timers {
		using namespace sack::containers;
		using namespace sack::memory;
		using namespace sack::logging;
#endif
//#define LOG_CREATE_EVENT_OBJECT
//#define LOG_THREAD
//#define LOG_SLEEPS
// - define this to log when timers were delayed in scheduling...
//198#define LOG_LATENCY_LIGHT
//#define LOG_LATENCY
//#define LOG_INSERTS
//#define LOG_DISPATCH
//#define DEBUG_PIPE_USAGE
typedef struct thread_event THREAD_EVENT;
typedef struct thread_event *PTHREAD_EVENT;
struct timer_tag
{
// putting next as first thing in structure
   // allows me to reference also prior
	struct timer_tag *next;
	union {
		struct timer_tag **me;
		struct timer_tag *prior;
	};
	struct {
		BIT_FIELD bRescheduled : 1;
	} flags;
	uint32_t frequency;
	int32_t delta;
	uint32_t ID;
	void (CPROC*callback)(uintptr_t user);
	uintptr_t userdata;
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	CTEXTSTR pFile;
	int nLine;
#endif
};
typedef struct timer_tag TIMER, *PTIMER;
#define MAXTIMERSPERSET 32
DeclareSet( TIMER );
struct threads_tag
{
	// these first two items MUST
	// be declared publically, and MUST be visible
	// to the thread created.
	uintptr_t param;
	uintptr_t (CPROC*proc)( struct threads_tag * );
	uintptr_t (CPROC*simple_proc)( POINTER );
 // might be not a real thread.
	TEXTSTR thread_event_name;
	THREAD_ID thread_ident;
	PTHREAD_EVENT thread_event;
#ifdef _WIN32
	//HANDLE hEvent;
	HANDLE hThread;
#else
#ifdef USE_PIPE_SEMS
 // file handles that are the pipe's ends. 0=read 1=write
	int pipe_ends[2];
#endif
 // use this as a status of pipes if USE_PIPE_SEMS is used...; otherwise it's a ipcsem
	int semaphore;
	pthread_t hThread;
#endif
	struct {
		//BIT_FIELD bLock : 1;
		//BIT_FIELD bSleeping : 1;
		//BIT_FIELD bWakeWhileRunning : 1;
		BIT_FIELD bRemovedWhileRunning : 1;
		BIT_FIELD bLocal : 1;
		BIT_FIELD bReady : 1;
		BIT_FIELD bStarted : 1;
	} flags;
	//struct threads_tag *next, **me;
	CTEXTSTR pFile;
	uint32_t nLine;
};
typedef struct threads_tag THREAD;
#define MAXTHREADSPERSET 16
DeclareSet( THREAD );
struct thread_event
{
	TEXTSTR name;
#ifdef _WIN32
	HANDLE hEvent;
#endif
};
static struct {
	uint32_t timerID;
	PTIMERSET timer_pool;
	PTIMER timers;
 // this timer is scheduled to be added...
	PTIMER add_timer;
	PTIMER current_timer;
	struct {
		BIT_FIELD away_in_timer : 1;
		BIT_FIELD insert_while_away : 1;
		BIT_FIELD set_timer_signal : 1;
		BIT_FIELD bExited : 1;
#ifdef ENABLE_CRITICALSEC_LOGGING
		BIT_FIELD bLogCriticalSections : 1;
#endif
		BIT_FIELD bLogSleeps : 1;
		BIT_FIELD bLogTimerDispatch : 1;
		BIT_FIELD bLogThreadCreate : 1;
		BIT_FIELD bHaltTimers : 1;
	} flags;
 // this timer is scheduled to be removed...
	uint32_t del_timer;
 // should somehow end up equating to sleep overhead...
	uint32_t tick_bias;
 // last known time that a timer could have fired...
	uint32_t last_tick;
 // the current moment up to which we fire all timers.
	uint32_t this_tick;
	PTHREAD pTimerThread;
	PTHREADSET threadset;
	PTHREAD threads;
	uint32_t lock_timers;
	CRITICALSECTION cs_timer_change;
	//uint32_t pending_timer_change;
	uint32_t remove_timer;
	uint32_t CurrentTimerID;
	int32_t last_sleep;
#define globalTimerData (*global_timer_structure)
	uintptr_t lock_thread_create;
	// should be a short list... 10 maybe 15...
	PLIST thread_events;
	CRITICALSECTION csGrab;
#if defined( WIN32 )
	DWORD my_thread_info_tls;
#elif defined( __LINUX__ )
	pthread_key_t my_thread_info_tls;
#endif
// = { 1000 };
} *global_timer_structure;
#if HAS_TLS
struct my_thread_info {
	PTHREAD pThread;
	THREAD_ID nThread;
};
#define MyThreadInfo (*_MyThreadInfo)
#endif
#ifdef _WIN32
#else
//#include <sys/ipc.h>
	 // hmm wonder why this has to be defined....
	 // semtimedop is a wonderful wonderful thing...
	 // but yet /usr/include/sys/sem.h only defines it if
// __USE_GNU is defined....
#ifndef __USE_GNU
#define __USE_GNU
#endif
#ifdef __ANDROID__
#include <linux/sem.h>
#else
#include <sys/sem.h>
#endif
#endif
void  RemoveTimerEx( uint32_t ID DBG_PASS );
static struct my_thread_info* GetThreadTLS( void )
{
	struct my_thread_info* _MyThreadInfo;
#if defined( WIN32 )
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
	if( !( _MyThreadInfo = (struct my_thread_info*)TlsGetValue( global_timer_structure->my_thread_info_tls ) ) )
	{
		int old = SetAllocateLogging( FALSE );
		TlsSetValue( global_timer_structure->my_thread_info_tls, _MyThreadInfo = New( struct my_thread_info ) );
		SetAllocateLogging( old );
		_MyThreadInfo->nThread = 0;
		_MyThreadInfo->pThread = 0;
	}
#elif defined( __LINUX__ )
	if( !( _MyThreadInfo = (struct my_thread_info*)pthread_getspecific( global_timer_structure->my_thread_info_tls ) ) )
	{
		pthread_setspecific( global_timer_structure->my_thread_info_tls, _MyThreadInfo = New( struct my_thread_info ) );
		_MyThreadInfo->nThread = 0;
		_MyThreadInfo->pThread = 0;
	}
#endif
	return _MyThreadInfo;
}
// this priorirty is also relative to a secondary init for procreg/names.c
// if you change this, need to change when that is scheduled also
PRIORITY_PRELOAD( LowLevelInit, CONFIG_SCRIPT_PRELOAD_PRIORITY-1 )
{
	// there is a small chance the local is already initialized.
	if( !global_timer_structure )
		SimpleRegisterAndCreateGlobal( global_timer_structure );
	if( !globalTimerData.timerID )
	{
#if defined( WIN32 )
		globalTimerData.my_thread_info_tls = TlsAlloc();
#elif defined( __LINUX__ )
		pthread_key_create( &globalTimerData.my_thread_info_tls, NULL );
#endif
		InitializeCriticalSec( &globalTimerData.csGrab );
		// this may have initialized early?
		globalTimerData.timerID = 1000;
		//lprintf( "thread global will be %p %p", global_timer_structure, &global_timer_structure );
	}
}
PRELOAD( ConfigureTimers )
{
#ifndef __NO_OPTIONS__
#  ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Memory Library/Log critical sections" ), 0 );
#  endif
	globalTimerData.flags.bLogThreadCreate = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Timers/Log Thread Create" ), 0 );
	globalTimerData.flags.bLogSleeps = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Timers/Log Sleeps" ), 0 );
	globalTimerData.flags.bLogTimerDispatch = SACK_GetProfileInt( GetProgramName(), WIDE( "SACK/Timers/Log Timer Dispatch" ), 0 );
#endif
}
//--------------------------------------------------------------------------
#ifdef __LINUX__
#ifdef __LINUX__
uint32_t  GetTickCount( void )
{
	struct timeval time;
	gettimeofday( &time, 0 );
	return (time.tv_sec * 1000) + (time.tv_usec / 1000);
}
uint32_t  timeGetTime( void )
{
	struct timeval time;
	gettimeofday( &time, 0 );
	return (time.tv_sec * 1000) + (time.tv_usec / 1000);
}
void  Sleep( uint32_t ms )
{
	(usleep((ms)*1000));
}
#endif
uintptr_t closesem( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
#ifdef USE_PIPE_SEMS
	//lprintf( "CLOSE PIPES %s %"_64fx, thread->thread_event_name, thread->thread_ident );
	close( thread->pipe_ends[0] );
	close( thread->pipe_ends[1] );
	thread->pipe_ends[0] = -1;
	thread->pipe_ends[1] = -1;
	thread->semaphore = -1;
#else
	if( semctl( thread->semaphore, 0, IPC_RMID ) == -1 )
	{
		lprintf( WIDE( "Error: %08x %s" ), thread->semaphore, strerror( errno ) );
	}
	thread->semaphore = -1;
#endif
	return 0;
}
static uintptr_t threadrunning( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	if( thread->hThread && thread->flags.bStarted )
		return 1;
	return 0;
}
// sharemem exit priority +1 (exit after everything else, except emmory; globals at memory+1)
PRIORITY_ATEXIT( CloseAllWakeups, ATEXIT_PRIORITY_THREAD_SEMS )
{
	//pid_t mypid = getppid();
	// not sure if mypid is needed...
	while( ForAllInSet( THREAD, globalTimerData.threadset, threadrunning, 0 ) )
		Relinquish();
	lprintf( WIDE("Destroy thread semaphores...") );
	ForAllInSet( THREAD, globalTimerData.threadset, closesem, (uintptr_t)0 );
	DeleteSet( (GENERICSET**)&globalTimerData.threadset );
	globalTimerData.pTimerThread = NULL;
	//globalTimerData.threads = NULL;
	globalTimerData.timers = NULL;
}
#endif
// sharemem exit priority +1 (exit after everything else, except emmory)
PRIORITY_ATEXIT( StopTimers, ATEXIT_PRIORITY_TIMERS )
{
	int tries = 0;
	//pid_t mypid = getppid();
	// not sure if mypid is needed...
	if( global_timer_structure ) {
		globalTimerData.flags.bExited = 1;
		if( globalTimerData.pTimerThread )
			WakeThread( globalTimerData.pTimerThread );
		while( globalTimerData.pTimerThread )
		{
			tries++;
			if( tries > 10 )
				return;
			WakeThread( globalTimerData.pTimerThread );
			Relinquish();
		}
	}
}
//--------------------------------------------------------------------------
static void InitWakeup( PTHREAD thread, CTEXTSTR event_name )
{
#ifdef _DEBUG
	int prior;
	prior = SetAllocateLogging( FALSE );
#endif
	if( !event_name )
		event_name = WIDE("ThreadSignal");
	thread->thread_event_name = StrDup( event_name );
#ifdef _WIN32
	if( !thread->thread_event )
	{
		PTHREAD_EVENT thread_event;
		TEXTCHAR name[64];
		tnprintf( name, 64, WIDE("%s:%08lX:%08lX"), event_name, (uint32_t)(thread->thread_ident >> 32)
		        , (uint32_t)(thread->thread_ident & 0xFFFFFFFF) );
		name[sizeof(name)/sizeof(name[0])-1] = 0;
#ifdef LOG_CREATE_EVENT_OBJECT
		lprintf( WIDE("Thread Event created is: %s everyone should use this..."), name );
#endif
		thread_event = New( THREAD_EVENT );
		thread_event->name = StrDup( name );
		thread_event->hEvent = CreateEvent( NULL, TRUE, FALSE, name );
		AddLink( &globalTimerData.thread_events, thread_event );
		thread->thread_event = thread_event;
	}
#else
#ifdef USE_PIPE_SEMS
	// store status of pipe() in semaphore... it's not really a semaphore..
#  ifdef DEBUG_PIPE_USAGE
	lprintf( "Init wakeup %p %s", thread, event_name );
#  endif
	if( ( thread->semaphore = pipe( thread->pipe_ends ) )  == -1 )
	{
		lprintf( WIDE("Failed to get pipe! %d:%s"), errno, strerror( errno ) );
	}
	else
	{
		char buf;
		int success = 0;
		do
		{
			int stat;
			int n;
			fd_set set;
			struct timeval timeout;
			FD_ZERO(&set);
			FD_SET( thread->pipe_ends[0], &set);
			timeout.tv_sec = 0;
			timeout.tv_usec = 100;
#  ifdef DEBUG_PIPE_USAGE
			lprintf(" Begin select-flush on thread %p", thread );
#  endif
			stat = select(thread->pipe_ends[0] + 1, &set, NULL, NULL, &timeout);
			if(stat == -1)
			{
				lprintf( WIDE("select error %d %d"), errno, thread->pipe_ends[0]);
			}
			else if(stat == 0)
			{
				success = 1;
#  ifdef DEBUG_PIPE_USAGE
				lprintf("timeout");
#  endif
			}
			else
			{
#  ifdef DEBUG_PIPE_USAGE
				lprintf(" immediate return?" );
#  endif
				stat = read( thread->pipe_ends[0], &buf, 1 );
#  ifdef DEBUG_PIPE_USAGE
				lprintf( "Stat is now %d", stat );
#  endif
			}
		}
		while( !success );
	}
#else
	thread->semaphore = semget( IPC_PRIVATE
	                          , 1, IPC_CREAT | 0600 );
	if( thread->semaphore == -1 )
	{
		// basically this can't really happen....
		if( errno ==  EEXIST )
		{
			thread->semaphore = semget( IPC_PRIVATE
			                          , 1, 0 );
			if( thread->semaphore == -1 )
				lprintf( WIDE("FAILED TO CREATE SEMAPHORE! : %d"), errno );
		}
		if( errno == ENOSPC )
		{
			lprintf( WIDE("Hmm Need to cleanup some semaphore objects!!!") );
		}
		else
			lprintf( WIDE("Failed to get semaphore! %d"), errno );
	}
	if( thread->semaphore != -1 )
	{
		//union semun ctl;
		//ctl.val = 0;
		//lprintf( WIDE("Setting thread semaphore to 0 (locked).") );
		if( semctl( thread->semaphore, 0, SETVAL, 0 ) < 0 )
		{
			lprintf( WIDE("Errro setting semaphre value: %d"), errno );
		}
		//lprintf( WIDE("after semctl = %d %08lx"), semctl( thread->semaphore, 0, GETVAL ), thread->semaphore );
	}
#endif
#endif
#ifdef _DEBUG
	SetAllocateLogging( prior );
#endif
}
//--------------------------------------------------------------------------
uintptr_t CPROC check_thread_name( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	if( StrCaseCmp( thread->thread_event_name, (CTEXTSTR)psv ) == 0 )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindWakeup( CTEXTSTR name )
{
	PTHREAD check;
	if( global_timer_structure )
	{
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
	}
	else
	{
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread_name, (uintptr_t)name );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = GetMyThreadID();
		InitWakeup( check, name );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
struct name_and_id_params
{
	CTEXTSTR name;
	THREAD_ID thread;
};
uintptr_t CPROC check_thread_name_and_id( POINTER p, uintptr_t psv )
{
	struct name_and_id_params *params = (struct name_and_id_params*)psv;
	PTHREAD thread = (PTHREAD)p;
	if( thread->thread_ident == params->thread
		&& StrCaseCmp( thread->thread_event_name, params->name ) == 0 )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindThreadWakeup( CTEXTSTR name, THREAD_ID thread )
{
	PTHREAD check;
	struct name_and_id_params params;
	params.name = name;
	params.thread = thread;
	if( global_timer_structure )
	{
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
	}
	else
	{
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread_name_and_id, (uintptr_t)&params );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = thread;
		InitWakeup( check, name );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
uintptr_t CPROC check_thread( POINTER p, uintptr_t psv )
{
	PTHREAD thread = (PTHREAD)p;
	THREAD_ID ID = *((THREAD_ID*)psv);
	//lprintf( "Check thread %016llx %016llx %s", thread->thread_ident, ID, thread->thread_event_name );
	if( ( thread->thread_ident == ID )
		&& ( StrCmp( thread->thread_event_name, WIDE("ThreadSignal") ) == 0 ) )
		return (uintptr_t)p;
	return 0;
}
static PTHREAD FindThread( THREAD_ID thread )
{
	PTHREAD check;
	if( global_timer_structure )
	{
		// don't need locks if init didn't finish, there's now way to have threads in loader lock.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
	}
	else
	{
		if( IsRootDeadstartStarted() )
			SimpleRegisterAndCreateGlobal( global_timer_structure );
	}
	check = (PTHREAD)ForAllInSet( THREAD, globalTimerData.threadset, check_thread, (uintptr_t)&thread );
	if( !check )
	{
#ifdef _DEBUG
		//lprintf( DBG_FILELINEFMT "Failed to find the thread - so let's add it" );
#endif
		check = GetFromSet( THREAD, &globalTimerData.threadset );
		MemSet( check, 0, sizeof( THREAD ) );
		check->thread_ident = thread;
		InitWakeup( check, NULL );
		check->flags.bReady = 1;
	}
	globalTimerData.lock_thread_create = 0;
	return check;
}
//--------------------------------------------------------------------------
void  WakeThreadEx( PTHREAD thread DBG_PASS )
{
 // can't wake nothing
	if( !thread )
	{
		//_lprintf(DBG_RELAY)( WIDE("Failed to find thread to wake...") );
		return;
	}
	//_xlprintf( 0 DBG_RELAY )( WIDE("Waking a thread: %p"), thread );
	//while( thread->flags.bLock )
	//{
	//	Log( WIDE("Waiting for thread to go to sleep") );
	//	Relinquish();
	//}
	//if( thread->flags.bLocal && !thread->flags.bSleeping )
	//{
	//	//Log( WIDE("Waking thread which is already awake") );
	//  thread->flags.bWakeWhileRunning = 1;
	//  Relinquish(); // wake implies that we want the other thing to run.
	//  lprintf( DBG_FILELINEFMT "Thread is not sleeping... woke it before it slept" );
	//  return;
	//}
#ifdef _WIN32
	//	lprintf( WIDE("setting event.") );
	{
		PTHREAD_EVENT thread_event;
		INDEX idx;
		TEXTCHAR name[64];
		if( !(thread_event = thread->thread_event ) )
		{
			tnprintf( name, sizeof(name), WIDE("%s:%08lX:%08lX")
			        , thread->thread_event_name, (uint32_t)(thread->thread_ident >> 32)
			        , (uint32_t)(thread->thread_ident & 0xFFFFFFFF));
			name[sizeof(name)/sizeof(name[0])-1] = 0;
			LIST_FORALL( globalTimerData.thread_events, idx, PTHREAD_EVENT, thread_event )
			{
				if( StrCmp( thread_event->name, name ) == 0 )
					break;
			}
#ifdef LOG_CREATE_EVENT_OBJECT
			lprintf( WIDE("Event opened is: %s"), name );
#endif
		}
#ifdef LOG_CREATE_EVENT_OBJECT
		else
		{
			lprintf( WIDE("Event opened is thread.") );
		}
#endif
		if( !thread_event )
		{
			thread_event = New( THREAD_EVENT );
			thread_event->name = StrDup( name );
 /*EVENT_MODIFY_STATE */
			thread_event->hEvent = OpenEvent( EVENT_ALL_ACCESS, FALSE, name );
			AddLink( &globalTimerData.thread_events, thread_event );
			thread->thread_event = thread_event;
		}
		if( thread_event->hEvent )
		{
			//lprintf( WIDE("event opened successfully... %d"), WaitForSingleObject( hEvent, 0 ) );
#ifndef NO_LOGGING
			if( globalTimerData.flags.bLogSleeps )
				_xlprintf(1 DBG_RELAY )( WIDE("About to wake on %d Thread event created...%016llx")
				                       , thread->thread_event->hEvent
				                       , thread->thread_ident );
#endif
			if( !SetEvent( thread_event->hEvent ) )
				lprintf( WIDE("Set event FAILED..%d"), GetLastError() );
 // may or may not execute other thread before this...
			Relinquish();
		}
		else
		{
			lprintf( WIDE("Failed to open that event! %d"), GetLastError() );
			// thread to wake is not ready to be
			// woken, does not exist, or some other
			// BAD problem.
		}
	}
#else
#ifdef USE_PIPE_SEMS
	if( thread->semaphore != -1 )
	{
#  ifdef DEBUG_PIPE_USAGE
		_lprintf(DBG_RELAY)( "(wakethread)wil write pipe... %p", thread );
#  endif
		write( thread->pipe_ends[1], "G", 1 );
		//lprintf( "did write pipe..." );
		Relinquish();
	}
#else
	if( thread->semaphore != -1 )
	{
		int stat;
		int val;
		struct sembuf semdo;
		semdo.sem_num = 0;
		semdo.sem_op = 1;
		semdo.sem_flg = 0;
		//_xlprintf( 1 DBG_RELAY )( WIDE("Resetting event on %08x %016"_64fx"x"), thread->semaphore, thread->thread_ident );
		//lprintf( WIDE("Before semval = %d %08lx"), semctl( thread->semaphore, 0, GETVAL ), thread->semaphore );
		stat = semop( thread->semaphore, &semdo, 1 );
		if( stat == -1 )
		{
			if( errno != ERANGE )
				lprintf( WIDE("semop error (wake) : %d"), errno );
		}
		//lprintf( WIDE("After semval = %d %08lx"), val = semctl( thread->semaphore, 0, GETVAL ), thread->semaphore );
		if( !val )
		{
			//DebugBreak();
			//lprintf( WIDE("Did we fail the semop?!") );
		}
 // may or may not execute other thread before this...
		Relinquish();
	}
#endif
#  if 0
 // thread creation might not be complete yet...
	if( thread->thread )
	{
		pthread_kill( thread->thread, SIGUSR1 );
	}
#  endif
#endif
}
void  WakeNamedThreadSleeperEx( CTEXTSTR name, THREAD_ID thread DBG_PASS )
{
	PTHREAD sleeper = FindThreadWakeup( name, thread );
	if( sleeper )
		WakeThreadEx( sleeper DBG_RELAY );
}
void  WakeNamedSleeperEx( CTEXTSTR name DBG_PASS )
{
	PTHREAD sleeper = FindWakeup( name );
	if( sleeper )
		WakeThreadEx( sleeper DBG_RELAY );
}
//#undef WakeThread
//void  WakeThread( PTHREAD thread )
//{
//	WakeThreadEx( thread DBG_SRC );
//}
//--------------------------------------------------------------------------
void  WakeThreadIDEx( THREAD_ID thread DBG_PASS )
{
	PTHREAD pThread = FindThread( thread );
	WakeThreadEx( pThread DBG_RELAY );
}
//--------------------------------------------------------------------------
#undef WakeThreadID
void  WakeThreadID( THREAD_ID thread )
{
	WakeThreadIDEx( thread DBG_SRC );
}
//--------------------------------------------------------------------------
#ifdef _NO_SEMTIMEDOP_
#ifndef _WIN32
static void CPROC TimerWake( uintptr_t psv )
{
	WakeThreadEx( (PTHREAD)psv DBG_SRC );
}
#endif
#endif
//--------------------------------------------------------------------------
static void  InternalWakeableNamedSleepEx( CTEXTSTR name, uint32_t n, LOGICAL threaded DBG_PASS )
{
	PTHREAD pThread;
	if( name && threaded )
		pThread = FindThreadWakeup( name, GetMyThreadID() );
	else if( name )
		pThread = FindWakeup( name );
	else
	{
#ifdef HAS_TLS
		struct my_thread_info* _MyThreadInfo = GetThreadTLS();
		pThread = MyThreadInfo.pThread;
		//lprintf( "thread will be %p %p", pThread, &MyThreadInfo );
		//lprintf( "pthread is %p", pThread );
		if( !pThread )
		{
			//lprintf( WIDE("had to init thread...") );
			MakeThread();
			pThread = MyThreadInfo.pThread;
		}
#  ifdef DEBUG_PIPE_USAGE
		lprintf( "Sleeping on threadsignal... %p", pThread );
#  endif
#else
		pThread = FindThread( GetMyThreadID() );
#endif
	}
	if( pThread )
	{
#ifdef _WIN32
#ifndef NO_LOGGING
		if( globalTimerData.flags.bLogSleeps )
			_xlprintf(1 DBG_RELAY )( WIDE("About to sleep on %d Thread event created...%s:%016llx")
			                         , pThread->thread_event->hEvent
			                         , pThread->thread_event_name
			                         , pThread->thread_ident );
#endif
		if( WaitForSingleObject( pThread->thread_event->hEvent
		                       , n==SLEEP_FOREVER?INFINITE:(n) ) != WAIT_TIMEOUT )
		{
#ifdef LOG_LATENCY
			_lprintf(DBG_RELAY)( WIDE("Woke up- reset event") );
#endif
			ResetEvent( pThread->thread_event->hEvent );
			//if( n == SLEEP_FOREVER )
			//   DebugBreak();
		}
#ifdef LOG_LATENCY
		else
			_lprintf(DBG_RELAY)( WIDE("Timed out from %d"), n );
#endif
#else
		{
#ifndef USE_PIPE_SEMS
#ifdef _NO_SEMTIMEDOP_
			int nTimer = 0;
			if( n != SLEEP_FOREVER )
			{
				//lprintf( WIDE("Wakeable sleep in %ld (oneshot, no frequency)"), n );
				nTimer = AddTimerExx( n, 0, TimerWake, (uintptr_t)pThread DBG_RELAY );
			}
#endif
#endif
			if( pThread->semaphore == -1 )
			{
				//lprintf( WIDE("Invalid semaphore...fixing?") );
				InitWakeup( pThread, name );
			}
			if( pThread->semaphore != -1 )
			{
#ifdef USE_PIPE_SEMS
#else
				struct sembuf semdo[2];
				semdo[0].sem_num = 0;
				semdo[0].sem_op = -1;
				semdo[0].sem_flg = 0;
#endif
				while(1)
				{
					int stat;
					//lprintf( WIDE("Lock on semop on semdo... %08x %016"_64fx"x"), pThread->semaphore, pThread->thread_ident );
					//lprintf( WIDE("Before semval = %d %08lx"), semctl( pThread->semaphore, 0, GETVAL ), pThread->semaphore );
					if( n != SLEEP_FOREVER )
					{
#ifdef USE_PIPE_SEMS
						char buf;
						{
							fd_set set;
							struct timeval timeout;
							FD_ZERO(&set);
							FD_SET( pThread->pipe_ends[0], &set);
							timeout.tv_sec = n / 1000;
							timeout.tv_usec = ( n % 1000 ) * 1000;
#  ifdef DEBUG_PIPE_USAGE
							lprintf(" Begin select-read on thread %p %d ", pThread, n );
							//_lprintf(DBG_RELAY)( "Select  %p %d  %d  %d", pThread, pThread->pipe_ends[0], pThread->pipe_ends[1],n );
#  endif
							stat = select(pThread->pipe_ends[0] + 1, &set, NULL, NULL, &timeout);
							if(stat == -1)
							{
								lprintf(WIDE("select error %d %d"), errno, pThread->pipe_ends[0]);
							}
							else if(stat == 0)
							{
#  ifdef DEBUG_PIPE_USAGE
								lprintf("timeout");
#  endif
							}
							else
							{
#  ifdef DEBUG_PIPE_USAGE
								lprintf(" immediate return?" );
#  endif
								stat = read( pThread->pipe_ends[0], &buf, 1 );
								// 1 = success
								// -1 will be an error (errno handled later)
								// 0 would be end of file...
#  ifdef DEBUG_PIPE_USAGE
								lprintf( "Stat is now %d", stat );
#endif
							}
						}
#  ifdef DEBUG_PIPE_USAGE
						lprintf( "end read" );
#  endif
#else
# ifdef _NO_SEMTIMEDOP_
						stat = semop( pThread->semaphore, semdo, 1 );
# else
						struct timespec timeout;
						timeout.tv_nsec = ( n % 1000 ) * 1000000L;
						timeout.tv_sec = n / 1000;
						stat = semtimedop( pThread->semaphore, semdo, 1, &timeout );
# endif
#endif
					}
					else
					{
#ifdef USE_PIPE_SEMS
						char buf;
#  ifdef DEBUG_PIPE_USAGE
						_lprintf(DBG_RELAY)(" Begin read on thread %p", pThread );
#  endif
						stat = read( pThread->pipe_ends[0], &buf, 1 );
#  ifdef DEBUG_PIPE_USAGE
						lprintf( "end read" );
#  endif
#else
						stat = semop( pThread->semaphore, semdo, 1 );
#endif
					}
					//lprintf( WIDE("After semval = %d %08lx"), semctl( pThread->semaphore, 0, GETVAL ), pThread->semaphore );
					//lprintf( WIDE("Lock passed.") );
					if( stat < 0 )
					{
						if( errno == EINTR )
						{
							//lprintf( WIDE("EINTR") );
							break;
							//continue;
						}
						if( errno == EAGAIN )
						{
							//lprintf( WIDE("EAGAIN?") );
							// timeout elapsed on semtimedop - or IPC_NOWAIT was specified
							// but since it's not, it must be the timeout condition.
							break;
						}
						if( errno == EIDRM )
						{
							lprintf( WIDE("Semaphore has been removed on us!?") );
							pThread->semaphore = -1;
							break;
						}
						if( errno == EINVAL )
						{
							lprintf( WIDE("Semaphore is no longer valid on this thread object... %d")
							       , pThread->semaphore );
							// this probably means that it has gone away..
							pThread->semaphore = -1;
							break;
						}
						lprintf( WIDE("stat from sempop on thread semaphore %p = %d (%d)")
						       , pThread
						       , stat
						       , stat<0?errno:0 );
						break;
					}
					else
					{
						// reset semaphore to nothing.... might
						// have been woken up MANY times.
							//lprintf( WIDE("Resetting our lock count from %d to 0....")
						//		 , semctl( pThread->semaphore, 0, GETVAL ));
#ifdef USE_PIPE_SEMS
						// flush? empty the pipe?
#else
						semctl( pThread->semaphore, 0, SETVAL, 0 );
#endif
						break;
					}
				}
			}
			else
			{
				lprintf( WIDE("Still an invalid semaphore? Dang.") );
				fprintf( stderr, WIDE("Out of semaphores.") );
				BAG_Exit(0);
			}
		}
#endif
		//pThread->flags.bSleeping = 0;
	}
	else
	{
		lprintf( WIDE("You, as a thread, do not exist, sorry.") );
	}
}
#ifdef USE_PIPE_SEMS
int GetThreadSleeper( PTHREAD thread )
{
	return thread->pipe_ends[0];
}
#endif
void  WakeableNamedThreadSleepEx( CTEXTSTR name, uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( name, n, TRUE DBG_RELAY );
}
void  WakeableNamedSleepEx( CTEXTSTR name, uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( name, n, FALSE DBG_RELAY );
}
void  WakeableSleepEx( uint32_t n DBG_PASS )
{
	InternalWakeableNamedSleepEx( NULL, n, FALSE DBG_RELAY );
}
#undef WakeableSleep
void  WakeableSleep( uint32_t n )
#define WakeableSleep(n) WakeableSleepEx(n DBG_SRC)
{
	WakeableSleepEx(n DBG_SRC);
}
//--------------------------------------------------------------------------
#ifdef __LINUX__
static void ContinueSignal( int sig )
{
	lprintf( WIDE("Sigusr1") );
}
// network is at GLOBAL_INIT_PRIORITY
PRIORITY_PRELOAD( IgnoreSignalContinue, GLOBAL_INIT_PRELOAD_PRIORITY-1 )
{
	//lprintf( "register handler for sigusr1" );
#if defined __ANDROID_OLD_PLATFORM_SUPPORT__
	bsd_signal( SIGUSR1, ContinueSignal );
#else
	signal( SIGUSR1, ContinueSignal );
#endif
}
static void AlarmSignal( int sig )
{
	//lprintf( "Received alarm" );
	WakeThread( globalTimerData.pTimerThread );
}
static void TimerWakeableSleep( uint32_t n )
{
	if( globalTimerData.pTimerThread )
	{
#ifndef USE_PIPE_SEMS
		if( !globalTimerData.flags.set_timer_signal )
		{
#  if defined __ANDROID_OLD_PLATFORM_SUPPORT__
			bsd_signal( SIGALRM, AlarmSignal );
#  else
			signal( SIGALRM, AlarmSignal );
#  endif
			globalTimerData.flags.set_timer_signal = 1;
		}
		if( n != SLEEP_FOREVER )
		{
			struct itimerval val;
			//lprintf( WIDE("Wakeable sleep in %") _32f WIDE(""), n );
			val.it_value.tv_sec = n / 1000;
			val.it_value.tv_usec = (n % 1000) * 1000;
			val.it_interval.tv_sec = 0;
			val.it_interval.tv_usec = 0;
			//lprintf( "setitimer %d %d", val.it_value.tv_sec, val.it_value.tv_usec );
			setitimer( ITIMER_REAL, &val, NULL );
		}
#endif
		if( globalTimerData.pTimerThread && globalTimerData.pTimerThread->semaphore != -1 )
		{
#ifdef USE_PIPE_SEMS
			InternalWakeableNamedSleepEx( NULL, n, FALSE DBG_SRC );
#else
			struct sembuf semdo;
			semdo.sem_num = 0;
			semdo.sem_op = -1;
			semdo.sem_flg = 0;
			//lprintf( WIDE("Before semval = %d %08lx")
			//		 , semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL )
			//		 , globalTimerData.pTimerThread->semaphore );
			while( semop( globalTimerData.pTimerThread->semaphore, &semdo, 1 ) < 0 )
			{
				if( !globalTimerData.pTimerThread )
					return;
				if( errno == EIDRM )
				{
 // closed.
					globalTimerData.pTimerThread->semaphore = -1;
					return;
				}
				//lprintf( WIDE("Before semval = %d"), semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL ) );
				if( errno == EINTR )
				{
					//lprintf( WIDE("Before semval = %d"), semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL ) );
					continue;
				}
				else
				{
					lprintf( WIDE("Semop failed: %d %08x"), errno, globalTimerData.pTimerThread->semaphore );
					break;
				}
			}
#endif
			//lprintf( WIDE("After semval = %d %08lx")
			//	      , semctl( globalTimerData.pTimerThread->semaphore, 0, GETVAL )
			//       , globalTimerData.pTimerThread->semaphore );
		}
	}
}
#endif
//--------------------------------------------------------------------------
uintptr_t CPROC ThreadProc( PTHREAD pThread );
// results if the timer
int  IsThisThreadEx( PTHREAD pThreadTest DBG_PASS )
{
	PTHREAD pThread;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
//   lprintf( WIDE("Found thread; %p is it %p?"), pThread, pThreadTest );
	if( pThread == pThreadTest )
		return TRUE;
	//lprintf( WIDE("Found thread; %p is not  %p?"), pThread, pThreadTest );
	return FALSE;
}
static int NotTimerThread( void )
{
	PTHREAD pThread;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
	if( pThread && ( pThread->proc == ThreadProc ) )
		return FALSE;
	return TRUE;
}
//--------------------------------------------------------------------------
void  UnmakeThread( void )
{
	PTHREAD pThread;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, (uintptr_t)_MyThreadInfo->nThread ) )
		Relinquish();
	pThread
#ifdef HAS_TLS
		= MyThreadInfo.pThread;
#else
		= FindThread( GetMyThreadID() );
#endif
	if( pThread )
	{
		// unlink from globalTimerData.threads list.
		//if( ( (*pThread->me)=pThread->next ) )
		//	pThread->next->me = pThread->me;
		{
			int tmp = SetAllocateLogging( FALSE );
#ifdef _WIN32
			//lprintf( WIDE("Unmaking thread event! on thread %016"_64fx"x"), pThread->thread_ident );
			CloseHandle( pThread->thread_event->hEvent );
			{
				struct my_thread_info* _MyThreadInfo = GetThreadTLS();
				Deallocate( struct my_thread_info*, _MyThreadInfo );
				TlsSetValue( global_timer_structure->my_thread_info_tls, NULL );
			}
#else
			closesem( (POINTER)pThread, 0 );
#endif
			Deallocate( TEXTSTR, pThread->thread_event_name );
#ifdef _WIN32
			Deallocate( TEXTSTR, pThread->thread_event->name );
			if( global_timer_structure )
				DeleteLink( &globalTimerData.thread_events, pThread->thread_event );
			Deallocate( PTHREAD_EVENT, pThread->thread_event );
#endif
			if( global_timer_structure )
 /*Release( pThread )*/
				DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
			SetAllocateLogging( tmp );
		}
	}
	globalTimerData.lock_thread_create = 0;
}
//--------------------------------------------------------------------------
#ifdef __WATCOMC__
static void *ThreadWrapper( PTHREAD pThread )
#else
static uintptr_t CPROC ThreadWrapper( PTHREAD pThread )
#endif
{
	uintptr_t result = 0;
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
#ifdef __LINUX__
	//lprintf( "register handler for sigusr1 (for thread)" );
#  if defined __ANDROID_OLD_PLATFORM_SUPPORT__
	bsd_signal( SIGUSR1, ContinueSignal );
#  else
	signal( SIGUSR1, ContinueSignal );
#  endif
#endif
#ifdef _WIN32
	while( !pThread->hThread )
		Relinquish();
#endif
	pThread->flags.bStarted = 1;
	//DeAttachThreadToLibraries( TRUE );
	while( !pThread->flags.bReady )
		Relinquish();
#ifdef HAS_TLS
#  ifdef LOG_THREAD
	lprintf( "thread will be %p %p", MyThreadInfo.pThread, &MyThreadInfo );
	lprintf( "thread will be %p %p", pThread, &MyThreadInfo.pThread );
#  endif
	MyThreadInfo.pThread = pThread;
	MyThreadInfo.nThread =
#endif
		pThread->thread_ident = _GetMyThreadID();
	//DebugBreak();
	InitWakeup( pThread, NULL );
#ifdef LOG_THREAD
	Log1( WIDE("Set thread ident: %016"_64fx""), pThread->thread_ident );
#endif
	if( pThread->proc )
		result = pThread->proc( pThread );
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
	//DeAttachThreadToLibraries( FALSE );
	UnmakeThread();
#ifdef __LINUX__
	pThread->hThread = 0;
#else
	pThread->hThread = NULL;
#endif
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
#ifdef __WATCOMC__
	return (void*)result;
#else
	return result;
#endif
}
//--------------------------------------------------------------------------
#ifdef __WATCOMC__
static void *SimpleThreadWrapper( PTHREAD pThread )
#else
static uintptr_t CPROC SimpleThreadWrapper( PTHREAD pThread )
#endif
{
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	uintptr_t result = 0;
#ifdef _WIN32
	while( !pThread->hThread )
	{
		Log( WIDE("wait for main thread to process...") );
		Relinquish();
	}
#endif
	pThread->flags.bStarted = 1;
	while( !pThread->flags.bReady )
		Relinquish();
#ifdef HAS_TLS
	MyThreadInfo.pThread = pThread;
	MyThreadInfo.nThread =
#endif
		pThread->thread_ident = GetMyThreadID();
	InitWakeup( pThread, NULL );
#ifdef LOG_THREAD
	Log1( WIDE("Set thread ident: %016") _64fx, pThread->thread_ident );
#endif
	if( pThread->proc )
		result = pThread->simple_proc( (POINTER)GetThreadParam( pThread ) );
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
	UnmakeThread();
	//lprintf( WIDE("%s(%d):Thread is exiting... "), pThread->pFile, pThread->nLine );
#ifdef __WATCOMC__
	return (void*)result;
#else
	return result;
#endif
}
//--------------------------------------------------------------------------
PTHREAD  MakeThread( void )
{
#ifdef HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	if( MyThreadInfo.pThread )
		return MyThreadInfo.pThread;
	MyThreadInfo.nThread = _GetMyThreadID();
#endif
	{
		PTHREAD pThread;
		THREAD_ID thread_ident = _GetMyThreadID();
#ifndef HAS_TLS
		if( !(pThread = FindThread( thread_ident ) ) )
#endif
		{
			uintptr_t oldval;
			LOGICAL dontUnlock = FALSE;
			while( ( oldval = LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, (uintptr_t)thread_ident ) ) && oldval != thread_ident )
			{
				if( oldval != thread_ident )
					globalTimerData.lock_thread_create = oldval;
				Relinquish();
			}
			if( oldval == thread_ident )
				dontUnlock = TRUE;
 /*Allocate( sizeof( THREAD ) )*/
			pThread = GetFromSet( THREAD, &globalTimerData.threadset );;
			//lprintf( WIDE("Get Thread %p"), pThread );
			MemSet( pThread, 0, sizeof( THREAD ) );
			pThread->flags.bLocal = TRUE;
			pThread->proc = NULL;
			pThread->param = 0;
			pThread->thread_ident = thread_ident;
			pThread->flags.bReady = 1;
			//if( ( pThread->next = globalTimerData.threads ) )
			//	globalTimerData.threads->me = &pThread->next;
			//pThread->me = &globalTimerData.threads;
			//globalTimerData.threads = pThread;
			InitWakeup( pThread, NULL );
			if( !dontUnlock )
				globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
			Log3( WIDE("Created thread address: %p %" PRIxFAST64 " at %p")
			    , pThread->proc, pThread->thread_ident, pThread );
#endif
		}
#ifdef HAS_TLS
		MyThreadInfo.pThread = pThread;
#endif
		return pThread;
	}
}
THREAD_ID GetThreadID( PTHREAD thread )
{
	if( thread )
		return thread->thread_ident;
	return 0;
}
THREAD_ID GetThisThreadID( void )
{
#if HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	if( !MyThreadInfo.nThread )
	{
		MyThreadInfo.nThread = _GetMyThreadID();
	}
	return MyThreadInfo.nThread;
#else
	return MakeThread()->thread_ident;
#endif
}
uintptr_t GetThreadParam( PTHREAD thread )
{
	if( thread )
		return thread->param;
	return 0;
}
//--------------------------------------------------------------------------
PTHREAD  ThreadToEx( uintptr_t (CPROC*proc)(PTHREAD), uintptr_t param DBG_PASS )
{
	int success;
	PTHREAD pThread;
	while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
		Relinquish();
	do
	{
		pThread = GetFromSet( THREAD, &globalTimerData.threadset );
		if( !pThread )
			xlprintf(LOG_ALWAYS)( WIDE( "Thread to pThread allocation failed!" ) );
	} while( !pThread );
	/*AllocateEx( sizeof( THREAD ) DBG_RELAY );*/
	if( globalTimerData.flags.bLogThreadCreate )
		_lprintf(DBG_RELAY)( WIDE("Create New thread %p"), pThread );
	MemSet( pThread, 0, sizeof( THREAD ) );
	pThread->flags.bLocal = TRUE;
	pThread->proc = proc;
	pThread->param = param;
	pThread->thread_ident = 0;
#if DBG_AVAILABLE
	pThread->pFile = pFile;
	pThread->nLine = nLine;
#endif
	globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
	Log( WIDE("Begin Create Thread") );
#endif
#ifdef _WIN32
#if defined( __WATCOMC__ ) || defined( __WATCOM_CPLUSPLUS__ )
	pThread->hThread = (HANDLE)_beginthread( (void(*)(void*))ThreadWrapper, 8192, pThread );
#else
	{
		DWORD dwJunk;
		pThread->hThread = CreateThread( NULL, 1024
		                               , (LPTHREAD_START_ROUTINE)(ThreadWrapper)
		                               , pThread
		                               , 0
		                               , &dwJunk );
	}
#endif
	success = (int)(pThread->hThread!=NULL);
#else
	//lprintf( "Create thread..." );
	success = !pthread_create( &pThread->hThread, NULL, (void*(*)(void*))ThreadWrapper, pThread );
#endif
	if( success )
	{
#ifndef _WIN32
		pthread_detach( pThread->hThread );
		// I don't get the return code from threads...
		// thread wrapper self destructs its handles...
		// should add an event callback on thread end.
#endif
		// link into list... it's a valid thread
		// the system claims that it can start one.
		//if( ( ( pThread->next = globalTimerData.threads ) ) )
		//   globalTimerData.threads->me = &pThread->next;
		//pThread->me = &globalTimerData.threads;
		//globalTimerData.threads = pThread;
		pThread->flags.bReady = 1;
		{
			uint32_t now = GetTickCount();
			while( !pThread->thread_event && ( now + 250 ) > GetTickCount()  )
				Relinquish();
		}
#ifdef LOG_THREAD
		Log3( WIDE("Created thread address: %p %016"_64fx" at %p")
		    , pThread->proc, pThread->thread_ident, pThread );
#endif
	}
	else
	{
		// unlink from globalTimerData.threads list.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
 /*Release( pThread )*/
		DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
		globalTimerData.lock_thread_create = 0;
		pThread = NULL;
	}
	return pThread;
}
//--------------------------------------------------------------------------
PTHREAD  ThreadToSimpleEx( uintptr_t (CPROC*proc)(POINTER), POINTER param DBG_PASS )
{
	int success;
	PTHREAD pThread;
	while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
		Relinquish();
	pThread = GetFromSet( THREAD, &globalTimerData.threadset );
	/*AllocateEx( sizeof( THREAD ) DBG_RELAY );*/
#ifdef LOG_THREAD
	Log( WIDE("Creating a new thread... ") );
	lprintf( WIDE("New thread %p"), pThread );
#endif
	MemSet( pThread, 0, sizeof( THREAD ) );
	pThread->flags.bLocal = TRUE;
	pThread->simple_proc = proc;
	pThread->param = (uintptr_t)param;
	pThread->thread_ident = 0;
#if DBG_AVAILABLE
	pThread->pFile = pFile;
	pThread->nLine = nLine;
#endif
	globalTimerData.lock_thread_create = 0;
#ifdef LOG_THREAD
	Log( WIDE("Begin Create Thread") );
#endif
#ifdef _WIN32
#if defined( __WATCOMC__ ) || defined( __WATCOM_CPLUSPLUS__ )
	pThread->hThread = (HANDLE)_beginthread( (void(*)(void*))SimpleThreadWrapper, 8192, pThread );
#else
	{
		DWORD dwJunk;
		pThread->hThread = CreateThread( NULL, 1024
		                               , (LPTHREAD_START_ROUTINE)(SimpleThreadWrapper)
		                               , pThread
		                               , 0
		                               , &dwJunk );
	}
#endif
	success = (int)(pThread->hThread!=NULL);
#else
	//lprintf( "Create thread" );
	success = !pthread_create( &pThread->hThread, NULL, (void*(*)(void*))SimpleThreadWrapper, pThread );
#endif
	if( success )
	{
		// link into list... it's a valid thread
		// the system claims that it can start one.
		//if( ( ( pThread->next = globalTimerData.threads ) ) )
		//   globalTimerData.threads->me = &pThread->next;
		//pThread->me = &globalTimerData.threads;
		//globalTimerData.threads = pThread;
		pThread->flags.bReady = 1;
		while( !pThread->thread_ident )
			Relinquish();
#ifdef LOG_THREAD
		lprintf( WIDE("Created thread address: %p %016"_64fx" at %p")
		       , pThread->proc, pThread->thread_ident, pThread );
#endif
	}
	else
	{
		// unlink from globalTimerData.threads list.
		while( LockedExchangePtrSzVal( &globalTimerData.lock_thread_create, 1 ) )
			Relinquish();
 /*Release( pThread )*/
		DeleteFromSet( THREAD, globalTimerData.threadset, pThread );
		globalTimerData.lock_thread_create = 0;
		pThread = NULL;
	}
	return pThread;
}
//--------------------------------------------------------------------------
void  EndThread( PTHREAD thread )
{
	if( thread )
	{
#ifdef __LINUX__
#  ifndef __ANDROID__
		pthread_cancel( thread->hThread );
#  endif
#else
		TerminateThread( thread->hThread, 0xD1E );
#ifdef LOG_THREAD
		lprintf( WIDE("Killing thread...") );
#endif
		CloseHandle( thread->thread_event->hEvent );
#endif
	}
}
#if _WIN32
HANDLE GetThreadHandle( PTHREAD thread )
{
	if( thread )
		return thread->hThread;
	return INVALID_HANDLE_VALUE;
}
#endif
#ifdef __LINUX__
pthread_t GetThreadHandle( PTHREAD thread )
{
	if( thread )
		return thread->hThread;
	return (pthread_t)NULL;
}
#endif
//--------------------------------------------------------------------------
static void DoInsertTimer( PTIMER timer )
{
	PTIMER check;
#ifdef ENABLE_CRITICALSEC_LOGGING
	BIT_FIELD bLock = globalTimerData.flags.bLogCriticalSections;
	SetCriticalLogging( 0 );
	globalTimerData.flags.bLogCriticalSections = 0;
#endif
	EnterCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = bLock;
	SetCriticalLogging( bLock );
#endif
	if( !(check = globalTimerData.timers) )
	{
#ifdef LOG_INSERTS
		Log( WIDE("First(only known) timer!") );
#endif
		// subtract already existing time... (ONLY if first timer)
		//timer->delta -= ( globalTimerData.this_tick - globalTimerData.last_tick );
		(*(timer->me = &globalTimerData.timers))=timer;
#ifdef LOG_INSERTS
		Log( WIDE("Done with addition") );
#endif
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
		globalTimerData.flags.bLogCriticalSections = bLock;
		SetCriticalLogging( bLock );
#endif
		return;
	}
	while( check )
	{
		// was previously <= which would schedule equal timers at the
		// head of the queue constantly.
#ifdef LOG_INSERTS
		lprintf( WIDE("Timer to store %d freq: %d delta: %d check delta: %d"), timer->ID, timer->frequency, timer->delta, check->delta );
#endif
		if( timer->delta < check->delta )
		{
			check->delta -= timer->delta;
#ifdef LOG_INSERTS
			Log3( WIDE("Storing before timer: %d delta %d next %d"), check->ID, timer->delta, check->delta );
#endif
			timer->next = check;
			(*(timer->me = check->me))=timer;
			check->me = &timer->next;
			break;
		}
		else
		{
			timer->delta -= check->delta;
		}
		if( !check->next )
		{
#ifdef LOG_INSERTS
			Log1( WIDE("Storing after last timer. Delta %d"), timer->delta );
#endif
			(*(timer->me = &check->next))=timer;
			break;
		}
		check = check->next;
	}
#ifdef LOG_INSERTS
	Log( WIDE("Done with addition") );
#endif
	if( !check )
		Log( WIDE("Fatal! Didn't add the timer!") );
#ifdef ENABLE_CRITICALSEC_LOGGING
	SetCriticalLogging( 0 );
	globalTimerData.flags.bLogCriticalSections = 0;
#endif
	LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
	globalTimerData.flags.bLogCriticalSections = bLock;
	SetCriticalLogging( bLock );
#endif
}
//--------------------------------------------------------------------------
static uintptr_t CPROC find_timer( POINTER p, uintptr_t psvID )
{
	uint32_t timerID = (uint32_t)psvID;
	PTIMER timer = (PTIMER)p;
	//lprintf( "Find to remove test %d==%d", timer->ID, timerID );
	if( timer->ID == timerID )
		return (uintptr_t)p;
	return 0;
}
static void  DoRemoveTimer( uint32_t timerID DBG_PASS )
{
	EnterCriticalSec( &globalTimerData.csGrab );
	{
		PTIMER timer = globalTimerData.timers;
		uintptr_t psvTimerResult = ForAllInSet( TIMER, &globalTimerData.timer_pool, find_timer, (uintptr_t)timerID );
		if( psvTimerResult )
			timer = (PTIMER)psvTimerResult;
		else
		{
			while( timer )
			{
				if( timer->ID == timerID )
					break;
				timer = timer->next;
			}
		}
		if( timer )
		{
			PTIMER tmp;
			if( ( tmp = ( (*timer->me) = timer->next ) ) )
			{
				// if I had a next - his refernece of thing that points at him is mine.
				tmp->delta += timer->delta;
				tmp->me = timer->me;
			}
			DeleteFromSet( TIMER, globalTimerData.timer_pool, timer );
		}
		else
			_lprintf(DBG_RELAY)( WIDE("Failed to find timer to grab") );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
static void InsertTimer( PTIMER timer DBG_PASS )
{
	if( NotTimerThread() )
	{
		if( globalTimerData.flags.away_in_timer )
 // if it's away - should be safe to add a new timer
		{
			globalTimerData.flags.insert_while_away = 1;
			// set that we're adding a timer while away
			if( globalTimerData.flags.away_in_timer )
			{
				// if the thread is still away - we can add the timer...
#ifdef LOG_SLEEPS
				lprintf( "Timer is away, just add this new timer back in.." );
#endif
				DoInsertTimer( timer );
				globalTimerData.flags.insert_while_away = 0;
				return;
			}
			// otherwise he came back before we set our addin
			// therefore it should be safe to schedule.
			globalTimerData.flags.insert_while_away = 0;
		}
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...to wait for change allow") );
#endif
		// lockout multiple additions...
		EnterCriticalSec( &globalTimerData.cs_timer_change );
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...to wait for free add") );
#endif
		// don't add a timer while there's one being added...
		while( globalTimerData.add_timer )
		{
			WakeThread(globalTimerData.pTimerThread);
			//Relinquish();
		}
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...setup dataa") );
#endif
		globalTimerData.add_timer = timer;
		LeaveCriticalSec( &globalTimerData.cs_timer_change );
		// it might be sleeping....
#ifdef LOG_INSERTS
		Log( WIDE("Inserting timer...wake and done") );
#endif
#ifdef LOG_SLEEPS
		lprintf( "Wake timer thread." );
#endif
		// wake this thread because it's current scheduled delta (ex 1000ms)
		// may put it's sleep beyond the frequency of this timer (ex 10ms)
		WakeThreadEx(globalTimerData.pTimerThread DBG_RELAY);
	}
	else
	{
		EnterCriticalSec( &globalTimerData.csGrab );
		// have to assume that we're away in callback
		// in order to get here... there's no other way
		// for this routine to be called and BE the timer thread.
		// therefore - safe to add it.
		DoInsertTimer( timer );
#ifdef LOG_SLEEPS
		lprintf( "Insert timer not dispatched." );
#endif
		if( globalTimerData.timers == timer )
		{
#ifdef LOG_SLEEPS
			lprintf( "Wake timer thread." );
#endif
			WakeThread(globalTimerData.pTimerThread);
		}
		LeaveCriticalSec( &globalTimerData.csGrab );
	}
}
//--------------------------------------------------------------------------
static PTIMER GrabTimer( PTIMER timer )
{
	// if a timer has been grabbed, it won't be grabbed...
	// but if a timer is being grabbed, it might get grabbed twice.
	if( timer && timer->me )
	{
		// the thing that points at me points at my next....
#ifdef LOG_INSERTS
		Log1( WIDE("Grab Timer: %d"), timer->ID );
#endif
		if( ( (*timer->me) = timer->next ) )
		{
			// if I had a next - his refernece of thing that points at him is mine.
			timer->next->me = timer->me;
		}
		timer->next = NULL;
		timer->me = NULL;
		return timer;
	}
	return NULL;
}
//--------------------------------------------------------------------------
static int CPROC ProcessTimers( uintptr_t psvForce )
{
	if( global_timer_structure )
	{
	PTIMER timer;
#ifdef ENABLE_CRITICALSEC_LOGGING
	BIT_FIELD bLock = globalTimerData.flags.bLogCriticalSections;
#endif
	uint32_t newtick;
	if( globalTimerData.flags.bExited )
		return -1;
	if( !psvForce && !IsThisThread( globalTimerData.pTimerThread ) )
	{
		//Log( WIDE("Unknown thread attempting to process timers...") );
		return -1;
	}
#ifndef _WIN32
	//nice( -3 ); // allow ourselves a bit more priority...
#endif
	{
		// there are timers - and there's one which wants to be added...
		// if there's no timers - just sleep here...
		while( ( !globalTimerData.add_timer && !globalTimerData.timers ) || globalTimerData.flags.bHaltTimers )
		{
			if( !psvForce )
				return 1;
#ifdef LOG_SLEEPS
			lprintf( WIDE("Timer thread sleeping forever...") );
#endif
#ifdef __LINUX__
			if( globalTimerData.pTimerThread )
				TimerWakeableSleep( SLEEP_FOREVER );
#else
			WakeableSleep( SLEEP_FOREVER );
#endif
			// had no timers - but NOW either we woke up by default...
			// OR - we go kicked awake - so mark the beginning of known time.
#ifdef LOG_LATENCY
			Log( WIDE("Re-synch first tick...") );
#endif
//GetTickCount();
			globalTimerData.last_tick = timeGetTime();
		}
		// add and delete new/old timers here...
		// should be the next event after sleeping (low var-sleep top const-sleep)
		if( globalTimerData.add_timer )
		{
#ifdef LOG_INSERTS
			Log( WIDE("Adding timer really...") );
#endif
			DoInsertTimer( globalTimerData.add_timer );
			globalTimerData.add_timer = NULL;
		}
		if( globalTimerData.del_timer )
		{
#ifdef LOG_INSERTS
			Log( WIDE("Scheduled remove timer...") );
#endif
			DoRemoveTimer( globalTimerData.del_timer DBG_SRC );
			globalTimerData.del_timer = 0;
		}
		// get the time now....
//GetTickCount();
		newtick = globalTimerData.this_tick = timeGetTime();
#ifdef LOG_LATENCY
		Log3( WIDE("total - Tick: %u Last: %u  delta: %u"), globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick );
#endif
		//if( globalTimerData.timers )
		//	 delay_skew = globalTimerData.this_tick-globalTimerData.last_tick - globalTimerData.timers->delta;
		// delay_skew = 0; // already chaotic...
		//if( timers )
		//	Log1( WIDE("timer delta: %ud"), timers->delta );
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		while( ( EnterCriticalSec( &globalTimerData.csGrab ), timer = globalTimerData.timers ) &&
				( (int32_t)( newtick - globalTimerData.last_tick ) >= timer->delta ) )
		{
#ifdef ENABLE_CRITICALSEC_LOGGING
			globalTimerData.flags.bLogCriticalSections = bLock;
			SetCriticalLogging( bLock );
#endif
#ifdef LOG_LATENCY
#ifdef _DEBUG
			_xlprintf( 1, timer->pFile, timer->nLine )( WIDE("Tick: %u Last: %u  delta: %u Timerdelta: %u")
																	, globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick, timer->delta );
#else
			lprintf( WIDE("Tick: %u Last: %u  delta: %u Timerdelta: %u")
			       , globalTimerData.this_tick, globalTimerData.last_tick, globalTimerData.this_tick-globalTimerData.last_tick, timer->delta );
#endif
#endif
			// also enters csGrab... should be ok.
			GrabTimer( timer );
#ifdef ENABLE_CRITICALSEC_LOGGING
			SetCriticalLogging( 0 );
			globalTimerData.flags.bLogCriticalSections = 0;
#endif
			LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
			globalTimerData.flags.bLogCriticalSections = bLock;
			SetCriticalLogging( bLock );
#endif
			globalTimerData.last_tick += timer->delta;
			if( timer->callback )
			{
#ifdef _WIN32
#if PARANOID
				if( IsBadCodePtr( (FARPROC)timer->callback ) )
				{
					Log1( WIDE("Timer %d proc has been unloaded! kiling timer"), timer->ID );
					timer->frequency = 0;
				}
				else
#endif
#endif
				{
					//#ifdef LOG_DISPATCH
					static int level;
					if( globalTimerData.flags.bLogTimerDispatch )
					{
						level++;
#ifdef _DEBUG
						lprintf( WIDE("%d Dispatching timer %")_32fs WIDE(" freq %")_32fs WIDE(" %s(%d)"), level, timer->ID, timer->frequency
						       , timer->pFile, timer->nLine );
#else
						lprintf( WIDE("%d Dispatching timer %") _32fs WIDE(" freq %") _32fs, level, timer->ID, timer->frequency );
#endif
					}
					//#endif
					globalTimerData.current_timer = timer;
					timer->flags.bRescheduled = 0;
					globalTimerData.flags.away_in_timer = 1;
					globalTimerData.CurrentTimerID = timer->ID;
					timer->callback( timer->userdata );
					if( globalTimerData.flags.bLogTimerDispatch )
					{
						level--;
						lprintf( WIDE("timer done. (%d)"), level );
					}
					globalTimerData.flags.away_in_timer = 0;
					while( globalTimerData.flags.insert_while_away )
					{
						// request for insert while away... allow it to
						// get scheduled...
						Relinquish();
					}
					globalTimerData.current_timer = NULL;
				}
				// allow timers to be added while away in this
				// timer's callback... so wait for it to finish.
				// but do - clear away status so that ANOTHER
				// timer will be held waiting...
			}
			// reset timer to frequency here
			// if a VERY long time has elapsed, next timer occurs its
			//  frequency after now.  Otherwise we may NEVER get out
			//  of processing this timer.
			// this point should be optioned whether the timer is
			// a guaranteed tick, or whether it's sloppy.
			if( timer->frequency || timer->flags.bRescheduled )
			{
				if( timer->flags.bRescheduled )
				{
					timer->flags.bRescheduled = 0;
					// delta will have been set for next run...
					// therefore do not schedule it ourselves.
				}
				else
				{
					if( ( newtick - globalTimerData.last_tick ) > timer->frequency )
					{
#ifdef LOG_LATENCY_LIGHT
						lprintf( WIDE("Timer used more time than its frequency.  Scheduling at 1 ms.") );
#endif
						timer->delta = ( newtick - globalTimerData.last_tick ) + 1;
					}
					else
					{
#ifdef LOG_LATENCY_LIGHT
						// timer alwyas goes +1 frequency from its base tick.
						lprintf( WIDE("Scheduling timer at 1 frequency.") );
#endif
						timer->delta = timer->frequency;
					}
				}
				DoInsertTimer( timer );
			}
			else
			{
#ifdef LOG_INSERTS
				lprintf( WIDE("Removing one shot timer. %d"), timer->ID );
#endif
				// was a one shot timer.
				DeleteFromSet( TIMER, globalTimerData.timer_pool, timer );
				timer = NULL;
			}
		}
#ifdef ENABLE_CRITICALSEC_LOGGING
		SetCriticalLogging( 0 );
		globalTimerData.flags.bLogCriticalSections = 0;
#endif
		LeaveCriticalSec( &globalTimerData.csGrab );
#ifdef ENABLE_CRITICALSEC_LOGGING
		globalTimerData.flags.bLogCriticalSections = bLock;
		SetCriticalLogging( bLock );
#endif
		if( timer )
		{
#ifdef LOG_LATENCY
			lprintf( WIDE("Pending timer in: %d Sleeping %d (%d) [%d]")
			       , timer->delta
			       , timer->delta - (newtick-globalTimerData.last_tick)
			       , timer->delta - (globalTimerData.this_tick-globalTimerData.last_tick)
			       , newtick - globalTimerData.this_tick
			       );
#endif
			globalTimerData.last_sleep = ( timer->delta - ( globalTimerData.this_tick - globalTimerData.last_tick ) );
			if( globalTimerData.last_sleep < 0 )
			{
				lprintf( WIDE( "next pending sleep is %d" ), globalTimerData.last_sleep );
				globalTimerData.last_sleep = 1;
			}
#ifdef LOG_LATENCY
			Log1( WIDE("Sleeping %d"), globalTimerData.last_sleep );
#endif
			if( !psvForce )
				return 1;
			if( globalTimerData.last_sleep )
			{
#ifdef __LINUX__
				TimerWakeableSleep( globalTimerData.last_sleep );
#else
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
				WakeableSleepEx( globalTimerData.last_sleep, timer->pFile, timer->nLine );
#else
				WakeableSleepEx( globalTimerData.last_sleep );
#endif
#endif
			}
			if( !global_timer_structure || globalTimerData.flags.bExited )
				return -1;
		}
		// else no timers - go back up to the top - where we sleep.
	}
	//Log( WIDE("Timer thread is exiting...") );
	return 1;
	}
	return -1;
}
//--------------------------------------------------------------------------
uintptr_t CPROC ThreadProc( PTHREAD pThread )
{
	InitializeCriticalSec( &globalTimerData.cs_timer_change );
	globalTimerData.pTimerThread = pThread;
#ifndef __NO_IDLE__
	AddIdleProc( ProcessTimers, (uintptr_t)0 );
#endif
#ifndef _WIN32
 // allow ourselves a bit more priority...
	nice( -3 );
#endif
	//Log( WIDE("Permanently lock timers - indicates that thread is running...") );
	globalTimerData.lock_timers = 1;
	//Log( WIDE("Get first tick") );
//GetTickCount();
	globalTimerData.last_tick = timeGetTime();
	while( ProcessTimers( 1 ) > 0 );
	//Log( WIDE("Timer thread is exiting...") );
	globalTimerData.pTimerThread = NULL;
	return 0;
}
//--------------------------------------------------------------------------
#if 0
// this would really be a good thing to impelment someday.
static void *WatchdogProc( void *unused )
{
	// this checks the running status of the main thread(s)
// if there is a paused thread, then a new thread is created.
// yeah see dekware( syscore/nexus.c WakeAThread() )
	return 0;
}
#endif
//--------------------------------------------------------------------------
uint32_t  AddTimerExx( uint32_t start, uint32_t frequency, TimerCallbackProc callback, uintptr_t user DBG_PASS )
{
	PTIMER timer = GetFromSet( TIMER, &globalTimerData.timer_pool );
	//timer = AllocateEx( sizeof( TIMER ) DBG_RELAY );
	MemSet( timer, 0, sizeof( TIMER ) );
	if( start && !frequency )
	{
		//"Creating one shot timer %d long", start );
	}
 // first time for timer to fire... may be 0
	timer->delta     = (int32_t)start;
	timer->frequency = frequency;
	timer->callback  = callback;
	timer->ID        = globalTimerData.timerID++;
	timer->userdata  = user;
#ifdef _DEBUG
	timer->pFile = pFile;
	timer->nLine = nLine;
#endif
	if( !globalTimerData.pTimerThread )
	{
		//Log( WIDE("Starting \"a\" timer thread!!!!" ) );
		if( !( ThreadTo( ThreadProc, 0 ) ) )
		{
			//Log1( WIDE("Failed to start timer ThreadProc... %d"), GetLastError() );
			return 0;
		}
		while( !globalTimerData.lock_timers )
			Relinquish();
		//Log1( WIDE("Thread started successfully? %d"), GetLastError() );
		// make sure that the thread is running, and had setup its
		// locks, and tick reference
	}
	//_xlprintf(1 DBG_RELAY)( WIDE("Inserting newly created timer.") );
	InsertTimer( timer DBG_RELAY );
	// don't need to sighup here, cause we MUST have permission
	// from the idle thread to add the timer, which means we issue it
	// a sighup to make it wake up and allow us to post.
#ifdef LOG_INSERTS
	_lprintf( DBG_RELAY )( "Resulting timer ID: %d", timer->ID );
#endif
	return timer->ID;
}
#undef AddTimerEx
uint32_t  AddTimerEx( uint32_t start, uint32_t frequency, void (CPROC*callback)(uintptr_t user), uintptr_t user )
{
	return AddTimerExx( start, frequency, callback, user DBG_SRC );
}
//--------------------------------------------------------------------------
void  RemoveTimerEx( uint32_t ID DBG_PASS )
{
	// Lockout multiple changes at a time...
 // IS timer thread..
	if( !NotTimerThread() &&
 // and not in THIS timer...
		( ID != globalTimerData.CurrentTimerID ) )
	{
		// is timer thread itself... safe to remove the timer....
		DoRemoveTimer( ID DBG_SRC );
		return;
	}
	EnterCriticalSec( &globalTimerData.cs_timer_change );
	// only allow one delete at a time...
	while( globalTimerData.del_timer )
	{
#ifdef LOG_INSERTS
		lprintf( "pending timer delete, wait." );
#endif
 // IS timer thread...
		if( !NotTimerThread() )
		{
#ifdef LOG_INSERTS
			lprintf( "is not the timer." );
#endif
			if( globalTimerData.del_timer != globalTimerData.CurrentTimerID )
			{
#ifdef LOG_INSERTS
				lprintf( "schedule timer is not the current timer..." );
#endif
				DoRemoveTimer( globalTimerData.del_timer DBG_SRC );
				globalTimerData.del_timer = 0;
			}
			if( ID != globalTimerData.CurrentTimerID )
			{
#ifdef LOG_INSERTS
				lprintf( "removing timer is not the current timer" );
#endif
				DoRemoveTimer( ID DBG_SRC );
				return;
			}
		}
		else
			Relinquish();
	}
	// now how to set del_timer to a valid timer?!
#ifdef LOG_INSERTS
	_lprintf(DBG_RELAY)( "Set del_timer to schedule delete." );
#endif
	globalTimerData.del_timer = ID;
	LeaveCriticalSec( &globalTimerData.cs_timer_change );
	if( NotTimerThread() )
	{
#ifdef LOG_INSERTS
		lprintf( "wake thread, scheduled delete" );
#endif
		//Log( WIDE("waking timer thread to indicate deletion...") );
		WakeThread( globalTimerData.pTimerThread );
	}
}
#undef RemoveTimer
void  RemoveTimer( uint32_t ID )
{
	RemoveTimerEx( ID DBG_SRC );
}
//--------------------------------------------------------------------------
static void InternalRescheduleTimerEx( PTIMER timer, uint32_t delay )
{
	if( timer )
	{
		PTIMER bGrabbed = GrabTimer( timer );
		timer->flags.bRescheduled = 1;
  // should never pass a negative value here, but delta can be negative.
		timer->delta = (int32_t)delay;
#ifdef LOG_SLEEPS
		lprintf( "Reschedule at %d  %p", timer->delta, bGrabbed );
#endif
		if( bGrabbed )
		{
			//lprintf( WIDE("Rescheduling timer...") );
			DoInsertTimer( timer );
			if( timer == globalTimerData.timers )
			{
#ifdef LOG_SLEEPS
				lprintf( "We cheated to insert - so create a wake." );
#endif
				WakeThread( globalTimerData.pTimerThread );
			}
		}
	}
}
//--------------------------------------------------------------------------
// should lock this...
void  RescheduleTimerEx( uint32_t ID, uint32_t delay )
{
	PTIMER timer;
	EnterCriticalSec( &globalTimerData.csGrab );
	if( !ID )
	{
		timer =globalTimerData.current_timer;
	}
	else
	{
		timer = globalTimerData.timers;
		while( timer && timer->ID != ID )
			timer = timer->next;
		if( !timer )
		{
			// this timer is not part of the list if it's
			// dispatched and we get here (timer itself rescheduling itself)
			if( globalTimerData.current_timer && globalTimerData.current_timer->ID == ID )
				timer = globalTimerData.current_timer;
		}
	}
	InternalRescheduleTimerEx( timer, delay );
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
void  RescheduleTimer( uint32_t ID )
{
	PTIMER timer = globalTimerData.timers;
	EnterCriticalSec( &globalTimerData.csGrab );
	while( timer && timer->ID != ID )
		timer = timer->next;
	if( !timer )
	{
		if( globalTimerData.current_timer && globalTimerData.current_timer->ID == ID )
			timer = globalTimerData.current_timer;
	}
	if( timer )
	{
		InternalRescheduleTimerEx( timer, timer->frequency );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
static void OnDisplayPause( WIDE("@Internal Timers") _WIDE(TARGETNAME) )( void )
{
	globalTimerData.flags.bHaltTimers = 1;
}
//--------------------------------------------------------------------------
static void OnDisplayResume( WIDE("@Internal Timers") _WIDE(TARGETNAME))( void )
{
	globalTimerData.flags.bHaltTimers = 0;
	if( globalTimerData.pTimerThread )
		WakeThread( globalTimerData.pTimerThread );
}
//--------------------------------------------------------------------------
void  ChangeTimerEx( uint32_t ID, uint32_t initial, uint32_t frequency )
{
	PTIMER timer = globalTimerData.timers;
	EnterCriticalSec( &globalTimerData.csGrab );
	while( timer && timer->ID != ID )
		timer = timer->next;
	if( timer )
	{
		timer->frequency = frequency;
		InternalRescheduleTimerEx( timer, initial );
	}
	LeaveCriticalSec( &globalTimerData.csGrab );
}
//--------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
#ifdef _MSC_VER
#  pragma optimize( "st", off )
#endif
LOGICAL  EnterCriticalSecEx( PCRITICALSECTION pcs DBG_PASS )
{
	int d;
	THREAD_ID prior = 0;
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#ifdef _DEBUG
	if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
		_lprintf( DBG_RELAY )( WIDE("Enter critical section %p (owner) %")_64fx, pcs, pcs->dwThreadID );
#endif
#endif
	do
	{
		d=EnterCriticalSecNoWaitEx( pcs, &prior DBG_RELAY );
		if( d < 0 )
			Relinquish();
		else if( d == 0 )
		{
			if( pcs->dwThreadID )
			{
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Failed to enter section... sleeping (forever)...") );
#  endif
#endif
				WakeableNamedThreadSleepEx( WIDE("sack.critsec"), SLEEP_FOREVER DBG_RELAY );
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Allowed to retry section entry, woken up...") );
#  endif
#endif
			}
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
			else
			{
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Lock Released while we logged?") );
			}
#  endif
#endif
		}
		else {
			if( prior ) {
#ifdef ENABLE_CRITICALSEC_LOGGING
#  ifdef _DEBUG
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					lprintf( WIDE("Entered section, restore prior waiting thread. %") _64fx  WIDE(" %" ) _64fx, prior, pcs->dwThreadWaiting );
#  endif
#endif
			}
		}
		// after waking up, this will re-aquire a lock, and
		// set the prior waiting ID into the criticalsection
		// this will then wake that process when this lock is left.
	}
	while( (d <= 0) );
	return TRUE;
}
#endif
//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
#ifdef _MSC_VER
#  pragma optimize( "st", off )
#endif
LOGICAL  LeaveCriticalSecEx( PCRITICALSECTION pcs DBG_PASS )
{
	THREAD_ID dwCurProc;
#ifdef _DEBUG
	uint32_t curtick;
#endif
	while( 1 ) {
#ifdef _DEBUG
		curtick = timeGetTime();
#endif
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			_xlprintf( LOG_NOISE DBG_RELAY )( WIDE( "Begin leave critical section %p %" ) _64fx, pcs, pcs->dwThreadWaiting );
#endif
		while( LockedExchange( &pcs->dwUpdating, 1 )
#ifdef _DEBUG
			//GetTickCount() )
			&& ( ( curtick + 2000 ) > timeGetTime() )
#endif
			) {
#ifdef ENABLE_CRITICALSEC_LOGGING
			if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
				_lprintf( DBG_RELAY )( WIDE( "On leave - section is updating, wait..." ) );
#endif
			Relinquish();
}
		dwCurProc = GetMyThreadID();
#ifdef _DEBUG
		//GetTickCount() )
		if( ( curtick + 2000 ) <= timeGetTime() ) {
			lprintf( WIDE( "Timeout during critical section wait for lock.  No lock should take more than 1 task cycle" ) );
			DebugBreak();
			continue;
		}
#endif
		break;
	}
	if( !( pcs->dwLocks & ~SECTION_LOGGED_WAIT ) )
	{
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			_lprintf( DBG_RELAY )( WIDE("Leaving a blank critical section") );
#endif
		DebugBreak();
		pcs->dwUpdating = 0;
		return FALSE;
	}
	if( pcs->dwThreadID == dwCurProc )
	{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
		pcs->pFile[pcs->nPrior] = pFile;
		pcs->nLine[pcs->nPrior] = nLine;
#  else
		pcs->pFile[pcs->nPrior] = __FILE__;
		pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
		pcs->nLineCS[pcs->nPrior] = __LINE__;
		pcs->isLock[pcs->nPrior] = 0;
		pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
		pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
		pcs->dwLocks--;
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
			lprintf( WIDE("Remaining locks... %08") _32fx, pcs->dwLocks );
#endif
		if( !( pcs->dwLocks & ~(SECTION_LOGGED_WAIT) ) )
		{
			pcs->dwLocks = 0;
			pcs->dwThreadID = 0;
			// wake the prior (if there is one sleeping)
			if( pcs->dwThreadWaiting )
			{
				pcs->dwUpdating = 0;
#ifdef ENABLE_CRITICALSEC_LOGGING
				if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
					_lprintf( DBG_RELAY )( WIDE("%8")_64fx WIDE(" Waking a thread which is waiting..."), pcs->dwThreadWaiting );
#endif
				// don't clear waiting... so the proper thread can
				// allow itself to claim section...
				WakeNamedThreadSleeperEx( WIDE("sack.critsec"), pcs->dwThreadWaiting DBG_RELAY );
				//WakeThreadIDEx( wake DBG_RELAY);
			}
			else
				pcs->dwUpdating = 0;
			return TRUE;
		}
	}
	else {
#ifdef ENABLE_CRITICALSEC_LOGGING
		if( global_timer_structure && globalTimerData.flags.bLogCriticalSections )
		{
			_lprintf( DBG_RELAY )(WIDE( "Sorry - you can't leave a section owned by %016" )_64fx WIDE( " locks:%08" )_32fx
#  ifdef DEBUG_CRITICAL_SECTIONS
				WIDE( "%s(%d)..." )
#  endif
				, pcs->dwThreadID
				, pcs->dwLocks
#  ifdef DEBUG_CRITICAL_SECTIONS
				, (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) ? (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) : WIDE( "Unknown" ), pcs->nLine[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]
#  endif
				);
		}
#endif
		DebugBreak();
	}
	pcs->dwUpdating = 0;
	return FALSE;
}
#endif
//--------------------------------------------------------------------------
void DeleteCriticalSec( PCRITICALSECTION pcs )
{
	// ya I don't have anything to do here...
	return;
}
#ifdef _WIN32
HANDLE  GetWakeEvent( void )
{
#if HAS_TLS
	struct my_thread_info* _MyThreadInfo = GetThreadTLS();
	if( !MyThreadInfo.pThread )
		MakeThread();
	return MyThreadInfo.pThread->thread_event->hEvent;
#else
	return MakeThread()->thread_event->hEvent;
#endif
}
#endif
#ifdef __cplusplus
//	namespace timers {
};
//namespace sack {
};
#endif
//--------------------------------------------------------------------------
// $Log: timers.c,v $
// Revision 1.140  2005/06/22 23:13:51  jim
// Differentiate the normal logging of 'entered, left section' but leave in notable exception case logging when enabling critical section debugging.
//
// Revision 1.108  2005/01/23 11:28:24  panther
// Thread ID modification broke timer...
//
// 400 lines of logging removed... version 1.109?
#ifdef __cplusplus
namespace sack {
	namespace timers {
		using namespace sack::memory;
#endif
      typedef struct idle_proc_tag IDLEPROC;
      typedef struct idle_proc_tag *PIDLEPROC;
struct idle_proc_tag
{
	struct {
		BIT_FIELD bDispatched : 1;
		BIT_FIELD bRemove : 1;
	} flags;
	// return -1 if not the correct thread
	// to handle this callback
	// return 0 if no messages were processed
	// return 1 if messages were processed
	int (CPROC*function)(uintptr_t);
	uintptr_t data;
	THREAD_ID thread;
	//PDATAQUEUE threads;
 // same function references go here - for multiple thread entries...
	PIDLEPROC similar;
	DeclareLink( struct idle_proc_tag );
};
struct idle_global_tag {
	CRITICALSECTION idle_cs;
	LOGICAL cs_inited;
	PIDLEPROC registered_idle_procs;
};
#ifndef __STATIC_GLOBALS__
// registered_idle_procs;
static struct idle_global_tag *idle_global;
PRIORITY_PRELOAD( InitGlobalIdle, OSALOT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( idle_global );
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = 1;
	}
}
#else
// registered_idle_procs;
static struct idle_global_tag _idle_global;
// registered_idle_procs;
static struct idle_global_tag *idle_global = &_idle_global;
#endif
#ifdef procs
#  undef procs
#endif
#define procs ((*idle_global).registered_idle_procs)
IDLE_PROC( void, AddIdleProc )( int (CPROC*Proc)( uintptr_t psv ), uintptr_t psvUser )
{
	PIDLEPROC proc = NULL;
#ifndef __STATIC_GLOBALS__
	if( !idle_global )
		SimpleRegisterAndCreateGlobal( idle_global );
#endif
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = TRUE;
	}
	EnterCriticalSec( &(*idle_global).idle_cs );
	for( proc = procs; proc; proc = proc->next )
	{
		if( Proc == proc->function )
		{
			PIDLEPROC newproc = (PIDLEPROC)Allocate( sizeof( IDLEPROC ) );
			MemSet( newproc, 0, sizeof( IDLEPROC ) );
			newproc->function = Proc;
			newproc->data = psvUser;
			LinkLast( proc->similar, PIDLEPROC, newproc );
			break;
		}
	}
	// if the function is not already registered as an idle proc, register it.
	if( !proc )
	{
		proc = (PIDLEPROC)Allocate( sizeof( IDLEPROC ) );
		MemSet( proc, 0, sizeof( IDLEPROC ) );
		proc->function = Proc;
		proc->data = psvUser;
		LinkThing( procs, proc );
	}
	LeaveCriticalSec( &(*idle_global).idle_cs );
}
IDLE_PROC( int, RemoveIdleProc )( int (CPROC*Proc)(uintptr_t psv ) )
{
	PIDLEPROC check_proc;
#ifndef __STATIC_GLOBALS__
	if( !idle_global )
		SimpleRegisterAndCreateGlobal( idle_global );
#endif
	if( !(*idle_global).cs_inited )
	{
		InitializeCriticalSec( &(*idle_global).idle_cs );
		(*idle_global).cs_inited = TRUE;
	}
	EnterCriticalSec( &(*idle_global).idle_cs );
	for( check_proc = procs; check_proc; check_proc = check_proc->next )
	{
		if( Proc == check_proc->function )
		{
			if( !check_proc->flags.bDispatched )
			{
				UnlinkThing( check_proc );
				if( check_proc->similar )
					LinkThing( check_proc->similar, procs );
				Release( check_proc );
			}
			else
			{
				check_proc->flags.bRemove = 1;
			}
			break;
		}
	}
	LeaveCriticalSec( &(*idle_global).idle_cs );
	return 0;
}
IDLE_PROC( int, IdleEx )( DBG_VOIDPASS )
{
	THREAD_ID me = GetMyThreadID();
	int success = 0;
	PIDLEPROC proc;
#ifndef __STATIC_GLOBALS__
	if( idle_global )
#endif
	for( proc = procs; proc;  )
	{
		PIDLEPROC check;
		for( check = proc; check; check = check->similar )
		{
			check->flags.bDispatched = 1;
			//lprintf( "attempt proc %p in %Lx  procthread=%Lx", check, GetThreadID( MakeThread() ), check->thread );
			//if( !check->thread || ( check->thread == me ) )
			// sometimes... a function belongs to multiple threads...
			if( check->function( check->data ) != -1 )
			{
				check->thread = me;
				success = 1;
			}
			check->flags.bDispatched = 0;
			if( check->flags.bRemove )
			{
				UnlinkThing( check );
				if( check->similar && check == proc )
					LinkThing( check->similar, procs );
				Release( proc );
				proc = procs;
				break;
			}
			else
			{
				//if( check->thread == me )
				{
					proc = proc->next;
					break;
				}
			}
		}
		if( check == NULL )
			proc = proc->next;
	}
	//_lprintf( DBG_AVAILABLE, WIDE("Is Going idle.") DBG_RELAY );
	Relinquish();
	//_lprintf( DBG_AVAILABLE, WIDE("Is back from idle.") DBG_RELAY );
	return success;
}
#undef Idle
IDLE_PROC( int, Idle )( void )
{
   return IdleEx( DBG_VOIDSRC );
}
IDLE_PROC( int, IdleForEx )( uint32_t dwMilliseconds DBG_PASS )
{
	uint32_t dwStart = timeGetTime();
	while( ( dwStart + dwMilliseconds ) > timeGetTime() )
	{
		if( !IdleEx( DBG_VOIDRELAY ) )
		{
			// sleeping... cause ew didn't do any idle procs...
			WakeableSleep( dwMilliseconds );
		}
	}
	return 0;
}
#undef IdleFor
IDLE_PROC( int, IdleFor )( uint32_t dwMilliseconds )
{
   return IdleForEx( dwMilliseconds DBG_SRC );
}
#undef procs
#ifdef __cplusplus
 //namespace sack {
};
 //	namespace idle {
};
#endif
#define NO_UNICODE_C
#define PROCREG_SOURCE
#ifdef __ANDROID__
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
#  endif
#endif
//#define DEBUG_GLOBAL_REGISTRATION
#define REGISTRY_STRUCTURE_DEFINED
//#define PROCREG_SOURCE
// include this first so we can have the namespace...
#undef REGISTRY_STRUCTURE_DEFINED
#ifndef REGISTRY_STRUCTURE_DEFINED
#define REGISTRY_STRUCTURE_DEFINED
#ifdef __LINUX__
// pid_t for service process registrations...
#endif
PROCREG_NAMESPACE
//typedef struct tree_def_tag *PCLASSROOT;
//typedef void (CPROC *PROCEDURE)(void);
enum proc_types {
	ARG_FLOAT
					, ARG_DOUBLE
					, ARG_CHAR
					, ARG_SHORT
					, ARG_LONG
					, ARG_LONGLONG
					, ARG_UCHAR
					, ARG_USHORT
					, ARG_ULONG
					, ARG_ULONGLONG
					, ARG_PTRFLOAT
					, ARG_PTRDOUBLE
					, ARG_PTRCHAR
					, ARG_PTRSHORT
					, ARG_PTRLONG
					, ARG_PTRLONGLONG
					, ARG_PTRUCHAR
					, ARG_PTRUSHORT
					, ARG_PTRULONG
					, ARG_PTRULONGLONG
               , ARG_PTRSTRING
};
#if 0
typedef struct proc_param_tag {
	enum proc_types type;
   int count;
//1>c:\work\sack\src\procreglib\registry.h(42) : warning C4200: nonstandard extension used : zero-sized array in struct/union
//1>        Cannot generate copy-ctor or copy-assignment operator when UDT contains a zero-sized array`
   char name[];
} PROC_PARAM;
#endif
typedef struct proc_def_tag
{
	//CTEXTSTR ret;
	// name is a NUL seperated list of fields
	// library:procname:return type:args
	// this is truly the full name of a procedure...
	// arguments have any spaces or odd characters stripped
	CTEXTSTR name;
	//CTEXTSTR args;
	CTEXTSTR library;
	CTEXTSTR procname;
 // proc is just a cache of library:name
	PROCEDURE proc;
} PROCDEF, *PPROCDEF;
#ifdef __cplusplus_cli
typedef struct stdproc_def_tag
{
	//CTEXTSTR ret;
	// name is a NUL seperated list of fields
	// library:procname:return type:args
	// this is truly the full name of a procedure...
	// arguments have any spaces or odd characters stripped
	CTEXTSTR name;
	//CTEXTSTR args;
	CTEXTSTR library;
	CTEXTSTR procname;
 // proc is just a cache of library:name
	STDPROCEDURE proc;
} STDPROCDEF, *PSTDPROCDEF;
#endif
#define MAGIC_TREE_NUMBER 0x20040525
#define IS_TREE_MAGIC(tree)  (*((uint32_t*)(&(tree))) == (uint32_t)MAGIC_TREE_NUMBER )
#define MAGIC_LIST_NUMBER 0x20040911
#define IS_LIST_MAGIC(tree)  (*((uint32_t*)(&(tree))) == (uint32_t)MAGIC_LIST_NUMBER )
typedef struct tree_def_tag
{
////////
// this and "/blah/blah/blah" look the same
// to an application.  Therefore a name is as good
// as text... internally a pointer to this structure
// when CTEXTSTR and PTREEDEF are received through a
// CTEXTSTR parameter, the distinction can be made by
// examinging the first 4 characters... however!
// the string passed must be at least 4 bytes of
   // real memory.
  // magic number 0x20040525
	uint32_t Magic;
	union {
 // any option can have a tree of suboptions?
		PTREEROOT Tree;
			// a list of things may serve as lightweight alternative
		PLIST List;
	};
   POINTER cursor;
   struct proc_name_tag *self;
} TREEDEF, *PTREEDEF;
typedef struct tree_def_tag const * PCTREEDEF;
#define MAXTREEDEFSPERSET 256
DeclareSet( TREEDEF );
typedef struct data_class_def_tag
{
   uintptr_t size;
   OpenCloseNotification Open;
   OpenCloseNotification Close;
   INDEX unique;
   TREEDEF instances;
} DATADEF, *PDATADEF;
typedef struct name_def_tag
{
	// a member can have a string and a number
   // associated with it.
   CTEXTSTR sValue;
   uintptr_t iValue;
} NAMEDEF, *PNAMEDEF;
#ifdef __LINUX__
typedef  struct service_tag {
	pid_t pid;
	uint32_t Msg;
	// paramters...
} SERVICE, *PSERVICE;
#endif
typedef struct proc_name_tag
{
	struct {
 // really only important when saving the tree
		BIT_FIELD bAlias: 1;
		// each and every node may reference a tree
		// if it does, then the tree will be non-NULL
 // else it's a proc leef...
		BIT_FIELD bTree : 1;
 // name value points at a name
		BIT_FIELD bValue : 1;
 // and value is a uintptr_t integer...
		BIT_FIELD bIntVal : 1;
 // and value is a uintptr_t integer...
		BIT_FIELD bStringVal : 1;
 // name points at a function
		BIT_FIELD bProc : 1;
  // this might be fun to register names across msgsvr's
		BIT_FIELD bService : 1;
 // data member defines data..
		BIT_FIELD bData : 1;
 // is a (__stdcall *) instead of a (CPROC *)
		BIT_FIELD bStdProc : 1;
	} flags;
	CTEXTSTR name;
	TREEDEF   tree;
	struct {
		NAMEDEF    name;
		PROCDEF    proc;
#ifdef __cplusplus_cli
		STDPROCDEF stdproc;
#endif
		DATADEF    data;
#ifdef __LINUX__
		SERVICE    service;
#endif
	}data;
	PTREEDEF parent;
} NAME, *PNAME;
#define MAXNAMESPERSET 256
DeclareSet( NAME );
#define NAMESPACE_SIZE (4096 - sizeof( uint32_t ) - 2 * sizeof( POINTER ))
typedef struct namespace_tag
{
	uint32_t nextname;
	TEXTCHAR buffer[NAMESPACE_SIZE];
	DeclareLink( struct namespace_tag );
} NAMESPACE, *PNAMESPACE;
PROCREG_NAMESPACE_END
#endif
PROCREG_NAMESPACE
// using lower level syslog bypasses some allocation requirements...
//#define lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf DBG_SRC ); }
	static struct procreg_local_private_tag {
		// don't use critical sections while registering.
		struct {
			BIT_FIELD enable_critical_sections : 1;
		} flags;
	} procreg_local_private_data;
struct tmp_namebuf
{
	TEXTCHAR *buffer;
	size_t length;
};
struct procreg_local_tag {
	struct {
		BIT_FIELD bInterfacesLoaded : 1;
		BIT_FIELD bIndexNameTable : 1;
		// if neither of the next two are set, then the statement can be processed; both are cleared at endif
 // set if 'if' condition is false - SUPPORT 32 levels of if (more than 2 and you're crazy with this)
		BIT_FIELD bFindEndif : 5;
 // set if 'if' condition is false - SUPPORT 32 levels of if (more than 2 and you're crazy with this)
		BIT_FIELD bFindElse : 1;
		//BIT_FIELD bIfSuccess : 1; // set if 'if' condition is true
		BIT_FIELD bTraceInterfaceLoading : 1;
		BIT_FIELD bDisableMemoryLogging : 1;
 // having read the configuration file
		BIT_FIELD bReadConfiguration : 1;
		BIT_FIELD bHeldDeadstart : 1;
	} flags;
	PTREEDEF Names;
	PTREEROOT NameIndex;
	PTREEDEFSET TreeNodes;
	PNAMESET NameSet;
	PNAMESPACE NameSpace;
	PLIST TransationSpaces;
 // open group ID
	int translations;
	TEXTCHAR *config_filename;
	FILE *file;
	CRITICALSECTION csName;
	uint32_t simple_lock;
	PLINKQUEUE tmp_names;
	int reference_count;
	PLIST global_spaces;
	//gcroot<System::IO::FileStream^> fs;
};
#ifdef l
#   undef l
#endif
#define l (*procreg_local_data)
static struct procreg_local_tag *procreg_local_data;
static CTEXTSTR SaveName( CTEXTSTR name );
PTREEDEF GetClassTreeEx( PCTREEDEF root
										, PCTREEDEF name_class
										, PTREEDEF alias, LOGICAL bCreate );
#define GetClassTree( root, name_class ) GetClassTreeEx( root, name_class, NULL, TRUE )
//---------------------------------------------------------------------------
static int CPROC SavedNameCmpEx(CTEXTSTR dst, CTEXTSTR src, size_t srclen)
{
	// NUL does not nessecarily terminate strings
	// instead slave off the length...
	 TEXTCHAR f,last;
 // one for length, one for nul
	size_t l1 = srclen;
 // one for length, one for nul
	size_t l2 = dst[-1] - 2;
	// case insensitive loop..
	//lprintf( WIDE("Compare %s(%d) vs %s[%p](%d)"), src, l1, dst, dst, l2 );
	// interesting... first sort by length
	// and then by content?
	//if( l1 != l2 )
	 //  return l2-l1;
	do {
		if( (*src) == '\\' || (*src)=='/' )
		{
 // no more length .. should have gotten a matched length on dst...
			l1 = 0;
			break;
		}
		if ( ((f = (TEXTCHAR)(*(dst++))) >= 'A') && (f <= 'Z') )
			f -= ('A' - 'a');
		if ( ((last = (TEXTCHAR)(*(src++))) >= 'A') && (last <= 'Z') )
			last -= ('A' - 'a');
		--l2;
		--l1;
	} while ( l2 && l1 && (f == last) );
	//lprintf( WIDE("Results to compare...%d,%d  %c,%c"), l1, l2, f, last );
	// if up to the end of some portion of the strings matched...
	if( !f && !last )
	{
		return 0;
	}
	if( !l2 && !l1 )
	{
		return f-last;
	}
	if( f == last )
	{
		if( l2 && !l1 )
			return 1;
		if( l1 && !l2 )
			return -1;
	}
	return(f - last);
}
//---------------------------------------------------------------------------
static int CPROC SavedNameCmp(CTEXTSTR dst, CTEXTSTR src)
{
	//lprintf( WIDE("Compare names... (tree) %s,%s"), dst, src );
	if( !src && !dst )
		return 0;
	if( !src ) {
		DebugBreak();
		return 1;
	}
	if( !dst && src )
		return -1;
	return SavedNameCmpEx( dst, src, src[-1]-2 );
}
//---------------------------------------------------------------------------
static TEXTSTR StripName( TEXTSTR buf, CTEXTSTR name )
{
	TEXTSTR savebuf = buf;
	int escape = 0;
	if( !name )
	{
		buf[0] = 0;
		return buf;
	}
	while( name[0] )
	{
		if( name[0] == '\\' )
		{
			escape = 1;
		}
		else
		{
			// drop spaces...
			if( escape || ( name[0] > ' ' && name[0] < 127 ) )
			{
				*(buf++) = name[0];
			}
			escape = 0;
		}
		name++;
	}
	buf[0] = 0;
	return savebuf;
}
//---------------------------------------------------------------------------
static TEXTSTR GetFullName( CTEXTSTR name )
{
	int len;
	int out;
	int totlen = name[-1];
	TEXTSTR result;
	//for( len = 0; name[len] != 0 || name[len+1] != 0; len++ );
	result = NewArray( TEXTCHAR, totlen + 1);
	out = 0;
	for( len = 0; len < totlen; len++ )
		if( name[len] )
			result[out++] = name[len];
	result[out] = 0;
	return result;
}
//---------------------------------------------------------------------------
static CTEXTSTR DressName( TEXTSTR buf, CTEXTSTR name )
{
	TEXTSTR savebuf = buf;
	savebuf[0] = 2;
	buf++;
	if( !name )
	{
		savebuf[0] = 0;
		return buf;
	}
	while( name[0] )
	{
		if( name[0] == '/' || name[0] == '\\' )
			break;
		if( name[0] < ' ' || name[0] >= 127 )
		{
			savebuf[0]++;
			(*buf++) = '\\';
			savebuf[0]++;
			(*buf++) = name[0];
		}
		else
		{
			savebuf[0]++;
			(*buf++) = name[0];
		}
		name++;
	}
	buf[0] = 0;
	return savebuf + 1;
}
//---------------------------------------------------------------------------
static CTEXTSTR DoSaveNameEx( CTEXTSTR stripped, size_t len DBG_PASS )
#define DoSaveName(a,b) DoSaveNameEx(a,b DBG_SRC )
{
	PNAMESPACE space = l.NameSpace;
	TEXTCHAR *p;
	// cannot save 0 length strings.
	if( !stripped || !stripped[0] || !len )
	{
		//lprintf( WIDE("zero length string passed") );
		return NULL;
	}
	// otherwise it will be single threaded?
	if( procreg_local_private_data.flags.enable_critical_sections )
	{
#if USE_CUSTOM_ALLOCER
		EnterCriticalSec( &l.csName );
#else
		while( LockedExchange( &l.simple_lock, 1 ) )
			Relinquish();
#endif
	}
	if( l.flags.bIndexNameTable )
	{
		POINTER p;
		p = (POINTER)FindInBinaryTree( l.NameIndex, (uintptr_t)stripped );
		if( p )
		{
			// otherwise it will be single threaded?
			if( procreg_local_private_data.flags.enable_critical_sections )
			{
#if USE_CUSTOM_ALLOCER
				LeaveCriticalSec( &l.csName );
#else
				l.simple_lock = 0;
#endif
			}
			return ((CTEXTSTR)p);
		}
	}
	else
	{
		for( space = l.NameSpace; space; space = space->next )
		{
			p = space->buffer;
			while( p[0] && len )
			{
				//lprintf( WIDE("Compare %s(%d) vs %s(%d)"), p+1, p[0], stripped,len );
				if( SavedNameCmpEx( p+1, stripped, len ) == 0 )
				{
					// otherwise it will be single threaded?
					if( procreg_local_private_data.flags.enable_critical_sections )
					{
						l.simple_lock = 0;
						//LeaveCriticalSec( &l.csName );
					}
					return (CTEXTSTR)p+1;
				}
				p +=
#if defined( __ARM__ ) || defined( UNDER_CE )
					(
#endif
					 p[0]
#if defined( __ARM__ ) || defined( UNDER_CE )
					 +3 ) & 0xFC;
#endif
				;
			}
		}
	}
	for( space = l.NameSpace; space; space = space->next )
	{
		//lprintf( "Finding next name space free %p %p %p", l.NameSpace, space, space->next );
		if( ( space->nextname + len ) < ( NAMESPACE_SIZE - 3 ) )
		{
			p = NULL;
			break;
		}
	}
	if( !space || !p )
	{
		size_t alloclen;
		if( !space )
		{
			space = (PNAMESPACE)Allocate( sizeof( NAMESPACE ) );
			space->nextname = 0;
			//lprintf( "Adding new namespace %p", space );
			LinkThing( l.NameSpace, space );
		}
		MemCpy( p = space->buffer + space->nextname + 1, stripped,(uint32_t)(sizeof( TEXTCHAR)*(len + 1)) );
 // make sure we get a null terminator...
		p[len] = 0;
		// +2 1 for byte of len, 1 for nul at end.
		alloclen = (len + 2);
		space->buffer[space->nextname] = (TEXTCHAR)(alloclen);
		space->nextname += (uint32_t)alloclen;
		space->buffer[space->nextname] = 0;
#if defined( __ARM__ ) || defined( UNDER_CE )
		space->nextname = ( space->nextname + 3 ) & 0xFFFFC;
		// +3&0xFC rounds to next full dword segment
		// arm requires this name be aligned on a dword boundry
		// because later code references this as a DWORD value.
#endif
		if( l.flags.bIndexNameTable )
		{
			AddBinaryNode( l.NameIndex, p, (uintptr_t)p );
			BalanceBinaryTree( l.NameIndex );
		}
	}
	// otherwise it will be single threaded?
	if( procreg_local_private_data.flags.enable_critical_sections )
	{
#if USE_CUSTOM_ALLOCER
		LeaveCriticalSec( &l.csName );
#else
		l.simple_lock = 0;
#endif
	}
	return (CTEXTSTR)p;
}
//---------------------------------------------------------------------------
static CTEXTSTR SaveName( CTEXTSTR name )
{
	if( name )
	{
		size_t len = StrLen( name );
		struct tmp_namebuf *tmp_namebuf = (struct tmp_namebuf*)DequeLink( &l.tmp_names );
		TEXTSTR stripped;
		size_t n;
		if( !tmp_namebuf )
		{
			tmp_namebuf = New( struct tmp_namebuf );
			tmp_namebuf->length = len + 2;
			tmp_namebuf->buffer = NewArray( TEXTCHAR, len + 2 );
		}
		else
		{
			if( tmp_namebuf->length < ( len + 2 ) )
			{
				Release( tmp_namebuf->buffer );
				tmp_namebuf->length = len + 2;
				tmp_namebuf->buffer = NewArray( TEXTCHAR, len + 2 );
			}
		}
		stripped = tmp_namebuf->buffer;
		stripped[0] = (TEXTCHAR)(len + 2);
		for( n = 0; n < len; n++ )
			if( name[n] == '\\' || name[n] == '/' )
			{
				len = n;
				break;
			}
 // allow +1 length for null after string; otherwise strncpy dropps the nul early
		StrCpyEx( stripped + 1, name, len + 1 );
		stripped[0] = (TEXTCHAR)(len + 2);
		{
			CTEXTSTR result = DoSaveName( stripped + 1, len );
			EnqueLink( &l.tmp_names, tmp_namebuf );
			return result;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
CTEXTSTR SaveNameConcatN( CTEXTSTR name1, ... )
#define SaveNameConcat(n1,n2) SaveNameConcatN( (n1),(n2),NULL )
{
	// space concat since that's eaten by strip...
	TEXTCHAR _stripbuffer[256];
	TEXTCHAR *stripbuffer = (_stripbuffer+1);
	size_t len = 0;
	CTEXTSTR namex;
	va_list args;
	va_start( args, name1 );
	for( namex = name1;
			 namex;
			 namex = va_arg( args, CTEXTSTR ) )
	{
		size_t newlen;
		// concat order for libraries is
		// args, return type, library, library_procname
		// this is appeneded to the key value FUNCTION
		//lprintf( WIDE("Concatting %s"), namex );
		newlen = StrLen( StripName( stripbuffer + len, namex ) );
		//if( newlen )
		newlen++;
		len += newlen;
	}
	_stripbuffer[0] = (TEXTCHAR)(len + 2);
	// and add another - final part of string is \0\0
	//stripbuffer[len] = 0;
	//len++;
	return DoSaveName( stripbuffer, len );
}
//---------------------------------------------------------------------------
CTEXTSTR SaveText( CTEXTSTR text )
#define SaveNameConcat(n1,n2) SaveNameConcatN( (n1),(n2),NULL )
{
	size_t len = StrLen( text );
	TEXTSTR stripped = NewArray( TEXTCHAR, len + 2 );
	CTEXTSTR result;
	StrCpyEx( stripped + 1, text, len + 1 );
	stripped[0] = (TEXTCHAR)(len + 2);
	result = DoSaveName( stripped + 1, len);
	Release( stripped );
	return result;
}
//---------------------------------------------------------------------------
static void CPROC KillName( CPOINTER user, uintptr_t key )
{
	PNAME name = (PNAME)user;
	if( name->tree.Tree )
	{
	}
	else if( name->flags.bValue )
	{
	}
	else if( name->flags.bProc )
	{
	}
	else if( name->flags.bData )
	{
	}
	//DeleteFromSet( NAME, l.TreeNodes, user );
}
//---------------------------------------------------------------------------
// p would be the global space, but it's also already set in it's correct spot
static void CPROC InitGlobalSpace( POINTER p, uintptr_t size )
{
	InitializeCriticalSec( &(*(struct procreg_local_tag*)p).csName );
	(*(struct procreg_local_tag*)p).Names = (PTREEDEF)GetFromSet( TREEDEF, &(*(struct procreg_local_tag*)p).TreeNodes );
	(*(struct procreg_local_tag*)p).Names->Magic = MAGIC_TREE_NUMBER;
	(*(struct procreg_local_tag*)p).Names->Tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp, KillName );
	// enable name indexing.
	// if we have 500 names, 9 searches is much less than 250 avg
	(*(struct procreg_local_tag*)p).flags.bIndexNameTable = 1;
	(*(struct procreg_local_tag*)p).NameIndex = CreateBinaryTreeExx( BT_OPT_NODUPLICATES, (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp, KillName );
	(*(struct procreg_local_tag*)p).reference_count++;
}
static void Init( void )
{
	// don't call this function, preserves the process line cache, just check the flag and simple skip any call.
	// use SAFE_INIT();
#define SAFE_INIT() if( !procreg_local_data ) SimpleRegisterAndCreateGlobalWithInit( procreg_local_data, InitGlobalSpace );
	SAFE_INIT();
}
static void ReadConfiguration( void );
//PRIORITY_UNLOAD( InitProcreg, NAMESPACE_PRELOAD_PRIORITY )
//{
	// release other members too, kindly
	//Deallocate( struct procreg_local_tag*, procreg_local_data );
	//procreg_local_data = NULL;
//}
PRIORITY_PRELOAD( InitProcReg2, SYSLOG_PRELOAD_PRIORITY )
{
	// this has to be done after timer's init is done, which is SYSLOG_PRELOAD_PRIORITY-1
	procreg_local_private_data.flags.enable_critical_sections = 1;
}
PRIORITY_PRELOAD( InitProcreg, NAMESPACE_PRELOAD_PRIORITY )
{
	Init();
#ifndef __NO_INTERFACE_SUPPORT__
#ifndef __NO_DEFAULT_INTERFACES__
	if( !l.flags.bReadConfiguration )
	{
		l.flags.bReadConfiguration = 1;
		ReadConfiguration();
	}
#endif
#endif
#ifndef __NO_OPTIONS__
	l.flags.bDisableMemoryLogging = SACK_GetProfileIntEx( GetProgramName(), WIDE("SACK/Process Registry/Disable Memory Logging"), 1, TRUE );
#else
	l.flags.bDisableMemoryLogging = 1;
#endif
}
//---------------------------------------------------------------------------
int GetClassPath( TEXTSTR out, size_t len, PCLASSROOT root )
{
	int ofs = 0;
	PLINKSTACK pls = CreateLinkStack();
	PTREEDEF current;
	PNAME name;
	for( current = (PTREEDEF)root; current->self && current; current = current->self->parent )
	{
		PushLink( &pls, current->self );
	}
	while( ( name = (PNAME)PopLink( &pls ) ) )
	{
		//pcr->
		ofs += tnprintf( out + ofs, len - ofs, WIDE("/%s"), name->name );
	}
	DeleteLinkStack( &pls );
	return ofs;
}
//---------------------------------------------------------------------------
static PTREEDEF AddClassTree( PCTREEDEF class_root, TEXTCHAR *name, PTREEROOT root, int bAlias )
{
	if( root && class_root )
	{
 //Allocate( sizeof( NAME ) );
		PNAME classname = GetFromSet( NAME, &l.NameSet );
		//MemSet( classname, 0, sizeof( NAME ) );
		classname->flags.bAlias = bAlias;
		classname->name = SaveName( name );
		classname->tree.Magic = MAGIC_TREE_NUMBER;
		classname->tree.Tree = root;
		classname->tree.self = classname;
		classname->flags.bTree = TRUE;
		classname->parent = (PTREEDEF)class_root;
		//lprintf( WIDE("Adding class tree thing %p  %s"), class_root->Tree, classname->name );
		if( !AddBinaryNode( class_root->Tree, classname, (uintptr_t)classname->name ) )
		{
			//Log( WIDE("For some reason could not add new class tree to tree!") );
			DeleteFromSet( NAME, l.NameSet, classname );
			return NULL;
		}
		return &classname->tree;
	}
	return NULL;
}
//---------------------------------------------------------------------------
static CTEXTSTR  my_pathchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrChr( path, (int)'\\' );
	end2 = StrChr( path, (int)'/' );
	if( end1 && end2 )
	{
		if( end1 < end2 )
			return end1;
		return end2;
	}
	else if( end1 )
		return end1;
	else if( end2 )
		return end2;
	return NULL;
}
//---------------------------------------------------------------------------
// if name_class is NULL then root is returned.
// if name_class is not NULL then if name_class references
// PTREEDEF structure, then name_class is returned.
// if root is NULL then it is set to l.nmaes... if this library has
// never been initialized it will return NULL.
// if name_class does not previously exist, then it is created.
// There is no protection for someone to constantly create large trees just
// by asking for them.
PTREEDEF GetClassTreeEx( PCTREEDEF root, PCTREEDEF _name_class, PTREEDEF alias, LOGICAL bCreate )
{
	PCTREEDEF class_root;
	if( !root )
	{
		Init();
		root = (PCTREEDEF)l.Names;
// fix root...
	}
	class_root = root;
	if(
#if defined( __ARM__ ) || defined( UNDER_CE )
		// if its odd, it comes from the name space
		// (savename)
		(((uintptr_t)class_root)&0x3) ||
#endif
		(class_root->Magic != MAGIC_TREE_NUMBER) )
	{
		// if root name is passed as a NAME, then resolve it
		// assuming the root of all names as the root...
		class_root = GetClassTreeEx( l.Names, class_root, NULL, bCreate );
	}
	if( _name_class )
	{
		if(
#if defined( __ARM__ ) || defined( UNDER_CE )
	  // if its odd, it comes from the name space
		// (savename)
			 !(((uintptr_t)_name_class)&0x3) &&
#endif
			(_name_class->Magic == MAGIC_TREE_NUMBER) )
		{
			return (PTREEDEF)_name_class;
		}
		else
		{
			size_t buflen = 0;
			//TEXTCHAR *original;
			TEXTCHAR *end, *start;
			CTEXTSTR name_class = (CTEXTSTR)_name_class;
			size_t len = StrLen( name_class ) + 1;
			PNAME new_root;
			int retry = 0;
			if( len > buflen )
			{
				buflen = len + 32;
			}
			start = (TEXTCHAR*)name_class;
			do
			{
				end = (TEXTCHAR*)my_pathchr( start );
				do
				{
					if( end == start )
					{
						start = start+1;
						end = (TEXTCHAR*)my_pathchr( start );
						continue;
					}
					if( !end || ((my_pathchr(end+1) - end) != 1) )
						break;
					end++;
				}
				while( 1 );
				do
				{
					{
						// dress name terminates on a '/'
						TEXTCHAR buf[256];
						//lprintf( "Finding a..." );
						new_root = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, start ) );
						//lprintf( WIDE("Found %p %s(%d)=%s"), new_root, buf+1, buf[0], start );
					}
					if( !new_root )
					{
						if( !bCreate )
							return NULL;
						if( alias && !end )
						{
							// added name in this place name terminates on a '/'
							//lprintf( WIDE("name not found, adding...!end && alias") );
							class_root = AddClassTree( class_root
															 , start
															 , alias->Tree
															 , TRUE );
							((PTREEDEF)class_root)->self = alias->self;
						}
						else
						{
							PTREEDEF new_root;
							PTREEROOT tree;
							// added name in this place name terminates on a '/'
							// interesting note - while searching for
							// a member, branches are created.... should consider
							// perhaps offering an option to read for class root without creating
							// however it gives one an idea of what methods might be avaialable...
							//lprintf( WIDE("name not found, adding.. [%s] %s"), start, class_root->self?class_root->self->name:"." );
							new_root = AddClassTree( class_root
															 , start
															 , tree = CreateBinaryTreeExx( BT_OPT_NODUPLICATES
																						 , (int(CPROC *)(uintptr_t,uintptr_t))SavedNameCmp
																						 , KillName )
															 , FALSE
															 );
							if( !new_root )
							{
								// if this happens it was probably added while adding...
								DebugBreak();
								DestroyBinaryTree( tree );
								if( retry < 2 )
								{
									retry++;
									continue;
								}
#ifndef NO_LOGGING
								SystemLog( WIDE("Failed to register...") );
								lprintf( WIDE("name not found, adding.. [%s] %s"), start, class_root->self?class_root->self->name:WIDE(".") );
#endif
								return NULL;
							}
							class_root = new_root;
						}
					}
					else
					{
						if( !end && alias && !new_root->flags.bAlias )
						{
							static int error_count;
							error_count++;
							// this orphans the prior tree; but probably results from requests for values that aren't present
							// and later are filled by an alias.
							if( error_count > 20 )
								lprintf( WIDE( " Name %s exists, but we want it to be an alias, and it is not...(a LOT of this is bad) " ), new_root->name );
							if( new_root->tree.Magic != MAGIC_TREE_NUMBER )
								lprintf( WIDE( "Hell it's not even a tree!" ) );
							new_root->flags.bAlias = 1;
							new_root->tree.Tree = alias->Tree;
							new_root->tree.self = alias->self;
						}
						class_root = &new_root->tree;
					}
					break;
				} while( 1 );
				if( end )
					start = end + 1;
				else
					break;
			}
			while( class_root && start[0] );
		}
	}
	return (PTREEDEF)class_root;
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, CheckClassRoot )( CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( NULL, (PTREEDEF)name_class, NULL, FALSE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( (PTREEDEF)root, (PTREEDEF)name_class, NULL, TRUE );
}
PROCREG_PROC( PCLASSROOT, GetClassRoot )( CTEXTSTR name_class )
{
	return (PCLASSROOT)GetClassTreeEx( l.Names, (PTREEDEF)name_class, NULL, TRUE );
}
#ifdef __cplusplus
PROCREG_PROC( PCLASSROOT, GetClassRootEx )( PCLASSROOT root, PCLASSROOT name_class )
{
	return GetClassTreeEx( root, (PTREEDEF)name_class, NULL, TRUE );
}
PROCREG_PROC( PCLASSROOT, GetClassRoot )( PCLASSROOT name_class )
{
	return GetClassTreeEx( l.Names, (PTREEDEF)name_class, NULL, TRUE );
}
#endif
//---------------------------------------------------------------------------
int AddNode( PTREEDEF class_root, POINTER data, uintptr_t key )
{
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, (CTEXTSTR)key ) );
		if( oldname )
		{
			//lprintf( WIDE("Name already in the tree... %s"), (CTEXTSTR)key );
			return FALSE;
		}
		else
		{
			//lprintf( WIDE("addnode? a data ndoe - create data structure") );
			if( !AddBinaryNode( class_root->Tree, data, key ) )
			{
				Log( WIDE("For some reason could not add new name to tree!") );
				return FALSE;
			}
		}
		return TRUE;
	}
	Log( WIDE("Nowhere to add the node...") );
	return FALSE;
}
//---------------------------------------------------------------------------
static int CPROC MyStrCmp( uintptr_t s1, uintptr_t s2 )
{
	//lprintf( WIDE("Compare (%s) vs (%s)"), s1, s2 );
	return StrCaseCmp( (TEXTCHAR*)s1, (TEXTCHAR*)s2 );
}
//---------------------------------------------------------------------------
#undef RegisterFunctionExx
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( PCLASSROOT root
													 , PCLASSROOT name_class
													 , CTEXTSTR public_name
													 , CTEXTSTR returntype
													 , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
													)
{
	if( root || name_class )
	{
//Allocate( sizeof( NAME ) );
		PNAME newname = GetFromSet( NAME, &l.NameSet );
		TEXTCHAR strippedargs[256];
		CTEXTSTR func_name = real_name?real_name:public_name;
		CTEXTSTR root_func_name = func_name;
		PTREEDEF class_root = (PTREEDEF)GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
		int tmp;
		MemSet( newname, 0, sizeof( NAME ) );
		newname->flags.bProc = 1;
		// this is kinda messed up...
		newname->name = SaveName( public_name );
		newname->data.proc.library = SaveName( library );
		newname->data.proc.procname = SaveName( real_name );
		//newname->data.proc.ret = SaveName( returntype );
		for( tmp = 0; func_name[tmp]; tmp++ )
			if( func_name[tmp] == '/' ||
				func_name[tmp] == '\\' )
			{
				func_name = func_name + tmp + 1;
				tmp = -1;
			}
		if( func_name != root_func_name )
		{
			size_t len;
			TEXTSTR new_root_func_name = NewArray( TEXTCHAR, len = ( func_name - root_func_name ) );
			StrCpyEx( new_root_func_name, root_func_name, len );
			new_root_func_name[len-1] = 0;
			//lprintf( "trimmed name would be %s  /   %s", new_root_func_name, func_name );
			class_root = GetClassTree( (PCTREEDEF)class_root, (PCTREEDEF)new_root_func_name );
			Release( new_root_func_name );
		}
		//newname->data.proc.args = SaveName( StripName( strippedargs, args ) );
		newname->data.proc.name = SaveNameConcatN( StripName( strippedargs, args )
															  , returntype
															  , library?library:WIDE("_")
															  , func_name
															  , NULL
															  );
		newname->data.proc.proc = proc;
		if( class_root )
		{
			PNAME oldname;
			oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)newname->name);
			if( oldname )
			{
				if( !oldname->data.proc.proc )
				{
					// old branch location might have existed, but no value assigned...
					//lprintf( WIDE( "overloading prior %p with %p and %p with %p" )
					//		 , oldname->data.proc.proc, proc
					//		 , oldname->data.proc.name, newname->data.proc.name
					//		 );
					oldname->flags.bProc = 1;
					oldname->data.proc.proc = proc;
					oldname->data.proc.name = newname->data.proc.name;
					oldname->data.proc.library = newname->data.proc.library;
					oldname->data.proc.procname = newname->data.proc.procname;
					newname->data.proc.name = NULL;
				}
				else if( oldname->data.proc.proc == proc )
					Log( WIDE("And fortunatly it's the same address... all is well...") );
				else
				{
					TEXTSTR s1, s2;
#ifndef NO_LOGGING
					CTEXTSTR file = GetRegisteredValue( (CTEXTSTR)&oldname->tree, WIDE( "Source File" ) );
					int line = (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)&oldname->tree, WIDE( "Source Line" ), TRUE );
					_xlprintf( 2 DBG_RELAY)( WIDE("proc %s/%s regisry by %s of %s(%s) conflicts with %s(%d):%s(%s)...")
												  , (CTEXTSTR)name_class?(CTEXTSTR)name_class:WIDE("@")
												  , public_name?public_name:WIDE("@")
												  , newname->name
												  , s1 = GetFullName( newname->data.proc.name )
													//,library
												  , newname->data.proc.procname
												  , file
												  , line
												  , s2 = GetFullName( oldname->data.proc.name )
												  //,library
												  , oldname->data.proc.procname );
					Release( s1 );
					Release( s2 );
					// perhaps it's same in a different library...
					Log( WIDE("All is not well - found same function name in tree with different address. (ignoring second) ") );
#endif
				}
				DeleteFromSet( NAME, l.NameSet, newname );
				return TRUE;
			}
			else
			{
				if( !AddBinaryNode( class_root->Tree, (PCLASSROOT)newname, (uintptr_t)newname->name ) )
				{
					Log( WIDE("For some reason could not add new name to tree!") );
					DeleteFromSet( NAME, l.NameSet, newname );
					return FALSE;
				}
			}
			{
				//PTREEDEF root = GetClassRoot( newname );
				newname->parent = class_root;
				newname->tree.Magic = MAGIC_TREE_NUMBER;
 // dups okay BT_OPT_NODUPLICATES
				newname->tree.Tree = CreateBinaryTreeExx( 0
																	 , (int(CPROC *)(uintptr_t,uintptr_t))MyStrCmp
																	 , KillName );
#ifdef _DEBUG
				{
					CTEXTSTR name = pathrchr( pFile );
					// chop the trailing filename, removing path of filename.
					if( name )
						name++;
					else
						name = pFile;
					RegisterValue( (CTEXTSTR)&newname->tree, WIDE( "Source File" ), name );
					RegisterIntValue( (CTEXTSTR)&newname->tree, WIDE( "Source Line" ), nLine );
				}
#endif
			}
		}
		else
		{
			lprintf( WIDE("I'm relasing this name!?") );
			DeleteFromSet( NAME, l.NameSet, newname );
		}
		return 1;
	}
	return FALSE;
}
#ifdef __cplusplus
PROCREG_PROC( LOGICAL, RegisterFunctionExx )( CTEXTSTR root
													 , CTEXTSTR name_class
													 , CTEXTSTR public_name
													 , CTEXTSTR returntype
													 , PROCEDURE proc
													 , CTEXTSTR args
													 , CTEXTSTR library
													 , CTEXTSTR real_name
													  DBG_PASS
														  )
{
	return RegisterFunctionExx( (PCLASSROOT)root, (PCLASSROOT)name_class, public_name, returntype
	                          , proc, args, library, real_name DBG_RELAY );
}
#endif
//---------------------------------------------------------------------------
#if 0
int ReleaseRegisteredFunctionEx( PCLASSROOT root, CTEXTSTR name_class
							 , CTEXTSTR public_name
							 )
{
	PTREEDEF class_root = GetClassTree( root, (PCLASSROOT)name_class );
	TEXTCHAR buf[256];
	PNAME node = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, public_name ) );
	if( node )
	{
		if( node->flags.bProc )
		{
			UnloadFunction( &node->data.proc.proc );
			//node->data.proc.proc = NULL;
			node->flags.bProc = 0;
			return 1;
		}
	}
	return 0;
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterProcedureExx )( PCLASSROOT root
														, CTEXTSTR name_class
														, CTEXTSTR public_name
														, CTEXTSTR returntype
														, CTEXTSTR library
														, CTEXTSTR name
														, CTEXTSTR args
														 DBG_PASS
														)
{
	//PROCEDURE proc = (PROCEDURE)LoadFunction( library, name );
	//if( proc )
	{
		return RegisterFunctionExx( root, (PCLASSROOT)name_class
		                          , public_name
		                          , returntype
		                          , NULL
		                          , args
		                          , library
		                          , name
		                          DBG_RELAY );
	}
   //return 0;
}
#undef RegisterProcedureEx
PROCREG_PROC( int, RegisterProcedureEx )( CTEXTSTR name_class
                                        , CTEXTSTR public_name
                                        , CTEXTSTR returntype
                                        , CTEXTSTR library
                                        , CTEXTSTR name
                                        , CTEXTSTR args
                                         DBG_PASS
                                        )
{
   return RegisterProcedureExx( NULL, name_class, public_name, returntype, library, name, args DBG_RELAY );
}
#ifndef __NO_INTERFACE_SUPPORT__
// used in dekware.
PROCREG_PROC( PROCEDURE, ReadRegisteredProcedureEx )( PCLASSROOT root
                                                    , CTEXTSTR returntype
                                                    , CTEXTSTR parms
                                                    )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, NULL );
	PNAME oldname = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
	if( oldname )
	{
		PROCEDURE proc = oldname->data.proc.proc;
		if( !proc && ( oldname->data.proc.library && oldname->data.proc.procname ) )
		{
			proc = (PROCEDURE)LoadFunction( oldname->data.proc.library
													, oldname->data.proc.procname );
			//lprintf( WIDE("Found a procedure %s=%p  (%p)"), name, oldname, proc );
			// should compare whether the types match...
			if( !proc )
			{
				Log( WIDE("Failed to load function when requested from tree...") );
			}
			oldname->data.proc.proc = proc;
		}
		return oldname->data.proc.proc;
	}
	return NULL;
}
#endif
//---------------------------------------------------------------------------
// can use the return type and args to validate the correct
// type of routine is called...
// name is not the function name, but rather the public/common name...
// this name may optionally include a # remark detailing more information
// about the name... the comparison of this name is done up to the #
// and data after a # is checked only if both values have a sub-comment.
// library name is not checked.
// this routine may find more than 1 routine which matches the given
// criteria.  return type and args may be NULL indicating a care-less
// approach.
void DumpRegisteredNamesWork( PTREEDEF tree, int level );
#undef GetRegisteredProcedureExx
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root, PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
#define GetRegisteredProcedureExx GetRegisteredProcedureExxx
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)name_class, NULL, FALSE );
	if( class_root )
	{
		PNAME oldname;
		//TEXTCHAR buf[256];
		//lprintf( WIDE("Found class %s=%p for %s"), name_class, class_root, name );
		//DumpRegisteredNamesWork( class_root, 5 );
		oldname = (PNAME)LocateInBinaryTree( class_root->Tree, (uintptr_t)name, NULL );
		//oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ) );
		if( oldname )
		{
#if 0
			PROCEDURE proc = oldname->data.proc.proc;
			if( !proc && ( oldname->data.proc.library && oldname->data.proc.procname ) )
			{
				proc = (PROCEDURE)LoadFunction( oldname->data.proc.library
														, oldname->data.proc.procname );
				//lprintf( WIDE("Found a procedure %s=%p  (%p)"), name, oldname, proc );
				// should compare whether the types match...
				if( !proc )
				{
					Log( WIDE("Failed to load function when requested from tree...") );
				}
				oldname->data.proc.proc = proc;
			}
#endif
			return oldname->data.proc.proc;
		}
		//else
      //   lprintf( WIDE("Failed to find %s in the tree"), buf );
	}
	//lprintf( WIDE("Failed to find the class root...") );
	return NULL;
}
#ifdef __cplusplus
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, (PCLASSROOT)name_class, returntype, name, args );
}
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, (PCLASSROOT)name_class, returntype, name, args );
}
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureExxx )( CTEXTSTR root, PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
   return GetRegisteredProcedureExxx( (PCLASSROOT)root, name_class, returntype, name, args );
}
#endif
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( PCLASSROOT name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
	Init();
   return GetRegisteredProcedureExx( (PCLASSROOT)l.Names, name_class, returntype, name, args );
}
#ifdef __cplusplus
PROCREG_PROC( PROCEDURE, GetRegisteredProcedureEx )( CTEXTSTR name_class, CTEXTSTR returntype, CTEXTSTR name, CTEXTSTR args )
{
	Init();
   return GetRegisteredProcedureExx( l.Names, name_class, returntype, name, args );
}
#endif
//---------------------------------------------------------------------------
void DumpRegisteredNamesWork( PTREEDEF tree, int level )
{
	PNAME name;
	PVARTEXT pvt;
	PTEXT pText;
   POINTER data;
	int bLogging = 0;
#if 0
	if( level == 0 )
	{
		Init();
		lprintf( "Names %p  %p", l.Names, l.NameSpace );
	}
#endif
   if( l.flags.bDisableMemoryLogging )
		bLogging = SetAllocateLogging( FALSE );
   // at least save the create/destroy uselessness...
	if( !tree->Tree )
	{
		if( l.flags.bDisableMemoryLogging )
			SetAllocateLogging( bLogging );
		return;
	}
	pvt = VarTextCreateExx( 512, 1024 );
#if 0
	DumpTree( tree->Tree, NULL );
	lprintf( "Tree is %p %p", tree, tree->Tree );
#endif
	for( name = (PNAME)GetLeastNodeEx( tree->Tree, &data );
		  name;
		  name = (PNAME)GetGreaterNodeEx( tree->Tree, &data ) )
	{
		int n;
		for( n = 0; n < level; n++ )
			vtprintf( pvt, WIDE("   ") );
		vtprintf( pvt, WIDE("%s"), name->name );
		if( name->flags.bValue )
		{
			vtprintf( pvt, WIDE(" = ") );
			if( name->flags.bIntVal )
				vtprintf( pvt, WIDE("[%ld]"), name->data.name.iValue );
			if( name->flags.bStringVal )
				vtprintf( pvt, WIDE("\"%s\""), name->data.name.sValue );
			if( name->flags.bProc )
            vtprintf( pvt, WIDE("*%p"), name->data.proc.proc );
		}
		else if( name->flags.bProc )
		{
			CTEXTSTR p = name->data.proc.name;
			if( p )
			{
				size_t len = p[-1] - 2;
				vtprintf( pvt, WIDE(" = ") );
				while( len )
				{
					size_t tmp;
					vtprintf( pvt, WIDE("%s "), p );
					tmp = StrLen( p ) + 1;
					len-= tmp;
					p += tmp;
				}
				vtprintf( pvt, WIDE("*%p"), name->data.proc.proc );
			}
		}
		pText = VarTextGet( pvt );
		xlprintf(LOG_INFO)( WIDE("%s"), GetText( pText ) );
		LineRelease( pText );
		DumpRegisteredNamesWork( &name->tree, level + 1 );
	}
	VarTextDestroy( &pvt );
	if( l.flags.bDisableMemoryLogging )
		SetAllocateLogging( bLogging );
}
//---------------------------------------------------------------------------
struct browse_index
{
	PTREEDEF current_limbs;
	PTREEDEF current_branch;
};
PROCREG_PROC( int, NameHasBranches )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bTree;
}
int NewNameIsAlias( PCLASSROOT *data )
{
	struct browse_index *class_root = (struct browse_index*)(*data);
	PNAME name;
	name = (PNAME)GetCurrentNodeEx( class_root->current_branch->Tree, &class_root->current_branch->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bAlias;
}
int NameIsAlias( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
 // may also have a value, but it was created as a path node in the tree
	return name->flags.bAlias;
}
PROCREG_PROC( PCLASSROOT, GetCurrentRegisteredTree )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	name = (PNAME)GetCurrentNodeEx( class_root->Tree, &class_root->cursor );
	if( name )
		return (PCLASSROOT)&name->tree;
	return NULL;
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredNameEx )( PCLASSROOT root, CTEXTSTR classname, PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	*data =
		(PCLASSROOT)(class_root = (PTREEDEF)GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname ));
	if( class_root )
	{
		name = (PNAME)GetLeastNodeEx( class_root->Tree, &class_root->cursor );
		if( name )
		{
			//lprintf( WIDE("Resulting first name: %s"), name->name );
			return name->name;
		}
	}
	return NULL;
}
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( CTEXTSTR classname, PCLASSROOT *data )
{
	return GetFirstRegisteredNameEx( NULL, classname, data );
}
#ifdef __cplusplus
PROCREG_PROC( CTEXTSTR, GetFirstRegisteredName )( PCLASSROOT classname, PCLASSROOT *data )
{
	return GetFirstRegisteredNameEx( NULL, (CTEXTSTR)classname, data );
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetNextRegisteredName )( PCLASSROOT *data )
{
	PTREEDEF class_root;
	PNAME name;
	class_root = (PTREEDEF)*data;
	if( class_root )
	{
		name = (PNAME)GetGreaterNodeEx( class_root->Tree, &class_root->cursor );
		if( name )
		{
			//lprintf( WIDE("Resulting next name: %s"), name->name );
			return name->name;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, DumpRegisteredNames )( void )
{
	if( l.Names )
		DumpRegisteredNamesWork( l.Names, 0 );
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, DumpRegisteredNamesFrom )( PCLASSROOT root )
{
	DumpRegisteredNamesWork( GetClassTreeEx( l.Names, (PCTREEDEF)root, NULL, TRUE ), 0 );
}
//---------------------------------------------------------------------------
PROCREG_PROC( void, InvokeProcedure )( void )
{
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ) );
		//lprintf( "... existed? %p", oldname );
		if( oldname )
		{
 // it is now a value, okay?
			oldname->flags.bValue = 1;
			if( bIntVal )
			{
				oldname->flags.bIntVal = 1;
				oldname->data.name.iValue = (uintptr_t)value;
			}
			else
			{
				oldname->flags.bStringVal = 1;
				oldname->data.name.sValue = SaveName( value );
			}
		}
		else
		{
 //Allocate( sizeof( NAME ) );
			PNAME newname = GetFromSet( NAME, &l.NameSet );
			//MemSet( newname, 0, sizeof( NAME ) );
			if( name )
				newname->name = SaveName( name );
			newname->flags.bValue = 1;
			newname->parent = class_root;
			if( bIntVal )
			{
				newname->flags.bIntVal = 1;
				newname->data.name.iValue = (uintptr_t)value;
			}
			else
			{
				newname->flags.bStringVal = 1;
 //StrDup( value );
				newname->data.name.sValue = SaveName( value );
			}
			//lprintf( "... adding %s (%s)", name, newname->name );
			if( !AddBinaryNode( class_root->Tree, newname, (uintptr_t)newname->name ) )
			{
				lprintf( WIDE("Failed to add name to tree...%s"), name );
			}
		}
		return TRUE;
	}
	return FALSE;
}
PROCREG_PROC( int, RegisterValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal, CTEXTSTR value )
{
	Init();
	return RegisterValueExx( (PCLASSROOT)l.Names, name_class, name, bIntVal, value );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterValue )( CTEXTSTR name_class, CTEXTSTR name, CTEXTSTR value )
{
	return RegisterValueEx( name_class, name, FALSE, value );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, RegisterIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, uintptr_t value )
{
	return RegisterValueExx( root, name_class, name, TRUE, (CTEXTSTR)value );
}
PROCREG_PROC( int, RegisterIntValue )( CTEXTSTR name_class, CTEXTSTR name, uintptr_t value )
{
	return RegisterValueEx( name_class, name, TRUE, (CTEXTSTR)value );
}
//---------------------------------------------------------------------------
int GetRegisteredStaticValue( PCLASSROOT root, CTEXTSTR name_class
									 , CTEXTSTR name
									 , CTEXTSTR *result
									 , int bIntVal )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	TEXTCHAR buf[256];
	PNAME oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
	if( oldname )
	{
		if( bIntVal )
		{
			*((int*)result) = (int)oldname->data.name.iValue;
			return TRUE;
		}
		else if( oldname->flags.bStringVal )
		{
			(*result) = oldname->data.name.sValue;
			return TRUE;
		}
	}
	return FALSE;
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	PTREEDEF class_root;
	TEXTCHAR buf[256];
	PNAME oldname;
	class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)name_class );
	oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
	if( oldname )
	{
		if( bIntVal )
			return (CTEXTSTR)oldname->data.name.iValue;
		else if( oldname->flags.bStringVal )
			return oldname->data.name.sValue;
	}
	return NULL;
}
#ifdef __cplusplus
PROCREG_PROC( CTEXTSTR, GetRegisteredValueExx )( CTEXTSTR root, CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	return GetRegisteredValueExx( (PCLASSROOT)root, name_class, name, bIntVal );
}
#endif
PROCREG_PROC( CTEXTSTR, GetRegisteredValueEx )( CTEXTSTR name_class, CTEXTSTR name, int bIntVal )
{
	Init();
	return GetRegisteredValueExx( (PCLASSROOT)l.Names, name_class, name, bIntVal );
}
//---------------------------------------------------------------------------
PROCREG_PROC( CTEXTSTR, GetRegisteredValue )( CTEXTSTR name_class, CTEXTSTR name )
{
	return GetRegisteredValueEx( name_class, name, FALSE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( int, GetRegisteredIntValue )( CTEXTSTR name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)name_class, name, TRUE );
}
PROCREG_PROC( int, GetRegisteredIntValueEx )( PCLASSROOT root, CTEXTSTR name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueExx( root, name_class, name, TRUE );
}
#ifdef __cplusplus
PROCREG_PROC( int, GetRegisteredIntValue )( PCLASSROOT name_class, CTEXTSTR name )
{
/*
 * this has a warning - typecast to value of differnet size.
 * this is OK.  the value originates as an 'int' and is typecast to a
 * CTEXTSTR which this then down converts back to 'int'
 */
	return (int)(uintptr_t)GetRegisteredValueEx( (CTEXTSTR)name_class, name, TRUE );
}
#endif
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, RegisterClassAliasEx )( PCLASSROOT root, CTEXTSTR original, CTEXTSTR alias )
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)original, NULL, TRUE );
	return (PCLASSROOT)GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)alias, class_root, TRUE );
}
//---------------------------------------------------------------------------
PROCREG_PROC( PCLASSROOT, RegisterClassAlias )( CTEXTSTR original, CTEXTSTR alias )
{
	Init();
	return (PCLASSROOT)RegisterClassAliasEx( (PCLASSROOT)l.Names, original, alias );
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, RegisterDataTypeEx )( PCLASSROOT root
												 , CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , void (CPROC *Open)(POINTER,uintptr_t)
												 , void (CPROC *Close)(POINTER,uintptr_t) )
{
	PTREEDEF class_root = GetClassTreeEx( (PCTREEDEF)root, (PCTREEDEF)classname, NULL, TRUE );
	if( class_root )
	{
 //(PNAME)Allocate( sizeof( NAME ) );
		PNAME pName = GetFromSet( NAME, &l.NameSet );
		//MemSet( pName, 0, sizeof( NAME ) );
		pName->flags.bData = 1;
		pName->name = SaveName( name );
		pName->data.data.Open = Open;
		pName->data.data.Close = Close;
		pName->data.data.size = size;
		pName->data.data.instances.Magic = MAGIC_TREE_NUMBER;
 // dups okay BT_OPT_NODUPLICATES
		pName->data.data.instances.Tree = CreateBinaryTreeExx( 0
														, (int(CPROC *)(uintptr_t,uintptr_t))MyStrCmp
														, KillName );
		pName->parent = class_root;
		if( !AddNode( class_root, pName, (uintptr_t)pName->name ) )
		{
			DeleteFromSet( NAME, l.NameSet, pName );
 // NULL
			return 0;
		}
		return (uintptr_t)pName;
	}
 // NULL
	return 0;
}
PROCREG_PROC( uintptr_t, RegisterDataType )( CTEXTSTR classname
												 , CTEXTSTR name
												 , uintptr_t size
												 , void (CPROC *Open)(POINTER,uintptr_t)
												 , void (CPROC *Close)(POINTER,uintptr_t) )
{
	Init();
	return RegisterDataTypeEx( (PCLASSROOT)l.Names, classname, name, size, Open, Close );
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, MakeRegisteredDataTypeEx)( PCLASSROOT root
																 , CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename
																 , POINTER data
																 , uintptr_t datasize
																 )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME pName = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
		if( !pName )
			pName = (PNAME)RegisterDataTypeEx( root, classname, name, datasize, NULL, NULL );
		if( pName && pName->flags.bData )
		{
			PDATADEF pDataDef = &pName->data.data;
			if( pDataDef )
			{
				if( !instancename )
				{
					TEXTCHAR buf[256];
					tnprintf( buf, sizeof(buf), WIDE("%s_%d"), name, (int)pDataDef->unique++ );
					instancename = SaveName( buf );
				}
				else
					instancename = SaveName( instancename );
				{
					// look up prior instance...
					if( !FindInBinaryTree( pDataDef->instances.Tree, (uintptr_t)instancename ) )
					{
						AddBinaryNode( pDataDef->instances.Tree
										 , data
										 , (uintptr_t)instancename );
					}
					else
					{
						lprintf( WIDE("Suck. We just created one externally, and want to use that data, but it already exists.") );
						DumpRegisteredNames();
						DebugBreak();
						// increment instances referenced so that close does not
						// destroy - fortunatly this is persistant data, and therefore
						// doesn't get destroyed yet.
					}
					return (uintptr_t)data;
				}
			}
		}
		else
		{
			lprintf( WIDE("No such struct defined: %s"), name );
		}
	}
	return 0;
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, CreateRegisteredDataTypeEx)( PCLASSROOT root
																	, CTEXTSTR classname
																	, CTEXTSTR name
																	, CTEXTSTR instancename )
{
	PTREEDEF class_root = GetClassTree( (PCTREEDEF)root, (PCTREEDEF)classname );
	if( class_root )
	{
		TEXTCHAR buf[256];
		PNAME pName = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)DressName( buf, name ));
		if( pName && pName->flags.bData )
		{
			PDATADEF pDataDef = &pName->data.data;
			if( pDataDef )
			{
				if( !instancename )
				{
					TEXTCHAR buf[256];
					tnprintf( buf, sizeof(buf), WIDE("%s_%d"), name, (int)pDataDef->unique++ );
					instancename = SaveName( buf );
				}
				else
					instancename = SaveName( instancename );
				{
					POINTER p;
					// look up prior instance...
					if( !( p = (POINTER)FindInBinaryTree( pDataDef->instances.Tree, (uintptr_t)instancename ) ) )
					{
#ifdef DEBUG_GLOBAL_REGISTRATION
						lprintf( WIDE( "Allocating new struct data :%" )_32f, pDataDef->size );
#endif
						p = Allocate( pDataDef->size + sizeof( PLIST ) );
						((PLIST*)p)[0] = NULL;
						p = (POINTER)( ((uintptr_t)p) + sizeof( PLIST ) );
						MemSet( p, 0, pDataDef->size );
						if( pDataDef->Open )
							pDataDef->Open( p, pDataDef->size );
						AddBinaryNode( pDataDef->instances.Tree
										 , p
										 , (uintptr_t)instancename );
					}
					else
					{
						// registered one, returned, needs to be offset for hold purposes.
						POINTER tmp_p = (POINTER)( (uintptr_t)p - sizeof( PLIST ) );
						Hold( tmp_p );
#ifdef DEBUG_GLOBAL_REGISTRATION
						lprintf( WIDE("Resulting with previuosly created instance.") );
						// increment instances referenced so that close does not
						// destroy - fortunatly this is persistant data, and therefore
						// doesn't get destroyed yet.
#endif
					}
					return (uintptr_t)p;
				}
			}
		}
#ifdef DEBUG_GLOBAL_REGISTRATION
		else
		{
			lprintf( WIDE("No such struct defined:[%s]%s"), classname, name );
		}
#endif
	}
	return 0;
}
//---------------------------------------------------------------------------
PROCREG_PROC( uintptr_t, CreateRegisteredDataType)( CTEXTSTR classname
																 , CTEXTSTR name
																 , CTEXTSTR instancename )
{
	Init();
	return CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, classname, name, instancename );
}
//---------------------------------------------------------------------------
typedef POINTER (CPROC *LOADPROC)( void );
typedef void	 (CPROC *UNLOADPROC)( POINTER );
//-----------------------------------------------------------------------
LOGICAL RegisterInterfaceEx( CTEXTSTR servicename, POINTER(CPROC*load)(void), void(CPROC*unload)(POINTER) DBG_PASS )
{
	//PARAM( args, TEXTCHAR*, servicename );
	//PARAM( args, TEXTCHAR*, library );
	//PARAM( args, TEXTCHAR*, load_proc_name );
	//PARAM( args, TEXTCHAR*, unload_proc_name );
	PCLASSROOT pcr = GetClassRoot( WIDE("system/interfaces") );
	if( GetRegisteredProcedureExx( pcr, (PCLASSROOT)servicename, WIDE("POINTER"), WIDE("load"), WIDE("void") ) )
	{
		lprintf( WIDE("Service: %s has multiple definitions, using first registered.")
				 , servicename );
		return FALSE;
	}
	//lprintf( WIDE("Registering library l:%p ul:%p"), load, unload );
	{
		RegisterFunctionExx( pcr
								  , (PCLASSROOT)servicename
								  , WIDE("load")
								  , WIDE("POINTER")
								  , (PROCEDURE)load
								  , WIDE("(void)"), NULL, NULL DBG_RELAY );
		RegisterFunctionExx( pcr
								  , (PCLASSROOT)servicename
								  , WIDE("unload")
								  , WIDE("void")
								  , (PROCEDURE)unload
								  , WIDE("(POINTER)"), NULL, NULL DBG_RELAY );
	}
	return TRUE;
}
//-----------------------------------------------------------------------
#ifndef __NO_INTERFACE_SUPPORT__
static uintptr_t CPROC HandleLibrary( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, servicename );
	PARAM( args, TEXTCHAR*, library );
	PARAM( args, TEXTCHAR*, load_proc_name );
	PARAM( args, TEXTCHAR*, unload_proc_name );
	PCLASSROOT pcr = GetClassRoot( WIDE("system/interfaces") );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( GetRegisteredProcedureExx( pcr, (PCLASSROOT)servicename, WIDE("POINTER"), WIDE("load"), WIDE("void") ) )
	{
		lprintf( WIDE("Service: %s has multiple definitions, will use last first.")
				 , servicename );
		return psv;
	}
	//lprintf( WIDE("Registering library %s function %s"), library, load_proc_name );
	{
		RegisterProcedureExx( pcr
		                    , servicename
		                    , WIDE("load")
		                    , WIDE("POINTER")
		                    , library
		                    , load_proc_name
		                    , WIDE("void") DBG_SRC );
		RegisterProcedureExx( pcr
		                    , servicename
		                    , WIDE("unload")
		                    , WIDE("void")
		                    , library
		                    , unload_proc_name, WIDE("POINTER") DBG_SRC );
	}
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleAlias( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, servicename );
	PARAM( args, TEXTCHAR*, originalname );
	TEXTCHAR fullservicename[256];
	TEXTCHAR fulloriginalname[256];
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "alias %s=%s" ), servicename, originalname );
	tnprintf( fullservicename, sizeof( fullservicename), WIDE("system/interfaces/%s"), servicename );
	tnprintf( fulloriginalname, sizeof( fulloriginalname), WIDE("system/interfaces/%s"), originalname );
	RegisterClassAlias( fulloriginalname, fullservicename );
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleModule( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, module );
	LOGICAL tempPath = FALSE;
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( module[0] == '~' || module[0] == '@' || module[0] == '^' || module[0] == '*' ) {
		module = ExpandPath( module );
		tempPath = TRUE;
	}
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "load module %s" ), module );
	if( !l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 1;
		SuspendDeadstart();
	}
	LoadFunction( module, NULL );
	if( tempPath )
		Deallocate( TEXTCHAR*, module );
	return psv;
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandlePrivateModule( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTCHAR*, module );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "load private module %s" ), module );
	if( !l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 1;
		SuspendDeadstart();
	}
	LoadPrivateFunction( module, NULL );
	return psv;
}
//-----------------------------------------------------------------------
static TEXTSTR SubstituteNameVars( CTEXTSTR name )
{
	PVARTEXT pvt = VarTextCreate();
	const TEXTCHAR *start = name;
	const TEXTCHAR *this_var = name;
	const TEXTCHAR *end;
	while( ( this_var = StrChr( start, '%' ) ) )
	{
		// allow specifying %% for a single %.
		// emit the stuff from start to the variable
		if( start < this_var )
			vtprintf( pvt, WIDE("%*.*s"), this_var-start, this_var-start, start );
		if( this_var[1] == '%' )
		{
			VarTextAddCharacter( pvt, '%' );
			start = this_var + 2;
			continue;
		}
		end = StrChr( this_var + 1, '%' );
		if( end )
		{
			TEXTCHAR *tmpvar = NewArray( TEXTCHAR, end - this_var );
			CTEXTSTR envvar;
			tnprintf( tmpvar, end-this_var, WIDE("%*.*s"), (int)(end-this_var-1), (int)(end-this_var-1), this_var + 1 );
			envvar = OSALOT_GetEnvironmentVariable( tmpvar );
			if( envvar )
				vtprintf( pvt, WIDE("%s"), OSALOT_GetEnvironmentVariable( tmpvar ) );
			else
				lprintf( WIDE("failed to find environment variable '%s'"), tmpvar );
			Release( tmpvar );
			start = end + 1;
		}
		else
			lprintf( WIDE("Bad framing on environment variable %%var%% syntax got [%s]"), start );
	}
	if( start[0] )
		vtprintf( pvt, WIDE("%s"), start );
	{
		TEXTSTR result = StrDup( GetText( VarTextPeek( pvt ) ) );
		VarTextDestroy( &pvt );
		return result;
	}
}
//-----------------------------------------------------------------------
static uintptr_t CPROC HandleModulePath( uintptr_t psv, arg_list args )
{
	PARAM( args, TEXTSTR, filepath );
	filepath = ExpandPath( filepath );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
# ifdef __LINUX__
	OSALOT_AppendEnvironmentVariable( WIDE("LD_LIBRARY_PATH"), filepath );
# else
#  ifndef UNDER_CE
	OSALOT_AppendEnvironmentVariable( WIDE("PATH"), filepath );
#  endif
# endif
	Release( filepath );
	return psv;
}
PROCREG_PROC( void, SetInterfaceConfigFile )( TEXTCHAR *filename )
{
	if( l.config_filename )
		Release( l.config_filename );
	l.config_filename = StrDup( filename );
}
static uintptr_t CPROC SetDefaultDirectory( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, CTEXTSTR, path );
	SetCurrentPath( path );
#endif
	return psv;
}
static uintptr_t CPROC SetOptionDefault( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, TEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	TEXTCHAR buf[256];
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( key[0] != '/' && key[0] != '\\' )
	{
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Default Option %s / [%s] = [%s}" ), GetProgramName(), key, value );
		key = SubstituteNameVars( key );
		SACK_GetProfileStringEx( GetProgramName(), key, value, buf, sizeof( buf ), TRUE );
		Release( key );
	}
	else
	{
		TEXTSTR optpath = (TEXTSTR)pathchr( key + 1 );
		TEXTSTR optname = (TEXTSTR)pathrchr( key );
		optname[0] = 0;
		optname++;
		optpath[0] = 0;
		optpath++;
		optname = SubstituteNameVars( optname );
		optpath = SubstituteNameVars( optpath );
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Default Option [%s]/[%s]/[%s] = [%s}" ), key, optpath, optname, value );
		SACK_GetPrivateProfileStringEx( optpath, optname, value, buf, sizeof( buf ), key, TRUE );
		Release( optname );
		Release( optpath );
	}
#endif
	return psv;
}
static uintptr_t CPROC SetOptionSet( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, TEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	if( l.flags.bFindEndif || l.flags.bFindElse )
		return psv;
	if( key[0] != '/' && key[0] != '\\' )
	{
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Set Option %s / [%s] = [%s}" ), GetProgramName(), key, value );
		key = SubstituteNameVars( key );
		SACK_WriteProfileStringEx( GetProgramName(), key, value, key, TRUE );
		Release( key );
	}
	else
	{
		TEXTSTR optpath = (TEXTSTR)pathchr( key + 1 );
		TEXTSTR optname = (TEXTSTR)pathrchr( key );
		optname[0] = 0;
		optname++;
		optpath[0] = 0;
		optpath++;
		optname = SubstituteNameVars( optname );
		optpath = SubstituteNameVars( optpath );
		if( l.flags.bTraceInterfaceLoading )
			lprintf( WIDE( "Set Option [%s]/[%s]/[%s] = [%s}" ), key, optpath, optname, value );
		SACK_WritePrivateProfileStringEx( optpath, optname, value, key, TRUE );
		Release( optname );
		Release( optpath );
	}
#endif
	return psv;
}
static uintptr_t CPROC TestOption( uintptr_t psv, arg_list args )
{
#ifndef __NO_OPTIONS__
	PARAM( args, CTEXTSTR, key );
	PARAM( args, CTEXTSTR, value );
	TEXTCHAR buf[256];
	SACK_GetProfileStringEx( GetProgramName(), key, WIDE( "" ), buf, sizeof( buf ), TRUE );
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( " is [%s] == [%s]  buf = [%s]" ), key, value, buf );
	if( buf[0] == 0 )
	{
		l.flags.bFindEndif++;
		l.flags.bFindElse = 1;
	}
	else if( StrCaseCmp( buf, value ) != 0 )
	{
		l.flags.bFindEndif++;
		l.flags.bFindElse = 1;
	}
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "seek(findendif, findelse) = %d %d" ), l.flags.bFindEndif, l.flags.bFindElse );
#endif
	return psv;
}
static uintptr_t CPROC EndTestOption( uintptr_t psv, arg_list args )
{
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "found endif..." ) );
	if(l.flags.bFindEndif)
	{
		l.flags.bFindEndif--;
		l.flags.bFindElse = 0;
	}
	return psv;
}
static uintptr_t CPROC ElseTestOption( uintptr_t psv, arg_list args )
{
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "found else..." ) );
	if(l.flags.bFindElse)
	{
		l.flags.bFindElse = 0;
		l.flags.bFindEndif = 0;
	}
	else
		l.flags.bFindEndif++;
	return psv;
}
static uintptr_t CPROC SetTrace( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, yesno );
	l.flags.bTraceInterfaceLoading = yesno;
	return psv;
}
static uintptr_t CPROC IncludeAdditional( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, path );
	TEXTSTR old_configname = l.config_filename;
	l.config_filename = ExpandPath( path );
	if( l.flags.bTraceInterfaceLoading )
		lprintf( WIDE( "include:%s from %s" ), l.config_filename, old_configname );
	if( !l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 1;
		SuspendDeadstart();
	}
	ReadConfiguration();
	if( l.flags.bHeldDeadstart )
	{
		ResumeDeadstart();
		l.flags.bHeldDeadstart = 0;
	}
	Release( l.config_filename );
	l.config_filename = old_configname;
	return psv;
}
static uintptr_t CPROC SetProducerName( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, name );
	sack_set_common_data_producer( name );
	return psv;
}
static uintptr_t CPROC SetApplicationName( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, name );
	sack_set_common_data_application( name );
	return psv;
}
#endif
//-----------------------------------------------------------------------
#ifndef __NO_INTERFACE_SUPPORT__
void ReadConfiguration( void )
{
	if( !l.flags.bInterfacesLoaded )
	{
		PCONFIG_HANDLER pch;
		pch = CreateConfigurationHandler();
		AddConfigurationMethod( pch, WIDE( "Producer=%m" ), SetProducerName );
		AddConfigurationMethod( pch, WIDE( "Application=%m" ), SetApplicationName );
		AddConfigurationMethod( pch, WIDE( "enable trace=%b" ), SetTrace );
		AddConfigurationMethod( pch, WIDE( "option default %m=%m" ), SetOptionDefault );
		AddConfigurationMethod( pch, WIDE( "option set %m=%m" ), SetOptionSet );
		AddConfigurationMethod( pch, WIDE( "default option %m=%m" ), SetOptionDefault );
		AddConfigurationMethod( pch, WIDE( "set option %m=%m" ), SetOptionSet );
		AddConfigurationMethod( pch, WIDE( "start directory \"%m\"" ), SetDefaultDirectory );
		AddConfigurationMethod( pch, WIDE( "include \"%m\"" ), IncludeAdditional );
		AddConfigurationMethod( pch, WIDE( "if %m==%m" ), TestOption );
		AddConfigurationMethod( pch, WIDE( "endif" ), EndTestOption );
		AddConfigurationMethod( pch, WIDE( "else" ), ElseTestOption );
		AddConfigurationMethod( pch, WIDE("service=%w library=%w load=%w unload=%w"), HandleLibrary );
		AddConfigurationMethod( pch, WIDE("alias service %w %w"), HandleAlias );
		AddConfigurationMethod( pch, WIDE("module %w"), HandleModule );
		AddConfigurationMethod( pch, WIDE("pmodule %w"), HandlePrivateModule );
		AddConfigurationMethod( pch, WIDE("modulepath %m"), HandleModulePath );
		{
			CTEXTSTR filepath
#ifdef __ANDROID__
				= WIDE(".");
#else
				= GetProgramPath();
#endif
			TEXTSTR loadname;
			size_t len;
			int success = FALSE;
			if( !filepath )
				filepath = WIDE("@");
			if( l.config_filename )
			{
				success = ProcessConfigurationFile( pch, l.config_filename, 0 );
				if( !success )
					lprintf( WIDE("Failed to open custom interface configuration file:%s"), l.config_filename );
				return;
			}
			if( !success )
			{
				CTEXTSTR dot;
				loadname = NewArray( TEXTCHAR, (uint32_t)(len = StrLen( GetProgramName() ) + StrLen( WIDE("interface.conf") ) + 3) );
				tnprintf( loadname, len, WIDE("%s.%s"), GetProgramName(), WIDE("interface.conf") );
				success = ProcessConfigurationFile( pch, loadname, 0 );
				if( !success )
					dot = GetProgramName();
				while( !success )
				{
					dot = StrChr( dot + 1, '.' );
					if( dot )
					{
						tnprintf( loadname, len, WIDE("%s.%s"), dot+1, WIDE("interface.conf") );
						success = ProcessConfigurationFile( pch, loadname, 0 );
					}
					else
						break;
				}
			}
			if( !success )
			{
				success = ProcessConfigurationFile( pch, WIDE( "interface.conf" ), 0 );
			}
			if( !success )
			{
				CTEXTSTR dot;
				loadname = NewArray( TEXTCHAR, (uint32_t)(len = StrLen( filepath ) + StrLen( GetProgramName() ) + StrLen( WIDE("interface.conf") ) + 3) );
				tnprintf( loadname, len, WIDE("%s/%s.%s"), filepath, GetProgramName(), WIDE("interface.conf") );
				success = ProcessConfigurationFile( pch, loadname, 0 );
				if( !success )
					dot = GetProgramName();
				while( !success )
				{
					dot = StrChr( dot + 1, '.' );
					if( dot )
					{
						tnprintf( loadname, len, WIDE("%s/%s.%s"), filepath, dot+1, WIDE("interface.conf") );
						success = ProcessConfigurationFile( pch, loadname, 0 );
					}
					else
						break;
				}
			}
			if( !success )
			{
				tnprintf( loadname, len, WIDE("%s/%s"), filepath, WIDE("interface.conf") );
				success = ProcessConfigurationFile( pch, loadname, 0 );
			}
			if( !success )
			{
				//lprintf( WIDE("Failed to open interface configuration file:%s - assuming it will never exist, and aborting trying this again")
				//		 , l.config_filename?l.config_filename:WIDE("interface.conf") );
			}
			if( loadname )
				Release( loadname );
		}
		DestroyConfigurationHandler( pch );
		//at this point... we should probably NOT
		// dump this information, a vast amount of information may occur.
		// consider impelmenting enumerators and allowing browsing
		//DumpRegisteredNames();
		// if we failed, probably noone will notice, and nooone will
		// get the clue that we need to have an interface.conf
		// for this to preload extra libraries that the program may be
		// requesting.
		l.flags.bInterfacesLoaded = 1;
	}
	//else
	//	lprintf( WIDE( "already loaded." ) );
	if( l.flags.bHeldDeadstart )
	{
		l.flags.bHeldDeadstart = 0;
		ResumeDeadstart();
	}
}
#endif
//-----------------------------------------------------------------------
POINTER GetInterfaceExx( CTEXTSTR pServiceName, LOGICAL ReadConfig DBG_PASS )
{
	TEXTCHAR interface_name[256];
	POINTER (CPROC *load)( void );
	static int reading_configuration;
	// this might be the first clean chance to run deadstarts
	// for ill behaved platforms that have forgotten to do this.
	if( !IsRootDeadstartStarted() )
	{
		InvokeDeadstart();
	}
#ifndef __NO_INTERFACE_SUPPORT__
	if( ReadConfig && !reading_configuration )
	{
		reading_configuration = 1;
		SuspendDeadstart();
		ReadConfiguration();
		ResumeDeadstart();
		reading_configuration = 0;
	}
#endif
	//lprintf( "Load interface [%s]", pServiceName );
	if( pServiceName )
	{
		tnprintf( interface_name, sizeof( interface_name ), WIDE("system/interfaces/%s"), pServiceName );
		load = GetRegisteredProcedure( (PCLASSROOT)interface_name, POINTER, load, (void) );
		//lprintf( WIDE("GetInterface for %s is %p"), pServiceName, load );
		if( load )
		{
			POINTER p = load();
			//lprintf( WIDE("And the laod proc resulted %p"), p );
 //load();
			return p;
		}
#ifdef _DEBUG
		else
		{
			if( l.flags.bInterfacesLoaded )
			{
				if( !GetRegisteredValueExx( (PCLASSROOT)interface_name, NULL, WIDE( "Logged" ), 1 ) )
				{
					_lprintf(DBG_RELAY)( WIDE("Did not find load procedure for:[%s] (dumping names from /system/interface/* so you can see what might be available)"), interface_name );
					DumpRegisteredNamesFrom(GetClassRoot(WIDE( "system/interfaces" )));
					RegisterValueExx( (PCLASSROOT)interface_name, NULL, WIDE( "Logged" ), 1, (CTEXTSTR)1 );
				}
			}
		}
#endif
	}
	return NULL;
}
#undef GetInterfaceEx
POINTER GetInterfaceEx( CTEXTSTR pServiceName, LOGICAL ReadConfig )
{
	return GetInterfaceExx( pServiceName, ReadConfig DBG_SRC );
}
POINTER GetInterfaceDbg( CTEXTSTR pServiceName DBG_PASS )
{
	POINTER result = GetInterfaceExx( pServiceName, FALSE DBG_RELAY );
	if( !result )
	{
		// don't force the issue too much
		if( l.flags.bReadConfiguration )
			result = GetInterfaceExx( pServiceName, TRUE DBG_RELAY );
	}
	return result;
}
#if 0
#undef GetInterface
PUBLIC( POINTER, GetInterface )( CTEXTSTR pServiceName )
{
	return GetInterfaceDbg( pServiceName DBG_SRC );
}
#endif
//-----------------------------------------------------------------------
PROCREG_PROC( void, DropInterface )( CTEXTSTR pServiceName, POINTER interface_drop )
{
	TEXTCHAR interfacename[256];
	void (CPROC *unload)( POINTER );
	tnprintf( interfacename, sizeof(interfacename), WIDE("system/interfaces/%s"), pServiceName );
	unload = GetRegisteredProcedure( (PCLASSROOT)interfacename, void, unload, (POINTER) );
	if( unload )
		unload( interface_drop );
}
//-----------------------------------------------------------------------
PRIORITY_ATEXIT( CloseGlobalRegions, ATEXIT_PRIORITY_SHAREMEM + 1 )
{
	PLIST *global_reference;
	INDEX idx;
	return;
	l.reference_count--;
	if( !l.reference_count )
		LIST_FORALL( l.global_spaces, idx, PLIST*, global_reference )
		{
			INDEX idx2;
			POINTER *ppGlobal;
			SetAllocateLogging( 0 );
			// hold the global reference once more, and then just release
			Hold( global_reference );
			LIST_FORALL( global_reference[0], idx2, POINTER *, ppGlobal )
			{
				// increment count here for number of Releases to do.
				(*ppGlobal) = NULL;
				Release( global_reference );
			}
			DeleteList( global_reference );
			// Release all times; number of holds should match number above...
			// safety check it?
			Release( global_reference );
		}
}
void RegisterAndCreateGlobalWithInit( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name, void (CPROC*Open)(POINTER,uintptr_t) )
{
	POINTER *ppGlobalMain;
	POINTER p;
	if( ppGlobal == (POINTER*)&procreg_local_data )
	{
		uintptr_t size = global_size + sizeof( PLIST );
		uint32_t created;
		TEXTCHAR spacename[32];
		if( procreg_local_data != NULL )
		{
			// if local already has something, just return.
			return;
		}
#ifdef DEBUG_GLOBAL_REGISTRATION
		lprintf( WIDE("Opening space...") );
#endif
#ifdef UNICODE
#define _S WIDE("ls")
#else
#define _S WIDE("s")
#endif
#ifdef WIN32
		tnprintf( spacename, sizeof( spacename ), WIDE("%s:%08lX"), name, GetCurrentProcessId() );
#else
		tnprintf( spacename, sizeof( spacename ), WIDE("%")_S WIDE(":%08X"), name, getpid() );
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
		{
			wchar_t buf[32];
			strcpy( (char*)buf, "abcdefghijklmn" );
			swprintf( buf, 32, L"%s", L"some_name" );
			{
				char tmpmsg[256];
				int chars;
				int ofs= 0;
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%02x ", ((char*)buf)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (buf)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
								ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (name)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
				ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
				for( chars = 0; chars < 32; chars++ )
					ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (spacename)[chars] );
				__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			}
		}
#  endif
#endif
		// hmm application only shared space?
		// how do I get that to happen?
		(*ppGlobal) = OpenSpaceExx( spacename, NULL, 0, &size, &created );
		(*ppGlobal) = (POINTER*)( (uintptr_t)(*ppGlobal) + sizeof( PLIST ) );
		// I myself must have a global space, which is kept sepearte from named spaces
		// but then... blah
		if( created )
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("(specific procreg global)clearing memory:%s(%p)"), spacename, (*ppGlobal ) );
#endif
			MemSet( (*ppGlobal), 0, global_size );
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( POINTER ) );
				global_references[0] = NULL;
				AddLink( global_references, ppGlobal );
			}
			if( Open )
				Open( (*ppGlobal), global_size );
			p = (POINTER)MakeRegisteredDataTypeEx( NULL, WIDE("system/global data"), name, name, (*ppGlobal), global_size );
		}
		else
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("(specific procreg global)using memory untouched:%s(%p)"), spacename, (*ppGlobal ) );
#endif
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( POINTER ) );
				AddLink( global_references, ppGlobal );
			}
		}
		// result is the same as the pointer input...
		return;
	}
	if( ppGlobal && !(*ppGlobal) )
	{
		Init();
		// RTLD_DEFAULT
		ppGlobalMain = &p;
		p = (POINTER)CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, WIDE("system/global data"), name, name );
		if( !p )
		{
			RegisterDataType( WIDE("system/global data"), name, global_size
								 , Open
								 , NULL );
			p = (POINTER)CreateRegisteredDataTypeEx( (PCLASSROOT)l.Names, WIDE("system/global data"), name, name );
			if( !p )
				ppGlobalMain = NULL;
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("Registered and created by registered type. %p"), p );
#endif
			{
				// only need each space once in this list; when it's created.
				POINTER tmp_p = (POINTER)( (uintptr_t)p - sizeof( PLIST ) );
				AddLink( &l.global_spaces, tmp_p );
			}
		}
		else
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("Found our shared region by asking politely for it! *********************") );
#endif
		}
		if( !ppGlobalMain )
		{
			lprintf( WIDE("None found in main... no way to mark for a peer...") );
			exit(0);
		}
		if( ppGlobalMain && *ppGlobalMain )
		{
#ifdef DEBUG_GLOBAL_REGISTRATION
			lprintf( WIDE("Resulting with a global space to use... %p"), (*ppGlobalMain) );
#endif
			(*ppGlobal) = (*ppGlobalMain);
			{
				// pp global is a double pointer type, I want the pointer before
				PLIST *global_references = (PLIST*)( (uintptr_t)(*ppGlobal) - sizeof( PLIST ) );
				AddLink( global_references, ppGlobal );
			}
		}
		else
		{
			lprintf( WIDE("Failure to get global_procreg_data block.") );
			exit(0);
		}
	}
	else
	{
		// thing is already apparently initizliaed.. don't do this.
		ppGlobalMain = NULL;
	}
}
void RegisterAndCreateGlobal( POINTER *ppGlobal, uintptr_t global_size, CTEXTSTR name )
{
	RegisterAndCreateGlobalWithInit( ppGlobal, global_size, name, NULL );
}
#ifdef __cplusplus_cli
using namespace System;
public ref class ProcReg
{
	static ProcReg()
	{
		InvokeDeadstart();
	}
	int Register( System::String^ name_class, String^ proc, STDPROCEDURE Delegate )
	{
		if( name_class )
		{
//Allocate( sizeof( NAME ) );
			PNAME newname = GetFromSet( NAME, &l.NameSet );
			TEXTCHAR strippedargs[256];
			pin_ptr<const WCHAR> tmp2 = PtrToStringChars(name_class);
			CTEXTSTR __name_class = DupWideToText( tmp2 );
			pin_ptr<const WCHAR> tmp = PtrToStringChars(proc);
			CTEXTSTR real_name = DupWideToText( tmp );
			PTREEDEF class_root = (PTREEDEF)GetClassTree( NULL, (PTREEDEF)__name_class );
			MemSet( newname, 0, sizeof( NAME ) );
			newname->flags.bStdProc = 1;
			// this is kinda messed up...
			newname->name = SaveName( real_name );
			//newname->data.stdproc.library = SaveName( library );
			newname->data.stdproc.procname = SaveName( real_name );
			//newname->data.proc.ret = SaveName( returntype );
			//newname->data.proc.args = SaveName( StripName( strippedargs, args ) );
			newname->data.proc.name = SaveNameConcatN( StripName( strippedargs, WIDE( "(*)" ) )
 //returntype
																  , WIDE("")
 // library
																  , WIDE("")
																  , real_name
																  , NULL
																  );
			newname->data.stdproc.proc = Delegate;
			if( class_root )
			{
				PNAME oldname;
				oldname = (PNAME)FindInBinaryTree( class_root->Tree, (uintptr_t)newname->name);
				if( oldname )
				{
					if( oldname->data.stdproc.proc == Delegate )
						Log( WIDE("And fortunatly it's the same address... all is well...") );
					else
					{
						xlprintf( 2 )( WIDE("proc %s/%s regisry by %s of %s(%s) conflicts with %s(%s)...")
													  , (CTEXTSTR)__name_class?(CTEXTSTR)__name_class:WIDE("@")
													  , real_name
													  , newname->name
													  , newname->data.proc.name
														//,library
													  , newname->data.proc.procname
													  , oldname->data.proc.name
													  //,library
													  , oldname->data.proc.procname );
						// perhaps it's same in a different library...
						Log( WIDE("All is not well - found same function name in tree with different address. (ignoring second) ") );
						//DebugBreak();
						//DumpRegisteredNames();
					}
					return TRUE;
				}
				else
				{
					newname->parent = class_root;
					if( !AddBinaryNode( class_root->Tree, newname, (uintptr_t)newname->name ) )
					{
						Log( WIDE("For some reason could not add new name to tree!") );
						DeleteFromSet( NAME, l.NameSet, newname );
					}
				}
			}
			else
			{
				lprintf( WIDE("I'm relasing this name!?") );
				DeleteFromSet( NAME, l.NameSet, newname );
			}
			return 1;
		}
	}
};
#endif
PROCREG_NAMESPACE_END
#undef l
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
//   DEBUG_SYMBOLS
// had some problems with OpenSpace opening a shared region under win98
// Apparently if a create happens with a size of 0, the name of the region
// becomes unusable, until a reboot happens.
//#define DEBUG_OPEN_SPACE
// this variable controls whether allocate/release is logged.
#ifndef NO_FILEOP_ALIAS
#  define NO_FILEOP_ALIAS
#endif
#define NO_UNICODE_C
//#define USE_SIMPLE_LOCK_ON_OPEN
#ifdef __LINUX__
#include <sys/mman.h>
#endif
#ifdef _MSC_VER
#ifndef UNDER_CE
#endif
#endif
#define DEFINE_MEMORY_STRUCT
/* A header for doing .NET /CLR compatiblity changes. Things
   like fopen needing to be _fopen_s and junk.               */
#ifndef FILE_DOT_NET_COMPAT
/* Header multiple inclusion protection symbol. */
#define FILE_DOT_NET_COMPAT
#ifdef __cplusplus_cli
#define Fopen( result, name, opts ) { char *tmp1 = CStrDup( name ); char *tmp2 = CStrDup( opts ); result = fopen( tmp1, tmp2 ); Deallocate( char *, tmp1 ); Deallocate( char *, tmp2 ); }
#if asdfasdlfkajsdflkj
#define fputs( msg, file ) { char *tmp = CStrDup( msg ); fputs( tmp, file ); Release( tmp ); }
#define unlink( name ) { char *tmp = CStrDup( name ); unlink( tmp ); Release( tmp ); }
#define rename( name1, name2 ) { char *tmp1 = CStrDup( name1 ); char *tmp2 = CStrDup( name2 ); rename( tmp1, tmp2 ); Release( tmp1 ); Release( tmp2 ); }
#define fprintf Fprintf
#endif
//int Fprintf( FILE *file, CTEXTSTR fmt, ... );
/*
using namespace Win32;
#define CreateEvent(a,b,c,d) Win32::Kernel::CreateEvent((SECURITY_ATTRIBUTES)a,b,c,d)
#define OpenEvent(a,b,c)     Win32::Kernel::OpenEvent(a,b,c)
#define Sleep(a)             Win32::Kernel::Sleep(a)
#define GetTickCount()       Win32::Kernel::GetTickCount()
#define GetCurrentProcessId() Win32::Kernel::GetCurrentProcessId()
#define GetCurrentThreadId()  Win32::Kernel::GetCurrentThreadId()
#define GetLastError()  Win32::Kernel::GetLastError()
#define SetEvent(a) Win32::Kernel::SetEvent(a)
#define ResetEvent(a) Win32::Kernel::ResetEvent(a)
#define CloseHandle(a) Win32::Kernel::CloseHandle(a)
#define WaitForSingleObject(a,b) Win32::Kernel::WaitForSingleObject(a,b)
#define PeekMessage(a,b,c,d,e)  Win32::User::PeekMessage(a,b,c,d,e)
#define DispatchMessage(a)   Win32::User::DispatchMessage(a)
#define GetModuleFileName(a,b) Win32::Kernel::GetModuleFileName(a,b)
*/
#if 0
typedef struct MyFile MYFILE;
MYFILE *Fopen( CTEXTSTR filename, CTEXTSTR mode );
int Fread( POINTER data, int count, int size, MYFILE *file );
int Fwrite( POINTER data, int count, int size, MYFILE *file );
int Fclose( MYFILE *file );
int Fseek( MYFILE *file, int64_t pos, int whence );
uint64_t Ftell( MYFILE *file );
MYFILE *Fdopen( int fd, CTEXTSTR mode );
int Ferror( MYFILE *file );
int Fflush( MYFILE *file );
int Rewind( MYFILE *file );
int Fputc( int c, MYFILE *file );
int Fgets( TEXTSTR buf, int buflen, MYFILE *file );
int Fputs( CTEXTSTR but, MYFILE *file );
int Unlink( CTEXTSTR filename );
int Rename( CTEXTSTR from, CTEXTSTR to );
#define rename Rename
#define unlink Unlink
#define FILE MYFILE
#define fopen Fopen
#define fseek Fseek
#define fclose Fclose
#define fprintf Fprintf
#define ftell Ftell
#define fread Fread
#define fwrite Fwrite
//#define fdopen Fdopen
#define ferror Ferror
#define fflush Fflush
#define rewind Rewind
#define fputc Fputc
#define fgets Fgets
#define fputs Fputs
#endif
#else
/* A macro which can be translated into microsoft so-called safe
   methods.                                                      */
#define Fopen( result, name, opts ) result = sack_fopen( 0, name, opts )
//#define MYFILE  FILE
//#define Fopen   fopen
//#define Fread   fread
//#define Fwrite  fread
//#define Fclose  fclose
//#define Fprintf fprintf
//#define Fseek   fseek
//#define Ftell   ftell
#endif
#endif
// end with a newline please.
#ifndef _SHARED_MEMORY_LIBRARY
#if !defined( MEMORY_STRUCT_DEFINED ) || defined( DEFINE_MEMORY_STRUCT )
//#define ENABLE_NATIVE_MALLOC_PROTECTOR
#ifdef _DEBUG
#  define USE_DEBUG_LOGGING 1
#else
#  define USE_DEBUG_LOGGING 0
#endif
#define MEMORY_STRUCT_DEFINED
#ifdef _DEBUG
//  Define this symbol in SHAREMEM.H!
// if you define it here it will not work as expected...
//// defined in sharemem.h #define DEBUG_CRITICAL_SECTIONS
//// defined in sharemem.h #define LOG_DEBUG_CRITICAL_SECTIONS
#endif
#define _SHARED_MEMORY_LIBRARY
#ifdef __cplusplus
namespace sack {
	namespace timers {
#endif
// bit set on dwLocks when someone hit it and it was locked
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#define SECTION_LOGGED_WAIT 0x80000000
#define AND_NOT_SECTION_LOGGED_WAIT(n) ((n)&(~SECTION_LOGGED_WAIT))
#define AND_SECTION_LOGGED_WAIT(n) ((n)&(SECTION_LOGGED_WAIT))
#else
#define SECTION_LOGGED_WAIT 0
#define AND_NOT_SECTION_LOGGED_WAIT(n) (n)
#define AND_SECTION_LOGGED_WAIT(n) (0)
#endif
// If you change this structure please change the public
// reference of this structure, and please, do hand-count
// the bytes to set there... so not include this file
// to get the size.  The size there should be the worst
// case - debug or release mode.
#ifdef NO_PRIVATE_DEF
struct critical_section_tag {
 // this is set when entering or leaving (updating)...
	volatile uint32_t dwUpdating;
	volatile uint32_t dwLocks;
 // windows upper 16 is process ID, lower is thread ID
	THREAD_ID dwThreadID;
 // ID of thread waiting for this..
	THREAD_ID dwThreadWaiting;
	//PDATAQUEUE pPriorWaiters;
#ifdef DEBUG_CRITICAL_SECTIONS
	uint32_t bCollisions ;
	CTEXTSTR pFile;
	uint32_t  nLine;
#endif
};
typedef struct critical_section_tag CRITICALSECTION;
#endif
#ifdef __cplusplus
	};
};
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
		using namespace sack::timers;
#endif
// pFile, nLine has been removed from this
// the references for this info are now
// stored at the end of the block
		// after the 0x12345678 tag.
#  ifdef _MSC_VER
#    pragma pack (push, 1)
#  endif
// custom allocer, use heap_chunk_tag
PREFIX_PACKED struct malloc_chunk_tag
{
   // if 0 - block is free
	uint16_t dwOwners;
      // extra bytes 4/12 typical, sometimes pad untill next. (alignment extra bytes)
	uint16_t dwPad;
#ifdef __64__
	uint32_t pad;
#endif
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
	uint32_t LeadProtect[2];
#endif
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
PREFIX_PACKED struct heap_chunk_tag
{
            // if 0 - block is free
	uint16_t dwOwners;
   // extra bytes 4/12 typical, sometimes pad untill next.
	uint16_t dwPad;
	// which is < ( CHUNK_SIZE + nMinAllocate )
	// real size is then dwSize - dwPad.
	// this is actually where the end of block tag(s) should begin!
  // limited to allocating 4 billion bytes...
	uintptr_t dwSize;
         // save some math backwards...
	struct heap_chunk_tag *pPrior;
  // pointer to master allocation struct (pMEM)
	struct memory_block_tag * pRoot;
	DeclareLink( struct heap_chunk_tag );
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t alignment;
 // this is additional to subtract to get back to start (aligned allocate)
	uint16_t to_chunk_start;
 // uint8_t is the smallest valid datatype could be _0
	uint8_t byData[1];
} PACKED;
// a chunk of memory in a heap space, heaps are also tracked, so extents
// of that space are known, therefore one can identify a heap chunk
// from a non-heap (malloc?) chunk.
typedef PREFIX_PACKED struct heap_chunk_tag HEAP_CHUNK, *PHEAP_CHUNK;
// CHUNK and HEAP_CHUNK are the same.  They were not the same when using an
// ifdef to separate custom allocation from malloc allocation.  HeapAllocate
// could still be passed a heap before, and would be able to allocate from it.
typedef PREFIX_PACKED struct heap_chunk_tag CHUNK, *PCHUNK;
typedef PREFIX_PACKED struct malloc_chunk_tag MALLOC_CHUNK, *PMALLOC_CHUNK;
#ifdef _MSC_VER
#pragma pack (pop)
#endif
// chunks allocated have no debug information.
#define HEAP_FLAG_NO_DEBUG 0x0001
struct memory_block_tag
{
	uintptr_t dwSize;
 // unique value 0xbab1f1ea (baby flea);
	uint32_t dwHeapID;
	// lock between multiple processes/threads
	CRITICALSECTION cs;
	uint32_t dwFlags;
	PHEAP_CHUNK pFirstFree;
	HEAP_CHUNK pRoot[1];
};
typedef struct memory_block_tag MEM;
#ifdef __cplusplus
	};
};
#endif
#endif
#endif
#if defined __ANDROID__
#include <linux/ashmem.h>
#endif
#ifdef _MSC_VER
//>= 900
#include <crtdbg.h>
#include <new.h>
#endif
#ifdef __cplusplus
namespace sack {
	namespace memory {
#endif
#ifdef __64__
#define CLEAR_MEMORY_TAG 0xDEADBEEFDEADBEEFULL
#define FREE_MEMORY_TAG 0xFACEBEADFACEBEADULL
#define LEAD_PROTECT_TAG 0xbabecafebabecafeULL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafebeefcafeULL
#else
#define CLEAR_MEMORY_TAG 0xDEADBEEFUL
#define FREE_MEMORY_TAG 0xFACEBEADUL
#define LEAD_PROTECT_TAG 0xbabecafeUL
#define LEAD_PROTECT_BLOCK_TAIL 0xbeefcafeUL
#endif
#ifdef g
#  undef g
#endif
#ifdef __64__
#  define makeULong(n) (~(n##ULL))
#else
#  define makeULong(n) (~(n##UL))
#endif
static uintptr_t masks[33] = { makeULong(0), makeULong(0), makeULong(1), 0, makeULong(3), 0, 0, 0, makeULong(7), 0, 0, 0, 0, 0, 0, 0, makeULong(15), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, makeULong(31) };
#define BASE_MEMORY (POINTER)0x80000000
// golly allocating a WHOLE DOS computer to ourselves? how RUDE
#define SYSTEM_CAPACITY  g.dwSystemCapacity
#define MALLOC_CHUNK_SIZE(pData) ( (pData)?( ( ( (uint16_t*)(pData))[-1] ) + offsetof( MALLOC_CHUNK, byData ) ):0 )
//#define CHUNK_SIZE(pData) ( ( (pData)?( (uint16_t*)(pData))[-1]:0 ) +offsetof( CHUNK, byData ) ) )
#define CHUNK_SIZE ( offsetof( CHUNK, byData ) )
#define MEM_SIZE  ( offsetof( MEM, pRoot ) )
// using lower level syslog bypasses some allocation requirements...
//#undef lprintf
//#undef _lprintf
#ifndef NO_LOGGING
#  ifdef _DEBUG
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, FILELINE_FILELINEFMT f,_pFile,_nLine,##__VA_ARGS__ ); SystemLogFL( buf FILELINE_SRC ); } }
#    define ll__lprintf( a ) {const TEXTCHAR *_pFile = pFile; int _nLine = nLine; _lprintf2
#  else
#    define ll_lprintf( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLog( buf ); }
#    define _lprintf2( f, ... ) { TEXTCHAR buf[256]; tnprintf( buf, 256, f,##__VA_ARGS__ ); SystemLog( buf ); } }
#    define ll__lprintf( a ) { _lprintf2
#  endif
#else
#  define lprintf( f,... )
#endif
// last entry in space tracking array will ALWAYS be
// another space tracking array (if used)
// (32 bytes)
typedef struct space_tracking_structure {
	PMEM pMem;
#ifdef _WIN32
	HANDLE  hFile;
	HANDLE  hMem;
#else
	struct {
		uint32_t bTemporary : 1;
	} flags;
	int hFile;
#endif
	uintptr_t dwSmallSize;
	DeclareLink( struct space_tracking_structure );
} SPACE, *PSPACE;
typedef struct space_pool_structure {
	DeclareLink( struct space_pool_structure );
	SPACE spaces[(4096 - sizeof( struct space_pool_structure * )
		- sizeof( struct space_pool_structure ** ))
		/ sizeof( SPACE )];
} SPACEPOOL, *PSPACEPOOL;
#define MAX_PER_BLOCK (4096 - sizeof( struct space_pool_structure *)	 - sizeof( struct space_pool_structure **) )	  / sizeof( SPACE )
#ifdef _WIN32
//(0x10000 * 0x1000) //256 megs?
#define FILE_GRAN g.si.dwAllocationGranularity
#else
#define FILE_GRAN g.pagesize
#endif
struct global_memory_tag {
 // basic OS block grabbed for allocation
	size_t dwSystemCapacity;
//#ifdef _DEBUG
// may define one or the other of these but NOT both
	int bDisableDebug;
	int bDisableAutoCheck;
	int bLogCritical;
	//#endif
	size_t nMinAllocateSize;
	int pagesize;
	int bLogAllocate;
	int bLogAllocateWithHold;
  // this option couldn't work; different block tracking methods are incompatible
	LOGICAL bCustomAllocer;
	LOGICAL bInit;
	LOGICAL allowLogging;
	PSPACEPOOL pSpacePool;
#ifdef _WIN32
	SYSTEM_INFO si;
#endif
 // don't add our tracking to ourselves...
	int InAdding;
 // set if anybody starts to DIG.
	uint32_t bMemInstanced;
	LOGICAL deadstart_finished;
	PMEM pMemInstance;
};
#ifdef __STATIC__
static struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 1, 1
													, 0
													, 0
													, 0
													, 0
													, 0
																	  , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
#  define g (global_memory_data)
#else
#  ifdef _DEBUG
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 0
#    ifdef DEBUG_CRITICAL_SECTIONS
															, 1
#    else
															, 0
#    endif
															, 0
															, 0
															, 0
															, 0
															 , USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  else
/* disable debug*/
struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 1, 1
 /* log crit */
 /* min alloc size */
															, 0, 0, 0
															, 0
															, 0
  // custom allocer
															, USE_CUSTOM_ALLOCER
																	  , 0
																	  , 0
																	  , NULL
#ifdef _WIN32
																	  , { 0 }
#endif
																	  , 0
																	  , 0
																	  , FALSE
                                                     , NULL
};
// this one has memory logging enabled by default...
//struct global_memory_tag global_memory_data = { 0x10000 * 0x08, 0, 1, 0, 0, 0, 1 };
#  endif
#define g global_memory_data
#endif
#ifndef NO_LOGGING
#  define ODSEx(s,pFile,nLine) SystemLogFL( s DBG_RELAY )
//#define ODSEx(s,pFile,nLine) SystemLog( s )
#  define ODS(s)  SystemLog(s)
#else
#  define ODSEx(s,file,line)
#  define ODS(s)
#endif
#define MAGIC_SIZE sizeof( void* )
#ifdef __64__
#define BLOCK_TAG(pc)  (*(uint64_t*)((pc)->byData + (pc)->dwSize - (pc)->dwPad ))
// so when we look at memory this stamp is 0123456789ABCDEF
#define TAG_FORMAT_MODIFIER "ll"
#define BLOCK_TAG_ID 0xefcdab8967452301LL
#else
#define BLOCK_TAG(pc)  (*(uint32_t*)((pc)->byData + (pc)->dwSize - (pc)->dwPad ))
// so when we look at memory this stamp is 12345678
#define TAG_FORMAT_MODIFIER ""
#define BLOCK_TAG_ID 0x78563412L
#endif
// file/line info are at the very end of the physical block...
// block_tag is at the start of the padding...
#define BLOCK_FILE(pc) (*(CTEXTSTR*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE*2))
#define BLOCK_LINE(pc) (*(int*)((pc)->byData + (pc)->dwSize - MAGIC_SIZE))
#ifndef _WIN32
#endif
PRIORITY_PRELOAD( Deadstart_finished_enough, GLOBAL_INIT_PRELOAD_PRIORITY + 1 )
{
	g.deadstart_finished = 1;
	//g.bLogAllocate = 1;
}
PRIORITY_PRELOAD( InitGlobal, DEFAULT_PRELOAD_PRIORITY )
{
#ifndef __NO_OPTIONS__
	g.bLogCritical = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Log critical sections" ), g.bLogCritical, TRUE );
	g.bLogAllocate = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Enable Logging" ), g.bLogAllocate, TRUE );
	if( g.bLogAllocate )
		ll_lprintf( WIDE( "Memory allocate logging enabled." ) );
	g.bLogAllocateWithHold = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Enable Logging Holds" ), g.bLogAllocateWithHold, TRUE );
	//USE_CUSTOM_ALLOCER = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Custom Allocator" ), USE_CUSTOM_ALLOCER, TRUE );
	g.bDisableDebug = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/Memory Library/Disable Debug" ), !USE_DEBUG_LOGGING, TRUE );
#else
	//g.bLogAllocate = 1;
#endif
	g.nMinAllocateSize = 32;
	g.allowLogging = 1;
}
#if __GNUC__
#  ifndef __ATOMIC_RELAXED
#    define __ATOMIC_RELAXED 0
#  endif
//#    define DoXchg  XCHG
#  ifndef __GNUC_VERSION
#    define __GNUC_VERSION ( __GNUC__ * 10000 ) + ( __GNUC_MINOR__ * 100 )
#  endif
#  if  ( __GNUC_VERSION >= 40800 ) || defined(__MAC__) || defined( __EMSCRIPTEN__ )
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
///  for some reason __GNUC_VERSION doesn't exist from android ?
#  elif defined __ARM__ || defined __ANDROID__
#    define XCHG(p,val)  __atomic_exchange_n(p,val,__ATOMIC_RELAXED)
#  else
inline uint32_t DoXchg( volatile uint32_t* p, uint32_t val ) { __asm__( WIDE( "lock xchg (%2),%0" ) :WIDE( "=a" )(val) : WIDE( "0" )(val), WIDE( "c" )(p) ); return val; }
inline uint64_t DoXchg64( volatile int64_t* p, uint64_t val ) { __asm__( WIDE( "lock xchg (%2),%0" ) :WIDE( "=a" )(val) : WIDE( "0" )(val), WIDE( "c" )(p) ); return val; }
#    define XCHG( p,val) ( ( sizeof( val ) > sizeof( uint32_t ) )?DoXchg64( (volatile int64_t*)p, (uint64_t)val ):DoXchg( (volatile uint32_t*)p, (uint32_t)val ) )
#  endif
//#  endif
#else
#  define XCHG(p,val)  LockedExchange( p, val )
#endif
//-------------------------------------------------------------------------
#if !defined( HAS_ASSEMBLY ) || defined( __CYGWIN__ )
uint32_t  LockedExchange( volatile uint32_t* p, uint32_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if ( defined( _WIN32 ) || defined( WIN32 ) ) && !defined( __ANDROID__ )
#  if !defined(_MSC_VER)
	return InterlockedExchange( (volatile LONG *)p, val );
#  else
	//return _InterlockedExchange_HLEAcquire( (volatile long*)p, val );
	return _InterlockedExchange( (volatile long*)p, val );
	// windows wants this as a LONG not ULONG
	//return InterlockedExchange( (volatile LONG *)p, val );
#  endif
#else
 //&& !( defined __ARM__ || defined __ANDROID__ )
#  if ( defined( __LINUX__ ) )
	return XCHG( p, val );
	//   return __atomic_exchange_n(p,val,__ATOMIC_RELAXED);
#  else
	{
			// swp is the instruction....
			uint32_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
uint32_t LockedIncrement( uint32_t* p ) {
#ifdef _WIN32
	return InterlockedIncrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_add_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint32_t LockedDecrement( uint32_t* p ) {
#ifdef _WIN32
	return InterlockedDecrement( (volatile LONG *)p );
#endif
#ifdef __LINUX__
	return __atomic_sub_fetch( p, 1, __ATOMIC_RELAXED );
#endif
}
uint64_t  LockedExchange64( volatile uint64_t* p, uint64_t val )
{
	// Windows only available - for linux platforms please consult
	// the assembly version should be consulted
#if defined WIN32 && !defined __ANDROID__
#ifdef _MSC_VER
#ifdef __64__
	uint64_t prior = (uint64_t)InterlockedExchange64( (volatile __int64 *)p, (int64_t)val );
#else
	// because the value is a LONG (signed) it has to be made unsigned of the same lenght (ULONG) then extended (uint64_t).
	// otherwise the sign extension was a bug.
	uint64_t prior = (uint64_t)(ULONG)InterlockedExchange( (DWORD*)p, (DWORD)val ) | ((uint64_t)InterlockedExchange( ((DWORD*)p) + 1, (DWORD)(val >> 32) ) << 32);
#endif
#else
	uint64_t prior = InterlockedExchange( (volatile LONG*)p, (int32_t)val ) | InterlockedExchange( ((volatile LONG*)p) + 1, (uint32_t)(val >> 32) );
#endif
	return prior;
#else
#  if defined __GNUC__
#     if !defined( __ANDROID__ ) || ( ANDROID_NDK_TARGET_PLATFORM > 16 )
//__atomic_exchange_n(p,val,__ATOMIC_RELAXED);
	return XCHG( p, val );
#else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#endif
#  else
	{
		// swp is the instruction....
		// going to have to set IRQ, PIRQ on arm...
		uint64_t prior = *p;
		*p = val;
		return prior;
	}
#  endif
#endif
}
#endif
//-------------------------------------------------------------------------
#ifdef DEBUG_CRITICAL_SECTIONS
#if 0
static void DumpSection( PCRITICALSECTION pcs )
{
	ll_lprintf( WIDE( "Critical Section....." ) );
	ll_lprintf( WIDE( "------------------------------" ) );
	ll_lprintf( WIDE( "Update: %08x" ), pcs->dwUpdating );
	ll_lprintf( WIDE( "Current Process: %16"_64fx"" ), pcs->dwThreadID );
	ll_lprintf( WIDE( "Next Process:    %16"_64fx"" ), pcs->dwThreadWaiting );
	ll_lprintf( WIDE( "Last update: %s(%d)" ), pcs->pFile ? pcs->pFile : "unknown", pcs->nLine );
}
#endif
#endif
#ifdef __cplusplus
 // namespace memory {
};
 // begin timer namespace
	namespace timers {
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
		uint32_t  CriticalSecOwners( PCRITICALSECTION pcs )
		{
			return pcs->dwLocks;
		}
#endif
#ifndef USE_NATIVE_CRITICAL_SECTION
//#  ifdef _MSC_VER
//#    pragma optimize( "st", off )
//#  endif
		int32_t  EnterCriticalSecNoWaitEx( PCRITICALSECTION pcs, THREAD_ID *prior DBG_PASS )
		{
			THREAD_ID dwCurProc;
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
#  ifndef NO_LOGGING
			if( g.bLogCritical > 0 && g.bLogCritical < 2 )
				ll__lprintf( DBG_RELAY )(WIDE( "Attempt enter critical Section %") _64fx WIDE( " %" ) _64fx WIDE( " %") _64fx WIDE(" %08" ) _32fx
					, pcs->dwThreadID
					, pcs->dwThreadWaiting
					, (prior?(*prior):-1)
					, pcs->dwLocks);
#  endif
#endif
			// need to aquire lock on section...
			// otherwise our old mechanism allowed an enter in another thread
			// to falsely identify the section as its own while the real owner
			// tried to exit...
			if( XCHG( &pcs->dwUpdating, 1 ) )
				return -1;
#ifdef USE_CUSTOM_ALLOCER
			dwCurProc = _GetMyThreadID();
#else
			dwCurProc = GetMyThreadID();
#endif
			if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
			{
				// section is unowned...
				if( pcs->dwThreadWaiting )
				{
					// someone was waiting for it...
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( prior ) {
							if( !(*prior) ) {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll__lprintf( DBG_RELAY )(WIDE( "waiter is not myself... this is more recent than him... claim now. %" ) _64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
								// this would stack me on top anyway so just allow the waitier to keep waiting....
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
								pcs->pFile[pcs->nPrior] = pFile;
								pcs->nLine[pcs->nPrior] = nLine;
#  else
								pcs->pFile[pcs->nPrior] = __FILE__;
								pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
								pcs->nLineCS[pcs->nPrior] = __LINE__;
								pcs->isLock[pcs->nPrior] = 1;
								pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
								pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
							}
							else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll__lprintf( DBG_RELAY )(WIDE( "waiter is not myself... AND am in stack of waiter. %" ) _64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
								// prior is set, so someone has set their prior to me....
								pcs->dwUpdating = 0;
								return 0;
							}
						}
						else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
							ll__lprintf( DBG_RELAY )(WIDE( "Waiter which is quick-wait does not sleep; claiming section... %" ) _64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, prior ? (*prior) : -1LL, pcs->dwThreadID);
#endif
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
							pcs->pFile[pcs->nPrior] = pFile;
							pcs->nLine[pcs->nPrior] = nLine;
#  else
							pcs->pFile[pcs->nPrior] = __FILE__;
							pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
							pcs->nLineCS[pcs->nPrior] = __LINE__;
							pcs->isLock[pcs->nPrior] = 1;
							pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
							pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
						}
					}
 //  waiting is me
					else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						ll_lprintf( WIDE( "@@@ Woke up after waiting, set prior waiter as next waiter... %" ) _64fx, prior ? (*prior) : -1LL );
#endif
						if( prior && (*prior) ) {
							if( (*prior) == 1 ) {
								pcs->dwThreadWaiting = 0;
							}
							else
								pcs->dwThreadWaiting = (*prior);
							(*prior) = 0;
						}
						else
							pcs->dwThreadWaiting = 0;
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 1;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
					}
				}
				else {
					if( prior && *prior ) {
						// shouldn't happen, if there's no waiter set, then there shouldn't be a prior.
						DebugBreak();
					}
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
					ll_lprintf( WIDE( "Claimed critical section." ) );
#endif
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
					pcs->pFile[pcs->nPrior] = pFile;
					pcs->nLine[pcs->nPrior] = nLine;
#  else
					pcs->pFile[pcs->nPrior] = __FILE__;
					pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
					pcs->nLineCS[pcs->nPrior] = __LINE__;
					pcs->isLock[pcs->nPrior] = 1;
					pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
					pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				}
 // claim the section and return success
				pcs->dwThreadID = dwCurProc;
				pcs->dwLocks = 1;
				pcs->dwUpdating = 0;
				return 1;
			}
			else if( dwCurProc == pcs->dwThreadID )
			{
				// otherwise 1) I won the thread already... (threadID == me )
				pcs->dwLocks++;
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifndef NO_LOGGING
#    ifdef LOG_DEBUG_CRITICAL_SECTIONS
				if( g.bLogCritical > 0 && g.bLogCritical < 2 )
					ll_lprintf( WIDE( "Locks are %08" )_32fx, pcs->dwLocks );
#    endif
				if( (pcs->dwLocks & 0xFFFFF) > 1 )
				{
#    ifdef LOG_DEBUG_CRITICAL_SECTIONS
					if( g.bLogCritical > 0 && g.bLogCritical < 2 )
						_xlprintf( 1 DBG_RELAY )(WIDE( "!!!!  %p  Multiple Double entry! %" )_32fx, pcs, pcs->dwLocks);
#    endif
				}
#  endif
#  ifdef _DEBUG
				pcs->pFile[pcs->nPrior] = pFile;
				pcs->nLine[pcs->nPrior] = nLine;
#  else
				pcs->pFile[pcs->nPrior] = __FILE__;
				pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
				pcs->nLineCS[pcs->nPrior] = __LINE__;
				pcs->isLock[pcs->nPrior] = 1;
				pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
				pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
				pcs->dwUpdating = 0;
				return 1;
			}
			//if( !(AND_SECTION_LOGGED_WAIT(pcs->dwLocks)) )
			{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
				pcs->dwLocks |= SECTION_LOGGED_WAIT;
				if( g.bLogCritical )
					ll_lprintf( WIDE( "Waiting on critical section owned by %s(%d) %08lx %." ) _64fx, (pcs->pFile) ? (pcs->pFile) : WIDE( "Unknown" ), pcs->nLine, pcs->dwLocks, pcs->dwThreadID );
#endif
			}
			// if the prior is wanted to be saved...
			if( prior )
			{
				if( *prior )
				{
					if( pcs->dwThreadWaiting != dwCurProc )
					{
						if( !pcs->dwThreadWaiting ) {
							ll_lprintf( WIDE( "@@@ Someone stole the critical section that we were wiating on before we reentered. fail. %" )_64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
							DebugBreak();
							// go back to sleep again.
							pcs->dwThreadWaiting = dwCurProc;
						}
						else {
							if( (*prior) == pcs->dwThreadWaiting ) {
								ll_lprintf( WIDE( "prior is thread wiaiting (normal?!) %" )_64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, *prior );
								DebugBreak();
								(*prior) = 0;
							}
							else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
								ll_lprintf( WIDE( "Someone stole the critical section that we were wiating on before we reentered. fail. %" )_64fx WIDE( " %" ) _64fx WIDE( " %" ) _64fx, pcs->dwThreadWaiting, dwCurProc, *prior );
#endif
							}
						}
						// assume that someone else kept our waiting ID...
						// cause we're not the one waiting, and we have someone elses ID..
						// we are awake out of order..
						pcs->dwUpdating = 0;
						return 0;
					}
					else {
						// waiting is the current threadproc; but someone claimed the section ahead of this.
					}
				}
				else if( pcs->dwThreadWaiting != dwCurProc )
				{
					if( pcs->dwThreadWaiting ) {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						if( g.bLogCritical )
							ll_lprintf( WIDE( "@@@ Setting prior to % " ) _64fx WIDE( " and prior was %" ) _64fx, pcs->dwThreadWaiting, (*prior) );
#endif
						*prior = pcs->dwThreadWaiting;
					}
					else {
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						if( g.bLogCritical )
							ll_lprintf( WIDE( "@@@ Setting prior to % " ) _64fx WIDE( " and prior was %" ) _64fx, pcs->dwThreadWaiting, (*prior) );
#endif
						*prior = 1;
					}
					pcs->dwThreadWaiting = dwCurProc;
				}
			}
			else
			{
				// else no prior... so don't set the dwthreadwaiting...
			}
			pcs->dwUpdating = 0;
			return 0;
		}
#endif
		//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
//#  ifdef _MSC_VER
//#    pragma optimize( "st", off )
//#  endif
		static LOGICAL LeaveCriticalSecNoWakeEx( PCRITICALSECTION pcs DBG_PASS )
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSecNoWakeEx( pcs DBG_SRC )
		{
			THREAD_ID dwCurProc;
			while( XCHG( &pcs->dwUpdating, 1 ) )
				Relinquish();
#ifdef USE_CUSTOM_ALLOCER
			dwCurProc = _GetMyThreadID();
#else
			dwCurProc = GetMyThreadID();
#endif
#  ifdef LOG_DEBUG_CRITICAL_SECTIONS
#    ifndef NO_LOGGING
			if( g.bLogCritical > 0 && g.bLogCritical < 2 )
				ll__lprintf( DBG_RELAY )(WIDE( "Locked %p for leaving..." ), pcs);
#    endif
#  endif
			if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
			{
				if( g.bLogCritical > 0 && g.bLogCritical < 2 )
					ll_lprintf( DBG_FILELINEFMT WIDE( "Leaving a blank critical section" ) DBG_RELAY );
				DebugBreak();
				//while( 1 );
				pcs->dwUpdating = 0;
				return FALSE;
			}
#ifdef DEBUG_CRITICAL_SECTIONS
			//if( g.bLogCritical > 1 )
			// ll_lprintf( DBG_FILELINEFMT WIDE( "Leaving %"_64fx"x %"_64fx"x %p" ) DBG_RELAY ,pcs->dwThreadID, dwCurProc, pcs );
#endif
			if( pcs->dwThreadID == dwCurProc )
			{
				pcs->dwLocks--;
				if( AND_SECTION_LOGGED_WAIT(pcs->dwLocks) )
				{
					if( !AND_NOT_SECTION_LOGGED_WAIT(pcs->dwLocks) )
					{
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 0;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
						pcs->dwLocks = 0;
#endif
						pcs->dwThreadID = 0;
						pcs->dwUpdating = 0;
 // allow whoever was waiting to go now...
						Relinquish();
						return TRUE;
					}
				}
				else
				{
					if( !pcs->dwLocks ) {
#ifdef DEBUG_CRITICAL_SECTIONS
#  ifdef _DEBUG
						pcs->pFile[pcs->nPrior] = pFile;
						pcs->nLine[pcs->nPrior] = nLine;
#  else
						pcs->pFile[pcs->nPrior] = __FILE__;
						pcs->nLine[pcs->nPrior] = __LINE__;
#  endif
						pcs->nLineCS[pcs->nPrior] = __LINE__;
						pcs->isLock[pcs->nPrior] = 1;
						pcs->dwThreadPrior[pcs->nPrior] = dwCurProc;
						pcs->nPrior = (pcs->nPrior + 1) % MAX_SECTION_LOG_QUEUE;
#endif
						pcs->dwThreadID = 0;
					}
				}
				// don't wake the prior (if there is one sleeping)
				// pcs->dwThreadID = 0;
			}
			else
			{
#ifdef DEBUG_CRITICAL_SECTIONS
				{
					_xlprintf( 0 DBG_RELAY )(WIDE( "Sorry - you can't leave a section owned by %") _64fx WIDE(" %08lx %s(%d)..." )
						, pcs->dwThreadID
						, pcs->dwLocks
						, (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) ? (pcs->pFile[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]) : WIDE( "Unknown" ), pcs->nLine[(pcs->nPrior + 15) % MAX_SECTION_LOG_QUEUE]);
					DebugBreak();
				}
#else
				lprintf( WIDE( "Sorry - you can't leave a section you don't own..." ) );
				DebugBreak();
#endif
				pcs->dwUpdating = 0;
				return FALSE;
			}
			// allow other locking threads immediate access to section
			// but I know when that happens - since the waiting process
			// will flag - SECTION_LOGGED_WAIT
			pcs->dwUpdating = 0;
			return TRUE;
		}
#else
#define LeaveCriticalSecNoWake(pcs) LeaveCriticalSection(pcs)
#endif
//-------------------------------------------------------------------------
#ifndef USE_NATIVE_CRITICAL_SECTION
		void  InitializeCriticalSec( PCRITICALSECTION pcs )
		{
			memset( pcs, 0, sizeof( CRITICALSECTION ) );
			return;
		}
#endif
#ifdef __cplusplus
 // namespace timers {
	};
 // resume memory namespace
	namespace memory {
#endif
//-------------------------------------------------------------------------
#ifdef _DEBUG
 // last values from getmemstats...
static uint32_t dwBlocks;
static uint32_t dwFreeBlocks;
static uint32_t dwAllocated;
static uint32_t dwFree;
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
static void DoCloseSpace( PSPACE ps, int bFinal );
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
LOGICAL OpenRootMemory()
{
	uintptr_t size = sizeof( SPACEPOOL );
	uint32_t created;
	TEXTCHAR spacename[32];
	if( g.pSpacePool != NULL )
	{
		// if local already has something, just return.
		return FALSE;
	}
#ifdef DEBUG_GLOBAL_REGISTRATION
	ll_lprintf( WIDE( "Opening space..." ) );
#endif
#ifdef WIN32
	tnprintf( spacename, sizeof( spacename ), WIDE( "memory:%" ) _32fx, GetCurrentProcessId() );
#else
	tnprintf( spacename, sizeof( spacename ), WIDE( "memory:%08X" ), getpid() );
#  ifdef DEBUG_FIRST_UNICODE_OPERATION
	{
		wchar_t buf[32];
		strcpy( (char*)buf, "abcdefghijklmn" );
		swprintf( buf, 32, L"%s", L"some_name" );
		{
			char tmpmsg[256];
			int chars;
			int ofs = 0;
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%02x ", ((char*)buf)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (buf)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (name)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
			ofs = snprintf( tmpmsg, 256, "in the beginning(w):" );
			for( chars = 0; chars < 32; chars++ )
				ofs += snprintf( tmpmsg + ofs, 256 - ofs, "%c", (spacename)[chars] );
			__android_log_print( ANDROID_LOG_INFO, "org.d3x0r.sack.xxxx", tmpmsg );
		}
	}
#  endif
#endif
	// hmm application only shared space?
	// how do I get that to happen?
	 g.pSpacePool = (PSPACEPOOL)OpenSpaceExx( spacename, NULL, 0, &size, &created );
	// I myself must have a global space, which is kept sepearte from named spaces
	// but then... blah
	return created;
}
#endif
// hmm this runs
PRIORITY_ATEXIT(ReleaseAllMemory,ATEXIT_PRIORITY_SHAREMEM)
{
#if defined( __SKIP_RELEASE_OPEN_SPACES__ ) || defined( __NO_MMAP__ )
	// actually, under linux, it releases /tmp/.shared files.
	//ll_lprintf( WIDE( "No super significant reason to release all memory blocks?" ) );
	//ll_lprintf( WIDE( "Short circuit on memory shutdown." ) );
	return;
#else
	// need to try and close /tmp/.shared region files...  so we only close
	// temporary spaces
	PSPACEPOOL psp;
	PSPACE ps;
	while( ( psp = g.pSpacePool ) )
	{
		int i;
		// I didn't allocate at the root; someone else is responsible.
		if( psp->me != &g.pSpacePool )
			break;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			ps = psp->spaces + i;
			if( ps->pMem )
			{
				/*
				* if we do this, then logging will attempt to possibly use memory which was allocated from this?
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					ll_lprintf( WIDE("Space: %p mem: %p-%p"), ps, ps->pMem, (uint8_t*)ps->pMem + ps->dwSmallSize );
					ll_lprintf( WIDE("Closing tracked space...") );
				}
#endif
*/
#ifndef _WIN32
				if( ps->flags.bTemporary )
#endif
					DoCloseSpace( ps, TRUE );
			}
		}
		if( !(*psp->me) )
			break;
		if( ( (*psp->me) = psp->next ) )
			psp->next->me = psp->me;
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		//ll_lprintf( WIDE("unmaping space tracking structure...") );
		munmap( ps, MAX_PER_BLOCK * sizeof( SPACE ) );
		//close( (int)ps->pMem );
		//if( ps->hFile >= 0 )
		//	close( ps->hFile );
#endif
	}
#endif
	g.bInit = FALSE;
}
//------------------------------------------------------------------------------------------------------
void InitSharedMemory( void )
{
#ifndef __NO_MMAP__
	if( !g.bInit )
	{
	// this would be really slick to do
	// especially in the case where files have been used
	// to back storage...
	// so please do make releaseallmemory smarter and dlea
	// only with closing those regions which have a file
		// backing, espcecially those that are temporary chickens.
		//atexit( ReleaseAllMemory );
#ifdef _WIN32
		GetSystemInfo( &g.si );
#else
		g.pagesize = sysconf(_SC_PAGESIZE);
#endif
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( WIDE("CHUNK: %d  MEM:%d"), CHUNK_SIZE(0), MEM_SIZE );
#endif
  // onload was definatly a zero.
		g.bInit = TRUE;
		{
			if( OpenRootMemory() )
			{
				MemSet( g.pSpacePool, 0, sizeof( SPACEPOOL ) );
				g.pSpacePool->me = &g.pSpacePool;
#ifdef VERBOSE_LOGGING
				if( !g.bDisableDebug )
					Log1( WIDE("Allocated Space pool %lu"), dwSize );
#endif
			}
		}
	}
	else
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			ODS( WIDE("already initialized?") );
#endif
	}
#endif
}
//------------------------------------------------------------------------------------------------------
// private
#ifndef __NO_MMAP__
static PSPACE AddSpace( PSPACE pAddAfter
#if defined( WIN32 ) || defined( __CYGWIN__ )
							, HANDLE hFile
							, HANDLE hMem
#else
							, int hFile
							, int hMem
#endif
							, POINTER pMem, uintptr_t dwSize, int bLink )
{
	PSPACEPOOL psp;
	PSPACEPOOL _psp = NULL;
	PSPACE ps;
	int i;
	if( !g.pSpacePool || g.InAdding )
	{
#ifdef VERBOSE_LOGGING
		if( !g.bDisableDebug )
			Log2( WIDE("No space pool(%p) or InAdding(%d)"), g.pSpacePool, g.InAdding );
#endif
		return NULL;
	}
	g.InAdding = 1;
	//_ps = NULL;
	psp = g.pSpacePool;
Retry:
	do {
		ps = psp->spaces;
		for( i = 0; i < (((int)(MAX_PER_BLOCK))-1); i++ )
		{
			if( !ps[i].pMem )
			{
				ps += i;
				break;
			}
		}
		if( i == (MAX_PER_BLOCK-1) )
		{
			_psp = psp;
			psp = psp->next;
		}
		else
			break;
	} while( psp );
	if( !psp )
	{
		//DebugBreak(); // examine conditions for allocating new space block...
		dwSize = sizeof( SPACEPOOL );
		if( _psp )
		{
			psp = _psp->next = (PSPACEPOOL)OpenSpace( NULL, NULL, &dwSize );
			MemSet( psp, 0, dwSize );
			psp->me = &_psp->next;
		}
		goto Retry;
	}
	//Log7( WIDE("Managing space (s)%p (pm)%p (hf)%08") _32fx WIDE(" (hm)%08") _32fx WIDE(" (sz)%") _32f WIDE(" %08") _32fx WIDE("-%08") _32fx WIDE("")
	//				, ps, pMem, (uint32_t)hFile, (uint32_t)hMem, dwSize
	//				, (uint32_t)pMem, ((uint32_t)pMem + dwSize)
	//				);
	ps->pMem = (PMEM)pMem;
	// okay yes I made this line ugly.
	ps->hFile =
#ifdef _WIN32
					(HANDLE)
#endif
								hFile;
#ifdef _WIN32
	ps->hMem = hMem;
#endif
	ps->dwSmallSize = dwSize;
	/*
	if( bLink )
	{
		while( AddAfter && AddAfter->next )
			AddAfter = AddAfter->next;
		//Log2( WIDE("Linked into space...%p after %p "), ps, AddAfter );
		if( AddAfter )
		{
			ps->me = &AddAfter->next;
			AddAfter->next = ps;
		}
		  ps->next = NULL;
	}
	*/
	g.InAdding = 0;
	return ps;
}
//------------------------------------------------------------------------------------------------------
PSPACE FindSpace( POINTER pMem )
{
	PSPACEPOOL psp;
	INDEX idx;
	for( psp = g.pSpacePool;psp; psp = psp->next)
		for( idx = 0; idx < MAX_PER_BLOCK; idx++ )
			if( psp->spaces[idx].pMem == pMem )
				return psp->spaces + idx;
	return NULL;
}
//------------------------------------------------------------------------------------------------------
static void DoCloseSpace( PSPACE ps, int bFinal )
{
	if( ps )
	{
		//Log( WIDE("Closing a space...") );
#ifdef _WIN32
		UnmapViewOfFile( ps->pMem );
		CloseHandle( ps->hMem );
		CloseHandle( ps->hFile );
#else
		munmap( ps->pMem, ps->dwSmallSize );
		if( ps->flags.bTemporary && (ps->hFile >= 0) )
		{
			if( bFinal )
			{
				char file[256];
				char fdname[64];
				snprintf( fdname, sizeof(fdname), "/proc/self/fd/%d", (int)ps->hFile );
				file[readlink( fdname, file, sizeof( file ) )] = 0;
				remove( file );
			}
			close( (int)ps->hFile );
		}
#endif
		MemSet( ps, 0, sizeof( SPACE ) );
	}
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpaceEx ( POINTER pMem, int bFinal )
{
	DoCloseSpace( FindSpace( pMem ), bFinal );
}
//------------------------------------------------------------------------------------------------------
 void  CloseSpace ( POINTER pMem )
{
	DoCloseSpace( FindSpace( pMem ), TRUE );
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  GetSpaceSize ( POINTER pMem )
{
	PSPACE ps;
	ps = FindSpace( pMem );
	if( ps )
		return ps->dwSmallSize;
	return 0;
}
#endif
#if defined( __LINUX__ ) && !defined( __CYGWIN__ )
uintptr_t GetFileSize( int fd )
{
	uintptr_t len = lseek( fd, 0, SEEK_END );
	lseek( fd, 0, SEEK_SET );
	return len;
}
#endif
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
 POINTER  OpenSpaceExx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize, uint32_t* bCreated )
{
	POINTER pMem = NULL;
#ifdef USE_SIMPLE_LOCK_ON_OPEN
	static uint32_t bOpening;
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	static CRITICALSECTION cs;
	static int first = 1;
#endif
	int readonly = FALSE;
	if( !g.bInit )
	{
		//ODS( WIDE("Doing Init") );
		InitSharedMemory();
	}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		if( first )
		{
			InitializeCriticalSection( &cs );
			first = 0;
		}
		while( !EnterCriticalSecNoWait( &cs, NULL ) )
			Relinquish();
	}
#else
	while( XCHG( &bOpening, 1 ) )
		Relinquish();
#endif
	{
#ifdef __LINUX__
		char *filename = NULL;
		int fd = -1;
		int bTemp = FALSE;
		int exists = FALSE;
		if( !pWhat && !pWhere)
		{
			pMem = mmap( 0, *dwSize
						 , PROT_READ|PROT_WRITE
						 , MAP_SHARED|MAP_ANONYMOUS
						 ,
#ifdef __QNX__
  // QNX Note; NOFD = -1
							NOFD
 // other systems were quite happy to have a 0 here for the handle.
#else
							0
#endif
						  , 0 );
			if( pMem == (POINTER)-1 )
			{
				ll_lprintf( WIDE("Something bad about this region sized %") _PTRSZVALfs WIDE("(%d)"), *dwSize, errno );
				DebugBreak();
			}
			//ll_lprintf( WIDE("Clearing anonymous mmap %p %") _size_f WIDE(""), pMem, *dwSize );
			MemSet( pMem, 0, *dwSize );
		}
 // name doesn't matter, same file cannot be called another name
		else if( pWhere )
		{
			filename = (char*)pWhere;
		 }
		else if( pWhat )
		{
			int len;
         char tmpbuf[256];
#ifdef __ANDROID__
			//if( !IsPath( "./tmp" ) )
			//	if( !MakePath( "./tmp" ) )
			//		ll_lprintf( "Failed to create a temporary space" );
			filename = tmpbuf;
			snprintf( tmpbuf, 256, "./tmp.shared.%s", pWhat );
#else
			filename = tmpbuf;
			snprintf( tmpbuf, 256, WIDE("/tmp/.shared.%s"), pWhat );
#endif
			bTemp = TRUE;
		}
		//ll_lprintf( "Open Space: %s", filename?filename:"anonymous" );
		if( !pMem && filename )
		{
#ifdef __ANDROID__
			//fd = ashmem_create_region( filename , size );
			if( pWhat )
			{
				fd = open(filename, O_RDWR);
				if (fd < 0 )
				{
					int ret;
					if( !(*dwSize ) )
					{
						ll_lprintf( WIDE("Region didn't exist... and no size... return") );
						return NULL;
					}
#   ifdef DEBUG_SHARED_REGION_CREATE
					ll_lprintf( WIDE("Shared region didn't already exist...: %s"), filename );
#   endif
					fd = open("/dev/ashmem", O_RDWR);
					if( fd < 0 )
					{
						ll_lprintf( WIDE("Failed to open core device...") );
						return NULL;
					}
					if( bCreated )
						(*bCreated) = 1;
 // skip 11 for the "/dev/ashmem/"
					ret = ioctl(fd, ASHMEM_SET_NAME, filename + 12 );
					if (ret < 0)
					{
						ll_lprintf( WIDE("Failed to set the name of ashmem region: %s"), filename + 12 );
						//							goto error;
					}
					ret = ioctl(fd, ASHMEM_SET_SIZE, (*dwSize) );
					if (ret < 0)
					{
						ll_lprintf( WIDE("Failed to set IOCTL size to %d"), (*dwSize) );
						//goto error;
					}
					/*
					 {
						// unpin; pages will be pined to start (I think)
						struct ashmem_pin pin = {
							.offset = 0,
							.len    = (*dwSize)
						};
						ret = ioctl(fd, ASHMEM_UNPIN, &pin);
					}
					*/
				}
				else
				{
					if( bCreated )
						(*bCreated) = 1;
				}
			}
			else
#endif
			{
				mode_t prior;
				if( bCreated )
					(*bCreated) = 1;
				prior = umask( 0 );
				fd = open( filename, O_RDWR|O_CREAT|O_EXCL, 0600 );
				umask(prior);
			}
			if( fd == -1 )
			{
				//ll_lprintf( "open is %d %s %d", errno, filename, prior );
				// if we didn't create the file...
				// then it can't be marked as temporary...
				bTemp = FALSE;
				if( GetLastError() == EEXIST )
				{
					exists = TRUE;
					fd = open( filename, O_RDWR );
					bTemp = FALSE;
					if( bCreated )
						(*bCreated) = 0;
				}
				if( fd == -1 )
				{
					readonly = TRUE;
					fd = open( filename, O_RDONLY );
				}
				if( fd == -1 )
				{
					Log2( WIDE("Sorry - failed to open: %d %s")
						, errno
						, filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
			}
			if( exists )
			{
				if( GetFileSize( fd ) < (uintptr_t)*dwSize )
				{
					// expands the file...
					ftruncate( fd, *dwSize );
					//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				}
				else
				{
					// expands the size requested to that of the file...
					(*dwSize) = GetFileSize( fd );
				}
			}
			else
			{
				if( !*dwSize )
				{
					// can't create a 0 sized file this way.
 // not zero.
					(*dwSize) = 1;
					close( fd );
					unlink( filename );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = FALSE;
#endif
					//if(filename)Release( filename );
					return NULL;
				}
				//*dwSize = ( ( *dwSize + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
				ftruncate( fd, *dwSize );
			}
			pMem = mmap( 0, *dwSize
			          , PROT_READ|(readonly?(0):PROT_WRITE)
			          , MAP_SHARED|((fd<0)?MAP_ANONYMOUS:0)
			          , fd, 0 );
			if( !exists && pMem )
			{
				MemSet( pMem, 0, *dwSize );
			}
		}
		if( pMem )
		{
			PSPACE ps = AddSpace( NULL, fd, 0, pMem, *dwSize, TRUE );
			if( ps )
				ps->flags.bTemporary = bTemp;
		}
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = FALSE;
#endif
		//if(filename)Release( filename );
		return pMem;
#elif defined( _WIN32 )
#ifndef UNDER_CE
		LOGICAL didCreate = FALSE;
		HANDLE hFile;
		HANDLE hMem = NULL;
		*dwSize = ( ( (*dwSize) + ( FILE_GRAN - 1 ) ) / FILE_GRAN ) * FILE_GRAN;
		if( !pWhat && !pWhere )
		{
			//ll_lprintf( "ALLOCATE %"_64fx"d", (*dwSize)>>32, 0 );
			hMem = CreateFileMapping( INVALID_HANDLE_VALUE, NULL
											, PAGE_READWRITE
											|SEC_COMMIT
#if __64__
 // dwSize is sometimes 64 bit... this should be harmless
											, (*dwSize)>>32
											, (*dwSize) & (0xFFFFFFFF)
#else
											, 0
											, (*dwSize)
#endif
 // which should be NULL... but is consistant
											, pWhat );
			if( !hMem )
			{
				//ll_lprintf( "Failed to allocate pagefile memory?! %p %d", *dwSize, GetLastError() );
				{
					POINTER p = malloc( *dwSize );
					//ll_lprintf(" but we could allocate it %p", p  );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return p;
				}
			}
			else
			{
			// created and this size is right...
				if( bCreated )
					(*bCreated) = TRUE;
			}
		}
		else if( pWhat )
		{
			hMem = OpenFileMapping( FILE_MAP_READ|FILE_MAP_WRITE
										, FALSE
										, pWhat );
			if( hMem )
			{
				if( bCreated )
					(*bCreated) = FALSE;
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Failed to open region named %s %d"), pWhat, GetLastError() );
#endif
  // don't continue... we're expecting open-existing behavior
				if( (*dwSize) == 0 )
				{
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return FALSE;
				}
			}
		}
		hFile = INVALID_HANDLE_VALUE;
		// I would have hmem here if the file was validly opened....
		if( !hMem )
		{
			hFile = CreateFile( pWhere, GENERIC_READ|GENERIC_WRITE
									,FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE
 // default security
									,NULL
									,(dwSize&&(*dwSize)) ? OPEN_ALWAYS : OPEN_EXISTING
 //|FILE_ATTRIBUTE_TEMPORARY
									,FILE_ATTRIBUTE_NORMAL
									//| FILE_FLAG_WRITE_THROUGH
									//| FILE_FLAG_NO_BUFFERING
									// must access on sector bournds
									// must read complete sectors
									//| FILE_FLAG_DELETE_ON_CLOSE
									, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( WIDE("Create file %s result %d"), pWhere, hFile );
			ll_lprintf( WIDE("File result is %ld (error %ld)"), hFile, GetLastError() );
#endif
			if( hFile == INVALID_HANDLE_VALUE )
			{
				readonly = 1;
				if( ( dwSize && (!(*dwSize )) ) && ( GetLastError() == ERROR_PATH_NOT_FOUND || GetLastError() == ERROR_FILE_NOT_FOUND ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( WIDE("File did not exist, and we're not creating the file (0 size passed)") );
#endif
#ifndef USE_SIMPLE_LOCK_ON_OPEN
					if( g.deadstart_finished )
					{
						LeaveCriticalSecNoWake( &cs );
					}
#else
					bOpening = 0;
#endif
					return NULL;
				}
				hFile = CreateFile( pWhere, GENERIC_READ
										,FILE_SHARE_READ|FILE_SHARE_DELETE
 // default security
										,NULL
										,OPEN_ALWAYS
 //|FILE_ATTRIBUTE_TEMPORARY
										,FILE_ATTRIBUTE_NORMAL
										//| FILE_FLAG_WRITE_THROUGH
										//| FILE_FLAG_NO_BUFFERING
										// must access on sector bournds
										// must read complete sectors
										//| FILE_FLAG_DELETE_ON_CLOSE
										, NULL );
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Create file %s result %d"), pWhere, hFile );
#endif
				if( hFile != INVALID_HANDLE_VALUE ) {
 // lie...
					SetLastError( ERROR_ALREADY_EXISTS );
				}
			}
			else {
 // lie...
				SetLastError( ERROR_ALREADY_EXISTS );
			}
			if( hFile == INVALID_HANDLE_VALUE )
			{
				// might still be able to open it by shared name; even if the file share is disabled
				readonly = 0;
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("file is still invalid(alreadyexist?)... new size is %d %d on %p"), (*dwSize), FILE_GRAN, hFile );
#endif
 // is INVALID_HANDLE_VALUE, but is consistant
				hMem = CreateFileMapping( hFile
												, NULL
												, (readonly?PAGE_READONLY:PAGE_READWRITE)
												/*|SEC_COMMIT|SEC_NOCACHE*/
#ifdef __64__
												, (uint32_t)((*dwSize)>>32)
#else
												, 0
#endif
												, (uint32_t)(*dwSize)
												, pWhat );
				if( hMem )
				{
					if( bCreated )
						(*bCreated) = 1;
					goto isokay;
				}
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Sorry - Nothing good can happen with a filename like that...%s %d"), pWhat, GetLastError());
#endif
					 //bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
			if( GetLastError() == ERROR_ALREADY_EXISTS )
			{
				LARGE_INTEGER lSize;
				GetFileSizeEx( hFile, &lSize );
			// mark status for memory... dunno why?
				// in theory this is a memory image of valid memory already...
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Getting existing size of region...") );
#endif
				if( SUS_LT( lSize.QuadPart, LONGLONG, (*dwSize), uintptr_t ) )
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( WIDE("Expanding file to size requested.") );
#endif
					didCreate = 1;
					SetFilePointer( hFile, (LONG)*dwSize, NULL, FILE_BEGIN );
					SetEndOfFile( hFile );
				}
				else
				{
#ifdef DEBUG_OPEN_SPACE
					ll_lprintf( WIDE("Setting size to size of file (which was larger..") );
#endif
					(*dwSize) = (uintptr_t)(lSize.QuadPart);
				}
			}
			else
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("New file, setting size to requested %d"), *dwSize );
#endif
				SetFilePointer( hFile, (LONG)*dwSize, NULL, FILE_BEGIN );
				SetEndOfFile( hFile );
				didCreate = 1;
			}
			if( bCreated )
				(*bCreated) = didCreate;
			//(*dwSize) = GetFileSize( hFile, NULL );
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( WIDE("%s Readonly? %d  hFile %d"), pWhat, readonly, hFile );
#endif
			hMem = CreateFileMapping( hFile
											, NULL
											, (readonly?PAGE_READONLY:PAGE_READWRITE)
											/*|SEC_COMMIT|SEC_NOCACHE*/
											, 0, 0
											, pWhat );
			if( pWhat && !hMem )
			{
#ifdef DEBUG_OPEN_SPACE
				ll_lprintf( WIDE("Create of mapping failed on object specified? %d %p"), GetLastError(), hFile );
#endif
				(*dwSize) = 1;
				CloseHandle( hFile );
				//bOpening = FALSE;
#ifndef USE_SIMPLE_LOCK_ON_OPEN
				if( g.deadstart_finished )
				{
					LeaveCriticalSecNoWake( &cs );
				}
#else
				bOpening = 0;
#endif
				return NULL;
			}
		}
	isokay:
      /*
		if( !hMem )
		{
			pMem = VirtualAlloc( address, (*dwSize), 0 ,PAGE_READWRITE );
			if( !VirtualLock( pMem, (*dwSize ) ) )
            DebugBreak();
		}
		else
      */
		{
			pMem = MapViewOfFileEx( hMem
										, FILE_MAP_READ| ((readonly)?(0):(FILE_MAP_WRITE))
  // offset high, low
										, 0, 0
	 // size of file to map
										, 0
 // don't specify load location... irrelavent...
										, (POINTER)address );
		}
	if( !pMem )
	{
#ifdef DEBUG_OPEN_SPACE
		Log1( WIDE("Create view of file for memory access failed at %p"), (POINTER)address );
#endif
		CloseHandle( hMem );
		if( hFile != INVALID_HANDLE_VALUE )
			CloseHandle( hFile );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
		if( g.deadstart_finished )
		{
			LeaveCriticalSecNoWake( &cs );
		}
#else
		bOpening = 0;
#endif
		return NULL;
	}
	else
	{
		if( bCreated && !(*bCreated) && ((*dwSize) == 0) )
		{
			MEMORY_BASIC_INFORMATION meminfo;
			VirtualQuery( pMem, &meminfo, sizeof( meminfo ) );
			(*dwSize) = meminfo.RegionSize;
#ifdef DEBUG_OPEN_SPACE
			ll_lprintf( WIDE("Fixup memory size to %ld %s:%s(reported by system on view opened)")
					, *dwSize, pWhat?pWhat:"ANON", pWhere?pWhere:"ANON" );
#endif
		}
	}
	// store information about this
	// external to the space - do NOT
	// modify content of memory opened!
	AddSpace( NULL, hFile, hMem, pMem, *dwSize, TRUE );
#ifndef USE_SIMPLE_LOCK_ON_OPEN
	if( g.deadstart_finished )
	{
		LeaveCriticalSecNoWake( &cs );
	}
#else
      bOpening = 0;
#endif
	return pMem;
#else
	if( bCreated )
		(*bCreated) = 1;
	return malloc( *dwSize );
#endif
#endif
	}
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpaceEx
 POINTER  OpenSpaceEx ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t address, uintptr_t *dwSize )
{
	uint32_t bCreated;
	return OpenSpaceExx( pWhat, pWhere, address, dwSize, &bCreated );
}
//------------------------------------------------------------------------------------------------------
#undef OpenSpace
 POINTER  OpenSpace ( CTEXTSTR pWhat, CTEXTSTR pWhere, uintptr_t *dwSize )
{
	return OpenSpaceEx( pWhat, pWhere, 0, dwSize );
}
#endif
//------------------------------------------------------------------------------------------------------
 int  InitHeap( PMEM pMem, uintptr_t dwSize )
{
	//pMem->dwSize = *dwSize - MEM_SIZE;
	// size of the PMEM block is all inclusive (from pMem(0) to pMem(dwSize))
	// do NOT need to substract the size of the tracking header
	// otherwise we would be working from &pMem->pRoot + dwSize
	if( pMem->dwSize )
	{
		if( pMem->dwHeapID != 0xbab1f1ea )
		{
			ll_lprintf( WIDE("Memory has content, and is NOT a heap!") );
			return FALSE;
		}
		ll_lprintf( WIDE("Memory was already initialized as a heap?") );
		return FALSE;
	}
#ifndef __NO_MMAP__
	if( !FindSpace( pMem ) )
	{
		//ll_lprintf( WIDE("space for heap has not been tracked yet....") );
		// a heap must be in the valid space pool.
		// it may not have come from a file, and will not have
		// a file or memory handle.
		AddSpace( NULL, 0, 0, pMem, dwSize, TRUE );
	}
#endif
	// the size passed is the full size of the memory, so we need to remove sizeof(MEM)
	// so there is room to track heap info at the start of the heap.
	dwSize -= sizeof( MEM );
	pMem->dwSize = dwSize;
	pMem->dwHeapID = 0xbab1f1ea;
	pMem->pFirstFree = NULL;
	pMem->dwFlags = 0;
	LinkThing( pMem->pFirstFree, pMem->pRoot );
	InitializeCriticalSec( &pMem->cs );
	pMem->pRoot[0].dwSize = dwSize - MEM_SIZE - CHUNK_SIZE;
	pMem->pRoot[0].dwPad = MAGIC_SIZE;
	pMem->pRoot[0].dwOwners = 0;
	pMem->pRoot[0].pRoot  = pMem;
	pMem->pRoot[0].pPrior = NULL;
#ifdef _DEBUG
	if( !g.bDisableDebug )
	{
#ifdef VERBOSE_LOGGING
		ll_lprintf( WIDE("Initializing %p %d")
				, pMem->pRoot[0].byData
				, pMem->pRoot[0].dwSize );
#endif
		MemSet( pMem->pRoot[0].byData, 0x1BADCAFE, pMem->pRoot[0].dwSize );
		BLOCK_TAG( pMem->pRoot ) = BLOCK_TAG_ID;
	}
	{
		pMem->pRoot[0].dwPad += 2*MAGIC_SIZE;
		BLOCK_FILE( pMem->pRoot ) = _WIDE(__FILE__);
		BLOCK_LINE( pMem->pRoot ) = __LINE__;
	}
#endif
	return TRUE;
}
//------------------------------------------------------------------------------------------------------
#ifndef __NO_MMAP__
PMEM DigSpace( TEXTSTR pWhat, TEXTSTR pWhere, uintptr_t *dwSize )
{
	PMEM pMem = (PMEM)OpenSpace( pWhat, pWhere, dwSize );
	if( !pMem )
	{
		// did reference BASE_MEMORY...
		ll_lprintf( WIDE("Create view of file for memory access failed at %p %p"), pWhat, pWhere );
		CloseSpace( (POINTER)pMem );
		return NULL;
	}
#ifdef VERBOSE_LOGGING
	Log( WIDE("Go to init the heap...") );
#endif
	pMem->dwSize = 0;
#if USE_CUSTOM_ALLOCER
	InitHeap( pMem, *dwSize );
#endif
	return pMem;
}
//------------------------------------------------------------------------------------------------------
int ExpandSpace( PMEM pHeap, uintptr_t dwAmount )
{
	PSPACE pspace = FindSpace( (POINTER)pHeap ), pnewspace;
	PMEM pExtend;
	//ll_lprintf( WIDE("Expanding by %d %d"), dwAmount );
	pExtend = DigSpace( NULL, NULL, &dwAmount );
	if( !pExtend )
	{
		ll_lprintf( WIDE("Failed to expand space by %") _PTRSZVALfs, dwAmount );
		return FALSE;
	}
	pnewspace = FindSpace( pExtend );
	if( pnewspace )
	{
		while( pspace && pspace->next )
			pspace = pspace->next;
		if( ( pspace->next = pnewspace ) )
		{
			pnewspace->me = &pspace->next;
		}
	}
	return TRUE;
}
#endif
//------------------------------------------------------------------------------------------------------
static PMEM InitMemory( void ) {
	uintptr_t MinSize = SYSTEM_CAPACITY;
	// generic internal memory, unnamed, unshared, unsaved
#ifndef __NO_MMAP__
	g.pMemInstance = DigSpace( NULL, NULL, &MinSize );
	if( !g.pMemInstance )
	{
		g.bMemInstanced = FALSE;
		ODS( WIDE( "Failed to allocate memory - assuming fatailty at Allocation service level." ) );
		return NULL;
	}
#endif
	return g.pMemInstance;
}
//------------------------------------------------------------------------------------------------------
static PMEM GrabMemEx( PMEM pMem DBG_PASS )
#define GrabMem(m) GrabMemEx( m DBG_SRC )
{
	if( !pMem )
	{
		// use default heap...
		if( !XCHG( &g.bMemInstanced, TRUE ) )
			pMem = InitMemory();
		else
			return 0;
	}
	//ll_lprintf( WIDE("grabbing memory %p"), pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		while( !TryEnterCriticalSection( &pMem->cs ) )
		{
			Relinquish();
		}
#else
		while( EnterCriticalSecNoWaitEx( &pMem->cs, NULL DBG_RELAY ) <= 0 )
		{
			Relinquish();
		}
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
	return pMem;
}
//------------------------------------------------------------------------------------------------------
static void DropMemEx( PMEM pMem DBG_PASS )
#define DropMem(m) DropMemEx( m DBG_SRC)
{
	if( !pMem )
		return;
	//ll_lprintf( WIDE("dropping memory %p"), pMem );
	{
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		int log = g.bLogCritical;
		g.bLogCritical = 0;
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSection( &pMem->cs );
#else
		LeaveCriticalSecNoWakeEx( &pMem->cs DBG_RELAY );
#endif
#ifdef LOG_DEBUG_CRITICAL_SECTIONS
		g.bLogCritical = log;
#endif
	}
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateAlignedEx( PMEM pHeap, uintptr_t dwSize, uint16_t alignment DBG_PASS )
{
   // if a heap is passed, it's a private heap, and allocation is as normal...
	uint32_t dwAlignPad = 0;
	if( alignment ) {
		dwSize += (alignment - 1);
		dwAlignPad = (alignment - 1);
	}
	if( !pHeap && !USE_CUSTOM_ALLOCER )
	{
		PMALLOC_CHUNK pc;
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + alignment + dwSize + sizeof( pc->LeadProtect ) );
		if( !pc )
			DebugBreak();
		MemSet( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) );
		MemSet( pc->byData + dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) );
#else
		pc = (PMALLOC_CHUNK)malloc( sizeof( MALLOC_CHUNK ) - 1 + dwSize );
#endif
		pc->dwOwners = 1;
		pc->dwSize = dwSize;
		pc->dwPad = dwAlignPad;
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate )
		{
			ll__lprintf(DBG_RELAY)( WIDE( "alloc %p(%p) %" ) _PTRSZVALfs, pc, pc->byData, dwSize );
		}
#  endif
#endif
		if( alignment && ( (uintptr_t)pc->byData & ~masks[alignment] ) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]);
			//pc->dwPad = (uint16_t)( dwAlignPad - sizeof(uintptr_t) );
			// to_chunk_start is the last thing in chunk, so it's pre-allocated space
 /*pc->alignemnt = */
			((uint16_t*)(retval - sizeof(uint32_t)))[0] =alignment;
 /*pc->to_chunk_start = */
			((uint16_t*)(retval - sizeof(uint32_t)))[1] =(uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]) - (uintptr_t)pc->byData);
			return (POINTER)retval;
		}
		else {
			pc->alignment = 0;
			pc->to_chunk_start = 0;
			return pc->byData;
		}
	}
#if USE_CUSTOM_ALLOCER
	else
	{
		PHEAP_CHUNK pc;
		PMEM pMem, pCurMem = NULL;
		PSPACE pMemSpace;
		uint32_t dwPad = 0;
		uint32_t dwMin = 0;
		//ll__lprintf(DBG_RELAY)( WIDE( "..." ) );
#ifdef _DEBUG
		if( !g.bDisableAutoCheck )
			GetHeapMemStatsEx(pHeap, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
 // no size is NO space!
		if( !dwSize )
		{
			return NULL;
		}
		// if memstats is used - memory could have been initialized there...
		// so wait til now to grab g.pMemInstance.
		if( !pHeap )
			pHeap = g.pMemInstance;
		pMem = GrabMem( pHeap );
#ifdef __64__
 // fix size to allocate at least _32s which
		dwSize += 7;
		dwSize &= 0xFFFFFFFFFFFFFFF8;
#else
 // fix size to allocate at least _32s which
		dwSize += 3;
		dwSize &= 0xFFFFFFFC;
#endif
#ifdef _DEBUG
		if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
		{
			dwPad += MAGIC_SIZE * 2;
 // pFile, nLine per block...
			dwSize += MAGIC_SIZE * 2;
									  //ll_lprintf( WIDE("Adding 8 bytes to block size...") );
		}
		if( !g.bDisableDebug )
		{
			dwPad += MAGIC_SIZE;
  // add a uint32_t at end to mark, and check for application overflow...
			dwSize += MAGIC_SIZE;
		}
		dwMin = dwPad;
#endif
		// re-search for memory should step long back...
	search_for_free_memory:
		for( pc = NULL, pMemSpace = FindSpace( pMem ); !pc && pMemSpace; pMemSpace = pMemSpace->next )
		{
			// grab the new memory (might be old, is ok)
			GrabMem( (PMEM)pMemSpace->pMem );
			// then drop old memory, don't need that anymore.
 // first time through, there is no current.
			if( pCurMem )
				DropMem( pCurMem );
			// then mark that this block is our current block.
			pCurMem = (PMEM)pMemSpace->pMem;
			//ll_lprintf( WIDE("region %p is now owned."), pCurMem );
			for( pc = pCurMem->pFirstFree; pc; pc = pc->next )
			{
 // if free block size is big enough...
				if( pc->dwSize >= dwSize )
				{
					// split block
 // must allocate it all.
					if( ( pc->dwSize - dwSize ) <= ( dwMin + CHUNK_SIZE + g.nMinAllocateSize ) )
					{
						pc->dwPad = (uint16_t)(dwPad + ( pc->dwSize - dwSize ));
						UnlinkThing( pc );
						pc->dwOwners = 1;
 // successful allocation....
						break;
					}
					else
					{
  // cleared, NEW, uninitialized block...
						PHEAP_CHUNK pNew;
						PHEAP_CHUNK next;
						next = (PHEAP_CHUNK)( pc->byData + pc->dwSize );
						pNew = (PHEAP_CHUNK)(pc->byData + dwSize);
						pNew->dwPad = 0;
						pNew->dwSize = ((pc->dwSize - CHUNK_SIZE) - dwSize);
#ifdef _DEBUG
						if( pNew->dwSize > 0x80000000 )
							DebugBreak();
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							pNew->dwPad += MAGIC_SIZE * 2;
						}
						if( !g.bDisableDebug )
						{
							pNew->dwPad += MAGIC_SIZE;
							BLOCK_TAG( pNew ) = BLOCK_TAG_ID;
						}
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
						{
							BLOCK_FILE( pNew ) = pFile;
							BLOCK_LINE( pNew ) = nLine;
						}
#endif
						pc->dwPad = (uint16_t)dwPad;
 // set old size?  this can wait until we have the block.
						pc->dwSize = dwSize;
						if( pc->dwSize & 0x80000000 )
							DebugBreak();
  // not beyond end of memory...
						if( (uintptr_t)next - (uintptr_t)pCurMem < (uintptr_t)pCurMem->dwSize )
							next->pPrior = pNew;
						pNew->dwOwners = 0;
						pNew->pRoot = pc->pRoot;
						pNew->pPrior = pc;
						// copy link...
						if( ( pNew->next = pc->next ) )
							pNew->next->me = &pNew->next;
						*( pNew->me = pc->me ) = pNew;
  // set owned block.
						pc->dwOwners = 1;
 // successful allocation....
						break;
					}
				}
			}
		}
		if( !pc )
		{
			if( dwSize < SYSTEM_CAPACITY )
			{
				if( ExpandSpace( pMem, SYSTEM_CAPACITY ) )
					goto search_for_free_memory;
			}
			else
			{
				// after 1 allocation, need a free chunk at end...
				// and let's just have a couple more to spaere.
				if( ExpandSpace( pMem, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE ) )
				{
#ifndef NO_LOGGING
					//ll__lprintf(DBG_RELAY)( WIDE("Creating a new expanded space... %")_size_fs, dwSize + (CHUNK_SIZE*4) + MEM_SIZE + 8 * MAGIC_SIZE );
#endif
					goto search_for_free_memory;
				}
			}
			DropMem( pCurMem );
			pCurMem = NULL;
#ifdef _DEBUG
			if( !g.bDisableDebug )
				ODS( WIDE("Remaining space in memory block is insufficient.  Please EXPAND block."));
#endif
			DropMem( pMem );
			return NULL;
		}
 //|| !defined( __NO_WIN32API__ )
#if defined( _DEBUG )
		if( !g.bDisableDebug )
		{
			// set end of block tag(s).
			// without disabling memory entirely, blocks are
			// still tagged and trashed in debug mode.
			MemSet( pc->byData, CLEAR_MEMORY_TAG, pc->dwSize );
			BLOCK_TAG(pc) = BLOCK_TAG_ID;
		}
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			if( pc->dwPad < 16 )
				DebugBreak();
			BLOCK_FILE(pc) = pFile;
			BLOCK_LINE(pc) = nLine;
		}
#endif
		DropMem( pCurMem );
		DropMem( pMem );
		//#if DBG_AVAILABLE
#ifndef NO_LOGGING
#  ifdef _DEBUG
		if( g.bLogAllocate && g.allowLogging )
		{
			_xlprintf( 2 DBG_RELAY )(WIDE( "Allocate : %p(%p) - %" ) _PTRSZVALfs WIDE( " bytes" ), pc->byData, pc, pc->dwSize);
		}
#  endif
#endif
		//#endif
		if( alignment && ((uintptr_t)pc->byData & ~masks[alignment]) ) {
			uintptr_t retval = ((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]);
 /*pc->alignemnt =*/
			((uint16_t*)(retval - sizeof( uint32_t )))[0] = alignment;
 /*pc->to_chunk_start =*/
			((uint16_t*)(retval - sizeof( uint32_t )))[1] = (uint16_t)(((((uintptr_t)pc->byData) + (alignment - 1)) & masks[alignment]) - (uintptr_t)pc->byData);
			return (POINTER)retval;
		}
		else {
			pc->alignment = 0;
			pc->to_chunk_start = 0;
			return pc->byData;
		}
	}
#endif
	return NULL;
}
//------------------------------------------------------------------------------------------------------
POINTER HeapAllocateEx( PMEM pHeap, uintptr_t dwSize DBG_PASS ) {
	return HeapAllocateAlignedEx( pHeap, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
#undef AllocateEx
POINTER  AllocateEx ( uintptr_t dwSize DBG_PASS )
{
	return HeapAllocateAlignedEx( g.pMemInstance, dwSize, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( dest, source, minSize );
		if( minSize < size )
			MemSet( ((uint8_t*)dest) + minSize, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapReallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( pHeap, source, size, 0 DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
POINTER  HeapPreallocateAlignedEx ( PMEM pHeap, POINTER source, uintptr_t size, uint16_t alignment DBG_PASS )
{
	POINTER dest;
	uintptr_t minSize;
	dest = HeapAllocateAlignedEx( pHeap, size, alignment DBG_RELAY );
	if( source )
	{
		minSize = SizeOfMemBlock( source );
		if( size < minSize )
			minSize = size;
		MemCpy( (uint8_t*)dest + (size-minSize), source, minSize );
		if( minSize < size )
			MemSet( dest, 0, size - minSize );
		ReleaseEx( source DBG_RELAY );
	}
	else
		MemSet( dest, 0, size );
	return dest;
}
POINTER  HeapPreallocateEx ( PMEM pHeap, POINTER source, uintptr_t size DBG_PASS ){
	return HeapPreallocateAlignedEx( pHeap, source, size, AlignOfMemBlock(source) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  HeapMoveEx( PMEM pNewHeap, POINTER source DBG_PASS )
{
	return HeapReallocateAlignedEx( pNewHeap, source, SizeOfMemBlock( source ), AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  ReallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapReallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
 POINTER  PreallocateEx( POINTER source, uintptr_t size DBG_PASS )
{
	return HeapPreallocateAlignedEx( g.pMemInstance, source, size, AlignOfMemBlock( source ) DBG_RELAY );
}
//------------------------------------------------------------------------------------------------------
static void Bubble( PMEM pMem )
{
	// handle sorting free memory to be least signficant first...
	PCHUNK temp, next;
	PCHUNK *prior;
	prior = &pMem->pFirstFree;
	temp = *prior;
	if( !temp )
		return;
	next = temp->next;
	while( temp && next )
	{
		if( (uintptr_t)next < (uintptr_t)temp )
		{
			UnlinkThing( temp );
			UnlinkThing( next );
			LinkThing( *prior, next );
			LinkThing( next->next, temp );
			prior = &next->next;
			temp = *prior;
			next = temp->next;
		}
		else
		{
			prior = &temp->next;
			temp = *prior;
#ifdef _DEBUG
			if( temp->next == temp )
			{
				ll_lprintf( WIDE("OOps this block is way bad... how'd that happen? %s(%d)"), BLOCK_FILE( temp ), BLOCK_LINE( temp ) );
				DebugBreak();
			}
#endif
			next = temp->next;
		}
	}
}
//------------------------------------------------------------------------------------------------------
 uintptr_t  SizeOfMemBlock ( CPOINTER pData )
{
	if( pData )
	{
		if( USE_CUSTOM_ALLOCER )
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
			return pc->dwSize - pc->dwPad;
		}
		else
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData));
			return pc->dwSize - pc->dwPad;
		}
	}
	return 0;
}
//------------------------------------------------------------------------------------------------------
uint16_t  AlignOfMemBlock( CPOINTER pData )
{
	if( pData )
	{
		return (((uint16_t*)pData)[-2]);
	}
	return 0;
 }
//------------------------------------------------------------------------------------------------------
 POINTER  MemDupEx ( CPOINTER thing DBG_PASS )
{
	uintptr_t size = SizeOfMemBlock( thing );
	POINTER result;
	result = HeapAllocateAlignedEx( g.pMemInstance, size, AlignOfMemBlock( thing ) DBG_RELAY );
	MemCpy( result, thing, size );
	return result;
}
#undef MemDup
 POINTER  MemDup (CPOINTER thing )
{
	return MemDupEx( thing DBG_SRC );
}
//------------------------------------------------------------------------------------------------------
POINTER ReleaseEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
#ifndef __NO_MMAP__
		// how to figure if it's a CHUNK or a HEAP_CHUNK?
		if( !( ((uintptr_t)pData) & 0x3FF ) )
		{
			// system allocated blocks ( OpenSpace ) will be tracked as spaces...
			// and they will be aligned on large memory blocks (4096 probably)
			PSPACE ps = FindSpace( pData );
			if( ps )
			{
				DoCloseSpace( ps, TRUE );
				return NULL;
			}
		}
#endif
		if( !USE_CUSTOM_ALLOCER )
		{
			//PMEM pMem = (PMEM)(pData - offsetof( MEM, pRoot ));
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)(((uintptr_t)pData) - MALLOC_CHUNK_SIZE(pData) );
			pc->dwOwners--;
			if( !pc->dwOwners )
			{
				extern int  MemChk ( POINTER p, uintptr_t val, size_t sz );
#ifndef NO_LOGGING
#  ifdef _DEBUG
				if( g.bLogAllocate )
				{
					ll__lprintf(DBG_RELAY)( WIDE( "Release %p(%p)" ), pc, pc->byData );
				}
#  endif
#endif
#ifdef ENABLE_NATIVE_MALLOC_PROTECTOR
				if( !MemChk( pc->LeadProtect, LEAD_PROTECT_TAG, sizeof( pc->LeadProtect ) ) ||
					!MemChk( pc->byData + pc->dwSize, LEAD_PROTECT_BLOCK_TAIL, sizeof( pc->LeadProtect ) ) )
				{
					ll_lprintf( WIDE( "overflow block (%p) %p" ), pData, pc );
					DebugBreak();
				}
#endif
				free( pc );
				return NULL;
			}
			else
			{
#ifndef NO_LOGGING
				if( g.bLogAllocate && g.bLogAllocateWithHold )
				{
					ll__lprintf(DBG_RELAY)( WIDE( "Release(holding) %p(%p)" ), pc, pc->byData );
				}
#endif
			}
			return pData;
		}
#if USE_CUSTOM_ALLOCER
		else
		{
			PCHUNK pc = (PCHUNK)(((uintptr_t)pData) - ( ( (uint16_t*)pData)[-1] +
													offsetof( CHUNK, byData ) ) );
			PMEM pMem, pCurMem;
			PSPACE pMemSpace;
			// Allow a simple release() to close a shared memory file mapping
			// this is a slight performance hit for all deallocations
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
#ifndef NO_LOGGING
#  ifdef _DEBUG
			if( g.bLogAllocate )
			{
				if( !g.bDisableDebug )
					_xlprintf( 2 DBG_RELAY )(WIDE( "Release  : %p(%p) - %" ) _PTRSZVALfs WIDE( " bytes %s(%d)" ), pc->byData, pc, pc->dwSize, BLOCK_FILE( pc ), BLOCK_LINE( pc ));
				else
					_xlprintf( 2 DBG_RELAY )(WIDE( "Release  : %p(%p) - %" ) _PTRSZVALfs WIDE( " bytes" ), pc->byData, pc, pc->dwSize);
			}
#  endif
#endif
			pMem = GrabMem( pc->pRoot );
			if( !pMem )
			{
#ifndef NO_LOGGING
				ll__lprintf( DBG_RELAY )( WIDE("ERROR: Chunk to free does not reference a heap!") );
#endif
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
			}
			pMemSpace = FindSpace( pMem );
			while( pMemSpace && ( ( pCurMem = (PMEM)pMemSpace->pMem ),
										(	( (uintptr_t)pData < (uintptr_t)pCurMem )
										||  ( (uintptr_t)pData > ( (uintptr_t)pCurMem + pCurMem->dwSize ) ) )
									 )
				 )
			{
				Log( WIDE("ERROR: This block should have immediatly referenced it's correct heap!") );
				pMemSpace = pMemSpace->next;
			}
			if( !pMemSpace )
			{
#ifndef NO_LOGGING
#  ifdef _DEBUG
				ll__lprintf( DBG_RELAY )( WIDE("This Block is NOT within the managed heap! : %p" ), pData );
#  endif
#endif
				ll_lprintf( WIDE("this may not be an error.  This could be an old block from not using customallocer...") );
				DebugDumpHeapMemEx( pc->pRoot, 1 );
				DebugBreak();
				DropMem( pMem );
				return NULL;
			}
			pCurMem = (PMEM)pMemSpace->pMem;
			if( pData && pc )
			{
				if( !pc->dwOwners )
				{
#ifndef NO_LOGGING
#  ifdef _DEBUG
					if( !g.bDisableDebug &&
						!(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
						_xlprintf( 2
									, BLOCK_FILE(pc)
									, BLOCK_LINE(pc)
									)( WIDE("Block is already Free! %p ")
									, pc );
					else
#  endif
						// CRITICAL ERROR!
						_xlprintf( 2 DBG_RELAY)( WIDE("Block is already Free! %p "), pc );
#endif
					DropMem( pMem );
					return pData;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug )
					if( BLOCK_TAG( pc ) != BLOCK_TAG_ID )
					{
						ll_lprintf( WIDE("Application overflowed memory:%p"), pc->byData );
						DebugDumpHeapMemEx( pc->pRoot, 1 );
						DebugBreak();
					}
#endif
				pc->dwOwners--;
				if( pc->dwOwners )
				{
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
#endif
					DropMem( pMem );
					return pData;
				}
				else
				{
					LOGICAL bCollapsed = FALSE;
					PCHUNK next, nextNext, pPrior;
					uintptr_t nNext;
					// fill memory with a known value...
					// this will allow me to check usage after release....
#ifdef _DEBUG
					if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
					{
						// store where it was released from
						BLOCK_FILE(pc) = pFile;
						BLOCK_LINE(pc) = nLine;
					}
					if( !g.bDisableDebug )
					{
						BLOCK_TAG(pc)=BLOCK_TAG_ID;
						MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->dwPad );
					}
#endif
					next = (PCHUNK)(pc->byData + pc->dwSize);
					if( (nNext = (uintptr_t)next - (uintptr_t)pCurMem) >= pCurMem->dwSize )
					{
						// if next is NOT within valid memory...
						next = NULL;
					}
 // is not root chunk...
					if( ( pPrior = pc->pPrior ) )
					{
 // prior physical is free
						if( !pPrior->dwOwners )
						{
 // add this header plus size
							pPrior->dwSize += CHUNK_SIZE + pc->dwSize;
#ifdef _DEBUG
							//if( bLogAllocate )
							{
								//ll_lprintf( WIDE("Collapsing freed block with prior block...%p %p"), pc, pPrior );
							}
							if( !g.bDisableDebug )
							{
								pPrior->dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
								BLOCK_TAG( pPrior ) = BLOCK_TAG_ID;
								MemSet( pPrior->byData, FREE_MEMORY_TAG, pPrior->dwSize - pPrior->dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pPrior->dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pPrior->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pPrior ) = pFile;
									BLOCK_LINE( pPrior ) = nLine;
								}
#endif
							}
							if( pPrior->dwSize & 0x80000000 )
								DebugBreak();
 // use prior block as base ....
							pc = pPrior;
							if( next )
								next->pPrior = pPrior;
							bCollapsed = TRUE;
						}
					}
					// begin checking NEXT physical memory block for conglomerating
					if( next )
					{
						if( !next->dwOwners )
						{
							pc->dwSize += CHUNK_SIZE + next->dwSize;
							if( bCollapsed )
							{
								// pc is already in free list...
								UnlinkThing( next );
							}
							else
							{
								// otherwise need to use next's link spot
								// for this pc...
								if( (pc->next = next->next) )
									pc->next->me = &pc->next;
								*( pc->me = next->me ) = pc;
								bCollapsed = TRUE;
							}
#ifdef _DEBUG
							//if( bLogAllocate )
								//ll_lprintf( WIDE("Collapsing freed block with next block...%p %p"), pc, next );
							if( !g.bDisableDebug )
							{
								pc->dwPad = MAGIC_SIZE;
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
								BLOCK_TAG( pc ) = BLOCK_TAG_ID;
								MemSet( pc->byData, FREE_MEMORY_TAG, pc->dwSize - pc->dwPad );
							}
							else
#endif
							{
 // *** NEEDFILELINE ***
								pc->dwPad = 0;
#ifdef _DEBUG
								if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
								{
									pc->dwPad += 2 * MAGIC_SIZE;
									BLOCK_FILE( pc ) = pFile;
									BLOCK_LINE( pc ) = nLine;
								}
#endif
							}
							if( pc->dwSize & 0x80000000 )
								DebugBreak();
							nextNext = (PCHUNK)(pc->byData + pc->dwSize );
							if( (((uintptr_t)nextNext) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
							{
								nextNext->pPrior = pc;
							}
						}
					}
 // no block near this one was free...
					if( !bCollapsed )
					{
						LinkThing( pc->pRoot->pFirstFree, pc );
					}
				}
			}
			Bubble( pMem );
			DropMem( pMem );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pMem, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
#endif
	}
	return NULL;
}
		//------------------------------------------------------------------------------------------------------
 POINTER  HoldEx ( POINTER pData DBG_PASS )
{
	if( pData )
	{
		if( !USE_CUSTOM_ALLOCER )
		{
			PMALLOC_CHUNK pc = (PMALLOC_CHUNK)((uintptr_t)pData - MALLOC_CHUNK_SIZE(pData));
			//ll__lprintf( DBG_RELAY )( "holding block %p", pc );
#ifndef NO_LOGGING
			if( g.bLogAllocate && g.bLogAllocateWithHold )
				_xlprintf( 2 DBG_RELAY)( WIDE("Hold	 : %p - %") _PTRSZVALfs WIDE(" bytes"),pc, pc->dwSize );
#endif
			pc->dwOwners++;
		}
		else
		{
			PCHUNK pc = (PCHUNK)((char*)pData - CHUNK_SIZE);
			PMEM pMem = GrabMem( pc->pRoot );
#ifndef NO_LOGGING
			if( g.bLogAllocate )
			{
				_xlprintf( 2 DBG_RELAY)( WIDE("Hold	 : %p - %") _PTRSZVALfs WIDE(" bytes"),pc, pc->dwSize );
			}
#endif
			if( !pc->dwOwners )
			{
				ll_lprintf( WIDE("Held block has already been released!  too late to hold it!") );
				DebugBreak();
				DropMem( pMem );
				return pData;
			}
			pc->dwOwners++;
			DropMem(pMem );
#ifdef _DEBUG
			if( !g.bDisableAutoCheck )
				GetHeapMemStatsEx(pc->pRoot, &dwFree,&dwAllocated,&dwBlocks,&dwFreeBlocks DBG_RELAY);
#endif
		}
	}
	return pData;
}
//------------------------------------------------------------------------------------------------------
 POINTER  GetFirstUsedBlock ( PMEM pHeap )
{
	return pHeap->pRoot[0].byData;
}
//------------------------------------------------------------------------------------------------------
void  DebugDumpHeapMemEx ( PMEM pHeap, LOGICAL bVerbose )
{
#if USE_CUSTOM_ALLOCER
	if( USE_CUSTOM_ALLOCER )
	{
		PCHUNK pc, _pc;
		uintptr_t nTotalFree = 0;
		uintptr_t nChunks = 0;
		uintptr_t nTotalUsed = 0;
		PSPACE pMemSpace;
		PMEM pMem = GrabMem( pHeap ), pCurMem;
		pc = pMem->pRoot;
		ll_lprintf(WIDE(" ------ Memory Dump ------- ") );
		{
			xlprintf(LOG_ALWAYS)( WIDE("FirstFree : %p"),
										pMem->pFirstFree );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
#ifndef __LINUX__
 // allow debug log to work... (OutputDebugString() Win32, also network streams may require)
				Relinquish();
#endif
				nChunks++;
				if( !pc->dwOwners )
				{
					nTotalFree += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:WIDE("Unknown");
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( WIDE("Free at %p size: %") _PTRSZVALfs WIDE("(%") _PTRSZVALfx WIDE(") Prior:%p NF:%p"),
																 pc, pc->dwSize, pc->dwSize,
																 pc->pPrior,
																 pc->next );
					}
#endif
				}
				else
				{
					nTotalUsed += pc->dwSize;
#ifndef NO_LOGGING
					if( bVerbose )
					{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
						CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:WIDE("Unknown");
						uint32_t nLine = BLOCK_LINE(pc);
#endif
						_xlprintf(LOG_ALWAYS DBG_RELAY)( WIDE("Used at %p size: %") _PTRSZVALfs WIDE("(%") _PTRSZVALfx WIDE(") Prior:%p"),
																 pc, pc->dwSize, pc->dwSize,
																 pc->pPrior );
					}
#endif
				}
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
					ll_lprintf( WIDE("Next block is the current block...") );
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		xlprintf(LOG_ALWAYS)( WIDE("Total Free: %")_PTRSZVALfs WIDE("  TotalUsed: %")_PTRSZVALfs WIDE("  TotalChunks: %")_PTRSZVALfs WIDE(" TotalMemory:%") _PTRSZVALfs,
									nTotalFree, nTotalUsed, nChunks,
									(nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		DropMem( pMem );
	}
	else
#endif
		xlprintf(LOG_ALWAYS)( WIDE( "Cannot log chunks allocated that are not using custom allocer." ) );
}
	//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemEx ( LOGICAL bVerbose )
{
	DebugDumpHeapMemEx( g.pMemInstance, bVerbose );
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpHeapMemFile ( PMEM pHeap, CTEXTSTR pFilename )
{
#if USE_CUSTOM_ALLOCER
	FILE *file;
#endif
	if( !USE_CUSTOM_ALLOCER )
		return;
#if USE_CUSTOM_ALLOCER
	Fopen( file, pFilename, WIDE("wt") );
	if( file )
	{
		PCHUNK pc, _pc;
		PMEM pMem, pCurMem;
		PSPACE pMemSpace;
		size_t nTotalFree = 0;
		size_t nChunks = 0;
		size_t nTotalUsed = 0;
		char byDebug[256];
		pMem = GrabMem( pHeap );
		fprintf( file, " ------ Memory Dump ------- \n" );
		{
			char  byDebug[256];
			snprintf( byDebug, sizeof( byDebug ), "FirstFree : %p",
						pMem->pFirstFree );
			byDebug[255] = 0;
			fprintf( file, "%s\n", byDebug );
		}
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pRoot;
 // while PC not off end of memory
			while( (((uintptr_t)pc) - ((uintptr_t)pCurMem)) < (uintptr_t)pCurMem->dwSize )
			{
				//Relinquish(); // allow debug log to work...
				nChunks++;
				if( !pc->dwOwners )
				{
					nTotalFree += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p NF:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior,
						pc->next );
					byDebug[255] = 0;
				}
				else
				{
					nTotalUsed += pc->dwSize;
					snprintf( byDebug, sizeof(byDebug), "Used at %p size: %" cPTRSZVALfs "(%" cPTRSZVALfx ") Prior:%p",
						pc, pc->dwSize, pc->dwSize,
						pc->pPrior );
					byDebug[255] = 0;
				}
#ifdef _DEBUG
				if( !g.bDisableDebug && !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					CTEXTSTR pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?BLOCK_FILE(pc)
							:WIDE("Unknown");
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
#endif
					fprintf( file, "%s\n", byDebug );
				_pc = pc;
				pc = (PCHUNK)(pc->byData + pc->dwSize );
				if( pc == _pc )
				{
 // broken memory chain
					DebugBreak();
					break;
				}
			}
		}
		fprintf( file, "--------------- FREE MEMORY LIST --------------------\n" );
		for( pc = NULL, pMemSpace = FindSpace( pMem ); pMemSpace; pMemSpace = pMemSpace->next )
		{
			pCurMem = (PMEM)pMemSpace->pMem;
 // current pChunk(pc)
			pc = pCurMem->pFirstFree;
 // while PC not off end of memory
			while( pc )
			{
				snprintf( byDebug, sizeof(byDebug), "Free at %p size: %" c_size_fs "(%" c_size_fx ") ",
							pc, pc->dwSize, pc->dwSize );
				byDebug[255] = 0;
	#ifdef _DEBUG
 /*!g.bDisableDebug && */
				if( !(pCurMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
				{
					const char * pFile =  !IsBadReadPtr( BLOCK_FILE(pc), 1 )
							?CStrDup(BLOCK_FILE(pc))
							:"Unknown";
					fprintf( file, "%s(%d):%s\n", pFile, BLOCK_LINE(pc), byDebug );
				}
				else
	#endif
					fprintf( file, "%s\n", byDebug );
				pc = pc->next;
			}
		}
		snprintf( byDebug, sizeof(byDebug), "Total Free: %" c_size_f "  TotalUsed: %" c_size_f "  TotalChunks: %" c_size_f " TotalMemory:%" c_size_f
					, nTotalFree, nTotalUsed, nChunks
					, (nTotalFree + nTotalUsed + nChunks * CHUNK_SIZE) );
		byDebug[255] = 0;
		fprintf( file, "%s\n", byDebug );
		//Relinquish();
		DropMem( pMem );
		 fclose( file );
	}
#endif
}
//------------------------------------------------------------------------------------------------------
 void  DebugDumpMemFile ( CTEXTSTR pFilename )
{
	DebugDumpHeapMemFile( g.pMemInstance, pFilename );
}
//------------------------------------------------------------------------------------------------------
 // returns true/false, updates pointer
 LOGICAL  Defragment ( POINTER *ppMemory )
{
	// this is broken... needs
	// to fixup BLOCK_TAG, BLOCK_FILE, etc...
#if 1
	return FALSE;
#else
	// pass an array of allocated memory... for all memory blocks in list,
	// check to see if they can be reallocated lower, and or just moved to
	// a memory space lower than they are now.
	PCHUNK pc, pPrior;
	PMEM pMem;
	if( !ppMemory || !*ppMemory)
		return FALSE;
	pc = (PCHUNK)(((uintptr_t)(*ppMemory)) - (((uint16_t*)pData)[-1] + offsetof( CHUNK, byData )));
	pMem = GrabMem( pc->pRoot );
		// check if prior block is free... if so - then...
		// move this data down, and reallocate the freeness at the end
		// this reallocation may move the free next to another free, which
		// should be collapsed into this one...
	pPrior = pc->pPrior;
 // not HELD by others... no way to update their pointers
	if( ( pc->dwOwners == 1 ) &&
		pPrior &&
		!pPrior->dwOwners )
	{
		CHUNK Free = *pPrior;
		CHUNK Allocated, *pNew;
 // save this chunk...
		Allocated = *pc;
		MemCpy( pPrior->byData, pc->byData, Allocated.dwSize );
		pNew = (PCHUNK)(pPrior->byData + Allocated.dwSize);
		pNew->dwSize = Free.dwSize;
		pNew->dwOwners = 0;
 // now pAllocated...
		pNew->pPrior = pPrior;
		pNew->pRoot = Free.pRoot;
		if( ( pNew->next = Free.next ) )
			pNew->next->me = &pNew->next;
		if( ( pNew->me = Free.me ) )
			(*pNew->me) = pNew;
#ifdef _DEBUG
		if( !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG ) )
		{
			BLOCK_FILE(pNew) = BLOCK_FILE(&Free);
			BLOCK_LINE(pNew) = BLOCK_LINE(&Free);
		}
#endif
		pPrior->dwSize = Allocated.dwSize;
		pPrior->dwOwners = 1;
		pPrior->next = NULL;
		pPrior->me = NULL;
		// update NEXT NEXT real block...
		{
			PCHUNK next;
			next = (PCHUNK)( pNew->byData + pNew->dwSize );
			if( (((uintptr_t)next) - ((uintptr_t)pMem)) < (uintptr_t)pMem->dwSize )
			{
 // if next is free.....
				if( !next->dwOwners )
				{
					// consolidate...
					if( (pNew->next = next->next) )
						pNew->next->me = &pNew->next;
					*( pNew->me = next->me ) = pNew;
					pNew->dwSize += next->dwSize + CHUNK_SIZE;
					next = (PCHUNK)( pNew->byData + pNew->dwSize );
					if( (uint32_t)(((char *)next) - ((char *)pMem)) < pMem->dwSize )
					{
						next->pPrior = pNew;
					}
				}
				else
					next->pPrior = pNew;
			}
		}
		*ppMemory = pPrior->byData;
		DropMem( pMem );
		GetHeapMemStats( g.pMemInstance, NULL, NULL, NULL, NULL );
		return TRUE;
	}
	DropMem( pMem );
	return FALSE;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetHeapMemStatsEx ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks DBG_PASS )
{
#if USE_CUSTOM_ALLOCER
	int nChunks = 0, nFreeChunks = 0, nSpaces = 0;
	uintptr_t nFree = 0, nUsed = 0;
	PCHUNK pc, _pc;
	PMEM pMem;
	PSPACE pMemSpace;
#endif
	if( !USE_CUSTOM_ALLOCER )
      return;
#if USE_CUSTOM_ALLOCER
	if( !pHeap )
		pHeap = g.pMemInstance;
	pMem = GrabMem( pHeap );
	pMemSpace = FindSpace( pMem );
	while( pMemSpace )
	{
		PMEM pMemCheck = ((PMEM)pMemSpace->pMem);
		pc = pMemCheck->pRoot;
		GrabMem( pMemCheck );
 // while PC not off end of memory
		while( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize )
		{
			nChunks++;
			if( !pc->dwOwners )
			{
				nFree += pc->dwSize;
				nFreeChunks++;
			}
			else
			{
				nUsed += pc->dwSize;
#ifdef _DEBUG
				if( !g.bDisableDebug )
				{
					if( pc->dwSize > pMemCheck->dwSize )
					{
						ll_lprintf( WIDE("Memory block %p has a corrupt size."), pc->byData );
						DebugBreak();
					}
					else
					{
						int minPad = MAGIC_SIZE;
						if( pMem && !(pMem->dwFlags & HEAP_FLAG_NO_DEBUG) )
							minPad += MAGIC_SIZE * 2;
						if( pc->dwPad >= minPad && BLOCK_TAG(pc) != BLOCK_TAG_ID )
						{
#ifndef NO_LOGGING
							ll_lprintf( WIDE("memory block: %p %08") TAG_FORMAT_MODIFIER WIDE("x insted of %08")TAG_FORMAT_MODIFIER WIDE("x"), pc->byData, BLOCK_TAG(pc), BLOCK_TAG_ID );
							if( !(pMemCheck->dwFlags & HEAP_FLAG_NO_DEBUG ) )
							{
								CTEXTSTR file = BLOCK_FILE(pc);
#  ifdef _WIN32
								if( IsBadReadPtr( file, 4 ) )
									file = WIDE("(corrupt)");
#  endif
								_xlprintf( 2, file, BLOCK_LINE(pc) )( WIDE("Application overflowed allocated memory.") );
							}
							else
								ODS( WIDE("Application overflowed allocated memory.") );
#endif
							DebugDumpHeapMemEx( pHeap, 1 );
							DebugBreak();
						}
					}
				}
#endif
			}
			_pc = pc;
			pc = (PCHUNK)(pc->byData + pc->dwSize );
			if( (((uintptr_t)pc) - ((uintptr_t)pMemCheck)) < (uintptr_t)pMemCheck->dwSize  )
			{
				if( pc == _pc )
				{
					Log( WIDE("Current block is the same as the last block we checked!") );
					DebugDumpHeapMemEx( pHeap, 1 );
 // broken memory chain
					DebugBreak();
					break;
				}
				if( pc->pPrior != _pc )
				{
					ll_lprintf( WIDE("Block's prior is not the last block we checked! prior %p sz: %") _PTRSZVALfs WIDE(" current: %p currentprior: %p")
						, _pc
						, _pc->dwSize
						, pc
						, pc->pPrior );
					DebugDumpHeapMemEx( pHeap, 1 );
					DebugBreak();
					break;
				}
			}
		}
		_pc = NULL;
		pc = pMemCheck->pFirstFree;
		while( pc )
		{
			if( pc->dwOwners )
  // owned block is in free memory chain ! ?
			{
				ll_lprintf( WIDE("Owned block %p is in free memory chain!"), pc );
				DebugBreak();
				break;
			}
			_pc = pc;
			pc = pc->next;
		}
		nSpaces++;
		pMemSpace = pMemSpace->next;
		DropMem( pMemCheck );
	}
	DropMem( pMem );
	if( pFree )
		*pFree = (uint32_t)nFree;
	if( pUsed )
		*pUsed = (uint32_t)nUsed;
	if( pChunks )
		*pChunks = nChunks;
	if( pFreeChunks )
		*pFreeChunks = nFreeChunks;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  GetMemStats ( uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStats( g.pMemInstance, pFree, pUsed, pChunks, pFreeChunks );
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateLogging ( LOGICAL bTrueFalse )
{
	LOGICAL prior = g.bLogAllocate;
	g.bLogAllocate = bTrueFalse;
	return prior;
}
//------------------------------------------------------------------------------------------------------
 int  SetCriticalLogging ( LOGICAL bTrueFalse )
{
#ifdef _DEBUG
	int prior = g.bLogCritical;
	g.bLogCritical = bTrueFalse;
	return prior;
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------------------------------
 int  SetAllocateDebug ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableDebug;
	g.bDisableDebug = !bDisable;
	g.bDisableAutoCheck = !bDisable;
	return save;
#else
	return 1;
#endif
}
 int  SetManualAllocateCheck ( LOGICAL bDisable )
{
#ifdef _DEBUG
	int save = g.bDisableAutoCheck;
	g.bDisableAutoCheck = bDisable;
	return save;
#else
	return 1;
#endif
}
//------------------------------------------------------------------------------------------------------
 void  SetMinAllocate ( size_t nSize )
{
	g.nMinAllocateSize = nSize;
}
//------------------------------------------------------------------------------------------------------
 void  SetHeapUnit ( size_t dwSize )
{
	g.dwSystemCapacity = dwSize;
}
//------------------------------------------------------------------------------------------------------
#undef GetHeapMemStats
 void  GetHeapMemStats ( PMEM pHeap, uint32_t *pFree, uint32_t *pUsed, uint32_t *pChunks, uint32_t *pFreeChunks )
{
	GetHeapMemStatsEx( pHeap, pFree, pUsed, pChunks, pFreeChunks DBG_SRC );
}
#if 0
#  ifdef _MSC_VER
//>= 900
_CRT_ALLOC_HOOK prior_hook;
int allocHook(int allocType, void *userData, size_t size, int
blockType, long requestNumber, const unsigned char *filename, int
lineNumber)
{
	static int logging;
	if( logging )
		return TRUE;
	logging = 1;
	switch( allocType )
	{
	case _HOOK_ALLOC:
		ll_lprintf( WIDE( "CRT Alloc: %d bytes %s(%d)" )
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_REALLOC:
		ll_lprintf( WIDE( "CRT Realloc: %d bytes %s(%d)" )
			, size
			, filename, lineNumber
			);
		break;
	case _HOOK_FREE:
		ll_lprintf( WIDE( "CRT Free: %p[%"_PTRSZVALfs"](%d) %s(%d)" )
			, userData
			, (uintptr_t)userData
			, size
			, filename, lineNumber
			);
		break;
	default:
		DebugBreak();
	}
	logging = 0;
	if( prior_hook )
		return prior_hook( allocType, userData, size, blockType, requestNumber, filename, lineNumber );
	return TRUE;
}
//int handle_program_memory_depletion( size_t )
//{
   // Your code
//}
PRELOAD( ShareMemToVSAllocHook )
{
	//_CRT_ALLOC_HOOK allocHook;
	//allocHook = 0 ;
	/* this is about useless... the free doesn't report the correct address
	* the allocate doesn't report the block
	* the free doesn't reprot the size
	* there is no way to relate what is freed with what is allocated
	*/
	//prior_hook = _CrtSetAllocHook(	allocHook );
	//_set_new_handler( pn );
}
#  endif
#endif
#ifdef __cplusplus
//namespace sack {
};
//	namespace memory {
};
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   created to provide standard memory allocation features.
 *   Release( Allocate(size) )
 *   Hold( pointer ); // must release a second time.
 *   if DEBUG, memory bounds checking enabled and enableable.
 *   if RELEASE standard memory includes no excessive operations
 *
 *  standardized to never use int. (was a clean port, however,
 *  inaccurate, knowing the conversions on calculations of pointers
 *  are handled by cast to int! )
 *
 * see also - include/sharemem.h
 *
 */
SACK_MEMORY_NAMESPACE
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#if defined( __GNUC__ )
#  pragma GCC push_options
#  pragma GCC optimize ("O0")
#endif
void  MemSet ( POINTER p, uintptr_t n, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
#  if defined( _WIN64 )
	//__asm cld;
	__stosq( (uint64_t*)p, n, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#  else
#    ifdef __64__
	__stosq( (uint64_t*)p, n, sz / 4 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    else
	__stosd( (DWORD*)p, n, sz / 4 );
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)p) + sz - (sz&1) ) ) = (uint8_t)n;
#    endif
#  endif
#elif defined( __GNUC__ )
	{
      uintptr_t tmp = (uintptr_t)p;
#  ifdef __64__
		{
			int m; int len = sz/8;
			for( m = 0; m < len; m++ ) {
				((uint64_t*)tmp)[0] = n;
				tmp += 8;
			}
		}
		if( sz & 4 )
			(*(uint32_t*)( ((uintptr_t)p) + sz - (sz&7) ) ) = (uint32_t)n;
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  else
		{
			int m; int len = sz/4;
			for( m = 0; m < len; m++ ) {
				((uint32_t*)tmp)[0] = n;
				tmp += 4;
			}
		}
		if( sz & 2 )
			(*(uint16_t*)( ((uintptr_t)p) + sz - (sz&3) ) ) = (uint16_t)n;
		if( sz & 1 )
			(*(uint8_t*)( ((uintptr_t)p) + sz - 1 ) ) = (uint8_t)n;
#  endif
	}
#else
   memset( p, n, sz );
#endif
}
#if defined( __GNUC__ )
#  pragma GCC pop_options
#endif
int  MemChk ( POINTER p, uintptr_t val, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ ) && !defined( UNDER_CE )
	size_t n;
	uintptr_t *data = (uintptr_t*)p;
	for( n = 0; n < sz/sizeof(uintptr_t); n++, data++ )
		if( data[0] != val )
			return 0;
   return 1;
#else
	//   memset( p, n, sz );
   return 1;
#endif
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 void  MemCpy ( POINTER pTo, CPOINTER pFrom, size_t sz )
{
#if defined( _MSC_VER ) && !defined( __NO_WIN32API__ )&& !defined( UNDER_CE )
#  ifdef _WIN64
	__movsq( (uint64_t*)pTo, (uint64_t*)pFrom, sz/8 );
	if( sz & 4 )
		(*(uint32_t*)( ((uintptr_t)pTo) + sz - (sz&7) ) ) = (*(uint32_t*)( ((uintptr_t)pFrom) + sz - (sz&7) ) );
#  else
	__movsd( (DWORD*)pTo, (DWORD*)pFrom, sz/4 );
#  endif
	if( sz & 2 )
		(*(uint16_t*)( ((uintptr_t)pTo) + sz - (sz&3) ) ) = (*(uint16_t*)( ((uintptr_t)pFrom) + sz - (sz&3) ) );
	if( sz & 1 )
		(*(uint8_t*)( ((uintptr_t)pTo) + sz - (sz&1) ) ) = (*(uint8_t*)( ((uintptr_t)pFrom) + sz - (sz&1) ) );
#else
	memcpy( pTo, pFrom, sz );
#endif
}
int  MemCmp ( CPOINTER pOne, CPOINTER pTwo, size_t sz )
{
   // zero byte comparison, always same.
	if( !sz )
      return 0;
	if( !pOne && !pTwo )
		return 0;
	if( !pOne )
 // NULL < "anything"
		return -1;
	if( !pTwo )
  // "anything" > NULL
		return 1;
	return memcmp( pOne, pTwo, sz );
}
TEXTSTR StrCpyEx( TEXTSTR s1, CTEXTSTR s2, size_t n )
{
	size_t x;
	if( !s1 ) return s1;
	if( !s2 ) { if( s1 ) { s1[0] = 0; return s1; } }
	for( x = 0; x < n && (s1[x]=s2[x]); x++ );
	if( n )
		s1[n-1] = 0;
	return s1;
}
#undef StrCpy
TEXTSTR StrCpy( TEXTSTR s1, CTEXTSTR s2 )
{
	int x;
	for( x = 0; (s1[x]=s2[x]); x++ );
	return s1;
}
CTEXTSTR StrChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
CTEXTSTR StrRChr( CTEXTSTR s1, TEXTCHAR c )
{
	CTEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] && p1[0] != c ) p1++;
	if( p1[0] )
		return p1;
	return NULL;
}
TEXTSTR StrRChr( TEXTSTR s1, TEXTCHAR c )
{
	TEXTSTR  p1 = s1;
	if( !p1 ) return NULL;
	while( p1[0] ) p1++;
	while( p1 != s1 && p1[0] != c ) p1--;
	if( p1[0] == c )
		return p1;
	return NULL;
}
#endif
CTEXTSTR StrCaseStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] ||
         (p1[0] == '/' && p2[0] == '\\' ) ||
         (p1[0] == '\\' && p2[0] == '/' ) ||
			(((p1[0] >='a' && p1[0] <='z' )?p1[0]-('a'-'A'):p1[0])
			 == ((p2[0] >='a' && p2[0] <='z' )?p2[0]-('a'-'A'):p2[0]) ))
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
CTEXTSTR StrStr( CTEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	CTEXTSTR p1, p2, began_at;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
	began_at = NULL;
	p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
			//p2++;
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#ifdef __cplusplus
TEXTSTR StrStr( TEXTSTR s1, CTEXTSTR s2 )
{
	int match = 0;
	TEXTSTR p1, began_at;
	CTEXTSTR p2;
	if( !s1 )
		return NULL;
	if( !s2 )
		return s1;
 // set began_at here too..
	began_at = p1 = s1;
	p2 = s2;
	while( p1[0] && p2[0] )
	{
		if( p1[0] == p2[0] )
		{
			if( !match )
			{
				match++;
				began_at = p1;
			}
		}
		else
		{
			if( began_at )
			{
  // start at the beginning again..
				p1 = began_at;
 // reset searching string.
				p2 = s2;
            began_at = NULL;
			}
			match = 0;
		}
		p1++;
      if( match )
			p2++;
	}
	if( !p2[0] )
		return began_at;
	return NULL;
}
#endif
//------------------------------------------------------------------------------------------------------
// result in 0(equal), 1 above, or -1 below
// *r contains the position of difference
 int  CmpMem8 ( void *s1, void *s2, unsigned long n, unsigned long *r )
{
	int t1, t2;
	uint32_t pos;
	{
		pos = 0;
		while( pos < n )
		{
			t1 = *(unsigned char*)s1;
			t2 = *(unsigned char*)s2;
			if( ( t1 ) == ( t2 ) ) {
				(pos)++;
				s1 = (void*)(((uintptr_t)s1) + 1);
				s2 = (void*)(((uintptr_t)s2) + 1);
			} else if( t1 > t2 ) {
				if( r )
					*r = pos;
				return 1;
			} else {
				if( r )
					*r = pos;
				return -1;
			}
		}
	}
	if( r )
		*r = pos;
	return 0;
}
//------------------------------------------------------------------------------------------------------
 TEXTSTR  StrDupEx ( CTEXTSTR original DBG_PASS )
{
	if( original )
	{
		uintptr_t len = (uintptr_t)StrLen( original ) + 1;
		TEXTCHAR *result;
		result = (TEXTCHAR*)AllocateEx( sizeof(TEXTCHAR)*len  DBG_RELAY );
		MemCpy( result, original, sizeof(TEXTCHAR)*len );
		return result;
	}
	return NULL;
}
size_t StrLen( CTEXTSTR s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++, s++);
	return l;
}
size_t CStrLen( char const* s )
{
	size_t l;
	if( !s )
		return 0;
	for( l = 0; s[0];l++,s++);
	return l;
}
#ifdef _UNICODE
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	return WcharConvertEx( original DBG_RELAY );
}
TEXTSTR  DupCStrEx ( const char * original DBG_PASS )
{
	if( original )
		return CharWConvertEx( original DBG_RELAY );
	return NULL;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	if( original )
		return CharWConvertExx( original, chars DBG_RELAY );
	return NULL;
}
#else
char *  CStrDupEx ( CTEXTSTR original DBG_PASS )
{
	INDEX len;
	char *result;
	if( !original )
		return NULL;
	for( len = 0; original[len]; len++ );
	result = (char*)AllocateEx( (len+1) * sizeof( result[0] ) DBG_RELAY );
	len = 0;
	while( ( result[len] = original[len] ) != 0 ) len++;
	return result;
}
TEXTSTR  DupCStrLenEx( const char * original, size_t chars DBG_PASS )
{
	size_t len = 0;
	TEXTSTR result, _result;
	if( !original )
		return NULL;
// (TEXTSTR)AllocateEx( (len + 1) * sizeof( result[0] )  DBG_RELAY );
	_result = result = NewArray( TEXTCHAR, chars + 1 );
	len = 0;
	while( len < chars ) ((*result++) = (*original++)), len++;
	result[0] = 0;
	return _result;
}
TEXTSTR  DupCStrEx( const char * original DBG_PASS )
{
	size_t len = 0;
	const char *_original;
	if( !original )
		return NULL;
	_original = original;
	while( (*original++) ) len++;
	return DupCStrLenEx( _original, len DBG_RELAY );
}
#endif
wchar_t *   DupTextToWideEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return CharWConvertEx( original DBG_RELAY );
#endif
}
char *     DupTextToCharEx( CTEXTSTR original DBG_PASS )
{
#ifdef _UNICODE
   return WcharConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupWideToTextEx( const wchar_t * original DBG_PASS )
{
#ifdef _UNICODE
   return StrDupEx( original DBG_RELAY );
#else
   return WcharConvertEx( original DBG_RELAY );
#endif
}
TEXTSTR     DupCharToTextEx( const char * original DBG_PASS )
{
#ifdef _UNICODE
   return CharWConvertEx( original DBG_RELAY );
#else
   return StrDupEx( original DBG_RELAY );
#endif
}
 int  StrCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ); s1++, s2++ );
	return s1[0] - s2[0];
}
 int  StrCaseCmp ( CTEXTSTR s1, CTEXTSTR s2 )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) );
		  s1++, s2++ );
	return tolower(s1[0]) - tolower(s2[0]);
}
 int  StrCmpEx ( CTEXTSTR s1, CTEXTSTR s2, INDEX maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
      return 0;
	for( ;s1[0] && s2[0] && ( s1[0] == s2[0] ) && maxlen; s1++, s2++, maxlen-- );
	if( maxlen )
		return s1[0] - s2[0];
	return 0;
}
 int  StrCaseCmpEx ( CTEXTSTR s1, CTEXTSTR s2, size_t maxlen )
{
	if( !s1 )
		if( s2 )
			return -1;
		else
			return 0;
	else
		if( !s2 )
			return 1;
	if( s1 == s2 )
 // ==0 is success.
		return 0;
	for( ;s1[0] && s2[0] && (((s1[0] >='a' && s1[0] <='z' )?s1[0]-('a'-'A'):s1[0])
									 == ((s2[0] >='a' && s2[0] <='z' )?s2[0]-('a'-'A'):s2[0]) ) && maxlen;
		  s1++, s2++, maxlen-- );
	if( maxlen )
		return tolower(s1[0]) - tolower(s2[0]);
	return 0;
}
 int  StriCmp ( CTEXTSTR pOne, CTEXTSTR pTwo )
{
   return -1;
}
SACK_MEMORY_NAMESPACE_END
#define FILESYSTEM_LIBRARY_SOURCE
#define NO_UNICODE_C
#define WINFILE_COMMON_SOURCE
#define FIX_RELEASE_COM_COLLISION
#ifndef _DEBUG
#  define __FILESYS_NO_FILE_LOGGING__
#endif
#if defined( _WIN32 ) && !defined( __TURBOC__ )
#  ifndef UNDER_CE
  // findfirst,findnext, fileinfo
#  endif
#  ifdef UNDER_CE
#    define finddata_t WIN32_FIND_DATA
#    define findfirst FindFirstFile
#    define findnext  FindNextFile
#    define findclose FindClose
#  else
#    ifdef UNICODE
#      define finddata_t _wfinddata_t
#      define findfirst _wfindfirst
#      define findnext  _wfindnext
#      define findclose _findclose
#    else
#      define finddata_t _finddata_t
#      define findfirst _findfirst
#      define findnext  _findnext
#      define findclose _findclose
#    endif
#  endif
#else
 // opendir etc..
#  include <dirent.h>
#  ifndef MAX_PATH_NAME
#    define MAX_PATH_NAME PATH_MAX
#  endif
#endif
//#undef DeleteList
#ifdef WIN32
#endif
#ifndef UNDER_CE
//#include <fcntl.h>
//#include <io.h>
#endif
FILESYS_NAMESPACE
enum textModes {
	TM_BINARY = 0,
	TM_UNKNOWN,
	TM_UTF8,
	TM_UTF16BE,
	TM_UTF16LE,
	TM_UTF32BE,
	TM_UTF32LE,
	TM_UTF7,
	TM_UTF1,
	TM_UTF_EBCDIC,
	TM_UTF_SCSU,
	TM_UTF_BOCU,
	TM_UTF_GB_18030
};
struct file{
	TEXTSTR name;
	TEXTSTR fullname;
	int fullname_size;
 // HANDLE 's
	PLIST handles;
 // FILE *'s
	PLIST files;
	INDEX group;
	enum textModes textmode;
  // text file modes; skip existing BOM for seek purposes.
	size_t file_start_offset;
	struct file_system_mounted_interface *mount;
};
struct file_interface_tracker
{
	CTEXTSTR name;
	struct file_system_interface *fsi;
};
struct Group {
	TEXTSTR name;
	TEXTSTR base_path;
};
struct file_system_mounted_interface
{
	DeclareLink( struct file_system_mounted_interface );
	const char *name;
	int priority;
	uintptr_t psvInstance;
	struct file_system_interface *fsi;
	LOGICAL writeable;
};
#ifndef WINFILE_COMMON_SOURCE
extern
#endif
 struct winfile_local_tag {
	CRITICALSECTION cs_files;
	PLIST files;
	PLIST groups;
	PLIST handles;
	PLIST file_system_interface;
	struct file_system_interface *default_file_system_interface;
	struct file_system_mounted_interface *mounted_file_systems;
	struct file_system_mounted_interface *last_find_mount;
	struct file_system_mounted_interface *default_mount;
	LOGICAL have_default;
	struct {
		BIT_FIELD bLogOpenClose : 1;
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bDeallocateClosedFiles : 1;
	} flags;
	TEXTSTR local_data_file_root;
	TEXTSTR data_file_root;
	TEXTSTR producer;
	TEXTSTR application;
} *winfile_local;
//#define l (*winfile_local)
static void UpdateLocalDataPath( void )
{
#ifdef _WIN32
	TEXTCHAR path[MAX_PATH];
	TEXTCHAR *realpath;
	size_t len;
#ifndef SHGFP_TYPE_CURRENT
#define SHGFP_TYPE_CURRENT 0
#endif
	SHGetFolderPath( NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_CURRENT, path );
	realpath = NewArray( TEXTCHAR, len = StrLen( path )
							  + StrLen( (*winfile_local).producer?(*winfile_local).producer:WIDE("") )
 // worse case +3
							  + StrLen( (*winfile_local).application?(*winfile_local).application:WIDE("") ) + 3 );
	tnprintf( realpath, len, WIDE("%s%s%s%s%s"), path
			  , (*winfile_local).producer?WIDE("/"):WIDE(""), (*winfile_local).producer?(*winfile_local).producer:WIDE("")
			  , (*winfile_local).application?WIDE("/"):WIDE(""), (*winfile_local).application?(*winfile_local).application:WIDE("")
			  );
	if( (*winfile_local).data_file_root )
		Deallocate( TEXTSTR, (*winfile_local).data_file_root );
	(*winfile_local).data_file_root = realpath;
	MakePath( (*winfile_local).data_file_root );
	SHGetFolderPath( NULL, CSIDL_LOCAL_APPDATA, NULL, SHGFP_TYPE_CURRENT, path );
	realpath = NewArray( TEXTCHAR, len = StrLen( path )
							  + StrLen( (*winfile_local).producer?(*winfile_local).producer:WIDE("") )
 // worse case +3
							  + StrLen( (*winfile_local).application?(*winfile_local).application:WIDE("") ) + 3 );
	tnprintf( realpath, len, WIDE("%s%s%s%s%s"), path
			  , (*winfile_local).producer?WIDE("/"):WIDE(""), (*winfile_local).producer?(*winfile_local).producer:WIDE("")
			  , (*winfile_local).application?WIDE("/"):WIDE(""), (*winfile_local).application?(*winfile_local).application:WIDE("")
			  );
	if( (*winfile_local).local_data_file_root )
		Deallocate( TEXTSTR, (*winfile_local).local_data_file_root );
	(*winfile_local).local_data_file_root = realpath;
	MakePath( (*winfile_local).local_data_file_root );
#else
	(*winfile_local).data_file_root = StrDup( WIDE(".") );
	(*winfile_local).local_data_file_root = StrDup( WIDE(".") );
#endif
}
void sack_set_common_data_producer( CTEXTSTR name )
{
	(*winfile_local).producer = StrDup( name );
	UpdateLocalDataPath();
}
void sack_set_common_data_application( CTEXTSTR name )
{
	(*winfile_local).application = StrDup( name );
	UpdateLocalDataPath();
}
static void LocalInit( void )
{
	if( !winfile_local )
	{
		SimpleRegisterAndCreateGlobal( winfile_local );
		if( !(*winfile_local).flags.bInitialized )
		{
			InitializeCriticalSec( &(*winfile_local).cs_files );
			(*winfile_local).flags.bInitialized = 1;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
			(*winfile_local).flags.bLogOpenClose = 0;
#endif
			{
#ifdef _WIN32
				sack_set_common_data_producer( WIDE( "Freedom Collective" ) );
				sack_set_common_data_application( GetProgramName() );
#else
				(*winfile_local).data_file_root = StrDup( WIDE( "~" ) );
#endif
			}
		}
	}
}
static void InitGroups( void )
{
	struct Group *group;
	TEXTCHAR tmp[256];
	// known handle '0' is 'default' which is CurrentWorkingDirectory at load.
	group = New( struct Group );
	group->base_path = StrDup( GetCurrentPath( tmp, sizeof( tmp ) ) );
	group->name = StrDup( WIDE( "Default" ) );
	AddLink( &(*winfile_local).groups, group );
	// known handle '1' is the program's load path.
	group = New( struct Group );
#ifdef __ANDROID__
	// assets and other files are in the data directory
	group->base_path = StrDup( GetStartupPath() );
#else
	group->base_path = StrDup( GetProgramPath() );
#endif
	group->name = StrDup( WIDE( "Program Path" ) );
	AddLink( &(*winfile_local).groups, group );
	// known handle '1' is the program's start path.
	group = New( struct Group );
	group->base_path = StrDup( GetStartupPath() );
	group->name = StrDup( WIDE( "Startup Path" ) );
	AddLink( &(*winfile_local).groups, group );
	(*winfile_local).have_default = TRUE;
}
static struct Group *GetGroupFilePath( CTEXTSTR group )
{
	struct Group *filegroup;
	INDEX idx;
	if( !(*winfile_local).groups )
	{
		InitGroups();
	}
	LIST_FORALL( (*winfile_local).groups, idx, struct Group *, filegroup )
	{
		if( StrCaseCmp( filegroup->name, group ) == 0 )
		{
		break;
		}
	}
	return filegroup;
}
INDEX  GetFileGroup ( CTEXTSTR groupname, CTEXTSTR default_path )
{
	struct Group *filegroup = GetGroupFilePath( groupname );
	if( !filegroup && default_path )
	{
		{
			TEXTCHAR tmp_ent[256];
			TEXTCHAR tmp[256];
			tnprintf( tmp_ent, sizeof( tmp_ent ), WIDE( "file group/%s" ), groupname );
			//lprintf( WIDE( "option to save is %s" ), tmp );
#ifdef __NO_OPTIONS__
			tmp[0] = 0;
#else
			if( (*winfile_local).have_default )
				SACK_GetProfileString( GetProgramName(), tmp_ent, default_path?default_path:WIDE( "" ), tmp, sizeof( tmp ) );
#endif
			if( tmp[0] )
				default_path = tmp;
			else if( default_path )
			{
#ifndef __NO_OPTIONS__
				SACK_WriteProfileString( GetProgramName(), tmp_ent, default_path );
#endif
			}
		}
		filegroup = New( struct Group );
		filegroup->name = StrDup( groupname );
		if( default_path )
			filegroup->base_path = StrDup( default_path );
		else
			filegroup->base_path = StrDup( WIDE( "." ) );
		AddLink( &(*winfile_local).groups, filegroup );
	}
	return FindLink( &(*winfile_local).groups, filegroup );
}
TEXTSTR GetFileGroupText ( INDEX group, TEXTSTR path, int path_chars )
{
	struct Group* filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
	if( !filegroup )
	{
		path[0] = 0;
		return 0;
	}
	StrCpyEx( path, filegroup->base_path, path_chars );
	return path;
}
TEXTSTR ExpandPathVariable( CTEXTSTR path )
{
	TEXTSTR subst_path = NULL;
	TEXTSTR end = NULL;
	TEXTSTR tmp_path = StrDup( path );
	TEXTSTR tmp = NULL;
	TEXTSTR newest_path = NULL;
	size_t  len;
	size_t  this_length;
	INDEX   group;
	struct  Group* filegroup;
	if( path )
	{
		while( ( subst_path = (TEXTSTR)StrChr( tmp_path, '%' ) ) )
		{
			end = (TEXTSTR)StrChr( ++subst_path, '%' );
			//lprintf( WIDE( "Found magic subst in string" ) );
			if( end )
			{
				this_length = StrLen( tmp_path );
				tmp = NewArray( TEXTCHAR, len = ( end - subst_path ) + 1 );
				tnprintf( tmp, len * sizeof( TEXTCHAR ), WIDE( "%*.*s" ), (int)(end-subst_path), (int)(end-subst_path), subst_path );
				group = GetFileGroup( tmp, NULL );
				if( group != INVALID_INDEX ) {
					filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
  // must deallocate tmp
					Deallocate( TEXTCHAR*, tmp );
					newest_path = NewArray( TEXTCHAR, len = (subst_path - tmp_path) + StrLen( filegroup->base_path ) + (this_length - (end - tmp_path)) + 1 );
					//=======================================================================
					// Get rid of the ending '%' AND any '/' or '\' that might come after it
					//=======================================================================
					tnprintf( newest_path, len, WIDE( "%*.*s%s/%s" ), (int)((subst_path - tmp_path) - 1), (int)((subst_path - tmp_path) - 1), tmp_path, filegroup->base_path,
						((end + 1)[0] == '/' || (end + 1)[0] == '\\') ? (end + 2) : (end + 1) );
					Deallocate( TEXTCHAR*, tmp_path );
					tmp_path = ExpandPathVariable( newest_path );
					Deallocate( TEXTCHAR*, newest_path );
				}
				else {
					CTEXTSTR external_var = OSALOT_GetEnvironmentVariable( tmp );
					if( external_var ) {
  // must deallocate tmp
						Deallocate( TEXTCHAR*, tmp );
						newest_path = NewArray( TEXTCHAR, len = (subst_path - tmp_path) + StrLen( external_var ) + (this_length - (end - tmp_path)) + 1 );
						//=======================================================================
						// Get rid of the ending '%' AND any '/' or '\' that might come after it
						//=======================================================================
						tnprintf( newest_path, len, WIDE( "%*.*s%s/%s" ), (int)((subst_path - tmp_path) - 1), (int)((subst_path - tmp_path) - 1), tmp_path, external_var,
							((end + 1)[0] == '/' || (end + 1)[0] == '\\') ? (end + 2) : (end + 1) );
						tmp_path = ExpandPathVariable( newest_path );
						Deallocate( TEXTCHAR*, newest_path );
					}
					else
						tmp_path = tmp;
				}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE( "transform subst [%s]" ), tmp_path );
#endif
			}
		}
	}
	return tmp_path;
}
TEXTSTR ExpandPathEx( CTEXTSTR path, struct file_system_interface *fsi )
{
	TEXTSTR tmp_path = NULL;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "input path is [%s]" ), path );
#endif
	if( path )
	{
		if( !fsi && !IsAbsolutePath( path ) )
		{
			if( ( path[0] == '.' ) && ( ( path[1] == 0 ) || ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				TEXTCHAR here[256];
				size_t len;
				GetCurrentPath( here, sizeof( here ) );
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s%s%s" )
						 , here
						 , path[1]?WIDE("/"):WIDE("")
						 , path[1]?(path + 2):WIDE("") );
			}
			else if( ( path[0] == '@' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = GetLibraryPath();
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == '#' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = GetProgramPath();
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == '~' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = OSALOT_GetEnvironmentVariable(WIDE("HOME"));
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == '*' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = (*winfile_local).data_file_root;
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( ( path[0] == ';' ) && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = (*winfile_local).data_file_root;
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( path[0] == '^' && ( ( path[1] == '/' ) || ( path[1] == '\\' ) ) )
			{
				CTEXTSTR here;
				size_t len;
				here = GetStartupPath();
				tmp_path = NewArray( TEXTCHAR, len = ( StrLen( here ) + StrLen( path ) ) );
				tnprintf( tmp_path, len, WIDE( "%s/%s" ), here, path + 2 );
			}
			else if( path[0] == '%' )
			{
				tmp_path = ExpandPathVariable( path );
			}
			else
			{
				tmp_path = StrDup( path );
			}
#if __ANDROID__
			{
				int len_base;
				TEXTCHAR here[256];
				size_t len;
				size_t ofs;
				GetCurrentPath( here, sizeof( here ) );
				if( StrStr( tmp_path, here ) )
					len = StrLen( here );
				else
					len = 0;
		/*
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( "Fix dots in [%s]", tmp_path );
				for( ofs = len+1; tmp_path[ofs]; ofs++ )
				{
					if( tmp_path[ofs] == '/' )
						tmp_path[ofs] = '.';
					if( tmp_path[ofs] == '\\' )
						tmp_path[ofs] = '.';
				}
				if( (*winfile_local).flags.bLogOpenClose )
				lprintf( "Fixed result [%s]", tmp_path );
			*/
			}
#endif
		}
		else if( StrChr( path, '%' ) != NULL )
		{
			tmp_path = ExpandPathVariable( path );
		}
		else
		{
			tmp_path = StrDup( path );
		}
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "output path is [%s]" ), tmp_path );
#endif
	return tmp_path;
}
TEXTSTR ExpandPath( CTEXTSTR path )
{
	return ExpandPathEx( path, NULL );
}
INDEX  SetGroupFilePath ( CTEXTSTR group, CTEXTSTR path )
{
	struct Group *filegroup = GetGroupFilePath( group );
	if( !filegroup )
	{
		TEXTCHAR tmp[256];
		filegroup = New( struct Group );
		filegroup->name = StrDup( group );
		filegroup->base_path = StrDup( path );
		tnprintf( tmp, sizeof( tmp ), WIDE( "file group/%s" ), group );
#ifndef __NO_OPTIONS__
		if( (*winfile_local).have_default )
		{
			TEXTCHAR tmp2[256];
			SACK_GetProfileString( GetProgramName(), tmp, WIDE( "" ), tmp2, sizeof( tmp2 ) );
		if( StrCaseCmp( path, tmp2 ) )
				SACK_WriteProfileString( GetProgramName(), tmp, path );
		}
#endif
		AddLink( &(*winfile_local).groups, filegroup );
		(*winfile_local).have_default = TRUE;
	}
	else
	{
		Deallocate( TEXTCHAR*, filegroup->base_path );
		filegroup->base_path = StrDup( path );
	}
	return FindLink( &(*winfile_local).groups, filegroup );
}
void SetDefaultFilePath( CTEXTSTR path )
{
	TEXTSTR tmp_path = NULL;
	struct Group *filegroup;
	LocalInit();
	filegroup = (struct Group *)GetLink( &(*winfile_local).groups, 0 );
	tmp_path = ExpandPath( path );
	if( (*winfile_local).groups && filegroup )
	{
		Deallocate( TEXTSTR, filegroup->base_path );
		filegroup->base_path = StrDup( tmp_path?tmp_path:path );
	}
	else
	{
		SetGroupFilePath( WIDE( "Default" ), tmp_path?tmp_path:path );
	}
	if( tmp_path )
		Deallocate( TEXTCHAR*, tmp_path );
}
static TEXTSTR PrependBasePathEx( INDEX groupid, struct Group *group, CTEXTSTR filename, LOGICAL expand_path )
{
	TEXTSTR real_filename = filename?ExpandPath( filename ):NULL;
	TEXTSTR fullname;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE("Prepend to {%s} %p %") _size_f, real_filename, group, groupid );
#endif
	if( (*winfile_local).groups )
	{
		//SetDefaultFilePath( GetProgramPath() );
		if( !group )
		{
			if( groupid < 4096 )
				group = (struct Group *)GetLink( &(*winfile_local).groups, groupid );
		}
	}
	if( !group || ( filename && ( IsAbsolutePath( real_filename ) ) ) )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("already an absolute path.  [%s]"), real_filename );
#endif
		return real_filename;
	}
	{
		TEXTSTR tmp_path;
		size_t len;
		if( expand_path )
			tmp_path = ExpandPath( group->base_path );
		else
			tmp_path = group->base_path;
		fullname = NewArray( TEXTCHAR, len = StrLen( filename ) + StrLen(tmp_path) + 2 );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf(WIDE("prepend %s[%s] with %s"), group->base_path, tmp_path, filename );
#endif
		tnprintf( fullname, len, WIDE("%s/%s"), tmp_path, real_filename );
		{
			// resolve recusive % paths...
			TEXTSTR tmp2 = ExpandPath( fullname );
			Deallocate( TEXTSTR, fullname );
			fullname = tmp2;
		}
#if __ANDROID__
		{
			int len_base;
			static TEXTCHAR here[256];
			static size_t len;
			size_t ofs;
			if( !here[0] )
			{
				GetCurrentPath( here, sizeof( here ) );
			}
			if( StrStr( tmp_path, here ) )
				len = StrLen( here );
			else
				len = 0;
		/*
			if( (*winfile_local).flags.bLogOpenClose )
				lprintf( WIDE("Fix dots in [%s]"), fullname );
			for( ofs = len+1; fullname[ofs]; ofs++ )
			{
				if( fullname[ofs] == '/' )
					fullname[ofs] = '.';
				if( fullname[ofs] == '\\' )
					fullname[ofs] = '.';
			}
		*/
		}
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("result %s"), fullname );
#endif
		if( expand_path )
			Deallocate( TEXTCHAR*, tmp_path );
		Deallocate( TEXTCHAR*, real_filename );
	}
	return fullname;
}
static TEXTSTR PrependBasePath( INDEX groupid, struct Group *group, CTEXTSTR filename )
{
   return PrependBasePathEx(groupid,group,filename,TRUE );
}
TEXTSTR sack_prepend_path( INDEX group, CTEXTSTR filename )
{
	struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
	TEXTSTR result = PrependBasePath( group, filegroup, filename );
	return result;
}
#ifdef __LINUX__
#define HANDLE int
#define INVALID_HANDLE_VALUE -1
#endif
static void DetectUnicodeBOM( FILE *file ) {
   //00 00 FE FF     UTF-32, big-endian
   //FF FE 00 00     UTF-32, little-endian
   //FE FF           UTF-16, big-endian
   //FF FE           UTF-16, little-endian
   //EF BB BF        UTF-8
//Encoding	Representation (hexadecimal)	Representation (decimal)	Bytes as CP1252 characters
//UTF-8[t 1]		EF BB BF		239 187 191
//UTF-16 (BE)		FE FF			254 255
//UTF-16 (LE)		FF FE			255 254
//UTF-32 (BE)		00 00 FE FF		0 0 254 255
//UTF-32 (LE)		FF FE 00 00[t 2]	255 254 0 0
//UTF-7[t 1]		2B 2F 76 38             43 47 118 56	+/v9
//			2B 2F 76 39		43 47 118 43	+/v+
//			2B 2F 76 2B             43 47 118 47	+/v/
//			2B 2F 76 2F[t 3]	43 47 118 57	+/v8
//			2B 2F 76 38 2D[t 4]	43 47 118 56 45	+/v8-
//
//UTF-1[t 1]		F7 64 4C	247 100 76
//UTF-EBCDIC[t 1]	DD 73 66 73	221 115 102 115
//SCSU[t 1]		0E FE FF[t 5]	14 254 255
//BOCU-1[t 1]		FB EE 28	251 238 40
//GB-18030[t 1]		84 31 95 33	132 49 149 51
	struct file* _file = (struct file*)file;
	// file was opened with 't' flag, test what sort of 't' the file might be.
	// can result in conversion based on UNICODE (utf-16) compilation flag is set or not (UTF8).
	if( _file->textmode == TM_UNKNOWN ) {
		uint8_t bytes[5];
		enum textModes textmode = _file->textmode;
		size_t bytelength;
		_file->textmode = TM_BINARY;
		bytelength = sack_fread( bytes, 1, 5, file );
		sack_fseek( file, 0, SEEK_SET );
		if( bytelength < 5 ) {
			size_t n;
			for( n = bytelength; n < 5; n++ )
				bytes[n] = 0;
		}
		if( bytes[0] == 0xEF ) {
			// UTF8 test
			if( bytes[1] == 0xBB && bytes[2] == 0xBF ) {
				_file->textmode = TM_UTF8;
				sack_fseek( file, 3, SEEK_SET );
			} else {
				_file->textmode = TM_UTF8;
			}
		} else if( bytes[0] == 0xFF ) {
			// UTF32/16 LE test
			if( bytes[1] == 0xFE ) {
				if( bytes[2] == 0 && bytes[3] == 0 ) {
					_file->textmode = TM_UTF32LE;
				}
			}
		} else if( bytes[0] == 0xFE ) {
			// UTF16ZBE test
			if( bytes[1] == 0xFF ) {
				_file->textmode = TM_UTF16BE;
			} else {
				_file->textmode = TM_UTF8;
			}
		} else if( bytes[0] == 0 && bytes[1] == 0 ) {
			// UTF32BE test...
			if( bytes[2] == 0xFE && bytes[3] == 0xFF ) {
				_file->textmode = TM_UTF32BE;
			} else
				_file->textmode = TM_UTF8;
		} else {
		}
	}
}
static void DecodeFopenOpts( struct file *file, CTEXTSTR opts ) {
	CTEXTSTR op = opts;
	for( ; op[0]; op++ ) {
		if( op[0] == 'w' || op[0] == 'a' || op[0] == 'r' || op[0] == '+' )
			continue;
		if( op[0] == ' ' ) continue;
		if( op[0] == 't' ) {
         file->textmode = TM_UNKNOWN;
		} else if( op[0] == 'b' ) {
 // also the default.
         file->textmode = TM_BINARY;
		} else if( op[0] == ',' ) {
         const char *restore = op;
			op++;
			while( op[0] == ' ' ) op++;
			if( op[0] == 'c' ) op++; else { op = restore; continue; }
			if( op[0] == 'c' ) op++; else { op = restore; continue; }
			if( op[0] == 's' ) op++; else { op = restore; continue; }
			while( op[0] == ' ' ) op++;
			if( op[0] == '=' ) op++; else { op = restore; continue; }
			while( op[0] == ' ' ) op++;
			if( StrCaseCmpEx( op, "unicode", 7 ) == 0 ) {
				file->textmode = TM_UTF16LE;
 // minus 1, becuase for loop will increment.
            op += 6;
			}
			else if( StrCaseCmpEx( op, "utf-16le", 8 ) == 0 ) {
				file->textmode = TM_UTF16LE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-8", 5 ) == 0 ) ) {
				file->textmode = TM_UTF8;
 // minus 1, becuase for loop will increment.
            op += 4;
			}
			else if( ( StrCaseCmpEx( op, "utf-16be", 8 ) == 0 ) ) {
				file->textmode = TM_UTF16BE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-32le", 8 ) == 0 ) ) {
				file->textmode = TM_UTF32LE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
			else if( ( StrCaseCmpEx( op, "utf-32be", 8 ) == 0 ) ) {
				file->textmode = TM_UTF32BE;
 // minus 1, becuase for loop will increment.
            op += 7;
			}
		}
	}
}
HANDLE sack_open( INDEX group, CTEXTSTR filename, int opts, ... )
{
	HANDLE handle;
	struct file *file;
	INDEX idx;
	EnterCriticalSec( &(*winfile_local).cs_files );
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		if( StrCmp( file->name, filename ) == 0 )
		{
			break;
		}
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	if( !file )
	{
		struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
		file = New( struct file );
		file->name = StrDup( filename );
		file->fullname = PrependBasePath( group, filegroup, filename );
		file->handles = NULL;
		file->files = NULL;
		file->group = group;
		EnterCriticalSec( &(*winfile_local).cs_files );
		AddLink( &(*winfile_local).files,file );
		LeaveCriticalSec( &(*winfile_local).cs_files );
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Open File: [%s]" ), file->fullname );
#endif
#ifdef __LINUX__
#  undef open
	{
#  ifdef UNICODE
		char *tmpfile = CStrDup( file->fullname );
		handle = open( tmpfile, opts );
		Deallocate( char *, tmpfile );
#  else
		handle = open( file->fullname, opts );
#  endif
	}
#  if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "open %s %d %d" ), file->fullname, handle, opts );
#  endif
#else
	switch( opts & 3 )
	{
	case 0:
	handle = CreateFile( file->fullname
							, GENERIC_READ
							, FILE_SHARE_READ
							, NULL
							, ((opts&O_CREAT)?CREATE_ALWAYS:OPEN_EXISTING)
							, FILE_ATTRIBUTE_NORMAL
							, NULL );
	break;
	case 1:
	handle = CreateFile( file->fullname
							, GENERIC_WRITE
							, FILE_SHARE_READ|FILE_SHARE_WRITE
							, NULL
							, ((opts&O_CREAT)?CREATE_ALWAYS:OPEN_EXISTING)
							, FILE_ATTRIBUTE_NORMAL
							, NULL );
		break;
	case 2:
	case 3:
	handle = CreateFile( file->fullname
							,(GENERIC_READ|GENERIC_WRITE)
							, FILE_SHARE_READ|FILE_SHARE_WRITE
							, NULL
							, ((opts&O_CREAT)?CREATE_ALWAYS:OPEN_EXISTING)
							, FILE_ATTRIBUTE_NORMAL
							, NULL );
	break;
	}
#  if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "open %s %p %08x" ), file->fullname, (POINTER)handle, opts );
#  endif
#endif
	if( handle == INVALID_HANDLE_VALUE )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open file [%s]=[%s]" ), file->name, file->fullname );
#endif
		return INVALID_HANDLE_VALUE;
	}
	if( handle != INVALID_HANDLE_VALUE )
	{
		HANDLE *holder = New( HANDLE );
		holder[0] = handle;
		AddLink( &file->handles, holder );
	}
	return handle;
}
#ifdef WIN32
HANDLE sack_openfile( INDEX group,CTEXTSTR filename, OFSTRUCT *of, int flags )
{
#ifdef _UNICODE
	char *tmpname = WcharConvert( filename );
#undef OpenFile
	HANDLE result = (HANDLE)OpenFile(tmpname,of,flags);
	Deallocate( char*, tmpname );
	return result;
#else
#undef OpenFile
	return (HANDLE)(uintptr_t)OpenFile(filename,of,flags);
#endif
}
#endif
struct file *FindFileByHandle( HANDLE file_file )
{
	struct file *file;
	INDEX idx;
	EnterCriticalSec( &(*winfile_local).cs_files );
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		INDEX idx2;
		HANDLE* check;
		LIST_FORALL( file->handles, idx2, HANDLE*, check )
		{
			if( check[0] == file_file )
				break;
		}
		if( check )
			break;
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return file;
}
//----------------------------------------------------------------------------
LOGICAL sack_iset_eof ( INDEX file_handle )
{
	HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
	HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
	return SetEndOfFile( handle );
#else
	return ftruncate( handle, lseek( handle, 0, SEEK_CUR ) );
#endif
}
//----------------------------------------------------------------------------
struct file *FindFileByFILE( FILE *file_file )
{
	struct file *file;
	INDEX idx;
	LocalInit();
	EnterCriticalSec( &(*winfile_local).cs_files );
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		INDEX idx2;
		FILE *check;
		LIST_FORALL( file->files, idx2, FILE *, check )
		{
			if( check == file_file )
				break;
		}
		if( check )
			break;
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return file;
}
LOGICAL sack_set_eof ( HANDLE file_handle )
{
	struct file *file;
	file = FindFileByFILE( (FILE*)(uintptr_t)file_handle );
	if( file )
	{
		if( file->mount )
		{
			file->mount->fsi->truncate( (void*)(uintptr_t)file_handle );
			//lprintf( WIDE("result is %d"), file->mount->fsi->size( (void*)file_handle ) );
		}
		else
		{
#ifdef _WIN32
			;
#else
			truncate( file->fullname, sack_ftell( (FILE*)(uintptr_t)file_handle ) );
#endif
		}
		return TRUE;
	}
	else
	{
		HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, (INDEX)file_handle );
		HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		return SetEndOfFile( handle );
#else
		return ftruncate( handle, lseek( handle, 0, SEEK_CUR ) );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_ftruncate( FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file )
	{
		if( file->mount && file->mount->fsi )
		{
			file->mount->fsi->truncate( (void*)file_file );
			//lprintf( WIDE("result is %d"), file->mount->fsi->size( (void*)file_file ) );
		}
		else
		{
#ifdef _WIN32
			_chsize( _fileno( file_file ), ftell( file_file ) );
#else
			truncate( file->fullname, sack_ftell( (FILE*)file_file ) );
#endif
		}
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
long sack_tell( INDEX file_handle )
{
	HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
	HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef WIN32
 // must have GENERIC_READ and/or GENERIC_WRITE
	uint32_t length = SetFilePointer( handle
	// do not move pointer
								, 0
  // hFile is not large enough to need this pointer
								, NULL
  // provides offset from current position
								, FILE_CURRENT);
	return length;
#else
	return lseek( handle, 0, SEEK_SET );
#endif
}
//----------------------------------------------------------------------------
HANDLE sack_creat( INDEX group, CTEXTSTR file, int opts, ... )
{
	return sack_open( group, file, opts | O_CREAT );
}
//----------------------------------------------------------------------------
int sack_lseek( HANDLE file_handle, int pos, int whence )
{
#ifdef _WIN32
	return SetFilePointer(file_handle,pos,NULL,whence);
#else
	return lseek( file_handle, pos, whence );
#endif
}
//----------------------------------------------------------------------------
int sack_read( HANDLE file_handle, POINTER buffer, int size )
{
#ifdef _WIN32
	DWORD dwLastReadResult;
	//lprintf( WIDE( "..." ) );
	return (ReadFile( (HANDLE)file_handle, buffer, size, &dwLastReadResult, NULL )?dwLastReadResult:-1 );
#else
	return read( file_handle, buffer, size );
#endif
}
//----------------------------------------------------------------------------
int sack_write( HANDLE file_handle, CPOINTER buffer, int size )
{
#ifdef _WIN32
	DWORD dwLastWrittenResult;
	return (WriteFile( (HANDLE)file_handle, (POINTER)buffer, size, &dwLastWrittenResult, NULL )?dwLastWrittenResult:-1 );
#else
	return write( file_handle, buffer, size );
#endif
}
//----------------------------------------------------------------------------
INDEX sack_icreat( INDEX group, CTEXTSTR file, int opts, ... )
{
	return sack_iopen( group, file, opts | O_CREAT );
}
//----------------------------------------------------------------------------
int sack_close( HANDLE file_handle )
{
	struct file *file = FindFileByHandle( (HANDLE)file_handle );
	if( file )
	{
		SetLink( &file->handles, (INDEX)file_handle, NULL );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("Close %s"), file->fullname );
#endif
		/*
		Deallocate( TEXTCHAR*, file->name );
		Deallocate( TEXTCHAR*, file->fullname );
		Deallocate( TEXTCHAR*, file );
		DeleteLink( &(*winfile_local).files, file );
		*/
	}
	if( file_handle != INVALID_HANDLE_VALUE )
#ifdef _WIN32
		return CloseHandle((HANDLE)file_handle);
#else
		return close( file_handle );
#endif
	return 0;
}
//----------------------------------------------------------------------------
INDEX sack_iopen( INDEX group, CTEXTSTR filename, int opts, ... )
{
	HANDLE h;
	INDEX result;
	h = sack_open( group, filename, opts );
	if( h == INVALID_HANDLE_VALUE )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open %s" ), filename );
#endif
		return INVALID_INDEX;
	}
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		HANDLE *holder = New( HANDLE );
		holder[0] = h;
		AddLink( &(*winfile_local).handles, holder );
		result = FindLink( &(*winfile_local).handles, holder );
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "return iopen of [%s]=%p(%")_size_f WIDE(")?" ), filename, (void*)(uintptr_t)h, (size_t)result );
#endif
	return result;
}
//----------------------------------------------------------------------------
int sack_iclose( INDEX file_handle )
{
	int result;
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
		SetLink( &(*winfile_local).handles, file_handle, 0 );
		Deallocate( HANDLE*, holder );
		result = sack_close( handle );
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return result;
}
//----------------------------------------------------------------------------
int sack_ilseek( INDEX file_handle, size_t pos, int whence )
{
	int result;
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		 HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		 HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		result = SetFilePointer(handle,(LONG)pos,NULL,whence);
#else
		result = lseek( handle, pos, whence );
#endif
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return result;
}
//----------------------------------------------------------------------------
int sack_iread( INDEX file_handle, POINTER buffer, int size )
{
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		 HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		 HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		DWORD dwLastReadResult;
		//lprintf( WIDE( "... %p %p" ), file_handle, h );
		LeaveCriticalSec( &(*winfile_local).cs_files );
		return (ReadFile( handle, (POINTER)buffer, size, &dwLastReadResult, NULL )?dwLastReadResult:-1 );
#else
		return read( handle, buffer, size );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_iwrite( INDEX file_handle, CPOINTER buffer, int size )
{
	EnterCriticalSec( &(*winfile_local).cs_files );
	{
		 HANDLE *holder = (HANDLE*)GetLink( &(*winfile_local).handles, file_handle );
		 HANDLE handle = holder?holder[0]:INVALID_HANDLE_VALUE;
#ifdef _WIN32
		DWORD dwLastWrittenResult;
		LeaveCriticalSec( &(*winfile_local).cs_files );
		return (WriteFile( handle, (POINTER)buffer, size, &dwLastWrittenResult, NULL )?dwLastWrittenResult:-1 );
#else
		return write( handle, buffer, size );
#endif
	}
}
//----------------------------------------------------------------------------
int sack_unlinkEx( INDEX group, CTEXTSTR filename, struct file_system_mounted_interface *mount )
{
	while( mount )
	{
		int okay = 1;
		if( mount->fsi )
		{
#ifdef UNICODE
			char *_filename = CStrDup( filename );
#  define filename _filename
#endif
			if( mount->fsi->exists( mount->psvInstance, filename ) )
			{
				mount->fsi->_unlink( mount->psvInstance, filename );
				okay = 0;
			}
#ifdef UNICODE
			Deallocate( char *, _filename );
#  undef filename
#endif
		}
		else
		{
			TEXTSTR tmp = PrependBasePath( group, NULL, filename );
#ifdef WIN32
			okay = DeleteFile(tmp);
#else
#  ifdef UNICODE
			char *_filename = CStrDup( filename );
#    define filename _filename
#  endif
			okay = unlink( filename );
#  ifdef UNICODE
			Deallocate( char *, _filename );
#    undef filename
#  endif
#endif
			Deallocate( TEXTCHAR*, tmp );
		}
		if( !okay )
			return !okay;
		mount = mount->next;
	}
	return 0;
}
//----------------------------------------------------------------------------
int sack_unlink( INDEX group, CTEXTSTR filename )
{
	return sack_unlinkEx( group, filename, (*winfile_local).mounted_file_systems );
}
//----------------------------------------------------------------------------
int sack_rmdir( INDEX group, CTEXTSTR filename )
{
#ifdef __LINUX__
	int okay;
	TEXTSTR tmp = PrependBasePath( group, NULL, filename );
#ifdef UNICODE
	char *tmpname = CStrDup( tmp );
	okay = rmdir( tmpname );
	Deallocate( char*, tmpname );
#else
	okay = rmdir( filename );
#endif
	Deallocate( TEXTCHAR*, tmp );
 // unlink returns TRUE is 0, else error...
	return !okay;
#else
	int okay;
	TEXTSTR tmp = PrependBasePath( group, NULL, filename );
	okay = RemoveDirectory(tmp);
	Deallocate( TEXTCHAR*, tmp );
 // unlink returns TRUE is 0, else error...
	return !okay;
#endif
}
#undef open
#undef fopen
//----------------------------------------------------------------------------
FILE * sack_fopenEx( INDEX group, CTEXTSTR filename, CTEXTSTR opts, struct file_system_mounted_interface *mount )
{
	FILE *handle = NULL;
	struct file *file;
	INDEX idx;
	LOGICAL memalloc = FALSE;
	LOGICAL single_mount = (mount != NULL );
	LocalInit();
	EnterCriticalSec( &(*winfile_local).cs_files );
	if( !mount )
		mount = (*winfile_local).mounted_file_systems;
	if( !StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		while( mount )
  // skip roms...
		{
			//lprintf( "check mount %p %d", mount, mount->writeable );
			if( mount->writeable )
				break;
			mount = mount->next;
		}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE("open %s %p(%s) %s (%d)"), filename, mount, mount->name, opts, mount?mount->writeable:1 );
#endif
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		if( ( file->group == group )
			&& ( StrCmp( file->name, filename ) == 0 )
			&& ( file->mount == mount ) )
		{
			break;
		}
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	if( !file )
	{
		TEXTSTR tmpname = NULL;
		struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
		file = New( struct file );
		memalloc = TRUE;
		DecodeFopenOpts( file, opts );
		if( StrChr( filename, '%' ) )
		{
			tmpname = ExpandPathVariable( filename );
			filename = tmpname;
		}
		if( (filename[0] == '@') || (filename[0] == '*') || (filename[0] == '~') )
		{
			tmpname = ExpandPathEx( filename, NULL );
			filename = tmpname;
		}
		file->handles = NULL;
		file->files = NULL;
		file->name = StrDup( filename );
		file->mount = mount;
		if( ( !file->mount || !file->mount->fsi ) && !IsAbsolutePath( filename ) )
		{
			tmpname = ExpandPath( filename );
			file->fullname = PrependBasePath( group, filegroup, tmpname );
			Deallocate( TEXTCHAR*, tmpname );
		}
		else
		{
			if( mount && group == 0 )
			{
				file->fullname = StrDup( file->name );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE("full is %s"), file->fullname );
#endif
			}
			else
			{
				TEXTSTR tmp;
				tmp = PrependBasePathEx( group, filegroup, file->name, !mount );
				file->fullname = ExpandPath( tmp );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE("full is %s %d"), file->fullname, (int)group );
#endif
				Deallocate( TEXTSTR, tmp );
			}
			//file->fullname = file->name;
		}
		file->group = group;
		if( (file->fullname[0] == '@') || (file->fullname[0] == '*') || (file->fullname[0] == '~') )
		{
			TEXTSTR tmpname = ExpandPathEx( file->fullname, NULL );
			Deallocate( TEXTSTR, file->fullname );
			file->fullname = tmpname;
		}
		if( StrChr( file->fullname, '%' ) )
		{
			if( memalloc )
			{
				DeleteLink( &(*winfile_local).files, file );
				Deallocate( TEXTCHAR*, file->name );
				Deallocate( TEXTCHAR*, file->fullname );
				Deallocate( struct file *, file );
			}
			//DebugBreak();
			return NULL;
		}
		EnterCriticalSec( &(*winfile_local).cs_files );
		AddLink( &(*winfile_local).files,file );
		LeaveCriticalSec( &(*winfile_local).cs_files );
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Open File: [%s]" ), file->fullname );
#endif
	if( mount && mount->fsi )
	{
		if( StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		{
			struct file_system_mounted_interface *test_mount = mount;
			while( !handle && test_mount )
			{
				if( test_mount->fsi )
				{
#if UNICODE
					char *_fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
					file->mount = test_mount;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
					if( (*winfile_local).flags.bLogOpenClose )
						lprintf( WIDE("Call mount %s to check if file exists %s"), test_mount->name, file->fullname );
#endif
					if( test_mount->fsi->exists( test_mount->psvInstance, _fullname ) )
					{
						handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
					}
					else if( single_mount )
					{
#if UNICODE
						Deallocate( char *, _fullname );
#else
#  undef _fullname
#endif
						return NULL;
					}
#if UNICODE
					Deallocate( char *, _fullname );
#endif
				}
				else
					goto default_fopen;
				test_mount = test_mount->next;
			}
		}
		else
		{
			struct file_system_mounted_interface *test_mount = mount;
			//lprintf( "full is %s", file->fullname );
			while( !handle && test_mount )
			{
				file->mount = test_mount;
				if( test_mount->fsi && test_mount->writeable )
				{
#ifdef UNICODE
					char* _fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
					if( (*winfile_local).flags.bLogOpenClose )
						lprintf( WIDE("Call mount %s to open file %s"), test_mount->name, file->fullname );
#endif
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
#ifdef UNICODE
					Deallocate( char*, _fullname );
#else
#  undef _fullname
#endif
				}
				else
					goto default_fopen;
				test_mount = test_mount->next;
			}
		}
	}
	if( !handle )
	{
default_fopen:
		//file->mount = NULL;
#ifdef __LINUX__
#  ifdef UNICODE
		char *tmpname = CStrDup( file->fullname );
		char *tmpopts = CStrDup( opts );
		handle = fopen( tmpname, tmpopts );
		Deallocate( char*, tmpname );
		Deallocate( char*, tmpopts );
#  else
		handle = fopen( file->fullname, opts );
#  endif
#else
#  ifdef _STRSAFE_H_INCLUDED_
#    ifdef UNICODE
		char *tmpname = CStrDup( file->fullname );
		char *tmpopts = CStrDup( opts );
		fopen_s( &handle, tmpname, tmpopts );
		Deallocate( char*, tmpname );
		Deallocate( char*, tmpopts );
#    else
		{
			wchar_t *tmp = CharWConvert( file->fullname );
			wchar_t *wopts = CharWConvert( opts );
			handle = _wfopen( tmp, wopts );
			//_wfopen_s( &handle, tmp, wopts );
			Deallocate( wchar_t *, tmp );
			Deallocate( wchar_t *, wopts );
		}
#    endif
#  else
		handle = fopen( file->fullname, opts );
#  endif
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("native opened %s"), file->fullname );
#endif
	}
	if( !handle )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open file [%s]=[%s]" ), file->name, file->fullname );
#endif
		DeleteLink( &(*winfile_local).files, file );
		Deallocate( TEXTCHAR*, file->name );
		Deallocate( TEXTCHAR*, file->fullname );
		Deallocate( struct file*, file );
		return NULL;
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "sack_open %s (%s)" ), file->fullname, opts );
#endif
	AddLink( &file->files, handle );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Added FILE* %p and list is %p" ), handle, file->files );
#endif
	return handle;
}
//----------------------------------------------------------------------------
FILE*  sack_fopen ( INDEX group, CTEXTSTR filename, CTEXTSTR opts )
{
	return sack_fopenEx( group, filename, opts, NULL );
}
//----------------------------------------------------------------------------
FILE*  sack_fsopenEx( INDEX group
					 , CTEXTSTR filename
					 , CTEXTSTR opts
					 , int share_mode
					 , struct file_system_mounted_interface *mount )
{
	FILE *handle = NULL;
	struct file *file;
	INDEX idx;
	LOGICAL single_mount = ( mount != NULL );
	LocalInit();
	EnterCriticalSec( &(*winfile_local).cs_files );
	if( !mount )
		mount = (*winfile_local).mounted_file_systems;
	if( !StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		while( mount )
  // skip roms...
		{
			//lprintf( "check mount %p %d", mount, mount->writeable );
			if( mount->writeable )
				break;
			mount = mount->next;
		}
	LIST_FORALL( (*winfile_local).files, idx, struct file *, file )
	{
		if( ( file->group == group )
			&& ( StrCmp( file->name, filename ) == 0 )
			&& ( file->mount == mount ) )
		{
			break;
		}
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	if( !file )
	{
		struct Group *filegroup = (struct Group *)GetLink( &(*winfile_local).groups, group );
		file = New( struct file );
      DecodeFopenOpts( file, opts );
		file->handles = NULL;
		file->files = NULL;
		file->name = StrDup( filename );
		file->group = group;
		file->mount = mount;
		if( !mount || !mount->fsi )
			file->fullname = PrependBasePath( group, filegroup, filename );
		else
			file->fullname = StrDup( filename );
		EnterCriticalSec( &(*winfile_local).cs_files );
		AddLink( &(*winfile_local).files,file );
		LeaveCriticalSec( &(*winfile_local).cs_files );
	}
	if( mount && mount->fsi )
	{
		if( StrChr( opts, 'r' ) && !StrChr( opts, '+' ) )
		{
			struct file_system_mounted_interface *test_mount = mount;
			while( !handle && test_mount && test_mount->fsi )
			{
#ifdef UNICODE
				char *_fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
				file->mount = test_mount;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
				if( (*winfile_local).flags.bLogOpenClose )
					lprintf( WIDE("Call mount %s to check if file exists %s"), test_mount->name, file->fullname );
#endif
				if( test_mount->fsi->exists( test_mount->psvInstance, _fullname ) )
				{
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
				}
#ifdef UNICODE
				Deallocate( char *, _fullname );
#else
#  undef _fullname
#endif
				if( !handle && single_mount )
				{
					return NULL;
				}
				test_mount = test_mount->next;
			}
		}
		else
		{
			struct file_system_mounted_interface *test_mount = mount;
			//lprintf( "full is %s", file->fullname );
			while( !handle && test_mount )
			{
				file->mount = test_mount;
				if( test_mount->fsi && test_mount->writeable )
				{
#ifdef UNICODE
					char* _fullname = CStrDup( file->fullname );
#else
#  define _fullname file->fullname
#endif
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
					if( (*winfile_local).flags.bLogOpenClose )
						lprintf( WIDE("Call mount %s to open file %s"), test_mount->name, file->fullname );
#endif
					handle = (FILE*)test_mount->fsi->open( test_mount->psvInstance, _fullname, opts );
#ifdef UNICODE
					Deallocate( char*, _fullname );
#else
#  undef _fullname
#endif
				}
				else
					goto default_fopen;
				test_mount = test_mount->next;
			}
		}
			//file->fsi = mount?mount->fsi:NULL;
	}
	if( !handle )
	{
default_fopen:
#ifdef __LINUX__
#  ifdef UNICODE
		char *tmpname = CStrDup( file->fullname );
		char *tmpopts = CStrDup( opts );
		handle = fopen( tmpname, tmpopts );
		Deallocate( char*, tmpname );
		Deallocate( char*, tmpopts );
#  else
		handle = fopen( file->fullname, opts );
#  endif
#else
		{
			wchar_t *tmp = CharWConvert( file->fullname );
			wchar_t *wopts = CharWConvert( opts );
			handle = _wfsopen( tmp, wopts, share_mode );
			Deallocate( wchar_t *, tmp );
			Deallocate( wchar_t *, wopts );
		}
#endif
	}
	if( !handle )
	{
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "Failed to open file [%s]=[%s]" ), file->name, file->fullname );
#endif
		return NULL;
	}
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "sack_open %s (%s)" ), file->fullname, opts );
#endif
	EnterCriticalSec( &(*winfile_local).cs_files );
	AddLink( &file->files, handle );
	LeaveCriticalSec( &(*winfile_local).cs_files );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
	if( (*winfile_local).flags.bLogOpenClose )
		lprintf( WIDE( "Added FILE* %p and list is %p" ), handle, file->files );
#endif
	return handle;
}
//----------------------------------------------------------------------------
FILE*  sack_fsopen( INDEX group, CTEXTSTR filename, CTEXTSTR opts, int share_mode )
{
/*(*winfile_local).mounted_file_systems*/
	return sack_fsopenEx( group, filename, opts, share_mode, NULL );
}
//----------------------------------------------------------------------------
static size_t sack_fsizeEx ( FILE *file_file, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
		return mount->fsi->size( file_file );
	{
		size_t here = ftell( file_file );
		size_t length;
		fseek( file_file, 0, SEEK_END );
		length = ftell( file_file );
		fseek( file_file, (long)here, SEEK_SET );
		return length;
	}
}
size_t sack_fsize ( FILE *file_file ) {
	struct file *file;
	file = FindFileByFILE( file_file );
	return sack_fsizeEx( file_file, file?file->mount:NULL );
}
static size_t sack_ftellEx ( FILE *file_file, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
		return mount->fsi->tell( file_file );
	return ftell( file_file );
}
size_t sack_ftell ( FILE *file_file ) {
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return sack_ftellEx(  file_file, file->mount );
	return sack_ftellEx( file_file, NULL );
}
size_t  sack_fseekEx ( FILE *file_file, size_t pos, int whence, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
	{
		return mount->fsi->seek( file_file, pos, whence );
	}
	if( fseek( file_file, (long)pos, whence ) )
		return -1;
	//struct file *file = FindFileByFILE( file_file );
	return ftell( file_file );
}
size_t  sack_fseek ( FILE *file_file, size_t pos, int whence ){
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
		return sack_fseekEx( file_file, pos, whence, file->mount );
	return sack_fseekEx( file_file, pos, whence, NULL );
}
static int  sack_fflushEx ( FILE *file_file, struct file_system_mounted_interface *mount )
{
	if( mount && mount->fsi )
	{
		return mount->fsi->flush( file_file );
		//DeleteLink( &file->files, file_file );
		//file->fsi->close( file_file );
		//file_file = (FILE*)file->fsi->open( file->fullname );
		//AddLink( &file->files, file_file );
		//return 0;
	}
	return fflush( file_file );
}
int  sack_fflush ( FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
	{
		return sack_fflushEx( file_file, file->mount );
	}
	return fflush( file_file );
}
//----------------------------------------------------------------------------
int  sack_fclose ( FILE *file_file )
{
	struct file *file;
	if( !file_file ) return -1;
	EnterCriticalSec( &(*winfile_local).cs_files );
	file = FindFileByFILE( file_file );
	if( file )
	{
		int status;
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE("Closing %s"), file->fullname );
#endif
		if( file->mount && file->mount->fsi )
			status = file->mount->fsi->_close( file_file );
		else
			status = fclose( file_file );
#if !defined( __NO_OPTIONS__ ) && !defined( __FILESYS_NO_FILE_LOGGING__ )
		if( (*winfile_local).flags.bLogOpenClose )
			lprintf( WIDE( "deleted FILE* %p and list is %p" ), file_file, file->files );
#endif
		DeleteLink( &file->files, file_file );
		if( !GetLinkCount( file->files ) ) {
			DeleteLink( &(*winfile_local).files, file );
			LeaveCriticalSec( &(*winfile_local).cs_files );
			DeleteListEx( &file->files DBG_SRC );
			Deallocate( TEXTCHAR*, file->name );
			Deallocate( TEXTCHAR*, file->fullname );
			Deallocate( struct file*, file );
		}
		else
			LeaveCriticalSec( &(*winfile_local).cs_files );
		return status;
	}
	LeaveCriticalSec( &(*winfile_local).cs_files );
	return fclose( file_file );
}
//----------------------------------------------------------------------------
static void transcodeOutputText( struct file *file, POINTER buffer, size_t size, POINTER *outbuf, size_t *outsize ) {
}
//----------------------------------------------------------------------------
static void transcodeInputText( struct file *file, POINTER buffer, size_t size, POINTER *outbuf, size_t *outsize ) {
}
//----------------------------------------------------------------------------
size_t  sack_fread ( POINTER buffer, size_t size, int count,FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file->mount && file->mount->fsi )
		return file->mount->fsi->_read( file_file, (char*)buffer, size * count );
	return fread( buffer, size, count, file_file );
}
//----------------------------------------------------------------------------
size_t  sack_fwrite ( CPOINTER buffer, size_t size, int count,FILE *file_file )
{
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
	{
		size_t result;
		if( file->mount->fsi->copy_write_buffer && file->mount->fsi->copy_write_buffer() )
		{
			POINTER dupbuf = malloc( size*count + 3 );
			memcpy( dupbuf, buffer, size*count );
			result = file->mount->fsi->_write( file_file, (const char*)dupbuf, size * count );
			free( dupbuf );
		}
		else
			result = file->mount->fsi->_write( file_file, (const char*)buffer, size * count );
		return result;
	}
	return fwrite( (POINTER)buffer, size, count, file_file );
}
//----------------------------------------------------------------------------
TEXTSTR sack_fgets ( TEXTSTR buffer, size_t size,FILE *file_file )
{
#ifdef _UNICODE
	//char *tmpbuf = NewArray( char, size+1);
	//TEXTSTR tmp_wbuf;
	fgets( (char*)buffer, size, file_file );
	//tmp_wbuf = CharWConvert( tmpbuf );
	//StrCpyEx( buffer, tmp_wbuf, size );
	return buffer;
#else
	struct file *file;
	file = FindFileByFILE( file_file );
	if( file && file->mount && file->mount->fsi )
	{
		size_t n;
		char *output = buffer;
		size = size-1;
		buffer[size] = 0;
		for( n = 0; n < size; n++ )
		{
			if( file->mount->fsi->_read( file_file, output, 1 ) )
			{
				if( output[0] == '\n' )
				{
					output[1] = 0;
					break;
				}
				output++;
			}
			else
			{
				output[0] = 0;
				break;
			}
		}
		if( n )
			return buffer;
		return NULL;
	}
	return fgets( buffer, (int)size, file_file );
#endif
}
//----------------------------------------------------------------------------
LOGICAL sack_existsEx ( const char *filename, struct file_system_mounted_interface *fsi )
{
	FILE *tmp;
	if( fsi && fsi->fsi && fsi->fsi->exists )
	{
		int result = fsi->fsi->exists( fsi->psvInstance, filename );
		return result;
	}
	else if( ( tmp = fopen( filename, "rb" ) ) )
	{
		fclose( tmp );
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_exists( const char * filename )
{
	struct file_system_mounted_interface *mount = (*winfile_local).mounted_file_systems;
	while( mount )
	{
		if( sack_existsEx( filename, mount ) )
		{
			(*winfile_local).last_find_mount = mount;
			return TRUE;
		}
		mount = mount->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_isPathEx ( const char *filename, struct file_system_mounted_interface *fsi )
{
	FILE *tmp;
	if( fsi && fsi->fsi && fsi->fsi->exists )
	{
		int result = fsi->fsi->is_directory( fsi->psvInstance, filename );
		return result;
	}
	else if( ( tmp = fopen( filename, "rb" ) ) )
	{
		fclose( tmp );
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL sack_isPath( const char * filename )
{
	struct file_system_mounted_interface *mount = (*winfile_local).mounted_file_systems;
	while( mount )
	{
		if( sack_isPathEx( filename, mount ) )
		{
			(*winfile_local).last_find_mount = mount;
			return TRUE;
		}
		mount = mount->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
int  sack_renameEx ( CTEXTSTR file_source, CTEXTSTR new_name, struct file_system_mounted_interface *mount )
{
	int status;
	if( mount && mount->fsi )
	{
		return mount->fsi->rename( mount->psvInstance, file_source, new_name );
	}
	else
	{
		TEXTSTR tmp_src = ExpandPath( file_source );
		TEXTSTR tmp_dst = ExpandPath( new_name );
#ifdef WIN32
		status = MoveFile( tmp_src, tmp_dst );
#else
#  ifdef UNICODE
		{
			char *tmpnames = CStrDup( tmp_src );
			char *tmpnamed = CStrDup( tmp_dst );
			status = rename( tmpnames, tmpnamed );
			Deallocate( char*, tmpnames );
			Deallocate( char*, tmpnamed );
		}
#  else
		status = rename( tmp_src, tmp_dst );
#  endif
#endif
		Deallocate( TEXTSTR, tmp_src );
		Deallocate( TEXTSTR, tmp_dst );
	}
	return status;
}
//----------------------------------------------------------------------------
int  sack_rename( CTEXTSTR file_source, CTEXTSTR new_name )
{
	return sack_renameEx( file_source, new_name, (*winfile_local).default_mount );
}
//----------------------------------------------------------------------------
size_t GetSizeofFile( TEXTCHAR *name, uint32_t* unused )
{
	size_t size;
#ifdef __LINUX__
#  ifdef UNICODE
	char *tmpname = CStrDup( name );
		  // open MYFILE.TXT
	int hFile = open( tmpname,
			 // open for reading
						  O_RDONLY );
	Deallocate( char*, tmpname );
#  else
		  // open MYFILE.TXT
	int hFile = open( name,
			 // open for reading
						  O_RDONLY );
#  endif
	if( hFile >= 0 )
	{
		size = lseek( hFile, 0, SEEK_END );
		close( hFile );
		return size;
	}
	else
		return 0;
#else
	HANDLE hFile = CreateFile( name, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		size = GetFileSize( hFile, (DWORD*)unused );
		if( sizeof( size ) > 4  && unused )
			size |= (uint64_t)(*unused) << 32;
		CloseHandle( hFile );
		return size;
	}
	else
		return (size_t)-1;
#endif
}
//-------------------------------------------------------------------------
uint32_t GetFileTimeAndSize( CTEXTSTR name
							, LPFILETIME lpCreationTime
							,  LPFILETIME lpLastAccessTime
							,  LPFILETIME lpLastWriteTime
							, int *IsDirectory
							)
{
	uint32_t size;
#ifdef __LINUX__
#  ifdef UNICODE
	char *tmpname = CStrDup( name );
		  // open MYFILE.TXT
	int hFile = open( tmpname,
			 // open for reading
						  O_RDONLY );
	Deallocate( char*, tmpname );
#  else
		  // open MYFILE.TXT
	int hFile = open( name,
			 // open for reading
						  O_RDONLY );
#  endif
	if( hFile >= 0 )
	{
		size = lseek( hFile, 0, SEEK_END );
		close( hFile );
		return size;
	}
	else
		return (uint32_t)-1;
#else
	HANDLE hFile = CreateFile( name, 0, 0, NULL, OPEN_EXISTING, 0, NULL );
	uint32_t extra_size;
	if( hFile != INVALID_HANDLE_VALUE )
	{
		size = GetFileSize( hFile, (DWORD*)&extra_size );
		GetFileTime( hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime );
		if( IsDirectory )
		{
			uint32_t dwAttr = GetFileAttributes( name );
			if( dwAttr & FILE_ATTRIBUTE_DIRECTORY )
				(*IsDirectory) = 1;
			else
				(*IsDirectory) = 0;
		}
		CloseHandle( hFile );
		return size;
	}
	else
		return (uint32_t)-1;
#endif
}
struct file_system_interface *sack_get_filesystem_interface( CTEXTSTR name )
{
	struct file_interface_tracker *fit;
	INDEX idx;
	LIST_FORALL( (*winfile_local).file_system_interface, idx, struct file_interface_tracker *, fit )
	{
		if( StrCaseCmp( fit->name, name ) == 0 )
			return fit->fsi;
	}
	return NULL;
}
void sack_set_default_filesystem_interface( struct file_system_interface *fsi )
{
	(*winfile_local).default_file_system_interface = fsi;
}
void sack_register_filesystem_interface( CTEXTSTR name, struct file_system_interface *fsi )
{
	struct file_interface_tracker *fit = New( struct file_interface_tracker );
	fit->name = StrDup( name );
	fit->fsi = fsi;
	LocalInit();
	AddLink( &(*winfile_local).file_system_interface, fit );
}
static void * CPROC sack_filesys_open( uintptr_t psv, const char *filename, const char *opts );
static int CPROC sack_filesys_close( void*file ) { return fclose(  (FILE*)file ); }
static size_t CPROC sack_filesys_read( void*file, char*buf, size_t len ) { return fread( buf, 1, len, (FILE*)file ); }
static size_t CPROC sack_filesys_write( void*file, const char*buf, size_t len ) { return fwrite( buf, 1, len, (FILE*)file ); }
static size_t CPROC sack_filesys_seek( void*file, size_t pos, int whence ) { return fseek( (FILE*)file, (long)pos, whence ), ftell( (FILE*)file ); }
static int CPROC sack_filesys_unlink( uintptr_t psv, const char*filename ) {
	int okay = 0;
#ifdef UNICODE
	TEXTCHAR *_filename = DupCStr( filename );
#  define filename _filename
#endif
#ifdef WIN32
	okay = DeleteFileA( filename );
#else
	okay = unlink( filename );
#endif
#ifdef UNICODE
	Deallocate( char *, _filename );
#  undef filename
#endif
	return okay;
}
static size_t CPROC sack_filesys_size( void*file ) {
	size_t here = ftell( (FILE*)file );
	size_t length;
	fseek( (FILE*)file, 0, SEEK_END );
	length = ftell( (FILE*)file );
	fseek( (FILE*)file, (long)here, SEEK_SET );
	return length;
}
static size_t CPROC sack_filesys_tell( void*file ) { return ftell( (FILE*)file ); }
static void CPROC sack_filesys_truncate( void*file ) {
#if _WIN32
	_chsize
#else
		ftruncate
#endif
		( fileno( (FILE*)file), ftell((FILE*)file) ); }
static int CPROC sack_filesys_flush( void*file ) { return fflush( (FILE*)file ); }
static int CPROC sack_filesys_exists( uintptr_t psv, const char*file );
static LOGICAL CPROC sack_filesys_rename( uintptr_t psvInstance, const char *original_name, const char *new_name );
static LOGICAL CPROC sack_filesys_copy_write_buffer( void ) { return FALSE; }
struct find_cursor_data {
	char *root;
	char *filemask;
	char *mask;
#ifdef WIN32
	intptr_t findHandle;
	struct _finddata_t fileinfo;
#else
	DIR* handle;
	struct dirent *de;
#endif
};
static	struct find_cursor * CPROC sack_filesys_find_create_cursor ( uintptr_t psvInstance, const char *root, const char *filemask ){
	struct find_cursor_data *cursor = New( struct find_cursor_data );
	char maskbuf[512];
	MemSet( cursor, 0, sizeof( *cursor ) );
	//snprintf( maskbuf, 512, "%s/%s", root ? root : ".", filemask?filemask:"*" );
	snprintf( maskbuf, 512, "%s/%s", root ? root : ".", "*" );
	cursor->mask = StrDup( filemask );
	cursor->root = StrDup( root?root:"." );
// StrDup( filemask ? filemask : "*" );
	cursor->filemask = ExpandPath( maskbuf );
#ifdef WIN32
   // windows mode is delayed until findfirst
#else
	cursor->handle = opendir( root?root:"." );
#endif
	return (struct find_cursor *)cursor;
}
static	int CPROC sack_filesys_find_first( struct find_cursor *_cursor ){
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
	cursor->findHandle = findfirst( cursor->filemask, &cursor->fileinfo );
	if( cursor->findHandle == -1 )
	{
		int err = errno;
		lprintf( "error:%d", err );
	}
	return ( cursor->findHandle != -1 );
#else
	if( cursor->handle ) {
		do {
			cursor->de = readdir( cursor->handle );
		} while( cursor->de && !CompareMask( cursor->mask, cursor->de->d_name, 0 ) );
		return ( cursor->de != NULL );
	}
	return 0;
#endif
}
static	int CPROC sack_filesys_find_close( struct find_cursor *_cursor ){
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
	findclose( cursor->findHandle );
#else
	if( cursor->handle )
		closedir( cursor->handle );
#endif
	Deallocate( char *, cursor->root );
	Deallocate( char *, cursor->mask );
	Deallocate( char *, cursor->filemask );
	Deallocate( struct find_cursor_data *, cursor );
	return 0;
}
static	int CPROC sack_filesys_find_next( struct find_cursor *_cursor ){
   int r;
   struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
   r = !findnext( cursor->findHandle, &cursor->fileinfo );
#else
	do {
		cursor->de = readdir( cursor->handle );
	} while( cursor->de && !CompareMask( cursor->mask, cursor->de->d_name, 0 ) );
   r = (cursor->de != NULL );
#endif
   return r;
}
static	char * CPROC sack_filesys_find_get_name( struct find_cursor *_cursor ){
   struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
#   ifdef UNDER_CE
	return cursor->fileinfo.cFileName;
#   else
	return cursor->fileinfo.name;
#   endif
#else
   return cursor->de->d_name;
#endif
}
static	size_t CPROC sack_filesys_find_get_size( struct find_cursor *_cursor ) {
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
	if( cursor )
		return cursor->fileinfo.size;
	return 0;
#else
	if( cursor ) {
		struct stat s;
		char filename[280];
		snprintf( filename, 280, "%s/%s", cursor->root, cursor->de->d_name );
		if( stat( filename, &s ) ) {
			lprintf( "getsize stat error:%d", errno );
			return -2;
		}
		if( s.st_mode & S_IFREG )
			return s.st_size;
		return -1;
	}
#endif
	return 0;
}
static	LOGICAL CPROC sack_filesys_find_is_directory( struct find_cursor *_cursor ){
	struct find_cursor_data *cursor = (struct find_cursor_data *)_cursor;
#ifdef WIN32
#  ifdef UNDER_CE
	return ( cursor->fileinfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
#  else
	return (cursor->fileinfo.attrib & _A_SUBDIR );
#  endif
#else
	char buffer[MAX_PATH_NAME];
	snprintf( buffer, MAX_PATH_NAME, WIDE("%s%s%s"), cursor->root, cursor->root[0]?"/":"", cursor->de->d_name );
	return IsPath( buffer );
#endif
}
static	LOGICAL CPROC sack_filesys_is_directory( uintptr_t psvInstance, const char *buffer ){
	return IsPath( buffer );
}
static struct file_system_interface native_fsi = {
	sack_filesys_open
		, sack_filesys_close
		, sack_filesys_read
		, sack_filesys_write
		, sack_filesys_seek
		, sack_filesys_truncate
		, sack_filesys_unlink
		, sack_filesys_size
		, sack_filesys_tell
		, sack_filesys_flush
		, sack_filesys_exists
		, sack_filesys_copy_write_buffer
  //( uintptr_t psvInstance, const char *root, const char *filemask );
		, sack_filesys_find_create_cursor
		, sack_filesys_find_first
		, sack_filesys_find_close
		, sack_filesys_find_next
		, sack_filesys_find_get_name
		, sack_filesys_find_get_size
																 , sack_filesys_find_is_directory
																 , sack_filesys_is_directory
 // rename
                                                 , sack_filesys_rename
} ;
PRIORITY_PRELOAD( InitWinFileSysEarly, OSALOT_PRELOAD_PRIORITY - 1 )
{
	LocalInit();
	if( !sack_get_filesystem_interface( WIDE("native") ) )
		sack_register_filesystem_interface( WIDE("native" ), &native_fsi );
	if( !(*winfile_local).default_mount )
		(*winfile_local).default_mount = sack_mount_filesystem( "native", &native_fsi, 1000, (uintptr_t)NULL, TRUE );
}
#if !defined( __NO_OPTIONS__ )
PRELOAD( InitWinFileSys )
{
#  if !defined( __FILESYS_NO_FILE_LOGGING__ )
	(*winfile_local).flags.bLogOpenClose = SACK_GetProfileIntEx( WIDE( "SACK/filesys" ), WIDE( "Log open and close" ), (*winfile_local).flags.bLogOpenClose, TRUE );
#  endif
}
#endif
static void * CPROC sack_filesys_open( uintptr_t psv, const char *filename, const char *opts ) {
	void *result;
#ifdef UNICODE
	TEXTCHAR *_filename = DupCStr( filename );
#  define filename _filename
#endif
	result = fopen( filename, opts );
#ifdef UNICODE
	Deallocate( TEXTCHAR *, _filename );
#  undef filename
#endif
	return result;
}
static int CPROC sack_filesys_exists( uintptr_t psv, const char *filename ) {
	int result;
#ifdef UNICODE
	TEXTSTR _filename = DupCStr( filename );
#define filename _filename
#endif
//(*winfile_local).default_mount );
	result = sack_existsEx( filename, NULL );
#ifdef UNICODE
	Deallocate( TEXTSTR, _filename );
#undef filename
#endif
	return result;
}
struct file_system_mounted_interface *sack_get_default_mount( void ) { return (*winfile_local).default_mount; }
struct file_system_interface * sack_get_mounted_filesystem_interface( struct file_system_mounted_interface *mount ){
	if( mount )
		return mount->fsi;
	return NULL;
}
uintptr_t sack_get_mounted_filesystem_instance( struct file_system_mounted_interface *mount ){
	if( mount )
		return mount->psvInstance;
	return 0;
}
struct file_system_mounted_interface *sack_get_mounted_filesystem( const char *name )
{
	struct file_system_mounted_interface *root = (*winfile_local).mounted_file_systems;
	while( root )
	{
		if( root->name ) if( stricmp( root->name, name ) == 0 ) break;
		root = NextThing( root );
	}
	return root;
}
void sack_unmount_filesystem( struct file_system_mounted_interface *mount )
{
	UnlinkThing( mount );
}
LOGICAL CPROC sack_filesys_rename( uintptr_t psvInstance, const char *original_name, const char *new_name ){
	return sack_renameEx( original_name, new_name, NULL );
}
struct file_system_mounted_interface *sack_mount_filesystem( const char *name, struct file_system_interface *fsi, int priority, uintptr_t psvInstance, LOGICAL writable )
{
	struct file_system_mounted_interface *root = (*winfile_local).mounted_file_systems;
	struct file_system_mounted_interface *mount = New( struct file_system_mounted_interface );
	mount->name = name?strdup( name ):NULL;
	mount->priority = priority;
	mount->psvInstance = psvInstance;
	mount->writeable = writable;
	mount->fsi = fsi;
	//lprintf( "Create mount called %s ", name );
	if( !root || ( root->priority >= priority ) )
	{
		if( !root || root == (*winfile_local).mounted_file_systems )
		{
			LinkThing( (*winfile_local).mounted_file_systems, mount );
		}
		else
		{
			LinkThingBefore( root, mount );
		}
	}
	else while( root )
	{
		if( root->priority >= priority )
		{
			LinkThingBefore( root, mount );
			break;
		}
		if( !NextThing( root ) )
		{
			LinkThingAfter( root, mount );
			break;
		}
		root = NextThing( root );
	}
	return mount;
}
int sack_vfprintf( FILE *file_handle, const char *format, va_list args )
{
	struct file *file;
	file = FindFileByFILE( file_handle );
	if( file->mount && file->mount->fsi )
	{
		PVARTEXT pvt;
		PTEXT output;
		int r;
#ifdef UNICODE
		TEXTCHAR *_format = DupCStr( format );
#define format _format
#endif
		pvt = VarTextCreate();
		vvtprintf( pvt, format, args );
		output = VarTextPeek( pvt );
#ifdef UNICODE
		Deallocate( TEXTCHAR*, _format );
#  undef format
#endif
		r = (int)file->mount->fsi->_write( file_handle, (char*)GetText( output ), GetTextSize( output ) * sizeof( TEXTCHAR ) );
		VarTextDestroy( &pvt );
		return r;
	}
	else
		return vfprintf( file_handle, format, args );
}
int sack_fprintf( FILE *file, const char *format, ... )
{
	va_list args;
	va_start( args, format );
	return sack_vfprintf( file, format, args );
}
int sack_fputs( const char *format,FILE *file )
{
	if( format )
	{
		size_t len = strlen( format );
		return (int)( sack_fwrite( format, 1, (int)len, file ) & 0x7FFFFFFF );
	}
	return 0;
}
LOGICAL SetFileLength( CTEXTSTR path, size_t length )
{
#ifdef __LINUX__
	// files are by default binary in linux
#  ifndef O_BINARY
#	define O_BINARY 0
#  endif
#endif
	INDEX file;
	file = sack_iopen( 0, path, O_RDWR | O_BINARY );
	if( file == INVALID_INDEX )
		return FALSE;
	sack_ilseek( file, length, SEEK_SET );
	sack_iset_eof( file );
	sack_iclose( file );
	return TRUE;
}
FILESYS_NAMESPACE_END
#define NO_UNICODE_C
#ifdef _MSC_VER
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#endif
#if defined( _WIN32 ) && !defined( __TURBOC__ )
 // windows lean_and_mean
#ifndef UNDER_CE
  // findfirst,findnext, fileinfo
#endif
#else
 // opendir etc..
#endif
FILESYS_NAMESPACE
#ifndef MAX_PATH_NAME
#  define MAX_PATH_NAME 512
#endif
// DEBUG_COMPARE 1 == full debug
// DEBUG_COMPARE 2 == quieter debug
#ifdef _DEBUG
#define DEBUG_COMPARE 5
#else
#define DEBUG_COMPARE 999
#endif
//--------------------------------------------------------------------------
 int  CompareMask ( CTEXTSTR mask, CTEXTSTR name, int keepcase )
{
	int m = 0, n = 0;
	int anymatch;
	int wasanymatch, wasmaskmatch;
	int matchone;
	TEXTCHAR namech, maskch;
	if( !mask )
		return 1;
	if( !name )
		return 0;
try_mask:
	anymatch = 0;
	wasanymatch = 0;
	wasmaskmatch = 0;
	matchone = 0;
#if ( DEBUG_COMPARE < 3 )
	lprintf( WIDE("Check %s vs %s"), mask + m, name );
#endif
	do
	{
		if( mask[m] == '\t' || mask[m] == '|' )
		{
			lprintf( WIDE("Found mask seperator - skipping to next mask :%s"), mask + m + 1 );
			n = 0;
			m++;
			continue;
		}
		while( mask[m] == '*' )
		{
			anymatch = 1;
			m++;
		}
		while( mask[m] == '?' )
		{
#if ( DEBUG_COMPARE < 2 )
         //Log( WIDE("Match any one character") );
#endif
			matchone++;
			m++;
		}
		if( !keepcase && name[n]>= 'a' && name[n] <= 'z' )
			namech = name[n] - ('a' - 'A');
		else if( name[n] == '/' )
			namech = '\\';
		else
			namech = name[n];
		if( !keepcase && mask[m]>= 'a' && mask[m] <= 'z' )
			maskch = mask[m] - ('a' - 'A');
		else if( mask[m] == '/' )
			maskch = '\\';
		else
			maskch = mask[m];
		if( matchone )
		{
			matchone--;
			n++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( WIDE("Check %c == %c?"), maskch, namech ),
#endif
				  maskch == namech )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" yes.") );
#endif
			 if( anymatch )
			 {
				 wasanymatch = n+1;
				 wasmaskmatch = m+1;
				 anymatch = 0;
			}
			 n++;
			 m++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( WIDE(" no. Any match?") ),
#endif
				  anymatch )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" yes"));
#endif
			n++;
		}
		else if(
#if ( DEBUG_COMPARE < 2 )
				  lprintf( WIDE(" No. wasanymatch?") ),
#endif
				  wasanymatch )
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" yes. reset to anymatch.") );
#endif
			n = wasanymatch - 1;
			m = wasmaskmatch - 1;
			anymatch = 1;
			n++;
		}
		else
		{
#if ( DEBUG_COMPARE < 2 )
			lprintf( WIDE(" No. match failed.") );
#endif
			break;
		}
	}while( name[n] );
	// 0 or more match a *
	// so auto match remaining *
	while( mask[m] && mask[m] == '*' )
		m++;
#if ( DEBUG_COMPARE < 3 )
	lprintf( WIDE("Skipping to next mask") );
#endif
	if( mask[m] &&
		 ( mask[m] != '\t' &&
			mask[m] != '|' ) )
	{
		int mask_m = m;
		while( mask[m] )
		{
			if( mask[m] == '\t' || mask[m] == '|' )
			{
				n = 0;
				m++;
				break;
			}
			m++;
		}
		if( mask[m] )
			goto try_mask;
		m = mask_m;
	}
	//lprintf( WIDE("Result: %d %c %d"), matchone, mask[m], name[n] );
	// match ???? will not match abc
	// a??? abc not match
	if( !matchone && (!mask[m] || mask[m] == '\t' || mask[m] == '|' ) && !name[n] )
		return 1;
	return  0;
}
//--------------------------------------------------------------------------
//---------------------------------------------------------------------------
typedef struct result_buffer
{
	TEXTSTR buffer;
	int len;
	int result_len;
} RESULT_BUFFER, *PRESULT_BUFFER;
static void CPROC MatchFile( uintptr_t psvUser, CTEXTSTR name, int flags )
{
	PRESULT_BUFFER buffer = (PRESULT_BUFFER)psvUser;
	buffer->result_len = tnprintf( buffer->buffer, buffer->len*sizeof(TEXTCHAR), WIDE("%s"), name );
}
int  GetMatchingFileName ( CTEXTSTR filemask, int flags, TEXTSTR pResult, int nResult )
{
	void *info = NULL;
	RESULT_BUFFER result_buf;
	result_buf.buffer = pResult;
	result_buf.len = nResult;
	result_buf.result_len = 0;
	// may need a while loop here...
	// but I'm just going to result the first matching anyhow.
	while( ScanFiles( NULL, filemask, &info, MatchFile, flags, (uintptr_t)&result_buf ) );
	return result_buf.result_len;
}
//---------------------------------------------------------------------------
#if defined( _WIN32 ) && !defined( __TURBOC__ )
#ifdef UNDER_CE
#define finddata_t WIN32_FIND_DATA
#define findfirst FindFirstFile
#define findnext  FindNextFile
#define findclose FindClose
#else
#  ifdef UNICODE
#define finddata_t _wfinddata_t
#define findfirst _wfindfirst
#define findnext  _wfindnext
#define findclose _findclose
#  else
#define finddata_t _finddata_t
#define findfirst _findfirst
#define findnext  _findnext
#define findclose _findclose
#  endif
#endif
#else
#endif
typedef struct myfinddata {
#ifdef WIN32
#  ifdef _MSC_VER
#define HANDLECAST intptr_t
	intptr_t
#  else
#define HANDLECAST int
	int
#  endif
#else
#  define HANDLECAST DIR*
	DIR*
#endif
		handle;
#  ifdef WIN32
#    ifdef UNDER_CE
	WIN32_FIND_DATA fd;
#    else
#      ifdef UNICODE
	struct _wfinddata_t fd;
#    else
	 struct finddata_t fd;
#    endif
#  endif
#endif
	struct find_cursor *cursor;
	INDEX scanning_interface_index;
	LOGICAL new_mount;
	LOGICAL single_mount;
	struct file_system_mounted_interface *scanning_mount;
	TEXTCHAR buffer[MAX_PATH_NAME];
	TEXTCHAR file_buffer[MAX_PATH_NAME];
	TEXTCHAR basename[MAX_PATH_NAME];
	TEXTCHAR findmask[MAX_PATH_NAME];
	struct myfinddata *current;
	struct myfinddata *prior;
	struct myfinddata **root_info;
} MFD, *PMFD;
#define findhandle(pInfo) ( ((PMFD)(*pInfo))->handle)
#define finddata(pInfo) ( &((PMFD)(*pInfo))->fd)
#define findbuffer(pInfo) ( ((PMFD)(*pInfo))->buffer)
#define findbasename(pInfo) ( ((PMFD)(*pInfo))->basename)
#define findmask(pInfo)     ( ((PMFD)(*pInfo))->findmask)
#define findinfo(pInfo)     (((PMFD)(*pInfo)))
#define findcursor(pInfo)     ( ((PMFD)(*pInfo))->cursor)
 int  ScanFilesEx ( CTEXTSTR base
           , CTEXTSTR mask
           , void **pInfo
           , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
           , int flags
           , uintptr_t psvUser
		   , LOGICAL begin_sub_path
		   , struct file_system_mounted_interface *mount
		   )
{
	PMFD pDataCurrent = (PMFD)(pInfo);
	PMFD pData = (PMFD)(*pInfo);
	TEXTSTR tmp_base = NULL;
	int sendflags;
	int processed = 0;
#ifndef WIN32
	struct dirent *de;
#endif
	if( begin_sub_path )
	{
		pInfo = (void**)&(pDataCurrent->current);
	}
	else
		pDataCurrent = NULL;
	//lprintf( "Search in %s for %s   %d %d", base?base:"(NULL)", mask?mask:"(*)", (*pInfo)?((PMFD)*pInfo)->scanning_mount:0, (*pInfo)?((PMFD)*pInfo)->single_mount:0 );
	if( !*pInfo || begin_sub_path || ((PMFD)*pInfo)->new_mount )
	{
		TEXTCHAR findmask[256];
		pData = (PMFD)(*pInfo);
		if( !pData )
		{
			*pInfo = Allocate( sizeof( MFD ) );
			pData = (PMFD)(*pInfo);
			if( !( pData->scanning_mount = mount ) )
			{
				if( !winfile_local )
					SimpleRegisterAndCreateGlobal( winfile_local );
				//lprintf( "... %p", winfile_local );
				pData->single_mount = FALSE;
				pData->scanning_mount = (*winfile_local).mounted_file_systems;
			}
			else
				pData->single_mount = TRUE;
			if( !pData->scanning_mount )
			{
				Deallocate( PMFD, pData );
				if( tmp_base )
					Release( tmp_base );
				return 0;
			}
			if( pData->scanning_mount->fsi )
			{
				char *tmp1, *tmp2;
				//lprintf( "create cursor" );
				tmp_base = ExpandPathEx( base, pData->scanning_mount->fsi );
				pData->cursor = pData->scanning_mount->fsi->find_create_cursor( pData->scanning_mount->psvInstance, tmp2 = CStrDup( tmp_base ), tmp1 = CStrDup( mask ) );
				Deallocate( char*, tmp1 );
				Deallocate( char*, tmp2 );
			}
			else
			{
				//lprintf( "no cursor" );
				pData->cursor = NULL;
			}
		}
		else
		{
			if( pData->new_mount )
			{
				if( pData->scanning_mount->fsi )
				{
					//lprintf( "create cursor (new mount)" );
					tmp_base = ExpandPathEx( base, pData->scanning_mount->fsi );
					pData->cursor = pData->scanning_mount->fsi->find_create_cursor( pData->scanning_mount->psvInstance, CStrDup( tmp_base ), CStrDup( mask ) );
				}
				else
					pData->cursor = NULL;
			}
		}
		pData->new_mount = FALSE;
		pData->current = NULL;
		pData->prior = pDataCurrent;
		if( pDataCurrent )
		{
			pData->root_info = pDataCurrent->root_info;
			pInfo = (void**)pData->root_info;
		}
		else
		{
			pData->root_info = (struct myfinddata**)pInfo;
		}
		(*pData->root_info) = pData;
		if( base )
		{
			TEXTSTR tmp;
			StrCpyEx( findbasename(pInfo), tmp = ExpandPathEx( base, pData->scanning_mount?pData->scanning_mount->fsi:NULL ), MAX_PATH_NAME );
			Release( tmp );
			StrCpyEx( findmask(pInfo), mask, MAX_PATH_NAME );
		}
		else
		{
			CTEXTSTR p = pathrchr( mask );
			if( p )
			{
				StrCpyEx( findbasename(pInfo), mask, p - mask + 1 );
				StrCpyEx( findmask(pInfo), p + 1, MAX_PATH_NAME );
				//mask = p + 1;
			}
			else
			{
				StrCpyEx( findbasename(pInfo), WIDE(""), 2 );
				StrCpyEx( findmask(pInfo), mask, MAX_PATH_NAME );
			}
		}
		if( findbasename(pInfo)[0] )
			tnprintf( findmask, sizeof(findmask), WIDE("%s/*"), findbasename(pInfo) );
		else {
			tnprintf( findmask, sizeof( findmask ), WIDE( "*" ) );
		}
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL ) {
#ifndef _WIN32
			de = NULL;
#endif
			if( pData->scanning_mount->fsi->find_first( findcursor(pInfo) ) )
				findhandle(pInfo) = 0;
			else
				findhandle(pInfo) = (HANDLECAST)-1;
		} else {
#ifdef WIN32
			findhandle(pInfo) = findfirst( findmask, finddata(pInfo) );
#else
			lprintf( "opendir [%s]", findbasename(pInfo) );
			if( !findbasename(pInfo)[0] ) {
				TEXTSTR tmp;
				tmp = ExpandPathEx( ".", pData->scanning_mount?pData->scanning_mount->fsi:NULL );
				findhandle( pInfo ) = opendir( tmp );
				Deallocate( TEXTSTR, tmp );
			} else
				findhandle( pInfo ) = opendir( findbasename(pInfo) );
			if( !findhandle(pInfo ) )
				findhandle(pInfo) = (HANDLECAST)-1;
			else
				de = readdir( (DIR*)findhandle( pInfo ) );
#endif
		}
		if( findhandle(pInfo) == (HANDLECAST)-1 )
		{
			PMFD prior = pData->prior;
			//lprintf( "first use of cursor or first open of directoy failed..." );
			if( pData->scanning_mount && pData->scanning_mount->fsi )
				pData->scanning_mount->fsi->find_close( (struct find_cursor*)findcursor(pInfo) );
			else
			{
#ifdef WIN32
				findclose( findhandle(pInfo) );
#else
				// but it failed... so ... don't close
				//closedir( findhandle( pInfo ) );
#endif
			}
			pData->scanning_mount = NextThing( pData->scanning_mount );
			if( !pData->scanning_mount || pData->single_mount )
			{
				(*pData->root_info) = pData->prior;
				if( !begin_sub_path ) {
					Release( pData ); pInfo[0] = NULL;
				}
				//lprintf( WIDE( "%p %d" ), prior, processed );
				if( tmp_base )
					Release( tmp_base );
				return prior?processed:0;
			}
			pData->new_mount = TRUE;
				if( tmp_base )
					Release( tmp_base );
			return 1;
		}
	}
	else
	{
		int r;
getnext:
		//lprintf( "returning customer..." );
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			r = !pData->scanning_mount->fsi->find_next( findcursor( pInfo ) );
		else
		{
#ifdef _WIN32
			r = findnext( findhandle(pInfo), finddata( pInfo ) );
#else
			de = readdir( (DIR*)findhandle( pInfo ) );
			//lprintf( "using %p got %p", findhandle( pInfo ), de );
			r = (de == NULL);
#endif
		}
		if( r )
		{
			PMFD prior = pData->prior;
			//lprintf( "nothing left to find..." );
			if( pData->scanning_mount->fsi )
				pData->scanning_mount->fsi->find_close( findcursor(pInfo) );
			else
			{
#ifdef WIN32
				findclose( findhandle(pInfo) );
#else
				closedir( (DIR*)findhandle(pInfo));
#endif
			}
			pData->scanning_mount = NextThing( pData->scanning_mount );
			//lprintf( "Step mount... %p %d", pData->scanning_mount, pData->single_mount );
			if( !pData->scanning_mount || pData->single_mount )
			{
				//lprintf( "done with mounts?" );
				(*pData->root_info) = pData->prior;
				Release( pData );
				if( prior )
					prior->current = NULL;
				if( !processed && !begin_sub_path )
				{
					//pInfo = (void**)&(prior->prior->current);
					pData = prior;
					if( pData )
						goto getnext;
				}
				if( tmp_base )
					Release( tmp_base );
				return (*pInfo)?processed:0;
			}
			pData->new_mount = TRUE;
			if( tmp_base )
				Release( tmp_base );
			return 1;
		}
	}
	if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
	{
		char * path = pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) );
		//lprintf( "... %s", path );
		if( !strcmp( ".", path ) ||
		    !strcmp( "..", path ) )
		goto getnext;
	}
	else
	{
#ifdef WIN32
		//lprintf( "... %s", finddata(pInfo)->name );
#  ifdef UNDER_CE
		if( !StrCmp( WIDE("."), finddata(pInfo)->cFileName ) ||
		    !StrCmp( WIDE(".."), finddata(pInfo)->cFileName ) )
#  else
		if( !StrCmp( WIDE("."), finddata(pInfo)->name ) ||
		    !StrCmp( WIDE(".."), finddata(pInfo)->name ) )
#  endif
#else
		if( !StrCmp( WIDE("."), de->d_name ) ||
		    !StrCmp( WIDE(".."), de->d_name ) )
#endif
			goto getnext;
	}
 // if nameonly - have to rebuild the correct name.
	if( !(flags & SFF_NAMEONLY) )
	{
		if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
		{
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE("%s"), pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) ) );
			if( findbasename( pInfo )[0] )
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s/%s"), findbasename(pInfo), pData->file_buffer );
			else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE( "%s" ), pData->file_buffer );
		}
		else
		{
#ifdef WIN32
#  ifdef UNDER_CE
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE( "%s" ), finddata( pInfo )->cFileName );
			tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s/%s"), findbasename(pInfo), finddata(pInfo)->cFileName );
#  else
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->name );
			tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s"), findbasename(pInfo), findbasename( pInfo )[0]?"/":"", pData->file_buffer );
#  endif
#else
			tnprintf( pData->file_buffer, MAX_PATH_NAME, WIDE("%s"), de->d_name );
			tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s"), findbasename(pInfo), findbasename( pInfo )[0]?"/":"", de->d_name );
#endif
		}
	}
	else
	{
		if( flags & SFF_SUBCURSE )
		{
			if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			{
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
					  , pData->prior?pData->prior->buffer:WIDE( "" )
					  , pData->prior?WIDE( "/" ):WIDE( "" )
					, pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) )
					);
			}
			else
			{
#ifdef WIN32
#  ifdef UNDER_CE
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
						  , pData->prior?pData->prior->buffer:WIDE( "" )
						  , pData->prior?WIDE( "/" ):WIDE( "" )
						  , finddata(pInfo)->cFileName );
#  else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
						  , pData->prior?pData->prior->buffer:WIDE( "" )
						  , pData->prior?WIDE( "/" ):WIDE( "" )
						  , finddata(pInfo)->name );
#  endif
#else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s%s%s")
					  , pData->prior?pData->prior->buffer:WIDE( "" )
					  , pData->prior?WIDE( "/" ):WIDE( "" )
					  , de->d_name );
					  lprintf( "resulting is %s", pData->buffer );
#endif
			}
		}
		else
		{
			if( pData->scanning_mount?pData->scanning_mount->fsi:NULL )
			{
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), pData->scanning_mount->fsi->find_get_name( findcursor(pInfo) ) );
			}
			else
			{
#ifdef WIN32
#  ifdef UNDER_CE
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->cFileName );
#  else
#    ifdef UNICODE
				snwprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->name );
#    else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), finddata(pInfo)->name );
#    endif
#  endif
#else
				tnprintf( pData->buffer, MAX_PATH_NAME, WIDE("%s"), de->d_name );
#endif
			}
		}
	}
 // force nul termination...
	pData->buffer[MAX_PATH_NAME-1] = 0;
#ifdef UNICODE
	{
		char *pDataBuffer = CStrDup( pData->buffer );
#else
#  define pDataBuffer pData->buffer
#endif
	//lprintf( "Check if %s is a directory...", pData->buffer );
	if( ((flags & (SFF_DIRECTORIES | SFF_SUBCURSE))
		&& (pData->scanning_mount && pData->scanning_mount->fsi
			&& (pData->scanning_mount->fsi->is_directory
				&& pData->scanning_mount->fsi->is_directory( pData->scanning_mount->psvInstance, pDataBuffer ))))
		|| (!(pData->scanning_mount ? pData->scanning_mount->fsi : NULL)
#ifdef WIN32
#  ifdef UNDER_CE
			&& (finddata( pInfo )->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
#  else
			&& (finddata( pInfo )->attrib & _A_SUBDIR)
#  endif
#else
			&& IsPath( pData->buffer )
#endif
			) )
	{
#ifdef UNICODE
		Deallocate( char *, pDataBuffer );
#else
#  undef pDataBuffer
#endif
		//lprintf( "... it is?" );
		if( flags & SFF_DIRECTORIES )
		{
			if( Process != NULL )
			{
				//lprintf( "Send %s", pData->buffer );
				Process( psvUser, pData->buffer, SFF_DIRECTORY );
				processed = 1;
			}
			//return 1;
		}
		if( flags & SFF_SUBCURSE )
		{
			//int ofs = 0;
			TEXTCHAR tmpbuf[MAX_PATH_NAME];
			if( flags & SFF_NAMEONLY )
			{
				// even in name only - need to have this full buffer for subcurse.
				if( pData->scanning_mount && pData->scanning_mount->fsi )
				{
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), pData->scanning_mount->fsi->find_get_name( findcursor( pInfo ) ) );
				}
				else
				{
#ifdef WIN32
#  ifdef UNDER_CE
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), finddata( pInfo )->cFileName );
#  else
#    ifdef UNICODE
					/*ofs = */
snwprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), finddata( pInfo )->name );
#    else
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), finddata( pInfo )->name );
#    endif
#  endif
#else
					/*ofs = */
tnprintf( tmpbuf, sizeof( tmpbuf ), WIDE( "%s/%s" ), findbasename( pInfo ), de->d_name );
#endif
				}
				//lprintf( "process sub... %s %s", tmpbuf, findmask(pInfo)  );
				processed |= ScanFilesEx( tmpbuf, findmask( pInfo ), (POINTER*)pData, Process, flags, psvUser, TRUE, pData->scanning_mount );
			}
			else
			{
				//lprintf( "process sub..." );
				processed |= ScanFilesEx( pData->buffer, findmask( pInfo ), (POINTER*)pData, Process, flags, psvUser, TRUE, pData->scanning_mount );
			}
		}
		if( !processed )
			goto getnext;
		if( tmp_base )
			Release( tmp_base );
		return (*pInfo) ? 1 : 0;
	}
#ifdef UNICODE
	Deallocate( char *, pDataBuffer );
	}
#else
#  undef pDataBuffer
#endif
	if( ( sendflags = SFF_DIRECTORY, ( ( flags & SFF_DIRECTORIES )
#ifdef WIN32
#  ifdef UNDER_CE
												 && ( finddata(pInfo)->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
#  else
												 && ( finddata(pInfo)->attrib & _A_SUBDIR )
#  endif
#else
												 && ( IsPath( pData->buffer ) )
#endif
												) ) || ( sendflags = 0, CompareMask( findmask( pInfo )
#ifdef WIN32
#  ifdef UNDER_CE
																							  , finddata(pInfo)->cFileName
#  else
																							  , pData->file_buffer
#  endif
#else
																							  , pData->scanning_mount?pData->scanning_mount->fsi->find_get_name( findcursor( pInfo ) ) : de->d_name
#endif
																								// yes this is silly - but it's correct...
																							  , (flags & SFF_IGNORECASE)?0:0 ) ) )
	{
		//lprintf( "Send %s", pData->buffer );
		if( Process != NULL )
			Process( psvUser, pData->buffer, sendflags );
		if( tmp_base )
			Release( tmp_base );
		return (*pInfo)?1:0;
	}
	if( tmp_base )
		Release( tmp_base );
	return (*pInfo)?1:0;
}
 int  ScanFiles ( CTEXTSTR base
                , CTEXTSTR mask
                , void **pInfo
                , void CPROC Process( uintptr_t psvUser, CTEXTSTR name, int flags )
                , int flags
                , uintptr_t psvUser )
 {
	 return ScanFilesEx( base, mask, pInfo, Process, flags, psvUser, FALSE, NULL );
 }
//---------------------------------------------------------------------------
 void  ScanDrives ( void (CPROC*Process)(uintptr_t user, CTEXTSTR letter, int flags)
									, uintptr_t user )
{
#ifdef WIN32
#  ifdef UNDER_CE
	Process( user, WIDE(""), SFF_DRIVE );
#  else
	uint32_t drives;
	int i;
	drives = GetLogicalDrives();
	for( i = 0; i < 26; i++ )
	{
		TEXTCHAR name[2];
		name[1] = 0;
		if( drives & ( 1 << i ) )
		{
			name[0] = 'A' + i;
			if( Process )
				Process( user, name, SFF_DRIVE );
		}
	}
#  endif
#endif
}
FILESYS_NAMESPACE_END
#ifdef __LINUX__
#endif
//-----------------------------------------------------------------------
FILESYS_NAMESPACE
#ifndef __NO_SACK_FILESYS__
extern TEXTSTR ExpandPath( CTEXTSTR path );
#endif
 CTEXTSTR  pathrchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrRChr( path, '\\' );
	end2 = StrRChr( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
#ifdef __cplusplus
 TEXTSTR  pathrchr ( TEXTSTR path )
{
	TEXTSTR end1, end2;
	end1 = StrRChr( path, '\\' );
	end2 = StrRChr( path, '/' );
	if( end1 > end2 )
		return end1;
	return end2;
}
#endif
//-----------------------------------------------------------------------
 CTEXTSTR  pathchr ( CTEXTSTR path )
{
	CTEXTSTR end1, end2;
	end1 = StrChr( path, (int)'\\' );
	end2 = StrChr( path, (int)'/' );
	if( end1 && end2 )
	{
		if( end1 < end2 )
			return end1;
		return end2;
	}
	else if( end1 )
		return end1;
	else if( end2 )
		return end2;
	return NULL;
}
//-----------------------------------------------------------------------
TEXTSTR GetCurrentPath( TEXTSTR path, int len )
{
	if( !path )
		return 0;
#ifndef UNDER_CE
#  ifdef _WIN32
	GetCurrentDirectory( len, path );
#  else
#	  ifdef UNICODE
	{
		char _path[256];
		//TEXTCHAR *tmppath;
		//getcwd( _path, 256 );
		//tmppath = DupCStr( _path );
		//StrCpyEx( path, tmppath, len );
		path[0] = '.';
		path[1] = 0;
	}
#	  else
	getcwd( path, len );
#	  endif
#  endif
#endif
	return path;
}
#ifndef _WIN32
static void convert( uint64_t* outtime, time_t *time )
{
	*outtime = *time;
}
#endif
//-----------------------------------------------------------------------
uint64_t GetTimeAsFileTime ( void )
{
#if defined( __LINUX__ )
	struct timeval tmp;
	struct timezone tz;
	FILETIME result;
	gettimeofday( &tmp, &tz );
	result = ( tmp.tv_usec * 10LL ) + ( tmp.tv_sec * 1000LL * 1000LL * 10LL );
	return result;
#else
	SYSTEMTIME st;
	FILETIME result;
	GetLocalTime( &st );
	SystemTimeToFileTime( &st, &result );
	return *(uint64_t*)&result;
#endif
}
 // last modification time.
 uint64_t  GetFileWriteTime( CTEXTSTR name )
{
#ifndef __NO_SACK_FILESYS__
	TEXTSTR tmppath = ExpandPath( name );
#else
#  define tmppath name
#endif
#ifdef _WIN32
	HANDLE hFile = CreateFile( tmppath
 // device access?
								  , 0
								  , FILE_SHARE_READ|FILE_SHARE_WRITE
								  , NULL
								  , OPEN_EXISTING
								  , 0
								  , NULL );
#ifndef __NO_SACK_FILESYS__
	Deallocate( TEXTSTR, tmppath );
#endif
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME filetime;
		//uint64_t realtime;
		GetFileTime( hFile, NULL, NULL, &filetime );
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
		//realtime *= 100; // nano seconds?
		return *(uint64_t*)&filetime;
	}
	return 0;
#else
	struct stat statbuf;
	 uint64_t realtime;
#ifdef UNICODE
	{
		char *tmpname = CStrDup( tmppath );
		stat( tmpname, &statbuf );
		Release( tmpname );
	}
#else
	stat( tmppath, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
//-----------------------------------------------------------------------
 // last modification time.
 LOGICAL  SetFileWriteTime( CTEXTSTR name, uint64_t filetime )
{
#ifdef _WIN32
	HANDLE hFile = CreateFile( name
 // device access?
								  , GENERIC_WRITE
								  , FILE_SHARE_READ|FILE_SHARE_WRITE
								  , NULL
								  , OPEN_EXISTING
								  , 0
								  , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		//uint64_t realtime;
		SetFileTime( hFile, NULL, NULL, (CONST FILETIME*)&filetime );
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
	   //realtime *= 100; // nano seconds?
	  return TRUE;
	}
	return FALSE;
#else
	struct stat statbuf;
	uint64_t realtime;
#ifdef UNICODE
	 {
		 int status;
	   char *tmpname = CStrDup( name );
		 stat( tmpname, &statbuf );
		 Release( tmpname );
	 }
#else
	 stat( name, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
#ifdef WIN32
uint64_t ConvertFileTimeToInt( const FILETIME *filetime )
{
	ULARGE_INTEGER tmp;
	tmp.u.LowPart = filetime->dwLowDateTime;
	tmp.u.HighPart = filetime->dwHighDateTime;
	return tmp.QuadPart;
}
void ConvertFileIntToFileTime( uint64_t int_filetime, FILETIME *filetime )
{
	ULARGE_INTEGER tmp;
	tmp.QuadPart = int_filetime;
	filetime->dwLowDateTime  = tmp.u.LowPart;
	filetime->dwHighDateTime = tmp.u.HighPart;
}
#endif
LOGICAL  SetFileTimes( CTEXTSTR name
  // last modification time.
							, uint64_t time_create
 // last modification time.
							, uint64_t time_modify
  // last modification time.
							, uint64_t time_access
							)
{
#ifdef _WIN32
	LOGICAL result = TRUE;
	HANDLE hFile = CreateFile( name
 //GENERIC_WRITE|FILE_WRITE_ATTRIBUTES //GENERIC_ALL // device access?
									 , GENERIC_ALL
									 , FILE_SHARE_READ|FILE_SHARE_WRITE
									 , NULL
									 , OPEN_EXISTING
									 , FILE_FLAG_BACKUP_SEMANTICS
									 , NULL );
	if( hFile != INVALID_HANDLE_VALUE )
	{
		FILETIME filetime_create;
		FILETIME filetime_modify;
		FILETIME filetime_access;
		ULARGE_INTEGER tmp;
		//uint64_t realtime;
		tmp.QuadPart = time_create;
		filetime_create.dwLowDateTime = tmp.u.LowPart;
		filetime_create.dwHighDateTime = tmp.u.HighPart;
		tmp.QuadPart = time_access;
		filetime_access.dwLowDateTime = tmp.u.LowPart;
		filetime_access.dwHighDateTime = tmp.u.HighPart;
		tmp.QuadPart = time_modify;
		filetime_modify.dwLowDateTime = tmp.u.LowPart;
		filetime_modify.dwHighDateTime = tmp.u.HighPart;
#if 0
		{
			TEXTCHAR buf[3][64];
			SYSTEMTIME st;
			FileTimeToSystemTime( &time_create, &st );
			snprintf( buf[0], 64, "%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			FileTimeToSystemTime( &time_access, &st );
			snprintf( buf[1], 64,"%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			FileTimeToSystemTime( &time_modify, &st );
			snprintf( buf[2], 64, "%02d/%02d/%04d %02d:%02d:%02d.%03d", st.wMonth, st.wDay, st.wYear, st.wHour, st.wMinute, st.wSecond, st.wMilliseconds );
			lprintf( "File times on [%s] are to be : %s %s %s", name, buf[0], buf[1], buf[2] );
		}
#endif
		if( !SetFileTime( hFile, (CONST FILETIME*)&filetime_create, (CONST FILETIME*)&filetime_access, (CONST FILETIME*)&filetime_modify ) )
		{
			result = FALSE;
			lprintf( WIDE("Failed to set times:(%s)%d"), name, GetLastError() );
		}
		CloseHandle( hFile );
		//realtime = *(uint64_t*)&filetime;
		//realtime *= 100; // nano seconds?
		return result;
	}
	else
	{
		lprintf( WIDE("Failed to open to set time on %s:%d"), name, GetLastError() );
	}
	return FALSE;
#else
	struct stat statbuf;
	 uint64_t realtime;
#ifdef UNICODE
	 {
	   char *tmpname = CStrDup( name );
		 stat( tmpname, &statbuf );
	   Release( tmpname );
	 }
#else
	 stat( name, &statbuf );
#endif
	convert( &realtime, (time_t*)&statbuf.st_mtime );
	return realtime;
#endif
	return 0;
}
//-----------------------------------------------------------------------
LOGICAL  IsPath ( CTEXTSTR path )
{
	if( !path )
		return 0;
#ifdef _WIN32
	{
		DWORD dwResult;
		dwResult = GetFileAttributes( path );
		if( dwResult == 0xFFFFFFFF )
			return 0;
		if( dwResult & FILE_ATTRIBUTE_DIRECTORY )
			return 1;
		return 0;
	}
#else
	 {
		 struct stat statbuf;
#ifdef UNICODE
		 {
			 int status;
			 char *tmppath = CStrDup( path );
			 status = stat( tmppath, &statbuf );
			 Release( tmppath );
			 if( status < 0 )
				 return 0;
		 }
#else
		 if( stat( path, &statbuf ) < 0 )
			 return 0;
#endif
		 return S_ISDIR( statbuf.st_mode );
	 }
#endif
}
//-----------------------------------------------------------------------
int  MakePath ( CTEXTSTR path )
{
	int status;
	if( !path )
		return 0;
#ifdef _WIN32
	status = CreateDirectory( path, NULL );
	if( !status )
	{
		uint32_t err = GetLastError();
		TEXTSTR tmppath = StrDup( path );
		TEXTSTR last = (TEXTSTR)pathrchr( tmppath );
		if( last )
		{
			last[0] = 0;
			if( MakePath( tmppath ) )
				status = CreateDirectory( path, NULL );
		}
		Release( tmppath );
	}
	return status;
#else
#  ifdef UNICODE
	{
		int status;
		char *tmppath = CStrDup( path );
 // make directory with full umask permissions
		status = mkdir( tmppath, -1 );
		Release( tmppath );
		return !status;
	}
#  else
 // make directory with full umask permissions
	if( ( status = mkdir( path, -1 ) ) < 0 )
	{
		TEXTSTR tmppath = StrDup( path );
		TEXTSTR last = (TEXTSTR)pathrchr( tmppath );
		if( last )
		{
			last[0] = 0;
			if( MakePath( tmppath ) ) {
				status = mkdir( path, -1 );
				if( status < 0 )
					if( EEXIST == errno )
						status = 0;
			}
		}
		Release( tmppath );
	}
	if( status < 0 )
		if( EEXIST == errno )
			status = 0;
	return !status;
#  endif
#endif
}
//-----------------------------------------------------------------------
int  SetCurrentPath ( CTEXTSTR path )
{
	int status = 1;
	TEXTSTR tmp_path;
	if( !path )
		return 0;
#ifndef __NO_SACK_FILESYS__
	tmp_path = ExpandPath( path );
#else
#  define tmp_path path
#endif
#ifndef UNDER_CE
#  ifdef _WIN32
	status = SetCurrentDirectory( tmp_path );
#  else
#	ifdef UNICODE
	{
		char *tmppath = CStrDup( path );
 // make directory with full umask permissions
		status = chdir( tmppath );
		Release( tmppath );
	}
#	else
	 status = !chdir( tmp_path );
#	endif
#  endif
#ifndef __NO_SACK_FILESYS__
	Release( tmp_path );
#endif
	if( status )
	{
#ifndef __NO_SACK_FILESYS__
		TEXTCHAR tmp[256];
		path = GetCurrentPath( tmp, sizeof( tmp ) );
		SetDefaultFilePath( path );
#endif
	}
	else
	{
		TEXTCHAR tmp[256];
		lprintf( WIDE( "Failed to change to [%s](%d) from %s" ), path, GetLastError(), GetCurrentPath( tmp, sizeof( tmp ) ) );
	}
#endif
	return status;
}
LOGICAL IsAbsolutePath( CTEXTSTR path )
{
	if(path)
	{
#ifdef WIN32
		if( ( path[0] && path[1] && path[2] ) &&
			  ( ( ( ( path[0] >= 'a' && path[0] <= 'z' )
				  || ( path[0] >= 'A' && path[0] <= 'Z' ) )
				  && ( path[1] == ':' )
				  && ( path[2] == '/' || path[2] == '\\' ) )
				|| ( path[0] == '/' && path[1] == '/' )
				|| ( path[0] == '\\' && path[1] == '\\' )
			  || ( path[0] == '/' || path[0] == '\\' ) )
		  )
			return TRUE;
#else
		if( path[0] == '/' || path[0] == '\\' )
			return TRUE;
#endif
	}
	return FALSE;
}
FILESYS_NAMESPACE_END
//-----------------------------------------------------------------------
/*
 *  Crafted by James Buckeyne
 *
 *	(c) Freedom Collective 2000-2006++
 *
 *	code to drive standard containers, lists, stacks, queues
 *	auto expanding, auto tracking, threadsafe containers...
 *
 *  standardized to never use int.
 *
 * see also - include/typelib.h
 *
 */
 // offsetof
 // Sleep
#define MY_OFFSETOF( ppstruc, member ) ((uintptr_t)&((*ppstruc)->member)) - ((uintptr_t)(*ppstruc))
#ifndef USE_CUSTOM_ALLOCER
#define USE_SACK_CUSTOM_MEMORY_ALLOCATION
// this has to be a compile option (option from cmake)
#ifdef USE_SACK_CUSTOM_MEMORY_ALLOCATION
#define USE_CUSTOM_ALLOCER 1
#else
#define USE_CUSTOM_ALLOCER 0
#endif
#endif
#ifdef __cplusplus
namespace sack {
	namespace containers {
#endif
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace list {
#endif
static struct list_local_data
{
	volatile uint32_t lock;
} s_list_local, *_list_local;
#ifdef __STATIC_GLOBALS__
#  define list_local  (s_list_local)
#  define list_local_lock (&s_list_local.lock)
#else
#  define list_local  ((_list_local)?(*_list_local):(s_list_local))
#  define list_local_lock ((_list_local)?(&_list_local->lock):(&s_list_local.lock))
#endif
#ifdef UNDER_CE
#define LockedExchange InterlockedExchange
#endif
PLIST  CreateListEx ( DBG_VOIDPASS )
{
	PLIST pl;
	INDEX size;
	pl = (PLIST)AllocateEx( ( size = (INDEX)offsetof( LIST, pNode[0] ) ) DBG_RELAY );
	MemSet( pl, 0, size );
	return pl;
}
//--------------------------------------------------------------------------
PLIST  DeleteListEx ( PLIST *pList DBG_PASS )
{
	PLIST ppList;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	if( pList &&
		( ppList = (PLIST)LockedExchangePtrSzVal( (uintptr_t*)pList, 0 ) )
	  )
	{
		ReleaseEx( ppList DBG_RELAY );
	}
	list_local_lock[0] = 0;
	return NULL;
}
//--------------------------------------------------------------------------
static PLIST ExpandListEx( PLIST *pList, INDEX amount DBG_PASS )
{
	PLIST old_list = (*pList);
	PLIST pl;
	uintptr_t size;
	uintptr_t old_size;
	if( !pList )
		return NULL;
	if( *pList )
	{
		old_size = ((uintptr_t)&((*pList)->pNode[(*pList)->Cnt])) - ((uintptr_t)(*pList));
		size = ((uintptr_t)&((*pList)->pNode[(*pList)->Cnt+amount])) - ((uintptr_t)(*pList));
		//old_size = offsetof( LIST, pNode[(*pList)->Cnt]));
		pl = (PLIST)AllocateEx( size DBG_RELAY );
	}
	else
	{
		old_size = 0;
		pl = (PLIST)AllocateEx( size = MY_OFFSETOF( pList, pNode[amount] ) DBG_RELAY );
		pl->Cnt = 0;
	}
	if( old_list )
	{
		// copy old list to new list
		MemCpy( pl, *pList, old_size );
		if( amount == 1 )
			pl->pNode[pl->Cnt++] = NULL;
		else
		{
			// clear the new additions to the list
			MemSet( pl->pNode + pl->Cnt, 0, size - old_size );
			pl->Cnt += amount;
		}
		// set the new list before releasing the old one.
		(*pList) = pl;
		// remove the old list...
		ReleaseEx( old_list DBG_RELAY );
	}
	else
	{
 // clear whole structure on creation...
		MemSet( pl, 0, size );
  // one more ( always a free )
		pl->Cnt = amount;
		// brand new list.
		*pList = pl;
	}
	return pl;
}
//--------------------------------------------------------------------------
 PLIST  AddLinkEx ( PLIST *pList, POINTER p DBG_PASS )
{
	INDEX i;
	if( !pList )
		return NULL;
	if( !(*pList ) )
	{
	retry1:
		ExpandListEx( pList, 8 DBG_RELAY );
	}
	else
	{
		while( LockedExchange( list_local_lock, 1 ) )
			Relinquish();
		// cannot trust that the list will exist all the time
		// we may start calling this function and have the
		// list re-allocated.
		if( !(*pList) )
		{
			list_local_lock[0] = 0;
			return NULL;
		}
	}
	for( i = 0; i < (*pList)->Cnt; i++ )
	{
		if( !(*pList)->pNode[i] )
		{
			(*pList)->pNode[i] = p;
			break;
		}
	}
	if( i == (*pList)->Cnt )
  // pList->Cnt changes - don't test in WHILE
		goto retry1;
	list_local_lock[0] = 0;
 // might be a NEW list...
	return *pList;
}
//--------------------------------------------------------------------------
 PLIST  SetLinkEx ( PLIST *pList, INDEX idx, POINTER p DBG_PASS )
{
	INDEX sz;
	if( !pList )
		return NULL;
	if( *pList )
	{
		while( LockedExchange( list_local_lock, 1 ) )
			Relinquish();
		if( !(*pList ) )
		{
			list_local_lock[0] = 0;
			return NULL;
		}
	}
	if( idx == INVALID_INDEX )
	{
		list_local_lock[0] = 0;
 // not set...
		return *pList;
	}
	sz = 0;
	while( !(*pList) || ( sz = (*pList)->Cnt ) <= idx )
		ExpandListEx( pList, (idx - sz) + 1 DBG_RELAY );
	(*pList)->pNode[idx] = p;
	list_local_lock[0] = 0;
 // might be a NEW list...
	return *pList;
}
//--------------------------------------------------------------------------
 POINTER  GetLink ( PLIST *pList, INDEX idx )
{
	// must lock the list so that it's not expanded out from under us...
	POINTER p;
	if( !pList || !(*pList) )
		return NULL;
	if( idx == INVALID_INDEX )
 // not set...
		return pList;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	if( !(*pList ) )
	{
		list_local_lock[0] = 0;
		return NULL;
	}
	if( (*pList)->Cnt <= idx )
	{
		list_local_lock[0] = 0;
		return NULL;
	}
	p = (*pList)->pNode[idx];
	list_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
 POINTER*  GetLinkAddress ( PLIST *pList, INDEX idx )
{
	// must lock the list so that it's not expanded out from under us...
	POINTER *p;
	if( !pList || !(*pList) )
		return NULL;
	if( idx == INVALID_INDEX )
 // not set...
		return NULL;
	if( (*pList)->Cnt <= idx )
	{
		return NULL;
	}
	p = (*pList)->pNode + idx;
	return p;
}
//--------------------------------------------------------------------------
 uintptr_t  ForAllLinks ( PLIST *pList, ForProc func, uintptr_t user )
{
	INDEX i;
	uintptr_t result = 0;
	while( LockedExchange( list_local_lock, 1 ) )
		Relinquish();
	 if( pList && *pList )
	{
		for( i=0; i < ((*pList)->Cnt); i++ )
		{
			if( (*pList)->pNode[i] )
			{
				result = func( user, i, (*pList)->pNode + i );
				if( result )
					break;
			}
		}
	}
	list_local_lock[0] = 0;
	return result;
}
 //--------------------------------------------------------------------------
 INDEX GetLinkCount( PLIST pList ) {
	 INDEX i;
	 POINTER p;
	 INDEX count = 0;
	 LIST_FORALL( pList, i, POINTER, p ) {
		 count++;
	 }
	 return count;
 }
 //--------------------------------------------------------------------------
static uintptr_t CPROC IsLink( uintptr_t value, INDEX i, POINTER *link )
{
	if( value == (uintptr_t)(*link) )
 // 0 might be value so add one to make it non zero
		return i+1;
	return 0;
}
//--------------------------------------------------------------------------
 INDEX  FindLink ( PLIST *pList, POINTER value )
{
	if( !pList || !(*pList ) )
		return INVALID_INDEX;
	return ForAllLinks( pList, IsLink, (uintptr_t)value ) - 1;
}
//--------------------------------------------------------------------------
static uintptr_t CPROC KillLink( uintptr_t value, INDEX i, POINTER *link )
{
	if( value == (uintptr_t)(*link) )
	{
		(*link) = NULL;
 // stop searching
		return 1;
	}
	return 0;
}
LOGICAL  DeleteLink( PLIST *pList, CPOINTER value )
{
	if( ForAllLinks( pList, KillLink, (uintptr_t)value ) )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
static uintptr_t CPROC RemoveItem( uintptr_t value, INDEX i, POINTER *link )
{
	*link = NULL;
	return 0;
}
void EmptyList( PLIST *pList )
{
	ForAllLinks( pList, RemoveItem, 0 );
}
#ifdef __cplusplus
//		namespace list {
		};
namespace data_list {
#endif
static struct data_list_local_data
{
	uint32_t lock;
} s_data_list_local, *_data_list_local;
#ifdef __STATIC_GLOBALS__
#  define data_list_local  ((s_data_list_local))
#  define data_list_local_lock  ((&s_data_list_local.lock))
#else
#  define data_list_local  ((_data_list_local)?(*_data_list_local):(s_data_list_local))
#  define data_list_local_lock  ((_data_list_local)?(&_data_list_local->lock):(&s_data_list_local.lock))
#endif
//--------------------------------------------------------------------------
PDATALIST ExpandDataListEx( PDATALIST *ppdl, INDEX entries DBG_PASS )
{
	PDATALIST pdl = (*ppdl);
	PDATALIST pNewList;
	if( !ppdl || !*ppdl )
 // can't expand - was not created (no data size)
		return NULL;
	if( (*ppdl) )
		entries += (*ppdl)->Avail;
	pNewList = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ( (*ppdl)->Size * entries ) - 1 DBG_RELAY );
	MemCpy( pNewList->data, (*ppdl)->data, (*ppdl)->Avail * (*ppdl)->Size );
	pNewList->Cnt = (*ppdl)->Cnt;
	pNewList->Avail = entries;
	pNewList->Size = (*ppdl)->Size;
	// set the new list int he pointer
	*ppdl = pNewList;
	ReleaseEx( pdl DBG_RELAY );
	return pNewList;
}
//--------------------------------------------------------------------------
 PDATALIST  CreateDataListEx ( uintptr_t nSize DBG_PASS )
{
	PDATALIST pdl = (PDATALIST)AllocateEx( sizeof( DATALIST ) + ( nSize * 8 ) - 1 DBG_RELAY );
	pdl->Cnt = 0;
	pdl->Avail = 8;
	pdl->Size = nSize;
	return pdl;
}
//--------------------------------------------------------------------------
 void  DeleteDataListEx ( PDATALIST *ppdl DBG_PASS )
{
	if( ppdl )
	{
		if( *ppdl )
		{
			ReleaseEx( *ppdl DBG_RELAY );
			*ppdl = NULL;
		}
	}
}
//--------------------------------------------------------------------------
POINTER SetDataItemEx( PDATALIST *ppdl, INDEX idx, POINTER data DBG_PASS )
{
	POINTER p = NULL;
	if( !ppdl || !(*ppdl) || idx > 0x100000 )
		return NULL;
	if( idx >= (*ppdl)->Avail )
	{
		ExpandDataListEx( ppdl, (idx-(*ppdl)->Avail)+32 DBG_RELAY );
	}
	p = (*ppdl)->data + ( (*ppdl)->Size * idx );
	MemCpy( p, data, (*ppdl)->Size );
	if( idx >= (*ppdl)->Cnt )
		(*ppdl)->Cnt = idx+1;
	return p;
}
//--------------------------------------------------------------------------
POINTER AddDataItemEx( PDATALIST *ppdl, POINTER data DBG_PASS )
{
	if( ppdl && *ppdl )
		return SetDataItemEx( ppdl, (*ppdl)->Cnt+1, data DBG_RELAY );
	if( ppdl )
		return SetDataItemEx( ppdl, 0, data DBG_RELAY );
	return NULL;
}
void EmptyDataList( PDATALIST *ppdl )
{
	if( ppdl && (*ppdl) )
		(*ppdl)->Cnt = 0;
}
//--------------------------------------------------------------------------
void DeleteDataItem( PDATALIST *ppdl, INDEX idx )
{
	if( ppdl && *ppdl )
	{
		if( idx < ( (*ppdl)->Cnt - 1 ) )
			MemCpy( (*ppdl)->data + ((*ppdl)->Size * idx )
					, (*ppdl)->data + ((*ppdl)->Size * (idx + 1) )
					, (*ppdl)->Size );
		(*ppdl)->Cnt--;
	}
}
//--------------------------------------------------------------------------
POINTER GetDataItem( PDATALIST *ppdl, INDEX idx )
{
	POINTER p = NULL;
	if( ppdl && *ppdl && ( idx < (*ppdl)->Cnt ) )
		p = (*ppdl)->data + ( (*ppdl)->Size * idx );
	return p;
}
//--------------------------------------------------------------------------
#ifdef __cplusplus
//		namespace data_list {
		};
namespace link_stack {
#endif
 PLINKSTACK		CreateLinkStackLimitedEx		  ( int max_entries  DBG_PASS )
{
	PLINKSTACK pls;
	pls = (PLINKSTACK)AllocateEx( sizeof( LINKSTACK ) DBG_RELAY );
	pls->Top = 0;
	pls->Cnt = 0;
	pls->Max = max_entries;
	return pls;
}
//--------------------------------------------------------------------------
 PLINKSTACK  CreateLinkStackEx ( DBG_VOIDPASS )
{
	return CreateLinkStackLimitedEx( 0 DBG_RELAY );
}
//--------------------------------------------------------------------------
 void  DeleteLinkStackEx ( PLINKSTACK *pls DBG_PASS )
{
	if( pls && *pls )
	{
		ReleaseEx( *pls DBG_RELAY );
		*pls = 0;
	}
}
//--------------------------------------------------------------------------
POINTER  PeekLinkEx ( PLINKSTACK *pls, INDEX n )
{
	// should lock - but it's fast enough?
	POINTER p = NULL;
	if( pls && (*pls) && n >= (*pls)->Top )
		return NULL;
	if( pls && *pls && ((*pls)->Top-n) )
		p = (*pls)->pNode[(*pls)->Top-(n+1)];
	else
		return NULL;
	return p;
}
//--------------------------------------------------------------------------
POINTER  PeekLink ( PLINKSTACK *pls )
{
	return PeekLinkEx( pls, 0 );
}
//--------------------------------------------------------------------------
POINTER  PopLink ( PLINKSTACK *pls )
{
	if( pls && *pls && (*pls)->Top )
		return (*pls)->pNode[--(*pls)->Top];
	return NULL;
}
//--------------------------------------------------------------------------
static PLINKSTACK ExpandStackEx( PLINKSTACK *stack, INDEX entries DBG_PASS )
{
	PLINKSTACK pNewStack;
	if( *stack )
		entries += (*stack)->Cnt;
	pNewStack = (PLINKSTACK)AllocateEx( my_offsetof( stack, pNode[entries] ) DBG_RELAY );
	if( *stack )
	{
		PLINKSTACK pls = (*stack);
		MemCpy( pNewStack->pNode, (*stack)->pNode, (*stack)->Cnt * sizeof(POINTER) );
		pNewStack->Top = (*stack)->Top;
		pNewStack->Max = (*stack)->Max;
		*stack = pNewStack;
		ReleaseEx( pls DBG_RELAY );
	}
	else
	{
		pNewStack->Top = 0;
		pNewStack->Max = 0;
		*stack = pNewStack;
	}
	pNewStack->Cnt = entries;
	return pNewStack;
}
//--------------------------------------------------------------------------
 PLINKSTACK  PushLinkEx ( PLINKSTACK *pls, POINTER p DBG_PASS )
{
	if( !pls )
		return NULL;
	// should lock this thing :)
	if( !*pls ||
		 (*pls)->Top == (*pls)->Cnt )
	{
		ExpandStackEx( pls, ((*pls)?((*pls)->Max):0)+8 DBG_RELAY );
	}
	if( (*pls)->Max )
		if( ((*pls)->Top) >= (*pls)->Max )
		{
			MemCpy( (*pls)->pNode, (*pls)->pNode + 1, (*pls)->Top - 1 );
			(*pls)->Top--;
		}
	(*pls)->pNode[(*pls)->Top] = p;
	(*pls)->Top++;
	return (*pls);
}
#ifdef __cplusplus
//namespace link_stack
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_stack {
#endif
 POINTER  PopData ( PDATASTACK *pds )
{
	POINTER p = NULL;
	if( (pds) && (*pds) && (*pds)->Top )
	{
		 (*pds)->Top--;
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top) );
	}
	return p;
}
//--------------------------------------------------------------------------
static PDATASTACK ExpandDataStackEx( PDATASTACK *ppds, INDEX entries DBG_PASS )
{
	PDATASTACK pNewStack;
	PDATASTACK pds = (*ppds);
	if( !pds )
		return NULL;
	entries += pds->Cnt;
	pNewStack = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ( (*ppds)->Size * entries ) - 1 DBG_RELAY );
	MemCpy( pNewStack->data, (*ppds)->data, (*ppds)->Cnt * (*ppds)->Size );
	pNewStack->Cnt = entries;
	pNewStack->Size = (*ppds)->Size;
	pNewStack->Top = (*ppds)->Top;
	(*ppds) = pNewStack;
	ReleaseEx( pds DBG_RELAY );
	return pNewStack;
}
//--------------------------------------------------------------------------
 PDATASTACK  PushDataEx ( PDATASTACK *pds, POINTER pdata DBG_PASS )
{
	if( pds && *pds )
	{
		if( (*pds)->Top == (*pds)->Cnt )
		{
			ExpandDataStackEx( pds, 1 DBG_RELAY );
		}
		if( (*pds)->Max )
			if( ((*pds)->Top) >= (*pds)->Max )
			{
				MemCpy( (*pds)->data, (*pds)->data + (*pds)->Size, ( (*pds)->Top - 1 ) * (*pds)->Size );
				(*pds)->Top--;
			}
		MemCpy( (*pds)->data + ((*pds)->Top * (*pds)->Size ), pdata, (*pds)->Size );
		(*pds)->Top++;
		return (*pds);
	}
	if( pds )
		return *pds;
	return NULL;
}
//--------------------------------------------------------------------------
 POINTER  PeekDataEx ( PDATASTACK *pds, INDEX nBack )
{
	POINTER p = NULL;
	nBack++;
	if( !(*pds) )
		return NULL;
	if( ( (int)((*pds)->Top) - (int)nBack ) >= 0 )
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top - nBack) );
	return p;
}
//--------------------------------------------------------------------------
 POINTER  PeekData ( PDATASTACK *pds )
{
	POINTER p = NULL;
	if( pds && *pds && (*pds)->Top )
		p = (*pds)->data + ( (*pds)->Size * ((*pds)->Top-1) );
	return p;
}
//--------------------------------------------------------------------------
void  EmptyDataStack( PDATASTACK *pds )
{
	if( pds && *pds )
		(*pds)->Top = 0;
}
//--------------------------------------------------------------------------
 PDATASTACK  CreateDataStackEx ( size_t size DBG_PASS )
{
	return CreateDataStackLimitedEx( size, 0 DBG_RELAY );
}
//--------------------------------------------------------------------------
 PDATASTACK  CreateDataStackLimitedEx ( size_t size, INDEX max_items DBG_PASS )
{
	PDATASTACK pds;
	pds = (PDATASTACK)AllocateEx( sizeof( DATASTACK ) + ( 10 * size ) DBG_RELAY );
	pds->Cnt = 10;
	pds->Top = 0;
	pds->Size = size;
	pds->Max = max_items;
	return pds;
}
//--------------------------------------------------------------------------
void DeleteDataStackEx( PDATASTACK *pds DBG_PASS )
{
	ReleaseEx( *pds DBG_RELAY );
	*pds = NULL;
}
#ifdef __cplusplus
//		namespace data_stack {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace queue {
#endif
static struct link_queue_local_data
{
	volatile uint32_t lock;
//#if !USE_CUSTOM_ALLOCER
	volatile PTHREAD thread;
//#endif
} s_link_queue_local, *_link_queue_local;
#ifdef __STATIC_GLOBALS__
#  define link_queue_local  ((s_link_queue_local))
#  define link_queue_local_thread  ((s_link_queue_local.thread))
#  define link_queue_local_lock  ((&s_link_queue_local.lock))
#else
#  define link_queue_local  ((_link_queue_local)?(*_link_queue_local):(s_link_queue_local))
#  define link_queue_local_thread  ((_link_queue_local)?(*_link_queue_local).thread:(s_link_queue_local.thread))
#  define link_queue_local_lock  ((_link_queue_local)?(&_link_queue_local->lock):(&s_link_queue_local.lock))
#endif
PLINKQUEUE CreateLinkQueueEx( DBG_VOIDPASS )
{
	PLINKQUEUE plq = 0;
	plq = (PLINKQUEUE)AllocateEx( MY_OFFSETOF( &plq, pNode[8] ) DBG_RELAY );
#if USE_CUSTOM_ALLOCER
	plq->Lock     = 0;
#endif
	plq->Top      = 0;
	plq->Bottom   = 0;
	plq->Cnt      = 8;
	plq->pNode[0] = NULL;
 // shrug
	plq->pNode[1] = NULL;
	return plq;
}
//--------------------------------------------------------------------------
void DeleteLinkQueueEx( PLINKQUEUE *pplq DBG_PASS )
{
	if( !pplq )
		return;
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
		Relinquish();
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
	if( !(*pplq) )
	{
		link_queue_local_lock[0] = 0;
		return;
	}
	if( (*pplq)->Lock )
	{
		link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
#endif
	link_queue_local_lock[0] = 0;
	if( pplq )
	{
		if( *pplq )
			ReleaseEx( *pplq DBG_RELAY );
		*pplq = NULL;
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = NULL;
#endif
	//link_queue_local_lock[0] = 0;
}
//--------------------------------------------------------------------------
static PLINKQUEUE ExpandLinkQueueEx( PLINKQUEUE *pplq, INDEX entries DBG_PASS )
{
	PLINKQUEUE plqNew = NULL;
#if USE_CUSTOM_ALLOCER
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
		Relinquish();
	}
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
#endif
	if( pplq )
	{
		PLINKQUEUE plq = *pplq;
		INDEX size;
		int prior_logging;
		size = MY_OFFSETOF( pplq, pNode[plq->Cnt + entries] );
		prior_logging = SetAllocateLogging( FALSE );
		plqNew = (PLINKQUEUE)AllocateEx( size DBG_RELAY );
		plqNew->Cnt = plq->Cnt + entries;
		plqNew->Bottom = 0;
		if( plq->Bottom > plq->Top )
		{
			INDEX bottom_half;
			plqNew->Top = (bottom_half = plq->Cnt - plq->Bottom ) + plq->Top;
			MemCpy( plqNew->pNode, plq->pNode + plq->Bottom, sizeof(POINTER)*bottom_half );
			MemCpy( plqNew->pNode + bottom_half, plq->pNode, sizeof(POINTER)*plq->Top );
		}
		else
		{
			plqNew->Top = plq->Top - plq->Bottom;
			MemCpy( plqNew->pNode, plq->pNode + plq->Bottom, sizeof(POINTER)*plqNew->Top );
		}
		//need to make sure plq is always valid; can be trying to get a lock
		(*pplq) = plqNew;
		Release( plq );
		SetAllocateLogging( prior_logging );
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = NULL;
	link_queue_local_lock[0] = 0;
#endif
	return plqNew;
}
//--------------------------------------------------------------------------
 PLINKQUEUE  EnqueLinkEx ( PLINKQUEUE *pplq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PLINKQUEUE plq;
#if USE_CUSTOM_ALLOCER
	int keep_lock = 0;
#endif
	if( !pplq )
		return NULL;
	if( !(*pplq) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
	{
#if USE_CUSTOM_ALLOCER
		if( link_queue_local_thread == MakeThread() )
		{
			keep_lock = 1;
			break;
		}
#endif
		Relinquish();
	}
#if USE_CUSTOM_ALLOCER
	if( _link_queue_local )
		_link_queue_local->thread = MakeThread();
	if( !(*pplq) )
	{
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
		return (*pplq);
	}
	if( (*pplq)->Lock )
	{
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
	if( !keep_lock )
	{
		if( _link_queue_local )
			_link_queue_local->thread = NULL;
		link_queue_local_lock[0] = 0;
	}
#else
	if( !(*pplq) )
	{
		//it could have been deallocated
		link_queue_local_lock[0] = 0;
		return (*pplq);
	}
#endif
	plq = *pplq;
	//else
	//	s_link_queue_local.thread = MakeThread();
	if( link )
	{
		tmp = plq->Top + 1;
		if( tmp >= plq->Cnt )
			tmp -= plq->Cnt;
 // collided with self...
		if( tmp == plq->Bottom )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = plq->Top + 1;
		}
		plq->pNode[plq->Top] = link;
		plq->Top = tmp;
	}
	*pplq = plq;
#if USE_CUSTOM_ALLOCER
	plq->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return plq;
}
//--------------------------------------------------------------------------
void EnqueLinkNLEx( PLINKQUEUE *pplq, POINTER link DBG_PASS )
 {
	INDEX tmp, t, c;
	PLINKQUEUE plq;
	if( !pplq )
		return;
	if( !( *pplq ) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
	plq = *pplq;
	if( link )
	{
		tmp = (t=plq->Top) + 1;
		if( tmp >= ( c = plq->Cnt ) )
			tmp -= c;
 // collided with self...
		if( tmp == ( plq->Bottom ) )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = (t=plq->Top) + 1;
		}
		plq->pNode[t] = link;
		plq->Top = tmp;
	}
	*pplq = plq;
 }
 //--------------------------------------------------------------------------
 PLINKQUEUE  PrequeLinkEx ( PLINKQUEUE *pplq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PLINKQUEUE plq;
	if( !pplq )
		return NULL;
	if( !(*pplq) )
		*pplq = CreateLinkQueueEx( DBG_VOIDRELAY );
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
	while( LockedExchange( link_queue_local_lock, __LINE__ ) )
		Relinquish();
#if USE_CUSTOM_ALLOCER
	if( !(*pplq) )
	{
		link_queue_local_lock[0] = 0;
		return NULL;
	}
	if( (*pplq)->Lock )
	{
		link_queue_local_lock[0] = 0;
		Relinquish();
		goto retry_lock;
	}
	(*pplq)->Lock = 1;
	link_queue_local_lock[0] = 0;
#else
	if( !(*pplq) )
	{
		//it could have been deallocated
		link_queue_local_lock[0] = 0;
		return (*pplq);
	}
#endif
	plq = *pplq;
	if( link )
	{
		tmp = plq->Bottom - 1;
		if( tmp & 0x80000000 )
			tmp += plq->Cnt;
 // collided with self...
		if( tmp == plq->Top )
		{
			plq = ExpandLinkQueueEx( pplq, 16 DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = plq->Cnt - 1;
		}
		plq->pNode[tmp] = link;
		plq->Bottom = tmp;
	}
#if USE_CUSTOM_ALLOCER
	plq->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return plq;
}
//--------------------------------------------------------------------------
 LOGICAL  IsQueueEmpty ( PLINKQUEUE *pplq  )
{
	if( !pplq || !(*pplq) ||
		(*pplq)->Bottom == (*pplq)->Top )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
 INDEX  GetQueueLength ( PLINKQUEUE plq )
{
	INDEX used = 0;
	if( plq )
	{
		used = plq->Top - plq->Bottom;
		if( plq->Top < plq->Bottom )
			used += plq->Cnt;
	}
	return used;
}
//--------------------------------------------------------------------------
POINTER  PeekQueueEx	 ( PLINKQUEUE plq, int idx )
{
	size_t top;
	if( !plq )
		return NULL;
	if( idx < 0 )
	{
		idx++;
		for( top = plq->Top?(plq->Top - 1):(plq->Cnt-1)
			 ; idx && top != plq->Bottom
			  ; )
		{
			idx++;
			if( !top ) top = plq->Cnt - 1;
			else top--;
		}
		if( idx == 0 )
		{
			if( plq->Top == plq->Bottom )
				return NULL;
			return plq->pNode[top];
		}
	}
	else
	{
		for( top = plq->Bottom
			 ; idx != -1 && top != plq->Top
			  ; )
		{
			if( idx ) {
				top++;
				if( top >= plq->Cnt )
					top-=plq->Cnt;
				idx--;
			}else { idx = -1; break; }
		}
		if( idx == -1 )
			return plq->pNode[top];
	}
	return NULL;
}
POINTER  PeekQueue ( PLINKQUEUE plq )
{
	return PeekQueueEx( plq, 0 );
}
//--------------------------------------------------------------------------
POINTER  DequeLink ( PLINKQUEUE *pplq )
{
	POINTER p;
	INDEX tmp;
	if( pplq && *pplq )
	{
#if USE_CUSTOM_ALLOCER
		int keep_lock = 0;
#endif
		uint32_t priorline;
#if USE_CUSTOM_ALLOCER
retry_lock:
#endif
		while( ( priorline = LockedExchange( link_queue_local_lock, __LINE__ ) ) )
		{
#if USE_CUSTOM_ALLOCER
			if( link_queue_local_thread == MakeThread() )
			{
				keep_lock = 1;
				break;
			}
#endif
			Relinquish();
		}
#if USE_CUSTOM_ALLOCER
		if( !pplq )
		{
			if( !keep_lock )
				link_queue_local_lock[0] = 0;
			return NULL;
		}
		if( (*pplq)->Lock )
		{
			if( !keep_lock )
				link_queue_local_lock[0] = 0;
			Relinquish();
			goto retry_lock;
		}
		(*pplq)->Lock = 1;
		if( !keep_lock )
			link_queue_local_lock[0] = 0;
#else
		if( !(*pplq) )
		{
			//it could have been deallocated
			link_queue_local_lock[0] = 0;
			return (*pplq);
		}
#endif
	}
	else
		return NULL;
	p = NULL;
	if( (*pplq)->Bottom != (*pplq)->Top )
	{
		tmp = (*pplq)->Bottom + 1;
		if( tmp >= (*pplq)->Cnt )
			tmp -= (*pplq)->Cnt;
		p = (*pplq)->pNode[(*pplq)->Bottom];
		(*pplq)->Bottom = tmp;
	}
#if USE_CUSTOM_ALLOCER
	(*pplq)->Lock = 0;
#endif
	link_queue_local_lock[0] = 0;
	return p;
}
POINTER  DequeLinkNL( PLINKQUEUE *pplq )
{
	INDEX b, t, c, tmp;
	POINTER p;
	if( !pplq || !*pplq )
		return NULL;
	p = NULL;
	if( (b=( *pplq )->Bottom) != (t=( *pplq )->Top) )
	{
		tmp = b + 1;
		if( tmp >= ( c = ( *pplq )->Cnt ) )
			tmp -= c;
		p = ( *pplq )->pNode[b];
		( *pplq )->Bottom = tmp;
	}
	return p;
}
#ifdef __cplusplus
//		namespace queue {
}
#endif
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
#ifdef __cplusplus
		namespace data_queue {
#endif
static struct data_queue_local_data
{
	volatile uint32_t lock;
} s_data_queue_local, *_data_queue_local;
#ifdef __STATIC_GLOBALS__
#  define data_queue_local  ((s_data_queue_local))
#  define data_queue_local_lock ((&s_data_queue_local.lock))
#else
#  define data_queue_local  ((_data_queue_local)?(*_data_queue_local):(s_data_queue_local))
#  define data_queue_local_lock ((_data_queue_local)?(&_data_queue_local->lock):(&s_data_queue_local.lock))
#endif
PDATAQUEUE CreateDataQueueEx( INDEX size DBG_PASS )
{
	PDATAQUEUE pdq;
	pdq = (PDATAQUEUE)AllocateEx( ( ( sizeof( DATAQUEUE ) + (2*size) ) - 1 ) DBG_RELAY );
	pdq->Top      = 0;
	pdq->Bottom	  = 0;
	pdq->ExpandBy = 16;
	pdq->Size     = size;
	pdq->Cnt      = 2;
	return pdq;
}
//--------------------------------------------------------------------------
void DeleteDataQueueEx( PDATAQUEUE *ppdq DBG_PASS )
{
	if( ppdq )
	{
		if( *ppdq )
			ReleaseEx( *ppdq DBG_RELAY );
		*ppdq = NULL;
	}
}
//--------------------------------------------------------------------------
static PDATAQUEUE ExpandDataQueueEx( PDATAQUEUE *ppdq, INDEX entries DBG_PASS )
{
	PDATAQUEUE pdqNew = NULL;
	if( ppdq )
	{
		PDATAQUEUE pdq = *ppdq;
		//pdq->Cnt += entries;
		pdqNew = (PDATAQUEUE)AllocateEx( (uint32_t)offsetof( DATAQUEUE, data[0] ) + ((pdq->Cnt+entries)  * pdq->Size) DBG_RELAY );
		pdqNew->Cnt = pdq->Cnt + entries;
		pdqNew->ExpandBy = pdq->ExpandBy;
		pdqNew->Bottom = 0;
		pdqNew->Size = pdq->Size;
		if( pdq->Bottom > pdq->Top )
		{
			INDEX bottom_half;
			/* if you see '- entries' in a diff... it was decided to not add it to the original queue above, instead */
			pdqNew->Top = (bottom_half = ( pdq->Cnt ) - pdq->Bottom ) + pdq->Top;
			MemCpy( pdqNew->data
				, pdq->data + (pdq->Bottom * pdq->Size)
				, pdq->Size * bottom_half );
			MemCpy( pdqNew->data + ( bottom_half * pdq->Size )
				, pdq->data
				, pdq->Size * pdq->Top );
		}
		else
		{
			pdqNew->Top = pdq->Top - pdq->Bottom;
			MemCpy( pdqNew->data
				, pdq->data + (pdq->Bottom * pdq->Size)
				, pdq->Size * pdqNew->Top );
		}
		(*ppdq) = pdqNew;
		Release( pdq );
	}
	return pdqNew;
}
PDATAQUEUE  CreateLargeDataQueueEx( INDEX size, INDEX entries, INDEX expand DBG_PASS )
{
	PDATAQUEUE pdq = CreateDataQueueEx( size DBG_RELAY );
	pdq->ExpandBy = expand;
	ExpandDataQueueEx( &pdq, entries DBG_RELAY );
	return pdq;
}
//--------------------------------------------------------------------------
 PDATAQUEUE  EnqueDataEx ( PDATAQUEUE *ppdq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PDATAQUEUE pdq;
	if( !ppdq )
		return NULL;
	if( !(*ppdq) )
 // cannot create this - no idea how big.
		return NULL;
	while( LockedExchange( data_queue_local_lock, 1 ) )
		Relinquish();
	pdq = *ppdq;
	if( link )
	{
		tmp = pdq->Top + 1;
		if( tmp >= pdq->Cnt )
			tmp -= pdq->Cnt;
 // collided with self...
		if( tmp == pdq->Bottom )
		{
			pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = pdq->Top + 1;
		}
		MemCpy( pdq->data + ( pdq->Top * pdq->Size ), link, pdq->Size );
		pdq->Top = tmp;
	}
	data_queue_local_lock[0] = 0;
	return pdq;
}
//--------------------------------------------------------------------------
 PDATAQUEUE  PrequeDataEx ( PDATAQUEUE *ppdq, POINTER link DBG_PASS )
{
	INDEX tmp;
	PDATAQUEUE pdq;
	if( !ppdq )
		return NULL;
	if( !(*ppdq) )
 // cannot create this - no idea how big.
		return NULL;
	while( LockedExchange( data_queue_local_lock, 1 ) )
		Relinquish();
	pdq = *ppdq;
	if( link )
	{
		tmp = pdq->Bottom - 1;
		if( tmp > 0x80000000 )
			tmp += pdq->Cnt;
 // collided with self...
		if( tmp == pdq->Top )
		{
			// expand re-aligns queue elements so bottom is 0 and top is N
			// so the bottom will always wrap when we try to add to the beginning...
			pdq = ExpandDataQueueEx( ppdq, (*ppdq)->ExpandBy DBG_RELAY );
 // should be room at the end of phsyical array....
			tmp = pdq->Cnt - 1;
		}
		MemCpy( pdq->data + ( tmp * pdq->Size ), link, pdq->Size );
		pdq->Bottom = tmp;
	}
	data_queue_local_lock[0] = 0;
	return pdq;
}
//--------------------------------------------------------------------------
 LOGICAL  IsDataQueueEmpty ( PDATAQUEUE *ppdq  )
{
	if( !ppdq || !(*ppdq) ||
		(*ppdq)->Bottom == (*ppdq)->Top )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
 LOGICAL  DequeData ( PDATAQUEUE *ppdq, POINTER result )
{
	LOGICAL p;
	INDEX tmp;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	p = 0;
	if( (*ppdq)->Bottom != (*ppdq)->Top )
	{
		tmp = (*ppdq)->Bottom + 1;
		if( tmp >= (*ppdq)->Cnt )
			tmp -= (*ppdq)->Cnt;
		if( result )
			MemCpy( result
					, (*ppdq)->data + (*ppdq)->Bottom * (*ppdq)->Size
					, (*ppdq)->Size );
		p = 1;
		(*ppdq)->Bottom = tmp;
	}
	data_queue_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
 LOGICAL  UnqueData ( PDATAQUEUE *ppdq, POINTER result )
{
	LOGICAL p;
	INDEX tmp;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	p = 0;
	if( (*ppdq)->Bottom != (*ppdq)->Top )
	{
		tmp = (*ppdq)->Top;
		if( tmp )
			tmp--;
		else
			tmp = ((*ppdq)->Cnt)-1;
		if( result )
			MemCpy( result
					, (*ppdq)->data + tmp * (*ppdq)->Size
					, (*ppdq)->Size );
		p = 1;
		(*ppdq)->Top = tmp;
	}
	data_queue_local_lock[0] = 0;
	return p;
}
//--------------------------------------------------------------------------
// zero is the first,
#undef PeekDataQueueEx
 LOGICAL  PeekDataQueueEx ( PDATAQUEUE *ppdq, POINTER result, INDEX idx )
{
	INDEX top;
	if( ppdq && *ppdq )
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
	else
		return 0;
	// cannot get invalid id.
	if( idx != INVALID_INDEX )
	{
		for( top = (*ppdq)->Bottom;
			 idx != INVALID_INDEX && top != (*ppdq)->Top
			 ; )
		{
			idx--;
			if( idx != INVALID_INDEX )
			{
				top++;
				if( (top) >= (*ppdq)->Cnt )
					top = top-(*ppdq)->Cnt;
			}
		}
		if( idx == INVALID_INDEX )
		{
			MemCpy( result, (*ppdq)->data + top * (*ppdq)->Size, (*ppdq)->Size );
			data_queue_local_lock[0] = 0;
			return 1;
			//return (*ppdq)->pNode + top;
		}
	}
	data_queue_local_lock[0] = 0;
	return 0;
}
#undef PeekDataQueue
 LOGICAL  PeekDataQueue ( PDATAQUEUE *ppdq, POINTER result )
{
	return PeekDataQueueEx( ppdq, result, 0 );
}
void  EmptyDataQueue ( PDATAQUEUE *ppdq )
{
	if( ppdq && *ppdq )
	{
		while( LockedExchange( data_queue_local_lock, 1 ) )
			Relinquish();
		(*ppdq)->Bottom = (*ppdq)->Top = 0;
		data_queue_local_lock[0] = 0;
	}
}
#ifdef __cplusplus
//		namespace data_queue {
};
#endif
#ifndef __STATIC_GLOBALS__
PRIORITY_PRELOAD( InitLocals, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
#  ifdef __cplusplus
	RegisterAndCreateGlobal((POINTER*)&list::_list_local, sizeof( *list::_list_local ), WIDE("_list_local") );
	RegisterAndCreateGlobal((POINTER*)&data_list::_data_list_local, sizeof( *data_list::_data_list_local ), WIDE("_data_list_local") );
	RegisterAndCreateGlobal((POINTER*)&queue::_link_queue_local, sizeof( *queue::_link_queue_local ), WIDE("_link_queue_local") );
	RegisterAndCreateGlobal((POINTER*)&data_queue::_data_queue_local, sizeof( *data_queue::_data_queue_local ), WIDE("_data_queue_local") );
#  else
	SimpleRegisterAndCreateGlobal( _list_local );
	SimpleRegisterAndCreateGlobal( _data_list_local );
	SimpleRegisterAndCreateGlobal( _link_queue_local );
	SimpleRegisterAndCreateGlobal( _data_queue_local );
#  endif
}
#endif
#ifdef __cplusplus
 //namespace sack {
};
 //	namespace containers {
};
#endif
//--------------------------------------------------------------
// $Log: typecode.c,v $
// Revision 1.47  2005/05/25 16:50:30  d3x0r
// Synch with working repository.
//
// Revision 1.56  2005/05/20 23:15:13  jim
// Remove a noisy logging statement
//
// Revision 1.55  2005/05/16 23:18:22  jim
// Allocate the correct amount of space for the message queue - it's a MSGQUEUE not a DATAQUEUE.  Also implement DequeMessage() in such a way that the waited for message ID can change.
//
// Revision 1.54  2005/05/02 17:02:58  jim
// Moved the process-wait information to a seperate queue... does not work inline with normal messages...
//
// Revision 1.53  2005/04/20 23:38:20  jim
// Fixed leaving the critical section under a loop condition that resulted in error.
//
// Revision 1.52  2005/04/18 15:55:59  jim
// Much logging added to sack's implementation of SYSV msgq communications.
//
// Revision 1.51  2005/03/22 12:33:50  panther
// Restore disabled message queue logging
//
// Revision 1.50  2005/03/17 02:23:53  panther
// Checkpoint - working on message server abstraction interface... some of this seems to work quite well, some of this is still broken very badly...
//
// Revision 1.49  2005/03/14 16:04:03  panther
// If someone is waiting for any message, then they are definatly waiting for the currently enquing message.
//
// Revision 1.48  2005/01/27 07:18:34  panther
// Linux cleaned.
//
// Revision 1.47  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.46  2004/10/25 10:40:00  d3x0r
// Linux compilation cleaning requirements...
//
// Revision 1.45  2004/10/02 19:49:57  d3x0r
// Fix logging... trying to track down multiple update display issues.... keys are queued, events are locally queued...
//
// Revision 1.44  2004/09/30 22:02:43  d3x0r
// checkpoing
//
// Revision 1.43  2004/09/30 09:42:52  d3x0r
// Fixed message queues for single app, all wraps, and nearly for two apps, but when removing logging, lost stability :(
//
// Revision 1.42  2004/09/30 01:14:48  d3x0r
// Cleaned up consistancy of PID and thread ID... extended message service a bit to supply event PID both ways.
//
// Revision 1.41  2004/09/29 16:43:03  d3x0r
// fixed queues a bit - added a test wait function for timers/threads
//
// Revision 1.40  2004/09/29 00:49:00  d3x0r
// Store waiting thread IDs IN the message queue... need to figure out how to shuffle these around.
//
// Revision 1.39  2004/09/24 08:09:49  d3x0r
// Test tial meeting the head...
//
// Revision 1.38  2004/09/23 11:07:33  d3x0r
// Minor adjustments...
//
// Revision 1.37  2004/09/23 00:36:55  d3x0r
// Fix result code when error no message and no wait... fix test for read messages and end of queue messages.
//
// Revision 1.36  2004/08/16 06:32:10  d3x0r
// Fix message queue routines... protect against no handle
//
// Revision 1.35  2004/07/13 04:17:49  d3x0r
// clean some warnings, and fix definiton of PRELOAD to be compiler friendly.
//
// Revision 1.34  2004/06/12 09:09:41  d3x0r
// ug - if queue is empty peek must be NULL...
//
// Revision 1.33  2004/05/24 16:40:29  d3x0r
// Add PeekQueue and GetQUeueLength
//
// Revision 1.32  2003/11/28 20:21:35  panther
// Add and fix EmptyList
//
// Revision 1.31  2003/10/31 02:24:53  panther
// Modified test to take variable msg count.
//
// Revision 1.30  2003/10/26 23:40:46  panther
// minor type fixes
//
// Revision 1.29  2003/10/26 23:32:17  panther
// Looks like most issues with simple message queuing are done.
//
// Revision 1.28  2003/10/22 10:45:40  panther
// Handle null lists in find
//
// Revision 1.27  2003/10/21 01:39:37  panther
// Fixed some issues with new perma-wait critical sections...
//
// Revision 1.26  2003/10/20 03:01:21  panther
// Fix getmythreadid - split depending if getpid returns ppid or pid.
// Fix memory allocator to init region correctly...
// fix initial status of found thred to reflect sleeping
// in /proc/#/status
//
// Revision 1.25  2003/10/20 00:04:21  panther
// Extend OpenSpace in SharedMem
// revise msgqueue operations to more resemble sysVipc msgq
//
// Revision 1.24  2003/10/18 23:41:04  panther
// Checkpoint... probably defuct
//
// Revision 1.23  2003/10/18 04:43:00  panther
// Quick patch...
//
// Revision 1.22  2003/10/17 00:56:05  panther
// Rework critical sections.
// Moved most of heart of these sections to timers.
// When waiting, sleep forever is used, waking only when
// released... This is preferred rather than continuous
// polling of section with a Relinquish.
// Things to test, event wakeup order uner linxu and windows.
// Even see if the wake ever happens.
// Wake should be able to occur across processes.
// Also begin implmeenting MessageQueue in containers....
// These work out of a common shared memory so multiple
// processes have access to this region.
//
// Revision 1.21  2003/08/20 08:07:13  panther
// some fixes to blot scaled... fixed to makefiles test projects... fixes to export containters lib funcs
//
// Revision 1.20  2003/07/25 10:21:57  panther
// Fix callback for foralllinks
//
// Revision 1.19  2003/05/12 01:31:52  panther
// Fix return
//
// Revision 1.18  2003/05/02 01:11:26  panther
// Many minor fixes, tweaks....
//
// Revision 1.17  2003/04/21 11:46:52  panther
// Ug - forgot a commit somewhere... return pointer at set data item
//
// Revision 1.16  2003/04/20 08:14:07  panther
// *** empty log message ***
//
// Revision 1.15  2003/04/12 20:52:46  panther
// Added new type contrainer - data list.
//
// Revision 1.14  2003/03/31 01:11:28  panther
// Tweaks to work better under service application
//
// Revision 1.13  2003/03/30 21:15:57  panther
// Added EX functions to pass application source to DataStack allocations
//
// Revision 1.12  2003/03/30 00:14:36  panther
// fix pop stack data function
//
// Revision 1.11  2003/01/28 16:37:48  panther
// More logging extended logging
//
// Revision 1.10  2003/01/27 09:20:34  panther
// Error in passing debug argument to create queue
//
// Revision 1.9  2003/01/22 17:10:09  panther
// Added forwarding in EnqueLink To CreateQueue
//
// Revision 1.8  2002/11/06 09:49:17  panther
// Fixed data-queue allocation/copy.
//
// Revision 1.7  2002/11/04 09:29:50  panther
// Added container class - DATAQUEUE.
//
//
//  - Added DataQueue to compliment LinkQueue  (datastack/linkstack)
//  - Added EmptyDataStack method to quickly remove all items on stack.
// Revision 1.6  2002/07/15 08:28:56  panther
// Fixed some debug passing to allocate.
//
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   code to provide a robust text class for C
 *   Parsing, text substitution, replacment, phrase splitting
 *   options for paired parsing of almost all pairable symbols
 *   used in common language.
 *
 *
 * see also - include/typelib.h
 *
 */
#ifdef _UNICODE
#define _INCLUDE_NLS
#endif
#define NO_UNICODE_C
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace text {
	using namespace sack::memory;
	using namespace sack::logging;
	using namespace sack::containers::queue;
#endif
typedef PTEXT (CPROC*GetTextOfProc)( uintptr_t, POINTER );
typedef struct text_exension_tag {
	uint32_t bits;
	GetTextOfProc TextOf;
	uintptr_t psvData;
}  TEXT_EXTENSION, *PTEXT_EXTENSION;
typedef struct vartext_tag {
	TEXTSTR collect_text;
	size_t collect_used;
	size_t collect_avail;
	size_t expand_by;
	PTEXT collect;
	PTEXT commit;
} VARTEXT;
//#ifdef __cplusplus
static PTEXT newline;
static PTEXT blank;
PRELOAD( AllocateDefaults )
{
	newline = (PTEXT)SegCreateFromText( WIDE("") );
	blank = (PTEXT)SegCreateFromText( WIDE(" ") );
}
//#define newline (*newline)
//#define blank	(*blank)
//#else
//__declspec( dllexport ) TEXT newline = { TF_STATIC, NULL, NULL, {1,1},{0,WIDE("")}};
//__declspec( dllexport ) TEXT blank = { TF_STATIC, NULL, NULL, {1,1},{1,WIDE(" ")}};
//#endif
static PLIST pTextExtensions;
//---------------------------------------------------------------------------
PTEXT SegCreateEx( size_t size DBG_PASS )
{
	PTEXT pTemp;
#if defined( _MSC_VER )
	//if( size > 0x8000 )
	//	_asm int 3;
#endif
	pTemp = (PTEXT)AllocateEx( sizeof(TEXT) + (size
#ifdef _MSC_VER
		+ 1
#endif
		)*sizeof(TEXTCHAR)
 // good thing [1] is already counted.
		DBG_RELAY );
	MemSet( pTemp, 0, sizeof(TEXT) + (size*sizeof(TEXTCHAR)) );
	pTemp->format.flags.prior_background = 1;
	pTemp->format.flags.prior_foreground = 1;
 // physical space IS one more....
	pTemp->data.size = size;
	return pTemp;
}
//---------------------------------------------------------------------------
PTEXT GetIndirect(PTEXT segment )
{
	if( !segment )
		return NULL;
	if( (segment->flags&TF_APPLICATION) )
	{
		INDEX idx;
		PTEXT_EXTENSION pte;
		LIST_FORALL( pTextExtensions, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->bits & segment->flags )
			{
				// size is used as a pointer...
				segment = pte->TextOf( pte->psvData, (POINTER)segment->data.size );
				break;
			}
		}
		if( !pte )
			return NULL;
		return segment;
	}
	// if it's not indirect... don't result..
	if( !(segment->flags&TF_INDIRECT) )
		return NULL;
	return (PTEXT)(segment->data.size);
}
//---------------------------------------------------------------------------
TEXTSTR GetText( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			return segment->data.data;
	}
	return NULL;
}
//---------------------------------------------------------------------------
size_t GetTextSize( PTEXT segment )
{
	while( segment )
	{
		if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		{
			segment = GetIndirect( segment );
		}
		else
			if( !segment->data.size )
			{
				if( segment->flags & IS_DATA_FLAGS )
				{
					//lprintf( "Is Data falgs returns 2. %08x", segment->flags & IS_DATA_FLAGS );
 // is data even if is not acurate....
					return segment->data.size;
				}
				break;
			}
			else
				return segment->data.size;
	}
	return 0;
}
//---------------------------------------------------------------------------
uint32_t GetTextFlags( PTEXT segment )
{
	if( !segment )
		return 0;
	if( segment->flags & (TF_INDIRECT|TF_APPLICATION) )
		return GetTextFlags( GetIndirect( segment ) );
	return segment->flags;
}
//---------------------------------------------------------------------------
void SegCopyFormat( PTEXT to_this, PTEXT copy_this )
{
	if( to_this && copy_this )
	{
		if( copy_this && !( copy_this->flags & TF_FORMATPOS ) )
		{
			to_this->format.position.offset.tabs = copy_this->format.position.offset.tabs;
			to_this->format.position.offset.spaces = copy_this->format.position.offset.spaces;
		}
		else
		{
			// copy absolute positioning...
		}
	}
}
//---------------------------------------------------------------------------
PTEXT SegDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT t;
	size_t n;
	if( pText )
	{
		if( pText->flags & TF_APPLICATION )
		{
			t = SegCreateIndirect( (PTEXT)pText->data.size );
			t->format = pText->format;
			t->flags = pText->flags;
		}
		else if( pText->flags & TF_INDIRECT )
		{
			t = SegCreateIndirectEx( SegDuplicateEx( GetIndirect( pText ) DBG_RELAY ) DBG_RELAY );
			t->format = pText->format;
			// some other mask needs to be here.. the getindirect
			// will have other flags...
			t->flags = pText->flags;
		}
		else
		{
			t = SegCreateEx( n = GetTextSize( pText ) DBG_RELAY );
			t->format = pText->format;
			MemCpy( GetText(t), GetText(pText), sizeof( TEXTCHAR ) * ( n + 1 ) );
			t->flags = pText->flags;
		}
		t->flags &= ~(TF_DEEP|TF_STATIC);
		return t;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT LineDuplicateEx( PTEXT pText DBG_PASS )
{
	PTEXT pt;
	pt = pText;
	while( pt )
	{
		if( !(pt->flags&TF_STATIC) )
			HoldEx( (uint8_t*)pt DBG_RELAY  );
		if( (pt->flags & TF_INDIRECT ) || (pt->flags&TF_APPLICATION) )
			LineDuplicateEx( GetIndirect( pt ) DBG_RELAY );
		pt = NEXTLINE( pt );
	}
	return pText;
}
//---------------------------------------------------------------------------
PTEXT TextDuplicateEx( PTEXT pText, int bSingle DBG_PASS )
{
	PTEXT pt;
	PTEXT pDup = NULL, pNew;
	pt = pText;
	while( pt )
	{
		if( (pt->flags & TF_INDIRECT ) && !(pt->flags&TF_APPLICATION) )
		{
			pNew = SegCreateIndirectEx(
			            TextDuplicateEx(
			                  GetIndirect( pt ), bSingle DBG_RELAY ) DBG_RELAY );
			pNew->format.position = pt->format.position;
			pNew->flags |= pt->flags&(IS_DATA_FLAGS);
			pNew->flags |= TF_DEEP;
		}
		else
			pNew = SegDuplicateEx( pt DBG_RELAY );
		pDup = SegAppend( pDup, pNew );
		if( bSingle )
			break;
		pt = NEXTLINE( pt );
	}
	return pDup;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromTextEx( CTEXTSTR text DBG_PASS )
{
	PTEXT pTemp;
	size_t nSize;
	if( text )
	{
		pTemp = SegCreateEx( nSize = StrLen( text ) DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( nSize + 1 ) );
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharLenEx( const char *text, size_t len DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
#ifdef _UNICODE
		TEXTSTR text_string = CharWConvertLen( text, len );
		pTemp = SegCreateEx( len DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text_string, sizeof( TEXTCHAR ) * ( len + 1 ) );
		Deallocate( TEXTSTR, text_string );
#else
		pTemp = SegCreateEx( len DBG_RELAY );
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( len + 1 ) );
#endif
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromCharEx( const char *text DBG_PASS )
{
	return SegCreateFromCharLenEx( text, strlen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideLenEx( const wchar_t *text, size_t nSize DBG_PASS )
{
	PTEXT pTemp;
	if( text )
	{
#ifdef _UNICODE
		pTemp = SegCreateEx( nSize DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text, sizeof( TEXTCHAR ) * ( nSize + 1 ) );
#else
		TEXTSTR text_string = WcharConvertLen( text, nSize );
		int outlen;
		for( outlen = 0; text_string[outlen]; outlen++ );
		pTemp = SegCreateEx( outlen DBG_RELAY );
		// include nul on copy
		MemCpy( pTemp->data.data, text_string, sizeof( TEXTCHAR ) * ( outlen + 1 ) );
		Deallocate( TEXTSTR, text_string );
#endif
		return pTemp;
	}
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromWideEx( const wchar_t *text DBG_PASS )
{
	return SegCreateFromWideLenEx( text, wcslen( text ) DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromIntEx( int value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 12 DBG_RELAY);
#ifdef _UNICODE
	pResult->data.size = swprintf( pResult->data.data, 12, WIDE("%d"), value );
#else
	pResult->data.size = snprintf( pResult->data.data, 12, WIDE("%d"), value );
#endif
	pResult->data.data[11] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFrom_64Ex( int64_t value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
#ifdef _UNICODE
	pResult->data.size = swprintf( pResult->data.data, 32, WIDE("%")_64f, value );
#else
	pResult->data.size = snprintf( pResult->data.data, 32, WIDE("%")_64f, value );
#endif
pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateFromFloatEx( float value DBG_PASS )
{
	PTEXT pResult;
	pResult = SegCreateEx( 32 DBG_RELAY);
#ifdef _UNICODE
	pResult->data.size = swprintf( pResult->data.data, 32, WIDE("%f"), value );
#else
	pResult->data.size = snprintf( pResult->data.data, 32, WIDE("%f"), value );
#endif
	pResult->data.data[31] = 0;
	return pResult;
}
//---------------------------------------------------------------------------
PTEXT SegCreateIndirectEx( PTEXT pText DBG_PASS )
{
	PTEXT pSeg;
 // no data content for indirect...
	pSeg = SegCreateEx( -1 DBG_RELAY );
	pSeg->flags |= TF_INDIRECT;
	pSeg->data.size = (uintptr_t)pText;
	return pSeg;
}
//---------------------------------------------------------------------------
  // remove leading segments.
PTEXT SegBreak(PTEXT segment)
	 // return leading segments!  might be ORPHANED if not handled.
{
	PTEXT temp;
	if( !segment )
		return NULL;
	if((temp=PRIORLINE(segment)))
		SETNEXTLINE(temp,NULL);
	SETPRIORLINE(segment,NULL);
	return(temp);
}
INDEX  GetSegmentSpaceEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs)
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < nTabs && (INDEX)position > tabs[n]; n++ );
			if( n < nTabs )
				// now position is before the first tab... such that
				for( ; n < nTabs && n < segment->format.position.offset.tabs; n++ )
				{
					total += tabs[n]-position;
					position = tabs[n];
				}
			lprintf( WIDE("Adding %d spaces"), segment->format.position.offset.spaces );
			total += segment->format.position.offset.spaces;
		}
	}
	while( (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentSpace ( PTEXT segment, INDEX position, int nTabSize )
{
	INDEX total = 0;
	do
	{
		if( segment && !( segment->flags & TF_FORMATPOS ) )
		{
			int n;
			for( n = 0; n < segment->format.position.offset.tabs; n++ )
			{
				if( !total )
					// I think this is wrong.  need to validate this equation.
					total += (position % nTabSize) + 1;
				else
					total += nTabSize;
			}
			total += segment->format.position.offset.spaces;
		}
	}
	while( (segment->flags & TF_INDIRECT) && ( segment = GetIndirect( segment ) ) );
	return total;
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLengthEx ( PTEXT segment, size_t position, int nTabs, INDEX *tabs )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpaceEx( segment, position, nTabs, tabs ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
INDEX  GetSegmentLength ( PTEXT segment, size_t position, int nTabSize )
{
	while( segment && segment->flags & TF_INDIRECT )
		segment = GetIndirect( segment );
	return GetSegmentSpace( segment, position, nTabSize ) + GetTextSize( segment );
}
//---------------------------------------------------------------------------
PTEXT SegAppend(PTEXT source,PTEXT other)
{
	PTEXT temp=source;
	if( temp )
	{
		if( other )
		{
			SetEnd(temp);
			SETNEXTLINE(temp,other);
			SETPRIORLINE(other,temp);
		}
	}
	else
	{
  // nothing was before...
		source=other;
	}
	return(source);
}
//---------------------------------------------------------------------------
void SegReleaseEx( PTEXT seg DBG_PASS)
{
	if( seg )
		ReleaseEx( seg DBG_RELAY );
}
//---------------------------------------------------------------------------
PTEXT SegExpandEx(PTEXT source, INDEX nSize DBG_PASS)
{
	PTEXT temp;
	//Log1( WIDE("SegExpand...%d"), nSize );
	temp = SegCreateEx( GetTextSize( source ) + nSize  DBG_RELAY );
	if( source )
	{
		MemCpy( temp->data.data, source->data.data, sizeof( TEXTCHAR)*(GetTextSize( source ) + 1) );
		temp->flags = source->flags;
		temp->format = source->format;
		SegSubst( temp, source );
		SegRelease( source );
	}
	return temp;
}
//---------------------------------------------------------------------------
void LineReleaseEx(PTEXT line DBG_PASS )
{
	PTEXT temp;
	if( !line )
		return;
	SetStart(line);
	while(line)
	{
		temp=NEXTLINE(line);
		if( !(line->flags&TF_STATIC) )
		{
			if( (( line->flags & (TF_INDIRECT|TF_DEEP) ) == (TF_INDIRECT|TF_DEEP) ) )
 // if indirect, don't want to release application content
				if( !(line->flags & TF_APPLICATION) )
					LineReleaseEx( GetIndirect( line ) DBG_RELAY );
			ReleaseEx( line DBG_RELAY );
		}
		line=temp;
	}
}
//---------------------------------------------------------------------------
PTEXT SegConcatEx(PTEXT output,PTEXT input,int32_t offset,size_t length DBG_PASS )
{
	size_t idx=0;
	size_t len=0;
	PTEXT newseg;
	SegAppend( output, newseg = SegCreateEx( length DBG_RELAY ) );
	output = newseg;
	//output=SegExpandEx(output, length DBG_RELAY); /* add 1 for a null */
	GetText(output)[0]=0;
	while (input&&idx<length)
	{
		//#define min(a,b) (((a)<(b))?(a):(b))
		if( ( GetTextSize( input ) - offset ) < ( length-idx  ) )
			len = GetTextSize( input ) - offset;
		else
         len = length - idx;
		MemCpy( GetText(output) + idx,
				  GetText(input) + offset,
				  sizeof( TEXTCHAR ) * ( len + 1 ) );
		idx += len;
		offset = 0;
		input=NEXTLINE(input);
	}
	GetText(output)[idx]=0;
	return(output);
}
//---------------------------------------------------------------------------
PTEXT SegUnlink(PTEXT segment)
{
	PTEXT temp;
	if (segment)
	{
		if( ( temp = PRIORLINE(segment) ) )
			SETNEXTLINE(temp,NEXTLINE(segment));
		if( ( temp = NEXTLINE(segment) ) )
			SETPRIORLINE(temp,PRIORLINE(segment));
		SETPRIORLINE(segment, NULL);
		SETNEXTLINE(segment, NULL);
	}
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegGrab( PTEXT segment )
{
	SegUnlink( segment );
	return segment;
}
//---------------------------------------------------------------------------
PTEXT SegDelete( PTEXT segment )
{
	LineReleaseEx( SegGrab( segment ) DBG_SRC );
	return NULL;
}
//---------------------------------------------------------------------------
PTEXT SegInsert( PTEXT what, PTEXT before )
{
	PTEXT that_start = what ,
			that_end= what;
	SetStart( that_start );
	SetEnd( that_end );
	if( before )
	{
		if( ( that_start->Prior = before->Prior) )
			that_start->Prior->Next = that_start;
		if( ( that_end->Next = before ) )
			that_end->Next->Prior = that_end;
	}
	return what;
}
//---------------------------------------------------------------------------
PTEXT SegSubst( PTEXT _this, PTEXT that )
{
	PTEXT that_start = that ,
			that_end= that;
	SetStart( that_start );
	SetEnd( that_end );
	if( ( that_end->Next = _this->Next ) )
		that_end->Next->Prior = that_end;
	if( ( that_start->Prior = _this->Prior) )
		that_start->Prior->Next = that_start;
	_this->Next = NULL;
	_this->Prior = NULL;
	return _this;
}
//---------------------------------------------------------------------------
PTEXT SegSplitEx( PTEXT *pLine, INDEX nPos  DBG_PASS)
{
	// there includes the character at nPos - so all calculations
	// on there are +1...
	PTEXT here, there;
	size_t nLen;
	nLen = GetTextSize( *pLine );
	if( nPos > nLen )
	{
		return NULL;
	}
	if( nPos == nLen )
		return *pLine;
	here = SegCreateEx( nPos DBG_RELAY );
	here->flags  = (*pLine)->flags;
	here->format = (*pLine)->format;
	there = SegCreateEx( (nLen - nPos) DBG_RELAY );
	there->flags  = (*pLine)->flags;
	there->format = (*pLine)->format;
 // was two characters presumably...
	there->format.position.offset.spaces = 0;
	there->format.position.offset.tabs = 0;
	MemCpy( GetText( here ), GetText( *pLine ), sizeof(TEXTCHAR)*nPos );
	GetText( here )[nPos] = 0;
	if( nLen - nPos )
	{
		MemCpy( GetText( there ), GetText( *pLine ) + nPos, sizeof(TEXTCHAR)*(nLen - nPos) );
		GetText( there )[nLen-nPos] = 0;
	}
	SETNEXTLINE( PRIORLINE( *pLine ), here );
	SETPRIORLINE( here, PRIORLINE( *pLine ) );
	SETNEXTLINE( here, there );
	SETPRIORLINE( there, here );
	SETNEXTLINE( there, NEXTLINE( *pLine ) );
	SETPRIORLINE( NEXTLINE( *pLine ), there );
	SETNEXTLINE( *pLine, NULL );
	SETPRIORLINE( *pLine, NULL );
	LineReleaseEx( *pLine DBG_RELAY );
	*pLine = here;
	return here;
}
//----------------------------------------------------------------------
TEXTCHAR NextCharEx( PTEXT input, size_t idx )
{
	if( ( ++idx ) >= input->data.size )
	{
		idx -= input->data.size;
		input = NEXTLINE( input );
	}
	if( input )
		return input->data.data[idx];
	return 0;
}
#define NextChar() NextCharEx( input, index )
//----------------------------------------------------------------------
// In this final implementation - it was decided that for a general
// library, that expressions, escapes of expressions, apostrophes
// were of no consequence, and without expressions, there is no excess
// so this simply is text stream in, text stream out.
// these are just shortcuts - these bits of code were used repeatedly....
#define SET_SPACES() do {		word->format.position.offset.spaces = (uint16_t)spaces;		 word->format.position.offset.tabs = (uint16_t)tabs;		                             spaces = 0;		                                                         tabs = 0; } while(0)
//static CTEXTSTR normal_punctuation=WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`");
//static CTEXTSTR not_punctuation;
PTEXT TextParse( PTEXT input, CTEXTSTR punctuation, CTEXTSTR filter_space, int bTabs, int bSpaces  DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
	   burst into its block peices.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
	      word;
	TEXTSTR tempText;
	int has_minus = -1;
	int has_plus = -1;
	uint32_t index;
	INDEX size;
	TEXTCHAR character;
	uint32_t elipses = FALSE,
	   spaces = 0, tabs = 0;
        // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, TextParse( GetIndirect( input ), punctuation, filter_space, bTabs, bSpaces DBG_RELAY ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( WIDE("Assuming %d spaces... "), spaces );
		for (index=0;(character = tempText[index]),
 // while not at the
                   (index < size); index++)
                                         // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( WIDE("VarTextGet Failed to result.") );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				continue;
			}
		if( StrChr( filter_space, character ) )
		{
			goto is_a_space;
		}
		else if( StrChr( punctuation, character ) )
		{
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
				outdata = SegAppend( outdata, word );
				SET_SPACES();
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				outdata = SegAppend( outdata, word );
			}
			else
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				word = VarTextGetEx( &out DBG_OVERRIDE );
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		else switch(character)
		{
		case '\n':
			if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
			{
					SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
 // add a line-break packet
			outdata = SegAppend( outdata, SegCreate( 0 ) );
			break;
		case ' ':
			if( bSpaces )
			{
			is_a_space:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			}
				if(0) {
		case '\t':
					if( bTabs )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							SET_SPACES();
							outdata = SegAppend( outdata, word );
						}
						if( spaces )
						{
						//lprintf( WIDE("Input stream has mangled spaces and tabs.") );
 // assume that the tab takes care of appropriate spacing
							spaces = 0;
						}
						tabs++;
						break;
					}
				} else if(0) {
 // a space space character...
		case '\r':
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					break;
				} else if(0) {
 // handle multiple periods grouped (elipses)
		case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
						  ( c = NextChar() ) &&
						  ( c == '.' ) ) )
						{
							if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
							{
								outdata = SegAppend( outdata, word );
								SET_SPACES();
							}
							VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
							elipses = TRUE;
							break;
						}
						if( ( c = NextChar() ) &&
							( c >= '0' && c <= '9' ) )
						{
							// gather together as a floating point number...
							VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
							break;
						}
					}
				} else if(0) {
  // work seperations flaming-long-sword
				case '-':
					if( has_minus == -1 ) {
						if( !punctuation || StrChr( punctuation, '-' ) )
							has_minus = 1;
						else
							has_minus = 0;
					}
					if( !has_minus )
					{
						VarTextAddCharacterEx( &out, '-' DBG_OVERRIDE );
						break;
					}
				case '+':
				{
					int c;
					if( has_plus == -1 ) {
						if( !punctuation || StrChr( punctuation, '-' ) )
							has_plus = 1;
						else
							has_plus = 0;
					}
					if( !has_plus )
					{
						VarTextAddCharacterEx( &out, '-' DBG_OVERRIDE );
						break;
					}
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
							// gather together as a sign indication on a number.
						}
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
				}
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
PTEXT burstEx( PTEXT input DBG_PASS )
// returns a TEXT list of parsed data
{
//#define DBG_OVERRIDE DBG_SRC
//#define DBG_OVERRIDE DBG_RELAY
	/* takes a line of input and creates a line equivalent to it, but
		burst into its block peices.*/
	VARTEXT out;
	PTEXT outdata=(PTEXT)NULL,
			word;
	TEXTSTR tempText;
	uint32_t index;
	size_t size;
	TEXTCHAR character;
	uint32_t elipses = FALSE,
		spaces = 0, tabs = 0;
		  // if nothing new to process- return nothing processed.
	if (!input)
		return((PTEXT)NULL);
	VarTextInitEx( &out DBG_OVERRIDE );
  // while there is data to process...
	while (input)
	{
		if( input->flags & TF_INDIRECT )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
			outdata = SegAppend( outdata, burst( GetIndirect( input ) ) );
			input = NEXTLINE( input );
			continue;
		}
  // point to the data to process...
		tempText = GetText(input);
		size = GetTextSize(input);
		if( input->format.position.offset.spaces || input->format.position.offset.tabs )
		{
			word = VarTextGetEx( &out DBG_OVERRIDE );
			if( word )
			{
				SET_SPACES();
				outdata = SegAppend( outdata, word );
			}
		}
		spaces += input->format.position.offset.spaces;
		tabs += input->format.position.offset.tabs;
		//Log1( WIDE("Assuming %d spaces... "), spaces );
		for (index=0;(character = tempText[index]),
 // while not at the
		             (index < size); index++)
		                                      // end of the line.
		{
			if( elipses && character != '.' )
			{
				if( VarTextEndEx( &out DBG_OVERRIDE ) )
				{
					PTEXT word = VarTextGetEx( &out DBG_OVERRIDE );
					if( word )
					{
						SET_SPACES();
						outdata = SegAppend( outdata, word );
					}
					//else
					//	Log( WIDE("VarTextGet Failed to result.") );
				}
				elipses = FALSE;
			}
 // elipses and character is . - continue
			else if( elipses )
			{
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				continue;
			}
			switch(character)
			{
			case '\n':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
 // add a line-break packet
				outdata = SegAppend( outdata, SegCreate( 0 ) );
				break;
			case ' ':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				spaces++;
				break;
			case '\t':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				if( spaces )
				{
				//lprintf( WIDE("Input stream has mangled spaces and tabs.") );
					spaces = 0;
				}
				tabs++;
				break;
 // a space space character...
			case '\r':
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
 // handle multiple periods grouped (elipses)
			case '.':
				//goto NormalPunctuation;
				{
					TEXTCHAR c;
					if( ( !elipses &&
							( c = NextChar() ) &&
							( c == '.' ) ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						VarTextAddCharacterEx( &out, '.' DBG_OVERRIDE );
						elipses = TRUE;
						break;
					}
					if( ( c = NextChar() ) &&
						 ( c >= '0' && c <= '9' ) )
					{
						// gather together as a floating point number...
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
  // work seperations flaming-long-sword
			case '-':
			case '+':
				{
					int c;
					if( ( c = NextChar() ) &&
						( c >= '0' && c <= '9' ) )
					{
						if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
						{
							outdata = SegAppend( outdata, word );
							SET_SPACES();
						}
						// gather together as a sign indication on a number.
						VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
						break;
					}
				}
 // single quote bound
			case '\'':
 // double quote bound
			case '\"':
 // escape next thingy... unusable in c processor
			case '\\':
 // expression bounders
			case '(':
			case '{':
			case '[':
			case '<':
 // expression closers
			case ')':
			case '}':
			case ']':
			case '>':
  // internet addresses
			case ':':
  // email addresses
			case '@':
			case '%':
			case '/':
			case ',':
			case ';':
			case '!':
			case '?':
			case '=':
			case '*':
			case '&':
			case '$':
			case '^':
			case '~':
			case '#':
			case '`':
//			NormalPunctuation:
				if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
				{
					outdata = SegAppend( outdata, word );
					SET_SPACES();
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					outdata = SegAppend( outdata, word );
				}
				else
				{
					VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
					word = VarTextGetEx( &out DBG_OVERRIDE );
					SET_SPACES();
					outdata = SegAppend( outdata, word );
				}
				break;
			default:
				if( elipses )
				{
					if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
					{
						outdata = SegAppend( outdata, word );
						SET_SPACES();
					}
					elipses = FALSE;
				}
				VarTextAddCharacterEx( &out, character DBG_OVERRIDE );
				break;
			}
		}
		input=NEXTLINE(input);
	}
 // any generic outstanding data?
	if( ( word = VarTextGetEx( &out DBG_OVERRIDE ) ) )
	{
		outdata = SegAppend( outdata, word );
		SET_SPACES();
	}
	SetStart(outdata);
	VarTextEmptyEx( &out DBG_OVERRIDE );
	return(outdata);
}
//---------------------------------------------------------------------------
#undef LineLengthExx
size_t LineLengthExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL )
{
	return LineLengthExEx( pt, bSingle, 8, pEOL );
}
size_t LineLengthExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL )
{
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	size_t length = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		if( !(pt->flags & ( IS_DATA_FLAGS | TF_INDIRECT)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
				length += pEOL->data.size;
			else
 // full binary \r\n insertion assumed
				length += 2;
		}
		else
		{
			if( skipspaces )
				skipspaces = FALSE;
			else
			{
				if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
 // not-including NULL.
					length += GetSegmentSpace( pt, length, nTabsize );
			}
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top seg.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
 // not-including NULL.
				length += GetTextSize( pt );
stack_resume:
			if( pt->flags&TF_TAG )
				length += 2;
			if( pt->flags&TF_PAREN )
				length += 2;
			if( pt->flags&TF_BRACE )
				length += 2;
			if( pt->flags&TF_BRACKET )
				length += 2;
			if( pt->flags&TF_QUOTE )
				length += 2;
			if( pt->flags&TF_SQUOTE )
				length += 2;
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
//	if( length > 60000 )
//		_asm int 3;
	return length;
}
#undef LineLengthEx
INDEX LineLengthEx( PTEXT pt, LOGICAL bSingle )
{
	return LineLengthExx( pt, bSingle, NULL );
}
//---------------------------------------------------------------------------
// attempts to build a solitary line segment from the text passed
// however, if there are color changes, or absolute position changes
// this cannot work... and it must provide multiple peices...
#undef BuildLineExx
PTEXT BuildLineExx( PTEXT pt, LOGICAL bSingle, PTEXT pEOL DBG_PASS )
{
	return BuildLineExEx( pt, bSingle, 8, pEOL DBG_RELAY );
}
PTEXT BuildLineExEx( PTEXT pt, LOGICAL bSingle, int nTabsize, PTEXT pEOL DBG_PASS )
{
	TEXTSTR buf;
	int	TopSingle = bSingle;
	PTEXT pStack[32];
	int	nStack, firstadded;
	int	skipspaces = ( PRIORLINE(pt) != NULL );
	PTEXT pOut;
	uintptr_t ofs;
	{
		INDEX len;
		len = LineLengthExx( pt,bSingle,pEOL );
		if( !len )
			return NULL;
		pOut = SegCreateEx( len DBG_RELAY );
		firstadded = TRUE;
		buf = GetText( pOut );
	}
	ofs = 0;
	nStack = 0;
	while( pt )
	{
		if( pt->flags & TF_BINARY )
		{
			pt = NEXTLINE( pt );
			if( bSingle )
				break;
			continue;
		}
		// test color fields vs PRIOR_COLOR
		// if either the color IS the prior color - OR the value IS PRIOR_COLOR
		// then they can still be collapsed... DEFAULT_COLOR MAY be prior color
		// but there's no real telling... default is more like after a
		// attribute reset occurs...
		if( firstadded )
		{
			pOut->format.flags.foreground = pt->format.flags.foreground;
			pOut->format.flags.background = pt->format.flags.background;
			firstadded = FALSE;
		}
		else
		{
			if( ( !pt->format.flags.prior_foreground &&
				  !pt->format.flags.default_foreground &&
					pt->format.flags.foreground != pOut->format.flags.foreground ) ||
				 ( !pt->format.flags.prior_background &&
				  !pt->format.flags.default_background &&
					pt->format.flags.background != pOut->format.flags.background )
			  )
			{
				PTEXT pSplit;
				// ofs is the next valid character position....
				//Log( WIDE("Changing segment's color...") );
				if( ofs )
				{
					pSplit = SegSplitEx( &pOut, ofs DBG_RELAY );
					if( !pSplit )
					{
						lprintf( WIDE("Line was shorter than offset: %") _size_f WIDE(" vs %") _PTRSZVALfs WIDE(""), GetTextSize( pOut ), ofs );
					}
					pOut = NEXTLINE( pSplit );
					// new segments takes on the new attributes...
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
						//Log2( WIDE("Split at %d result %d"), ofs, GetTextSize( pOut ) );
						buf = GetText( pOut );
					ofs = 0;
				}
				else
				{
					pOut->format.flags.foreground = pt->format.flags.foreground;
					pOut->format.flags.background = pt->format.flags.background;
				}
			}
		}
		if( !(pt->flags& (TF_INDIRECT|IS_DATA_FLAGS)) &&
			 !pt->data.size
		  )
		{
			if( pEOL )
			{
				MemCpy( buf + ofs, pEOL->data.data, sizeof( TEXTCHAR )*(pEOL->data.size + 1) );
				ofs += pEOL->data.size;
			}
			else
			{
				buf[ofs++] = '\r';
				buf[ofs++] = '\n';
			}
		}
		else
		{
			if( skipspaces )
			{
				skipspaces = FALSE;
			}
			else if( !(pt->flags & (TF_FORMATABS|TF_FORMATREL)) )
			{
				size_t spaces = GetSegmentSpace( pt, ofs, nTabsize );
				// else we cannot collapse into single line (similar to colors.)
				while( spaces-- )
				{
					buf[ofs++] = ' ';
				}
			}
			// at this point spaces before tags, and after tags
			// which used to be expression level parsed are not
			// reconstructed correctly...
			if( pt->flags&TF_TAG )
				buf[ofs++] = '<';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = '(';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '{';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = '[';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_INDIRECT )
			{
 // will be restored when we get back to top.
				bSingle = FALSE;
				pStack[nStack++] = pt;
				pt = GetIndirect( pt );
				//if( nStack >= 32 )
				//	DebugBreak();
				continue;
			}
			else
			{
				size_t len;
				MemCpy( buf+ofs, GetText( pt ), sizeof( TEXTCHAR) * (len = GetTextSize( pt ))+1 );
					ofs += len;
			}
stack_resume:
			if( pt->flags&TF_SQUOTE )
				buf[ofs++] = '\'';
			if( pt->flags&TF_QUOTE )
				buf[ofs++] = '\"';
			if( pt->flags&TF_BRACKET )
				buf[ofs++] = ']';
			if( pt->flags&TF_BRACE )
				buf[ofs++] = '}';
			if( pt->flags&TF_PAREN )
				buf[ofs++] = ')';
			if( pt->flags&TF_TAG )
				buf[ofs++] = '>';
		}
		if( bSingle )
		{
			bSingle = FALSE;
			break;
		}
		pt = NEXTLINE( pt );
	}
	if( nStack )
	{
		pt = pStack[--nStack];
		if( !nStack )
			bSingle = TopSingle;
		goto stack_resume;
	}
 // have to return length instead of new text seg...
	if( !pOut )
		return (PTEXT)ofs;
 // if formatting was inserted into the stream...
	SetStart( pOut );
	return pOut;
}
#undef BuildLineEx
PTEXT BuildLineEx( PTEXT pt, int bSingle DBG_PASS )
{
	return BuildLineExx( pt, bSingle, FALSE DBG_RELAY );
}
PTEXT FlattenLine( PTEXT pLine )
{
	 PTEXT pCur, p;
	 pCur = pLine;
	 // all indirected segments get promoted to
	 // the first level...
	 while( pCur )
	 {
		  if( pCur->flags & TF_STATIC )
		  {
			  p = SegDuplicate( pCur );
			  if( p )
			  {
				  SegSubst( pCur, p );
				  if( pCur == pLine )
					  pLine = p;
				  LineReleaseEx( pCur DBG_SRC );
				  pCur = p;
			  }
			  else
			  {
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
					continue;
			  }
		  }
		  if( pCur->flags & TF_INDIRECT )
		  {
				if( pCur->flags & TF_DEEP )
				{
					 p = FlattenLine( GetIndirect( pCur ) );
					 pCur->flags &= ~TF_DEEP;
				}
				else
				{
					 p = TextDuplicate( GetIndirect( pCur ), FALSE );
				}
				if( p )
				{
					SegSubst( pCur, p );
					if( pCur == pLine )
						pLine = p;
					p->flags |= pCur->flags & (~(TF_INDIRECT|TF_DEEP));
					LineReleaseEx( pCur DBG_SRC );
					pCur = p;
				}
				else
				{
					PTEXT next = NEXTLINE( pCur );
					SegGrab( pCur );
					LineRelease( pCur );
					pCur = next;
				}
				continue;
		  }
		  pCur = NEXTLINE( pCur );
	 }
	 return pLine;
}
//----------------------------------------------------------------------------
POINTER GetApplicationPointer( PTEXT text )
{
	// okay indirects up to application data are okay.
	while( ( text->flags & TF_INDIRECT ) && !(text->flags & TF_APPLICATION) )
		return GetApplicationPointer( (PTEXT)text->data.size );
	if( text->flags & TF_APPLICATION )
		return (POINTER)text->data.size;
	return NULL;
}
//----------------------------------------------------------------------------
void SetApplicationPointer( PTEXT text, POINTER p)
{
	// sets only this segment.
	if( text )
	{
		text->flags |= TF_APPLICATION;
		text->data.size = (uintptr_t)p;
	}
}
//----------------------------------------------------------------------------
void RegisterTextExtension( uint32_t flags, PTEXT(CPROC*TextOf)(uintptr_t,POINTER), uintptr_t psvData)
{
	PTEXT_EXTENSION pte = (PTEXT_EXTENSION)Allocate( sizeof( TEXT_EXTENSION ) );
	pte->bits = flags;
	pte->TextOf = TextOf;
	pte->psvData = psvData;
	AddLink( &pTextExtensions, pte );
#if 0
	if( text && ( text->flags & TF_APPLICATION ) )
	{
		INDEX idx;
		PTEXT_EXENSTION pte;
		LIST_FORALL( pTextExtension, idx, PTEXT_EXTENSION, pte )
		{
			if( pte->flags & text->flags )
			{
				text = pte->TextOf( text );
				break;
			}
		}
	}
#endif
	return;
}
//---------------------------------------------------------------------------
int TextIs( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextLike( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
		return !StrCaseCmp( data, string );
	return 0;
}
//---------------------------------------------------------------------------
int TextSimilar( PTEXT pText, CTEXTSTR string )
{
	CTEXTSTR data = GetText( pText );
	if( data )
	{
		size_t len1 = data ? StrLen( data ) : 0;
		size_t len2 = string ? StrLen( string ) : 0;
		return !StrCaseCmpEx( data, string, textmin( len1, len2 ) );
	}
	return 0;
}
//---------------------------------------------------------------------------
int SameText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	CTEXTSTR d2 = GetText( l2 );
	if( d1 && d2 )
		return StrCmp( d1, d2 );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int LikeText( PTEXT l1, PTEXT l2 )
{
	CTEXTSTR d1 = GetText( l1 );
	size_t len1 = d1 ? StrLen( d1 ) : 0;
	CTEXTSTR d2 = GetText( l2 );
	size_t len2 = d2 ? StrLen( d2 ) : 0;
	if( d1 && d2 )
		return StrCaseCmpEx( d1, d2, textmin( len1, len2 ) );
	else if( d1 )
		return 1;
	else if( d2 )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
int CompareStrings( PTEXT pt1, int single1
                  , PTEXT pt2, int single2
                  , int bExact )
{
	while( pt1 && pt2 )
	{
		while( pt1 &&
				 pt1->flags && ( pt1->flags & TF_BINARY ) )
			pt1 = NEXTLINE( pt1 );
		while( pt2 &&
				 pt2->flags && ( pt2->flags & TF_BINARY ) )
			pt2 = NEXTLINE( pt2 );
		if( !pt1 && pt2 )
			return FALSE;
		if( pt1 && !pt2 )
			return FALSE;
		if( bExact )
		{
			if( SameText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		else
		{
			// Like returns string compare function literal...
			if( LikeText( pt1, pt2 ) != 0 )
				return FALSE;
		}
		if( !single1 )
		{
			pt1 = NEXTLINE( pt1 );
			if( pt1 &&
				 !GetTextSize( pt1 ) && !(pt1->flags & IS_DATA_FLAGS))
				pt1 = NULL;
		}
		else
			pt1 = NULL;
		if( !single2 )
		{
			pt2 = NEXTLINE( pt2 );
			if( pt2 &&
				 !GetTextSize( pt2 ) &&
				 !(pt2->flags & IS_DATA_FLAGS))
				pt2 = NULL;
		}
		else
			pt2 = NULL;
	}
	if( !pt1 && !pt2 )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromText( CTEXTSTR p )
{
	//CTEXTSTR p;
	int s;
	int begin;
	int64_t num;
	LOGICAL altBase = FALSE;
	LOGICAL altBase2 = FALSE;
	int64_t base = 10;
	//p = GetText( pText );
	if( !p )
		return 0;
	//if( pText->flags & TF_INDIRECT )
	//   return IntCreateFromSeg( GetIndirect( pText ) );
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '.' )
			break;
		else if( *p == '+' )
		{
		}
		else if( *p == '-' && begin)
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( !altBase2 ) {
				if( *p == 'x' ) { altBase2 = TRUE; base = 16; }
				else if( *p == 'b' ) { altBase2 = TRUE; base = 2; }
				else break;
			} else {
				if( base > 10 ) {
					if( *p >= 'a' && *p <= 'f' ) {
						num *= base;
						num += *p - 'a' + 10;
					}
					else if( *p >= 'A' && *p <= 'F' ) {
						num *= base;
						num += *p - 'A' + 10;
					}
					else break;
				}
				else break;
			}
		}
		else
		{
			if( ( !altBase ) && (*p == '0') ) { altBase = TRUE; base = 8; }
			else { if( (*p - '0') >= base ) { break; } altBase = TRUE; }
			num *= base;
			num += *p - '0';
		}
		begin = FALSE;
		p++;
	}
	if( s & 1 )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
int64_t IntCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !pText || !p )
		return FALSE;
	if( pText->flags & TF_INDIRECT )
		return IntCreateFromSeg( GetIndirect( pText ) );
	return IntCreateFromText( p );
}
//--------------------------------------------------------------------------
double FloatCreateFromText( CTEXTSTR p, CTEXTSTR *vp )
{
	return strtod( p, (char **)vp );
	int s, begin, bDec = FALSE;
	double num;
	double base = 1;
	double temp;
	if( !p )
	{
		if( vp )
			(*vp) = p;
		return 0;
	}
	s = 0;
	num = 0;
	begin = TRUE;
	while( *p )
	{
		if( *p == '-' && begin )
		{
			s++;
		}
		else if( *p < '0' || *p > '9' )
		{
			if( *p == '.' )
			{
				bDec = TRUE;
				base = 0.1;
			}
			else
				break;
		}
		else
		{
			if( bDec )
			{
				temp = *p - '0';
				num += base * temp;
				base /= 10;
			}
			else
			{
				num *= 10;
				num += *p - '0';
			}
		}
		begin = FALSE;
		p++;
	}
	if( vp )
		(*vp) = p;
	if( s )
		num *= -1;
	return num;
}
//--------------------------------------------------------------------------
double FloatCreateFromSeg( PTEXT pText )
{
	CTEXTSTR p;
	p = GetText( pText );
	if( !p )
		return FALSE;
	return FloatCreateFromText( p, NULL );
}
//--------------------------------------------------------------------------
// if bUseAll - all segments must be part of the number
// otherwise, only as many segments as are needed for the number are used...
int IsSegAnyNumberEx( PTEXT *ppText, double *fNumber, int64_t *iNumber, int *bIntNumber, int bUseAll )
{
	CTEXTSTR pCurrentCharacter;
	PTEXT pBegin;
	PTEXT pText = *ppText;
	int decimal_count, s, begin = TRUE, digits;
	// remember where we started...
	// if the first segment is indirect, collect it and only it
	// as the number... making indirects within a number what then?
	if( pText->flags & TF_INDIRECT )
	{
		int status;
		PTEXT pTemp = GetIndirect( pText );
		if( pTemp
			&& (status = IsSegAnyNumberEx( &pTemp, fNumber, iNumber, bIntNumber, TRUE )) )
		{
			// step to next token - so we toss just this
			// one indirect statement.
			if( fNumber || iNumber )
			{
				// if resulting with a number, then step the text...
				(*ppText) = NEXTLINE( pText );
			}
			return status;
		}
		// not a number....
		return FALSE;
	}
	pBegin = pText;
	decimal_count = 0;
	s = 0;
	digits = 0;
	while( pText )
	{
		// at this point... is this really valid?
		if( pText->flags & TF_INDIRECT )
		{
			lprintf( WIDE("Encountered indirect segment gathering number, stopping.") );
			break;
		}
		if( !begin &&
			( pText->format.position.offset.spaces || pText->format.position.offset.tabs ) )
		{
			// had to continue with new segment, but it had spaces so stop now
			break;
		}
		pCurrentCharacter = GetText( pText );
		while( pCurrentCharacter && *pCurrentCharacter )
		{
			if( *pCurrentCharacter == '.' )
			{
				if( !decimal_count )
					decimal_count++;
				else
					break;
			}
			else if( ((*pCurrentCharacter) == '-') && begin)
			{
				s++;
			}
			else if( ((*pCurrentCharacter) < '0') || ((*pCurrentCharacter) > '9') )
			{
				if( digits && ( pCurrentCharacter == GetText( pText ) ) )
				{
					pCurrentCharacter = GetText( PRIORLINE( pText ) );
					while( pCurrentCharacter[0] )
					{
						// if the number ended in a decimal, it can qualify as an integer
						if( pCurrentCharacter[0] == '.' && !pCurrentCharacter[1] )
							decimal_count--;
						pCurrentCharacter++;
					}
					pText = NULL;
				}
				break;
			}
			else
				digits++;
			begin = FALSE;
			pCurrentCharacter++;
		}
		// invalid character - stop, we're to abort.
		if( *pCurrentCharacter )
			break;
		pText = NEXTLINE( pText );
 //while( pText );
	}
	if( bUseAll && pText )
		// it's not a number, cause we didn't use all segments to get one
		return FALSE;
	if( *pCurrentCharacter || ( decimal_count > 1 ) || !digits )
	{
		// didn't collect enough meaningful info to be a number..
		// or information in this state is
		return FALSE;
	}
	// yeah it was a number, update the incoming pointer...
	if( fNumber || iNumber )
	{
		// if resulting with a number, then step the text...
		(*ppText) = pText;
	}
	if( decimal_count == 1 )
	{
		if( fNumber )
			(*fNumber) = FloatCreateFromSeg( pBegin );
		if( bIntNumber )
			(*bIntNumber) = 0;
 // return specifically it's a floating point number
		return 2;
	}
	if( iNumber )
		(*iNumber) = IntCreateFromSeg( pBegin );
	if( bIntNumber )
		(*bIntNumber) = 1;
 // return yes, and it's an int number
	return 1;
}
//---------------------------------------------------------------------------
//#define VERBOSE_DEBUG_VARTEXT
//---------------------------------------------------------------------------
#define COLLECT_LEN 4096
void VarTextInitEx( PVARTEXT pvt DBG_PASS )
{
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( COLLECT_LEN DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log( WIDE("Resetting collect_used (init)") );
#endif
	pvt->collect_used = 0;
	pvt->collect_avail = COLLECT_LEN;
	pvt->expand_by = 0;
}
 PVARTEXT  VarTextCreateExEx ( uint32_t initial, uint32_t expand DBG_PASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	pvt->commit = NULL;
	pvt->collect = SegCreateEx( initial DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_used = 0;
	pvt->collect_avail = initial;
	pvt->expand_by = expand;
	return pvt;
}
//---------------------------------------------------------------------------
PVARTEXT VarTextCreateEx( DBG_VOIDPASS )
{
	PVARTEXT pvt = (PVARTEXT)AllocateEx( sizeof( VARTEXT ) DBG_RELAY );
	VarTextInitEx( pvt DBG_RELAY );
	return pvt;
}
//---------------------------------------------------------------------------
void VarTextDestroyEx( PVARTEXT *ppvt DBG_PASS )
{
	if( ppvt && *ppvt )
	{
		VarTextEmptyEx( *ppvt DBG_RELAY );
		ReleaseEx( (*ppvt) DBG_RELAY );
		*ppvt = NULL;
	}
}
//---------------------------------------------------------------------------
void VarTextEmptyEx( PVARTEXT pvt DBG_PASS )
{
	if( pvt )
	{
		size_t expand = pvt->expand_by;
		LineReleaseEx( pvt->collect DBG_RELAY );
		LineReleaseEx( pvt->commit DBG_RELAY );
		MemSet( pvt, 0, sizeof( VARTEXT ) );
		pvt->expand_by = expand;
	}
}
//---------------------------------------------------------------------------
void VarTextAddCharacterEx( PVARTEXT pvt, TEXTCHAR c DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( WIDE("Adding character %c"), c );
#endif
	if( c == '\b' )
	{
		if( pvt->collect_used )
		{
			pvt->collect_used--;
			pvt->collect_text[pvt->collect_used] = 0;
		}
	}
	else
	{
		pvt->collect_text[pvt->collect_used++] = c;
		if( pvt->collect_used >= pvt->collect_avail )
		{
			//lprintf( WIDE("Expanding segment to make sure we have room to extend...(old %d)"), pvt->collect->data.size );
			pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 DBG_RELAY );
			pvt->collect_avail = pvt->collect->data.size;
			pvt->collect_text = GetText( pvt->collect );
		}
	}
}
void VarTextAddRuneEx( PVARTEXT pvt, TEXTRUNE c, LOGICAL overlong DBG_PASS )
{
	int chars;
	int n;
#ifdef _UNICODE
	wchar_t output[3];
	chars = ConvertToUTF16( output, c );
#else
	char output[6];
	chars = ConvertToUTF8Ex( output, c, overlong );
#endif
	for( n = 0; n < chars; n++ )
		VarTextAddCharacterEx( pvt, output[n] DBG_RELAY );
}
//---------------------------------------------------------------------------
void VarTextAddDataEx( PVARTEXT pvt, CTEXTSTR block, size_t length DBG_PASS )
{
	if( !pvt->collect )
		VarTextInitEx( pvt DBG_RELAY );
#ifdef VERBOSE_DEBUG_VARTEXT
	Log1( WIDE("Adding character %c"), c );
#endif
	{
		uint32_t n;
		for( n = 0; n < length; n++ )
		{
			if( !block[n] && ( length == VARTEXT_ADD_DATA_NULTERM ) )
				break;
			pvt->collect_text[pvt->collect_used++] = block[n];
			if( pvt->collect_used >= pvt->collect_avail )
			{
				//lprintf( WIDE("Expanding segment to make sure we have room to extend...(old %d)"), pvt->collect->data.size );
				pvt->collect = SegExpandEx( pvt->collect, pvt->collect_avail * 2 + COLLECT_LEN DBG_RELAY );
				pvt->collect_avail = pvt->collect->data.size;
				pvt->collect_text = GetText( pvt->collect );
			}
		}
	}
}
//---------------------------------------------------------------------------
LOGICAL VarTextEndEx( PVARTEXT pvt DBG_PASS )
{
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		PTEXT segs= SegSplitEx( &pvt->collect, pvt->collect_used DBG_RELAY );
		//lprintf( WIDE("End collect at %d %d"), pvt->collect_used, segs?segs->data.size:pvt->collect->data.size );
		if( !segs )
		{
			segs = pvt->collect;
		}
		//Log1( WIDE("Breaking collection adding... %s"), GetText( segs ) );
		// so now the remaining buffer( if any )
		// is assigned to collect into.
		// This results in...
		pvt->collect = NEXTLINE( segs );
 // used all of the line...
		if( !pvt->collect )
		{
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( WIDE("Starting with new buffers ") );
#endif
			VarTextInitEx( pvt DBG_RELAY );
		}
		else
		{
			 //Log1( WIDE("Remaining buffer is %d"), GetTextSize( pvt->collect ) );
			SegBreak( pvt->collect );
			pvt->collect_text = GetText( pvt->collect );
#ifdef VERBOSE_DEBUG_VARTEXT
			Log( WIDE("resetting collect_used after split") );
#endif
			pvt->collect_avail -= pvt->collect_used;
			pvt->collect_used = 0;
		}
		pvt->commit = SegAppend( pvt->commit, segs );
		return 1;
	}
	if( pvt && pvt->commit )
		return 1;
	return 0;
}
//---------------------------------------------------------------------------
PTEXT VarTextGetEx( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
	{
#ifdef VERBOSE_DEBUG_VARTEXT
		lprintf( DBG_FILELINEFMT "Get Text failed - no PVT." DBG_RELAY );
#endif
		return NULL;
	}
#ifdef VERBOSE_DEBUG_VARTEXT
	lprintf( DBG_FILELINEFMT "Grabbing the text from %p..." DBG_RELAY, pvt );
#endif
	if( VarTextEndEx( pvt DBG_RELAY ) )
	{
		PTEXT result = pvt->commit;
		pvt->commit = NULL;
		return result;
	}
	return NULL;
}
//---------------------------------------------------------------------------
 PTEXT  VarTextPeekEx ( PVARTEXT pvt DBG_PASS )
{
	if( !pvt )
		return NULL;
 // otherwise ofs will be 0...
	if( pvt && pvt->collect_used )
	{
		SetTextSize( pvt->collect, pvt->collect_used );
		//VarTextAddCharacterEx( pvt, 0 DBG_RELAY );
		return pvt->collect;
	}
	return NULL;
}
//---------------------------------------------------------------------------
void VarTextExpandEx( PVARTEXT pvt, INDEX size DBG_PASS)
{
	pvt->collect = SegExpandEx( pvt->collect, size DBG_RELAY );
	pvt->collect_text = GetText( pvt->collect );
	pvt->collect_avail += size;
}
//---------------------------------------------------------------------------
INDEX VarTextLength( PVARTEXT pvt )
{
	//Log1( WIDE("Length is : %d"), pvt->collect_used );
	if( pvt )
		return pvt->collect_used;
	return 0;
}
//---------------------------------------------------------------------------
INDEX vvtprintf( PVARTEXT pvt, CTEXTSTR format, va_list args )
{
	INDEX len;
// this might be unicode...
#if ( defined( UNDER_CE ) || defined( _WIN32 ) ) && !defined( MINGW_SUX )
#  ifdef USE_UCRT
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
#    ifdef _UNICODE
#       define vsnprintf vswprintf
#    endif
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
							, args
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
		va_end( tmp_args );
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#ifdef VERBOSE_DEBUG_VARTEXT
		Log3( WIDE("Print Length: %d into %d after %s"), len, pvt->collect_used, pvt->collect_text );
#endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#  else
	int tries = 0;
	while( 1 )
	{
		size_t destlen;
		if( pvt->collect_text )
		{
			len = StringCbVPrintf ( pvt->collect_text + pvt->collect_used
									, ((destlen = pvt->collect_avail - pvt->collect_used) * sizeof( TEXTCHAR ))
									, format, args );
		}
		else
			len = STRSAFE_E_INSUFFICIENT_BUFFER;
		if( len == STRSAFE_E_INSUFFICIENT_BUFFER )
		{
			tries++;
			if( tries == 100 )
			{
				lprintf( WIDE( "Single buffer expanded more then %d" ), tries * ( (pvt->expand_by)?pvt->expand_by:(16384+pvt->expand_by) ) );
 // didn't add any
				return 0;
			}
			VarTextExpand( pvt, (pvt->expand_by)?pvt->expand_by:(16384)  );
			continue;
		}
		len = StrLen( pvt->collect_text + pvt->collect_used );
		pvt->collect_used += len;
		break;
	}
	return len;
#  endif
#elif defined( __GNUC__ ) && !defined( _WIN32 )
	{
		va_list tmp_args;
		va_copy( tmp_args, args );
#    ifdef _UNICODE
#      define vsnprintf vswprintf
#    endif
		// len returns number of characters (not NUL)
		len = vsnprintf( NULL, 0, format
#  ifdef __GNUC__
							, tmp_args
#  else
							, args
#  endif
							);
 // nothign to add... we'll get stuck looping if this is not checked.
		if( !len )
			return 0;
#  ifdef __GNUC__
		va_end( tmp_args );
#  endif
		// allocate +1 for length with NUL
		if( ((uint32_t)len+1) >= (pvt->collect_avail-pvt->collect_used) )
		{
			// expand when we need more room.
			VarTextExpand( pvt, ((len+1)<pvt->expand_by)?pvt->expand_by:(len+1+pvt->expand_by)  );
		}
#  ifdef VERBOSE_DEBUG_VARTEXT
		Log3( WIDE("Print Length: %d into %d after %s"), len, pvt->collect_used, pvt->collect_text );
#  endif
		// include NUL in the limit of characters able to print...
		vsnprintf( pvt->collect_text + pvt->collect_used, len+1, format, args );
	}
#elif defined( __WATCOMC__ )
	{
		int destlen;
		va_list _args;
		_args[0] = args[0];
		do {
#  ifdef VERBOSE_DEBUG_VARTEXT
			Log2( WIDE("Print Length: ofs %d after %s")
				 , pvt->collect_used
				 , pvt->collect_text );
#  endif
			args[0] = _args[0];
			//va_start( args, format );
#  ifdef _UNICODE
#    define vsnprintf _vsnwprintf
#  endif
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, destlen = pvt->collect_avail - pvt->collect_used
								, format, args );
 // nothign to add... we'll get stuck looping if this is not checked.
			if( !len )
				return 0;
#  ifdef VERBOSE_DEBUG_VARTEXT
			lprintf( WIDE("result of vsnprintf: %d(%d) \'%s\' (%s)")
					 , len, destlen
					 , pvt->collect_text
					 , format );
#  endif
			if( len >= destlen )
			{
				// vsnwprintf() for NULL and 0 length returns -1
				// so, make length be something larger than -1, and keep expanding by that much.
				if( len == -1 )
					len = 256;
				VarTextExpand( pvt, len + pvt->expand_by );
			}
		} while( len >= destlen );
	}
#else
	// uhmm not sure what state this is then...
	{
		do {
			len = vsnprintf( pvt->collect_text + pvt->collect_used
								, pvt->collect_avail - pvt->collect_used
								, format, args );
			if( len < 0 )
				VarTextExpand( pvt, pvt->expand_by?pvt->expand_by:4096 );
			//					 VarTextExpandEx( pvt, 32 DBG_SRC );
		} while( len < 0 );
		//Log1( WIDE("Print Length: %d"), len );
	}
#endif
#ifdef VERBOSE_DEBUG_VARTEXT
	Log2( WIDE("used: %d plus %d"), pvt->collect_used , len );
#endif
	pvt->collect_used += len;
	return len;
}
//---------------------------------------------------------------------------
INDEX vtprintfEx( PVARTEXT pvt , CTEXTSTR format, ... )
{
	va_list args;
	va_start( args, format );
	return vvtprintf( pvt, format, args );
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
//
// PTEXT DumpText( PTEXT somestring )
//	 PTExT (single data segment with full description \r in text)
//
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
static CTEXTSTR Ops[] = {
	WIDE("FORMAT_OP_CLEAR_END_OF_LINE"),
	WIDE("FORMAT_OP_CLEAR_START_OF_LINE"),
	WIDE("FORMAT_OP_CLEAR_LINE "),
	WIDE("FORMAT_OP_CLEAR_END_OF_PAGE"),
	WIDE("FORMAT_OP_CLEAR_START_OF_PAGE"),
	WIDE("FORMAT_OP_CLEAR_PAGE"),
	WIDE("FORMAT_OP_CONCEAL")
 // background is how many to delete.
	  , WIDE("FORMAT_OP_DELETE_CHARS")
 // format.x, y are start/end of region -1,-1 clears.
	  , WIDE("FORMAT_OP_SET_SCROLL_REGION")
 // this works as a transaction...
	  , WIDE("FORMAT_OP_GET_CURSOR")
 // responce to getcursor...
	  , WIDE("FORMAT_OP_SET_CURSOR")
 // clear page, home page... result in page break...
	  , WIDE("FORMAT_OP_PAGE_BREAK")
 // break between paragraphs - kinda same as lines...
	  , WIDE("FORMAT_OP_PARAGRAPH_BREAK")
};
//---------------------------------------------------------------------------
static void BuildTextFlags( PVARTEXT vt, PTEXT pSeg )
{
	vtprintf( vt, WIDE( "Text Flags: " ));
	if( pSeg->flags & TF_STATIC )
		vtprintf( vt, WIDE( "static " ) );
	if( pSeg->flags & TF_QUOTE )
		vtprintf( vt, WIDE( "\"\" " ) );
	if( pSeg->flags & TF_SQUOTE )
		vtprintf( vt, WIDE( "\'\' " ) );
	if( pSeg->flags & TF_BRACKET )
		vtprintf( vt, WIDE( "[] " ) );
	if( pSeg->flags & TF_BRACE )
		vtprintf( vt, WIDE( "{} " ) );
	if( pSeg->flags & TF_PAREN )
		vtprintf( vt, WIDE( "() " ) );
	if( pSeg->flags & TF_TAG )
		vtprintf( vt, WIDE( "<> " ) );
	if( pSeg->flags & TF_INDIRECT )
		vtprintf( vt, WIDE( "Indirect " ) );
	/*
	if( pSeg->flags & TF_SINGLE )
	vtprintf( vt, WIDE( "single " ) );
	*/
	if( pSeg->flags & TF_FORMATREL )
		vtprintf( vt, WIDE( "format x,y(REL) " ) );
	if( pSeg->flags & TF_FORMATABS )
		vtprintf( vt, WIDE( "format x,y " ) );
	else
		vtprintf( vt, WIDE( "format spaces " ) );
	if( pSeg->flags & TF_COMPLETE )
		vtprintf( vt, WIDE( "complete " ) );
	if( pSeg->flags & TF_BINARY )
		vtprintf( vt, WIDE( "binary " ) );
	if( pSeg->flags & TF_DEEP )
		vtprintf( vt, WIDE( "deep " ) );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_ENTITY )
		vtprintf( vt, WIDE( "entity " ) );
	if( pSeg->flags & TF_SENTIENT )
		vtprintf( vt, WIDE( "sentient " ) );
#endif
	if( pSeg->flags & TF_NORETURN )
		vtprintf( vt, WIDE( "NoReturn " ) );
	if( pSeg->flags & TF_LOWER )
		vtprintf( vt, WIDE( "Lower " ) );
	if( pSeg->flags & TF_UPPER )
		vtprintf( vt, WIDE( "Upper " ) );
	if( pSeg->flags & TF_EQUAL )
		vtprintf( vt, WIDE( "Equal " ) );
	if( pSeg->flags & TF_TEMP )
		vtprintf( vt, WIDE( "Temp " ) );
#ifdef DEKWARE_APP_FLAGS
	if( pSeg->flags & TF_PROMPT )
		vtprintf( vt, WIDE( "Prompt " ) );
	if( pSeg->flags & TF_PLUGIN )
		vtprintf( vt, WIDE( "Plugin=%02x " ), (uint8_t)(( pSeg->flags >> 26 ) & 0x3f ) );
#endif
	if( (pSeg->flags & TF_FORMATABS ) )
		vtprintf( vt, WIDE( "Pos:%d,%d " )
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else if( (pSeg->flags & TF_FORMATREL ) )
		vtprintf( vt, WIDE( "Rel:%d,%d " )
				, pSeg->format.position.coords.x
				, pSeg->format.position.coords.y  );
	else
		vtprintf( vt, WIDE( "%d tabs %d spaces" )
				  , pSeg->format.position.offset.tabs
				  , pSeg->format.position.offset.spaces
				  );
	if( pSeg->flags & TF_FORMATEX )
		vtprintf( vt, WIDE( "format extended(%s) length:%d" )
					  , Ops[ pSeg->format.flags.format_op
							 - FORMAT_OP_CLEAR_END_OF_LINE ]
					  , GetTextSize( pSeg ) );
	else
		vtprintf( vt, WIDE( "Fore:%d Back:%d length:%d" )
					, pSeg->format.flags.foreground
					, pSeg->format.flags.background
					, GetTextSize( pSeg ) );
}
PTEXT DumpText( PTEXT text )
{
	if( text )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT textsave = text;
		while( text )
		{
			BuildTextFlags( pvt, text );
			vtprintf( pvt, WIDE( "\n->%s\n" ), GetText( text ) );
			text = NEXTLINE( text );
		}
		textsave = VarTextGet( pvt );
		VarTextDestroy( &pvt );
		return textsave;
	}
	return NULL;
}
//---------------------------------------------------------------------------
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertAsciiEbdic( TEXTSTR text, INDEX length )
{
	static unsigned char a2e[256] = {
		0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 37, 11, 12, 13, 14, 15,
		16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
		64, 79,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
		240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
		124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
		215,216,217,226,227,228,229,230,231,232,233, 74,224, 90, 95,109,
		121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
		151,152,153,162,163,164,165,166,167,168,169,192,106,208,161,  7,
		32, 33, 34, 35, 36, 21,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
		48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,225,
		65, 66, 67, 68, 69, 70, 71, 72, 73, 81, 82, 83, 84, 85, 86, 87,
		88, 89, 98, 99,100,101,102,103,104,105,112,113,114,115,116,117,
		118,119,120,128,138,139,140,141,142,143,144,154,155,156,157,158,
		159,160,170,171,172,173,174,175,176,177,178,179,180,181,182,183,
		184,185,186,187,188,189,190,191,202,203,204,205,206,207,218,219,
		220,221,222,223,234,235,236,237,238,239,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = a2e[(unsigned)text[n]];
		}
	}
	return text;
}
/*
**  ASCII <=> EBCDIC conversion functions
*/
TEXTSTR ConvertEbcdicAscii( TEXTSTR text, INDEX length )
{
	static unsigned char e2a[256] = {
		0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
		16, 17, 18, 19,157,133,  8,135, 24, 25,146,143, 28, 29, 30, 31,
		128,129,130,131,132, 10, 23, 27,136,137,138,139,140,  5,  6,  7,
		144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
		32,160,161,162,163,164,165,166,167,168, 91, 46, 60, 40, 43, 33,
		38,169,170,171,172,173,174,175,176,177, 93, 36, 42, 41, 59, 94,
		45, 47,178,179,180,181,182,183,184,185,124, 44, 37, 95, 62, 63,
		186,187,188,189,190,191,192,193,194, 96, 58, 35, 64, 39, 61, 34,
		195, 97, 98, 99,100,101,102,103,104,105,196,197,198,199,200,201,
		202,106,107,108,109,110,111,112,113,114,203,204,205,206,207,208,
		209,126,115,116,117,118,119,120,121,122,210,211,212,213,214,215,
		216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,
		123, 65, 66, 67, 68, 69, 70, 71, 72, 73,232,233,234,235,236,237,
		125, 74, 75, 76, 77, 78, 79, 80, 81, 82,238,239,240,241,242,243,
		92,159, 83, 84, 85, 86, 87, 88, 89, 90,244,245,246,247,248,249,
		48, 49, 50, 51, 52, 53, 54, 55, 56, 57,250,251,252,253,254,255
	};
	{
		INDEX n;
		for( n = 0; length?(n<length):text[n]; n++ )
		{
			text[n] = e2a[(unsigned)text[n]];
		}
	}
	return text;
}
//---------------------------------------------------------------------------
#define NUM_RESERVED (sizeof(reserved_uri)/sizeof(reserved_uri[0]))
static TEXTCHAR reserved_uri[] = {'!','*','\'','(',')',';',':','@','&','=','+','$',',','/','?','#','[',']'
												  ,'<','>','~','.','"','{','}','|','\\','-','`','_','^','%',' '
												  , 0 };
static const TEXTCHAR *translated[] = { WIDE( "%21" ),WIDE( "%2A" ),WIDE( "%27" ),WIDE( "%28" ),WIDE( "%29" ),WIDE( "%3B" ),WIDE( "%3A" )
												,WIDE( "%40" ),WIDE( "%26" ),WIDE( "%3D" ),WIDE( "%2B" ),WIDE( "%24" ),WIDE( "%2C" ),WIDE( "%2F" )
												 ,WIDE( "%3F" ),WIDE( "%23" ),WIDE( "%5B" ),WIDE( "%5D" )
												 ,WIDE( "%3C" ),WIDE( "%3E" ),WIDE( "%7E" ),WIDE( "%2E" ),WIDE( "%22" ),WIDE( "%7B" ),WIDE( "%7D" ),WIDE( "%7C" ),WIDE( "%5C" ),WIDE( "%2D" ),WIDE( "%60" ),WIDE( "%5F" ),WIDE( "%5E" ),WIDE( "%25" ),WIDE( "%20" )
};
static int MeasureTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
			out_length++;
		else if( StrChr( reserved_uri, text[i] ) )
			out_length += 3;
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertTextURI( CTEXTSTR text, INDEX length, int skip_slash )
{
	int target_len = MeasureTextURI( text, length, skip_slash );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	const TEXTCHAR *char_pos;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( skip_slash && text[i] == '/' )
		{
			out_pos[0] = text[i];
			out_pos++;
		}
		else if( ( char_pos = StrChr( reserved_uri, text[i] ) ) )
		{
#ifdef __cplusplus
			sack::memory::
#endif
			StrCpyEx( out_pos, translated[char_pos - reserved_uri], target_len - ( out_pos - target ) );
			out_pos += 3;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	return target;
}
static int MeasureURIText( CTEXTSTR text, INDEX length )
{
	// compute how long it should be.
	INDEX i;
	int out_length = 0;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			i += 2;
			out_length++;
		}
		else
			out_length++;
	}
	return out_length;
}
TEXTSTR ConvertURIText( CTEXTSTR text, INDEX length )
{
	int target_len = MeasureURIText( text, length );
	TEXTSTR target = NewArray( TEXTCHAR, target_len + 1 );
	INDEX i;
	TEXTSTR out_pos = target;
	for( i = 0; i < length && text[i]; i++ )
	{
		if( text[i] == '%' )
		{
			char char_byte;
			// A 41
			// a 61
			// 0 30
			char_byte = (((text[i+1] & 10)?(text[i+1]-0x30)
							  : (text[i+1] & 20)?(text[i+1]-'a'+10)
							  : (text[i+1]-'A'+10)) << 4 )
				| (((text[i+2] & 10)?(text[i+2]-0x30)
					 : (text[i+2] & 20)?(text[i+2]-'a'+10)
					 : (text[i+2]-'A'+10)) );
			out_pos[0] = char_byte;
			out_pos++;
		}
		else
		{
			out_pos[0] = text[i];
			out_pos++;
		}
	}
	out_pos[0] = 0;
	//out_pos++;
	return target;
}
//---------------------------------------------------------------------------
int ConvertToUTF16( wchar_t *output, TEXTRUNE rune )
{
	if( !( rune & 0xFFFF0000 ) )
	{
		if( rune < 0xD800 || rune >= 0xE000 )
		{
			output[0] = (wchar_t)rune;
			return 1;
		}
		else
 // invalid rune specified.
			return 0;
	}
	else
	{
		rune -= 0x10000;
		if( !( rune & 0xFFFFF ) )
		{
			output[0] = 0xD800 + (wchar_t)( ( rune & 0xFFC00 ) >> 10 );
			output[1] = 0xDC00 + (wchar_t)( ( rune & 0x003FF ) );
			return 2;
		}
	}
 // invalid rune.
	return 0;
}
int ConvertToUTF8( char *output, TEXTRUNE rune )
{
	int ch = 1;
	if( !( rune & 0xFFFFFF80 ) )
	{
		// 7 bits
		(*output++) = (char)rune;
		goto plus0;
	}
	else if( !( rune & 0xFFFFF800 ) )
	{
		// 11 bits
		(*output++) = 0xC0 | ( ( ( rune & 0x07C0 ) >> 6 ) & 0xFF );
		goto plus1;
	}
	else if( !( rune & 0xFFFF0000 ) )
	{
		// 16 bits
		(*output++) = 0xE0 | ( ( ( rune & 0xF000 ) >> 12 ) & 0xFF );
		goto plus2;
	}
	else if( !( rune & 0xFFE00000 ) )
	{
		// 21 bits
		(*output++) = 0xF0 | ( ( ( rune & 0x1C0000 ) >> 15 ) & 0xFF );
		goto plus3;
	}
	else if( !( rune & 0xFC000000 ) )
	{
		// 26 bits
		(*output++) = 0xF8 | ( ( ( rune & 0x3000000 ) >> 24 ) & 0xFF );
		goto plus4;
	}
	else if( !( rune & 0x80000000 ) )
	{
		// 31 bits
		(*output++) = 0xFC | ( ( ( rune & 0x40000000 ) >> 30 ) & 0xFF );
		//goto plus5;
	}
	// invalid rune (out of range)
//plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
plus0:
	return ch;
}
int ConvertToUTF8Ex( char *output, TEXTRUNE rune, LOGICAL overlong )
{
	int ch = 1;
	if( !overlong ) return ConvertToUTF8( output, rune );
	if( !(rune & 0xFFFFFF80) )
	{
		// 11 bits
		(*output++) = 0xC0 | (((rune & 0x07C0) >> 6) & 0xFF);
		goto plus1;
	}
	else if( !(rune & 0xFFFFF800) )
	{
		// 16 bits
		(*output++) = 0xE0 | (((rune & 0xF000) >> 12) & 0xFF);
		goto plus2;
	}
	else if( !(rune & 0xFFFF0000) )
	{
		// 21 bits
		(*output++) = 0xF0 | (((rune & 0x1C0000) >> 15) & 0xFF);
		goto plus3;
	}
	else if( !(rune & 0xFFE00000) )
	{
		// 26 bits
		(*output++) = 0xF8 | (((rune & 0x3000000) >> 24) & 0xFF);
		goto plus4;
	}
	else if( !(rune & 0xFC000000) )
	{
		// 31 bits
		(*output++) = 0xFC | (((rune & 0x40000000) >> 30) & 0xFF);
		goto plus5;
	}
	else if( !(rune & 0x80000000) ) {
		(*output++) = 0xFEU;
	}
	ch++; (*output++) = 0x80 | (((rune & 0xC0000000) >> 30) & 0xFF);
plus5:
	ch++; (*output++) = 0x80 | (((rune & 0x3F000000) >> 24) & 0xFF);
plus4:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0000) >> 18) & 0xFF);
plus3:
	ch++; (*output++) = 0x80 | (((rune & 0x03F000) >> 12) & 0xFF);
plus2:
	ch++; (*output++) = 0x80 | (((rune & 0x0FC0) >> 6) & 0xFF);
plus1:
	ch++; (*output++) = 0x80 | (rune & 0x3F);
//plus0:
	return ch;
}
char * WcharConvertExx ( const wchar_t *wch, size_t len DBG_PASS )
{
	// Conversion to char* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInBytes;
	char  tmp[2];
	char	 *ch;
	char	 *_ch;
	const wchar_t *_wch = wch;
 // start with 1 for the ending nul
	sizeInBytes = 1;
	_ch = ch = tmp;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "wch = %04x", wch[0] );
			if( !( wch[0] & 0xFF80 ) )
			{
				//lprintf( "1 byte encode..." );
				sizeInBytes++;
			}
			else if( !( wch[0] & 0xF800 ) )
			{
				//lprintf( "2 byte encode..." );
				sizeInBytes += 2;
			}
			else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
					   && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
					 && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
					   && ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
			{
				int longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
				//lprintf( "3 or 4 byte encode..." );
				if( !(longer_value & 0xFFFF0000 ) )
					sizeInBytes += 3;
 // hack a way to encode D800-DFFF
				else if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					sizeInBytes += 2;
				else
					sizeInBytes += 4;
				wch++;
			}
			else
			{
				// just encode the 16 bits as it is.
				//lprintf( " 3 byte encode?" );
				sizeInBytes+= 3;
			}
			wch++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( char, sizeInBytes);
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			{
				if( !( wch[0] & 0xFF80 ) )
				{
					(*ch++) = ((unsigned char*)wch)[0];
				}
				else if( !( wch[0] & 0xFF00 ) )
				{
					//(*ch++) = ((unsigned char*)wch)[0];
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( !( wch[0] & 0xF800 ) )
				{
					(*ch++) = 0xC0 | ( ( ((unsigned char*)wch)[1] & 0x7 ) << 2 ) | ( ( ((unsigned char*)wch)[0] ) >> 6 );
					(*ch++) = 0x80 | ( ((unsigned char*)wch)[0] & 0x3F );
				}
				else if( (  ( ( wch[0] & 0xFC00 ) >= 0xD800 )
							 && ( ( wch[0] & 0xFC00 ) < 0xDC00 ) )
						  && ( ( ( wch[1] & 0xFC00 ) >= 0xDC00 )
								&& ( ( wch[1] & 0xFC00 ) < 0xE000 ) )
					 )
				{
					uint32_t longer_value;
					longer_value = 0x10000 + ( ( ( wch[0] & 0x3ff ) << 10 ) | ( ( wch[1] & 0x3ff ) ) );
 // hack a way to encode D800-DFFF
					if( ( longer_value >= 0xF0000 ) && ( longer_value < 0xF0800 ) )
					{
						longer_value = ( longer_value - 0xF0000 ) + 0xD800;
						sizeInBytes += 2;
					}
					wch++;
					if( !(longer_value & 0xFFFF ) )
					{
						// 16 bit encoding (shouldn't be hit
						(*ch++) = 0xE0 | (char)( ( longer_value >> 12 ) & 0x0F );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					else if( !( longer_value & 0xFFE00000 ) )
					{
						// 21 bit encoding ...
						(*ch++) = 0xF0 | (char)( ( longer_value >> 18 ) & 0x07 );
						(*ch++) = 0x80 | (char)( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | (char)( ( longer_value >> 0 ) & 0x3f );
					}
					/*  ** functionally removed from spec ..... surrogates cannot be this long.
					else if( !( longer_value & 0xFC000000 ) )
					{
						(*ch++) = 0xF8 | ( longer_value >> 24 );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					else  if( !( longer_value & 0x80000000 ) )
					{
						// 31 bit encode
						(*ch++) = 0xFC | ( longer_value >> 30 );
						(*ch++) = 0x80 | ( ( longer_value >> 24 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 18 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 12 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( longer_value >> 0 ) & 0x3f );
					}
					*/
					else
					{
						// too long to encode.
					}
				}
				else
				{
					   //lprintf( " 3 byte encode?  16 bits" );
 // mask just in case of stupid compiles that tread wchar as signed?
						(*ch++) = 0xE0 | ( ( wch[0] >> 12 ) & 0x0F );
						(*ch++) = 0x80 | ( ( wch[0] >> 6 ) & 0x3f );
						(*ch++) = 0x80 | ( ( wch[0] >> 0 ) & 0x3f );
				}
			}
			wch++;
		}
	}
	(*ch) = 0;
	ch = _ch;
	return ch;
}
char * WcharConvertEx ( const wchar_t *wch DBG_PASS )
{
	size_t len;
	for( len = 0; wch[len]; len++ );
	return WcharConvertExx( wch, len DBG_RELAY );
}
wchar_t * CharWConvertExx ( const char *wch, size_t len DBG_PASS )
{
	// Conversion to wchar_t* :
	// Can just convert wchar_t* to char* using one of the
	// conversion functions such as:
	// WideCharToMultiByte()
	// wcstombs_s()
	// ... etc
	size_t  sizeInChars = 0;
	const char *_wch = wch;
	wchar_t	*ch;
	wchar_t   *_ch;
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( (wch[0] & 0xE0) == 0xC0 )
				wch += 2;
			else if( (wch[0] & 0xF0) == 0xE0 )
				wch += 3;
			else if( (wch[0] & 0xF0) == 0xF0 )
			{
				sizeInChars++;
				wch += 4;
			}
			else
				wch++;
			sizeInChars++;
		}
	}
	wch = _wch;
	_ch = ch = NewArray( wchar_t, sizeInChars + 1 );
	{
		size_t n;
		for( n = 0; n < len; n++ )
		{
			//lprintf( "first char is %d (%08x)", wch[0] );
			if( ( wch[0] & 0xE0 ) == 0xC0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0x1F ) << 6 ) | ( (wchar_t)wch[1] & 0x3f );
				wch += 2;
			}
			else if( ( wch[0] & 0xF0 ) == 0xE0 )
			{
				ch[0] = ( ( (wchar_t)wch[0] & 0xF ) << 12 )
					| ( ( (wchar_t)wch[1] & 0x3F ) << 6 )
					| ( (wchar_t)wch[2] & 0x3f );
				wch += 3;
			}
			else if( ( wch[0] & 0xF0 ) == 0xF0 )
			{
				uint32_t literal_char =  ( ( (wchar_t)wch[0] & 0x7 ) << 18 )
				                 | ( ( (wchar_t)wch[1] & 0x3F ) << 12 )
				                 | ( (wchar_t)wch[2] & 0x3f ) << 6
				                 | ( (wchar_t)wch[3] & 0x3f );
				//lprintf( "literal char is %d (%08x", literal_char, literal_char );
// ((wchar_t*)&literal_char)[0];
				ch[0] = 0xD800 + ( ( ( literal_char - 0x10000 ) & 0xFFC00 ) >> 10 );
// ((wchar_t*)&literal_char)[1];
				ch[1] = 0xDC00 + ( ( literal_char - 0x10000 ) & 0x3ff );
				ch++;
				wch += 4;
			}
			else
			{
				ch[0] = wch[0] & 0x7f;
				wch++;
			}
			ch++;
		}
		ch[0] = 0;
	}
	return _ch;
}
wchar_t * CharWConvertEx ( const char *ch DBG_PASS )
{
	int len;
	for( len = 0; ch[len]; len++ );
	return CharWConvertExx( ch, len DBG_RELAY );
}
LOGICAL ParseStringVector( CTEXTSTR data, CTEXTSTR **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseStringVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (POINTER)(*pData) );
		}
		(*pData) = NewArray( CTEXTSTR, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
			size_t len;
			start = end;
			end = StrChr( start, ',' );
			if( end )
			{
				end++;
				(*pData)[count] = NewArray( TEXTCHAR, len = end - start );
			}
			else
			{
				(*pData)[count] = NewArray( TEXTCHAR, len = StrLen( start ) + 1 );
			}
			StrCpyEx( (TEXTSTR)(*pData)[count], start, len );
			count++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfChar( const char * *from )
{
	TEXTRUNE result = (unsigned char)(*from)[0];
	//if( !result ) return result;
	if( (*from)[0] & 0x80 )
	{
		if( ( (*from)[0] & 0xE0 ) == 0xC0 )
		{
			if( ( (*from)[1] & 0xC0 ) == 0x80 )
			{
				result = ( ( (unsigned int)(*from)[0] & 0x1F ) << 6 ) | ( (unsigned int)(*from)[1] & 0x3f );
				(*from) += 2;
			}
			else
			{
				result = 0;
				//lprintf( "a 2 byte code with improper continuation encodings following it was found. %02x %02x"
				//		, (*from)[0]
				//		, (*from)[1]
				//		);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF0 ) == 0xE0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 ) )
			{
				result = ( ( (unsigned int)(*from)[0] & 0xF ) << 12 ) | ( ( (unsigned int)(*from)[1] & 0x3F ) << 6 ) | ( (unsigned int)(*from)[2] & 0x3f );
				(*from) += 3;
			}
			else
			{
				result = 0;
				//lprintf( "a 3 byte code with improper continuation encodings following it was found. %02x %02x %02x"
				//	, (*from)[0]
				//	, (*from)[1]
				//	, (*from)[2]
				//	);
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xF8 ) == 0xF0 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 ) && ( ( (*from)[2] & 0xC0 ) == 0x80 ) && ( ( (*from)[3] & 0xC0 ) == 0x80 ) )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x7 ) << 18 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[2] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[3] & 0x3f );
				(*from) += 4;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFC ) == 0xF8 )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x3 ) << 24 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[3] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[4] & 0x3f );
				(*from) += 5;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xFE ) == 0xFC )
		{
			if( ( ( (*from)[1] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[2] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[3] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[4] & 0xC0 ) == 0x80 )
			  && ( ( (*from)[5] & 0xC0 ) == 0x80 )
			  )
			{
				result =   ( ( (unsigned int)(*from)[0] & 0x1 ) << 30 )
						| ( ( (unsigned int)(*from)[1] & 0x3F ) << 24 )
						| ( ( (unsigned int)(*from)[2] & 0x3F ) << 18 )
						| ( ( (unsigned int)(*from)[3] & 0x3F ) << 12 )
						| ( ( (unsigned int)(*from)[4] & 0x3f ) << 6 )
						| ( (unsigned int)(*from)[5] & 0x3f );
				(*from) += 6;
			}
			else
			{
				result = 0;
				//lprintf( "a 4 byte code with improper continuation encodings following it was found." );
				(*from)++;
			}
		}
		else if( ( (*from)[0] & 0xC0 ) == 0x80 )
		{
			// things like 0x9F, 0x9A is OK; is a single byte character, is a unicode application escape
			//lprintf( "a continuation encoding was found." );
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
		else
		{
			//result = (unsigned char)(*from)[0];
			(*from)++;
		}
	}
	else
	{
		result = (unsigned char)(*from)[0];
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexed( const char * pc, size_t *n, size_t length )
{
	if( length )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetUtfChar( &tmp );
		if( (size_t)( tmp - orig ) <= length ) {
			n[0] += tmp - orig;
			return result;
		}
		// if illformed character was at the end... return 0
	   // cap result to length.
		( *n ) = length;
	}
	return 0;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfChar( const char *start, const char * *from )
{
	TEXTRUNE result;
	if( (*from) == start ) return 0;
	result = (unsigned char)(*from)[-1];
	if( !result ) return result;
	if( (*from)[-1] & 0x80 )
	{
		CTEXTSTR end;
		while( (*from > start) && ( (*from)[-1] & 0xC0 ) == 0x80 )
			(*from)--;
		if( (*from > start) ) {
			(*from)--;
			end = (*from);
			result = GetUtfChar( from );
			(*from) = end;
		}
		else
			result = 0;
	}
	else
	{
		result = (unsigned char)(*from)[-1];
		(*from)--;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexed( const char *pc, size_t *n )
{
	if( *n )
	{
		CTEXTSTR orig = pc + n[0];
		CTEXTSTR tmp = orig;
		TEXTRUNE result = GetPriorUtfChar( pc, &tmp );
		if( tmp <= orig ) {
			n[0] -= orig - tmp;
			return result;
		}
	}
	return INVALID_RUNE;
}
//---------------------------------------------------------------------------
TEXTRUNE GetUtfCharW( const wchar_t * *from )
{
	TEXTRUNE result = (unsigned)(*from)[0];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[0] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetUtfCharIndexedW( const wchar_t* pc, size_t *n )
{
	const wchar_t * orig = pc + n[0];
	const wchar_t * tmp = orig;
	TEXTRUNE result = GetUtfCharW( &tmp );
	n[0] += tmp - orig;
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharW( const wchar_t*start, const wchar_t* *from )
{
	TEXTRUNE result = (unsigned)(*from)[-1];
	if( !result ) return result;
	if( ( ( (*from)[0] & 0xFC00 ) >= 0xD800 )
		&& ( ( (*from)[0] & 0xFC00 ) <= 0xDF00 ) )
	{
		result = 0x10000 + ( ( ( (*from)[0] & 0x3ff ) << 10 ) | ( ( (*from)[1] & 0x3ff ) ) );
		(*from) += 2;
	}
	else
	{
		(*from)++;
	}
	return result;
}
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
TEXTRUNE GetPriorUtfCharIndexedW( const wchar_t *pc, size_t *n )
{
	if( *n )
	{
		const wchar_t * orig = pc + n[0];
		const wchar_t * tmp = orig;
		TEXTRUNE result = GetPriorUtfCharW( pc, &tmp );
		n[0] += tmp - orig;
		return result;
	}
	return 0;
}
//---------------------------------------------------------------------------
// Return the integer character from the string
// using utf-8 or utf-16 decoding appropriately.  No more extended-ascii.
static int Step( CTEXTSTR *pc, size_t *nLen )
{
	CTEXTSTR _pc = (*pc);
	int ch;
	//lprintf( "Step (%s[%*.*s])", (*pc), nLen,nLen, (*pc) );
	if( nLen && !*nLen )
		return 0;
	ch = GetUtfChar( pc );
	//if( ch & 0xFFE00000 )
	//	DebugBreak();
	if( nLen )
		(*nLen) -= (*pc) - _pc;
	_pc = (*pc);
	if( ch )
	{
		while( ch == WIDE('\x9F') )
		{
			while( ch && ( ch != WIDE( '\x9C' ) ) )
			{
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
			// if the string ended...
			if( !ch )
			{
				// this is done.  There's nothing left... command with no data is bad form, but not illegal.
				return FALSE;
			}
  // pc is now on the stop command, advance one....
			else
			{
				// this is in a loop, and the next character may be another command....
				ch = GetUtfChar( pc );
				if( nLen )
					(*nLen) -= (*pc) - _pc;
				_pc = (*pc);
			}
		}
	}
	return ch;
}
size_t GetDisplayableCharacterBytes( CTEXTSTR string, size_t character_count )
{
	CTEXTSTR original = string;
	int ch;
	if( !string ) return 0;
	while( character_count &&
		( ch = Step( &string, NULL ) ) )
	{
		character_count--;
	}
	return string - original;
}
size_t GetDisplayableCharacterCount( CTEXTSTR string, size_t max_bytes )
{
	int ch;
	size_t count = 0;
	if( !string ) return 0;
	while( ( ch = Step( &string, &max_bytes ) ) )
	{
		count++;
	}
	return count;
}
CTEXTSTR GetDisplayableCharactersAtCount( CTEXTSTR string, size_t nLen )
{
	int ch;
	if( !string ) return 0;
	while( nLen > 0 &&
		 ( ch = Step( &string, NULL ) ) )
	{
		nLen--;
	}
	return string;
}
LOGICAL ParseIntVector( CTEXTSTR data, int **pData, int *nData )
{
	if( !data[0] )
	{
		*nData = 0;
		return 0;
	}
	//xlprintf(2100)( "ParseIntVector" );
	//if( StrChr( data, ',' ) )
	{
		CTEXTSTR start, end;
		int count = 0;
		end = data;
		do
		{
			count++;
			start = end;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		if( (*pData) )
		{
			//lprintf( "Had old data, release and make new" );
			Release( (*pData) );
		}
		(*pData) = NewArray( int, count );
		(*nData) = count;
		count = 0;
		end = data;
		do
		{
#ifndef _MSC_VER
#if defined( _UNICODE )
#   define sscanf     swscanf
#endif
#else
#if defined( _UNICODE )
#   undef sscanf
#   define sscanf     swscanf_s
#endif
#endif
			start = end;
			sscanf( start, WIDE("%d"), (*pData) + count );
			count++;
			end = StrChr( start, ',' );
			if( end )
				end++;
		}
		while( end );
		return TRUE;
	}
	return FALSE;
}
const char encodings[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_";
const char encodings2[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
static TEXTCHAR b64xor_table[256][256];
static TEXTCHAR u8xor_table[256][256];
static TEXTCHAR b64xor_table2[256][256];
static TEXTCHAR u8xor_table2[256][256];
PRELOAD( initTables ) {
	int n, m;
	for( n = 0; n < (sizeof( encodings )-1); n++ )
		for( m = 0; m < (sizeof( encodings )-1); m++ ) {
			b64xor_table[encodings[n]][encodings[m]] = encodings[n^m];
			u8xor_table[n][encodings[m]] = n^m;
			b64xor_table2[encodings2[n]][encodings2[m]] = encodings2[n^m];
			u8xor_table2[n][encodings2[m]] = n^m;
	}
	//LogBinary( (uint8_t*)u8xor_table[0], sizeof( u8xor_table ) );
	b64xor_table['=']['='] = '=';
}
char * b64xor( const char *a, const char *b ) {
	int n;
	char *out = NewArray( char, strlen(a) + 1);
	for( n = 0; a[n]; n++ ) {
		out[n] = b64xor_table[a[n]][b[n]];
	}
	out[n] = 0;
	return out;
}
char * u8xor( const char *a, size_t alen, const char *b, size_t blen, int *ofs ) {
	size_t n;
	size_t keylen = blen-5;
	int o = ofs[0];
	size_t outlen;
	char *out = NewArray( char, (outlen=alen) + 1);
	char *_out = out;
	int l = 0;
	int _mask = 0x3f;
	for( n = 0; n < alen; n++ ) {
		char v = (*a++);
		int mask;
		mask = _mask;
		if( (v & 0x80) == 0x00 ) { if( l ) lprintf( "short utf8 sequence found" ); mask = 0x3f; _mask = 0x3f; }
		else if( (v & 0xC0) == 0x80 ) { if( !l ) lprintf( "invalid utf8 sequence" ); l--; _mask = 0x3f; }
		else if( (v & 0xE0) == 0xC0 ) { if( l )
  // 6 + 1 == 7
			lprintf( "short utf8 sequence found" ); l = 1; mask = 0x1; _mask = 0x3f; }
		else if( (v & 0xF0) == 0xE0 ) { if( l )
  // 6 + 5 + 0 == 11
			lprintf( "short utf8 sequence found" ); l = 2; mask = 0;  _mask = 0x1f; }
		else if( (v & 0xF8) == 0xF0 ) { if( l )
  // 6(2) + 4 + 0 == 16
			lprintf( "short utf8 sequence found" ); l = 3; mask = 0;  _mask = 0x0f; }
		else if( (v & 0xFC) == 0xF8 ) { if( l )
  // 6(3) + 3 + 0 == 21
			lprintf( "short utf8 sequence found" ); l = 4; mask = 0;  _mask = 0x07; }
		else if( (v & 0xFE) == 0xFC ) { if( l )
  // 6(4) + 2 + 0 == 26
			lprintf( "short utf8 sequence found" ); l = 5; mask = 0;  _mask = 0x03; }
		char bchar = b[(n+o)%(keylen)];
		(*out) = (v & ~mask ) | ( u8xor_table[v & mask ][bchar] & mask );
		out++;
	}
	(*out) = 0;
	ofs[0] = (int)((ofs[0]+outlen)%keylen);
	return _out;
}
static const char * const _base642 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789$_=";
static const char * const _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
static char _base64_r[256];
static void encodeblock( unsigned char in[3], TEXTCHAR out[4], size_t len, const char *base64 )
{
	out[0] = base64[ in[0] >> 2 ];
	out[1] = base64[ ((in[0] & 0x03) << 4) | ( ( len > 0 ) ? ((in[1] & 0xf0) >> 4) : 0 ) ];
	out[2] = (len > 1 ? base64[ ((in[1] & 0x0f) << 2) | ( ( len > 2 ) ? ((in[2] & 0xc0) >> 6) : 0 ) ] : base64[64]);
	out[3] = (len > 2 ? base64[ in[2] & 0x3f ] : base64[64]);
}
static void decodeblock( char in[4], uint8_t out[3], size_t len, const char *base64 )
{
	int index[4];
	int n;
	for( n = 0; n < 4; n++ )
	{
//   strchr( base64, in[n] );
		index[n] = _base64_r[in[n]];
		//if( ( index[n] - base64 ) == 64 )
		//	last_byte = 1;
	}
	//if(
	out[0] = (char)(( index[0] ) << 2 | ( index[1] ) >> 4);
	out[1] = (char)(( index[1] ) << 4 | ( ( ( index[2] ) >> 2 ) & 0x0f ));
	out[2] = (char)(( index[2] ) << 6 | ( ( index[3] ) & 0x3F ));
	//out[] = (len > 2 ? base64[ in[2] & 0x3f ] : 0);
}
TEXTCHAR *EncodeBase64Ex( uint8_t* buf, size_t length, size_t *outsize, const char *base64 )
{
	size_t fake_outsize;
	TEXTCHAR * real_output;
	if( !outsize ) outsize = &fake_outsize;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	real_output = NewArray( TEXTCHAR, 1 + ( ( length * 4 + 2) / 3 ) + 1 + 1 + 1 );
	{
		size_t n;
		for( n = 0; n < (length+2)/3; n++ )
		{
			size_t blocklen;
			blocklen = length - n*3;
			if( blocklen > 3 )
				blocklen = 3;
			encodeblock( ((uint8_t*)buf) + n * 3, real_output + n*4, blocklen, base64 );
		}
		(*outsize) = n*4 + 1;
		real_output[n*4] = 0;
	}
	return real_output;
}
static void setupDecodeBytes( const char *code ) {
   int n = 0;
   memset( _base64_r, 0, 256 );
	while( *code ) {
      _base64_r[*code] = n++;
      code++;
	}
}
uint8_t *DecodeBase64Ex( char* buf, size_t length, size_t *outsize, const char *base64 )
{
	size_t fake_outsize;
	uint8_t * real_output;
	if( !outsize ) outsize = &fake_outsize;
	if( !base64 )
		base64 = _base64;
	else if( ((uintptr_t)base64) == 1 )
		base64 = _base642;
	setupDecodeBytes( base64 );
	real_output = NewArray( uint8_t, ( ( ( length + 1 ) * 3 ) / 4 ) + 1 );
	{
		size_t n;
		for( n = 0; n < (length+3)/4; n++ )
		{
			size_t blocklen;
			blocklen = length - n*4;
			if( blocklen > 4 )
				blocklen = 4;
			decodeblock( buf + n * 4, real_output + n*3, blocklen, base64 );
		}
		if( buf[length - 1] == '=' ) {
			if( buf[length - 2] == '=' ) {
				(*outsize) = (length * 3 / 4) - 2;
			}
			else
				(*outsize) = (length * 3 / 4) - 1;
		}
		else
			(*outsize) = (length * 3 / 4) - 2;
		real_output[(*outsize)] = 0;
	}
	return real_output;
}
#ifdef __cplusplus
 //namespace text {
};
 //namespace containers {
};
 // namespace sack {
};
#endif
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree container storing a user pointer blob of some user defined structure
 *   and a uintptr_t key which is used to check for content matchin.
 *   Binary tree has algorithms to become balanced, if the input is known to be weighted,
 *   or if statistics are pulled that indicate that the tree should be balanced, this
 *   function is available on demand.  Also searching through the tree using
 *   Least, Greatest, lesser, and greater is available.
 *
 * see also - include/typelib.h
 *
 */
//#include <sack_types.h>
//#include <sharemem.h>
//#include <logging.h>
//#define DEBUG_STEPPING
#ifdef __cplusplus
namespace sack {
	namespace containers {
		namespace BinaryTree {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
// consider slab allocation... 32 bytes even.
struct treenode_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
	} flags;
	uint32_t children;
	CPOINTER userdata;
	uintptr_t key;
	struct treenode_tag *lesser;
	struct treenode_tag *greater;
	struct treenode_tag **me;
	struct treenode_tag *parent;
};
typedef struct treenode_tag TREENODE;
#define MAXTREENODESPERSET 256
DeclareSet( TREENODE );
typedef struct treeroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // tree points to the real TREEROOT (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	uint32_t children;
	uint32_t lock;
	GenericDestroy Destroy;
	GenericCompare Compare;
	PTREENODE tree;
	PTREENODE prior, current, lastfound;
} TREEROOT;
static PTREENODESET TreeNodeSet;
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from );
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from );
//---------------------------------------------------------------------------
PTREEROOT FindTreeRoot( PTREENODE node )
{
	while( node && (!node->flags.bRoot) && node->parent )
	{
		node = node->parent;
	}
	return (PTREEROOT)node;
}
//---------------------------------------------------------------------------
int CPROC BinaryCompareInt( uintptr_t old, uintptr_t new_key )
{
	if( old > new_key )
		return 1;
	else if( old < new_key )
		return -1;
	return 0;
}
//---------------------------------------------------------------------------
PTREENODE RotateToRight( PTREENODE node )
{
	PTREENODE greater = node->greater;
	*node->me = node->greater;
	// my parent's nodes do NOT change....
	// node->parent->children += node->greater->children - node->children;
	greater->me       = node->me;
	greater->parent   = node->parent;
	node->children   -= (greater->children+1);
	if( ( node->greater = greater->lesser ) )
	{
		greater->lesser->me     = &node->greater;
		greater->lesser->parent = node;
		node->children    += (greater->lesser->children + 1);
		greater->children -= (greater->lesser->children + 1);
	}
	greater->lesser = node;
	node->me        = &greater->lesser;
	node->parent    = greater;
	greater->children += (node->children + 1);
	return greater;
}
//---------------------------------------------------------------------------
PTREENODE RotateToLeft( PTREENODE node )
{
	PTREENODE lesser = node->lesser;
	*node->me = node->lesser;
	// my parent's nodes do NOT change....
	// node->parent->children += node->lesser->children - node->children;
	lesser->me       = node->me;
	lesser->parent   = node->parent;
	node->children  -= (lesser->children+1);
	if( ( node->lesser = lesser->greater ) )
	{
		lesser->greater->me     = &node->lesser;
		lesser->greater->parent = node;
		node->children   += (lesser->greater->children + 1);
		lesser->children -= (lesser->greater->children + 1);
	}
	lesser->greater = node;
	node->me        = &lesser->greater;
	node->parent    = lesser;
	lesser->children += (node->children + 1);
	return lesser;
}
//---------------------------------------------------------------------------
// RotateToLeft - make left node root/current.
// RotateToRight - make right node root/current
static int BalanceBinaryBranch( PTREENODE root )
{
	PTREENODE check;
	int balances = 0;
	//while( balances )
	{
		balances = 0;
	   if( ( check = root ) )
	   {
		    if( check->lesser && check->greater)
		 {
			int left = check->lesser->children
			 , right = check->greater->children;
			if( left && right && ( left > ( right * 2 ) ) )
			{
				//if( left > 2+((left+right)*55)/100 )
				{
					 //Log2( WIDE("rotateing to left (%d/%d)"), left, right );
					root = RotateToLeft( check );
					balances++;
				}
				//else
				//	root = NULL;
			}
			else if( right > ( left * 2 ) )
			{
				//if( right  > 2+((left+right)*55)/100 )
				{
					 //Log2( WIDE("rotateing to right (%d/%d)"), right, left );
					root = RotateToRight( check );
					balances++;
				}
				//else
				//	root = NULL;
			}
		 }
		 else if( check->lesser && ( check->children >= 2 ) )
		 {
			 //Log1( WIDE("rotateing to left (%d)"), check->children );
			 root = RotateToLeft( check );
			balances++;
		 }
		 else if( check->greater && ( check->children >= 2 )  )
		 {
			 //Log1( WIDE("rotateing to right (%d)"), check->children );
			 root = RotateToRight( check );
			balances++;
		 }
		 //else
		 //	root = NULL;
		 if( root )
		 {
			balances += BalanceBinaryBranch( root->lesser );
			balances += BalanceBinaryBranch( root->greater );
		  }
	    }
	 }
	 return balances;
}
//---------------------------------------------------------------------------
void BalanceBinaryTree( PTREEROOT root )
{
	while( LockedExchange( &root->lock, 1 ) )
		Relinquish();
	while( BalanceBinaryBranch( root->tree ) > 1 && 0);
	root->lock = 0;
	//Log( WIDE("=========") );;
}
//---------------------------------------------------------------------------
int HangBinaryNode( PTREEROOT root, PTREENODE node )
{
	PTREENODE check;
	if( !node )
		return 0;
	root->children += ( node->children + 1 );
	if( !(root->tree) )
	{
		root->tree = node;
		node->me = &root->tree;
		node->parent = (PTREENODE)root;
		return 1;
	}
	 check = root->tree;
	 while( check )
	 {
		 int dir = root->Compare( node->key, check->key );
		 check->children += (node->children + 1);
		 if( dir < 0 )
		 {
			 if( check->lesser )
			 {
				 check = check->lesser;
			 }
			else
			{
				check->lesser = node;
				node->me = &check->lesser;
				node->parent = check;
				break;
			}
		 }
		 else if( dir > 0 )
			 if( check->greater )
			 {
				 check = check->greater;
			 }
			else
			{
				check->greater = node;
				node->me = &check->greater;
				node->parent = check;
				break;
			}
		else if( root->flags.bNoDuplicate )
		{
			while( check && !check->flags.bRoot )
			{
				check->children -= (node->children + 1);
				check = check->parent;
			}
			if( check )
				check->children -= (node->children + 1);
			DeleteFromSet( TREENODE, TreeNodeSet, node );
			//Release( node );
		 return 0;
		}
		else
		{
			int leftchildren = 0, rightchildren = 0;
			if( check->lesser )
				leftchildren = check->lesser->children;
			if( check->greater )
				rightchildren = check->greater->children;
			if( leftchildren <= rightchildren )
			{
				if( check->lesser )
					check = check->lesser;
				else
				{
					check->lesser = node;
					node->me = &check->lesser;
					node->parent = check;
					break;
				}
			}
			else
			{
				if( check->greater )
					check = check->greater;
				else
				{
					check->greater = node;
					node->me = &check->greater;
					node->parent = check;
					break;
				}
			}
		}
	}
	return 1;
}
//---------------------------------------------------------------------------
int AddBinaryNodeEx( PTREEROOT root
                   , CPOINTER userdata
                   , uintptr_t key DBG_PASS )
{
	PTREENODE node;
	if( !root )
		return 0;
//AllocateEx( sizeof( TREENODE ) DBG_RELAY );
	node = GetFromSet( TREENODE, &TreeNodeSet );
	node->lesser = NULL;
	node->greater = NULL;
	node->me = NULL;
	node->children = 0;
	node->userdata = userdata;
	node->key = key;
	node->flags.bUsed = 1;
	node->flags.bRoot = 0;
	return HangBinaryNode( root, node );
}
#undef AddBinaryNode
int AddBinaryNode( PTREEROOT root
						, CPOINTER userdata
					  , uintptr_t key )
{
	return AddBinaryNodeEx( root, userdata, key DBG_SRC );
}
//---------------------------------------------------------------------------
static void RehangBranch( PTREEROOT root, PTREENODE node )
{
	if( node )
	{
 // make sure I'm out of the tree...
		(*node->me) = NULL;
		if( node->greater )
		{
			RehangBranch( root, node->greater );
		}
		if( node->lesser )
		{
			RehangBranch( root, node->lesser );
		}
		node->children = 0;
		//lprintf( "putting self node back in tree %p", node );
		HangBinaryNode( root, node );
	}
}
static void DecrementParentCounts( PTREENODE node, int count )
{
	PTREENODE parent;
	for( parent = node; parent && !parent->flags.bRoot; parent = parent->parent )
	{
		parent->children -= count;
	}
}
static void NativeRemoveBinaryNode( PTREEROOT root, PTREENODE node )
{
	if( root )
	{
		// lprintf( "Removing node from tree.. %p under %p", node, node->parent );
		if( node->parent->lesser != node && node->parent->greater != node )
		{
			*(int*)0=0;
		}
		// lprintf( "%p should be removed!", node );
 // pull me out of the tree.
		(*node->me) = NULL;
		DecrementParentCounts( node->parent, node->children+1 );
		// hang my right...
		RehangBranch( root, node->greater );
		// hang my left...
		RehangBranch( root, node->lesser );
		if( root->Destroy )
			root->Destroy( node->userdata, node->key );
		MemSet( node, 0, sizeof( node ) );
		DeleteFromSet( TREENODE, TreeNodeSet, node );
		//Release( node );
		return;
	}
	lprintf( WIDE("Fatal RemoveBinaryNode could not find the root!") );
}
//---------------------------------------------------------------------------
 void  RemoveBinaryNode ( PTREEROOT root, POINTER data, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
		{
			if( node->userdata == data )
			{
				NativeRemoveBinaryNode( root, node );
				break;
			}
			else
			{
				// hmm same key different data...
				break;
			}
		}
	}
	return ;
}
//---------------------------------------------------------------------------
#define MAXTREEROOTSPERSET 128
DeclareSet( TREEROOT );
static PTREEROOTSET treepool;
//---------------------------------------------------------------------------
void ResetBinaryTree( PTREEROOT root )
{
	while( root->tree )
		NativeRemoveBinaryNode( root, root->tree );
}
//---------------------------------------------------------------------------
void DestroyBinaryTree( PTREEROOT root )
{
	while( root->tree )
		NativeRemoveBinaryNode( root, root->tree );
	DeleteFromSet( TREEROOT, treepool, root );
}
//---------------------------------------------------------------------------
PTREEROOT CreateBinaryTreeExtended( uint32_t flags
									  , GenericCompare Compare
									  , GenericDestroy Destroy DBG_PASS )
{
	PTREEROOT root;
//(PTREEROOT)AllocateEx( sizeof( TREEROOT ) DBG_RELAY );
	root = GetFromSet( TREEROOT, &treepool );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	if( flags & BT_OPT_NODUPLICATES  )
		root->flags.bNoDuplicate = 1;
	root->Destroy = Destroy;
	//root->return  = NULL; // upgoing... (return from right )
	if( Compare )
		root->Compare = Compare;
	else
		root->Compare = BinaryCompareInt;
	return root;
}
#undef CreateBinaryTreeEx
PTREEROOT CreateBinaryTreeEx( GenericCompare Compare
								    , GenericDestroy Destroy )
{
	return CreateBinaryTreeExx( 0, Compare, Destroy );
}
//---------------------------------------------------------------------------
int maxlevel = 0;
void DumpNode( PTREENODE node, int level, int (*DumpMethod)( CPOINTER user, uintptr_t key ) )
{
	int print;
	if( !node )
		return;
	if( level > maxlevel )
		maxlevel = level;
	DumpNode( node->lesser, level+1, DumpMethod );
	if( DumpMethod )
		print = DumpMethod( node->userdata, node->key );
	else
		print = TRUE;
	//else
	if( print )
		lprintf( WIDE("[%3d] %p Node has %3")_32f WIDE(" children (%p %3")_32f WIDE(",%p %3")_32f WIDE("). %10") _PTRSZVALfs
				 , level, node, node->children
				 , node->lesser
				 , (node->lesser)?(node->lesser->children+1):0
				 , node->greater
				 , (node->greater)?(node->greater->children+1):0
				 , node->key
				 );
	DumpNode( node->greater, level+1, DumpMethod );
}
//---------------------------------------------------------------------------
void DumpTree( PTREEROOT root
				 , int (*Dump)( CPOINTER user, uintptr_t key ) )
{
	maxlevel = 0;
	if( !Dump ) lprintf( WIDE("Tree %p has %")_32f WIDE(" nodes. %p is root"), root, root->children, root->tree );
	DumpNode( root->tree, 1, Dump );
	if( !Dump ) lprintf( WIDE("Tree had %d levels."), maxlevel );
}
//---------------------------------------------------------------------------
CPOINTER FindInBinaryTree( PTREEROOT root, uintptr_t key )
{
	PTREENODE node;
	if( !root )
		return 0;
	node = root->tree;
	while( node )
	{
		int dir = root->Compare( key, node->key );
		if( dir > 0 )
			node = node->greater;
		else if( dir < 0 )
			node = node->lesser;
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
int CPROC TextMatchLocate( uintptr_t key1, uintptr_t key2 )
{
	size_t k1len = StrLen( (CTEXTSTR)key1 );
	size_t k2len = StrLen( (CTEXTSTR)key2 );
	//lprintf( "COmpare %s(%d) vs %s(%d)", key1, k1len, key2, k2len );
	if( k2len < k1len )
	{
		// cannot match this.... but should
		// try to choose a direction
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k2len );
		if( dir == 0 )
			return 101;
		if( dir > 0 )
			return 1;
		return -1;
	}
	else if( k2len > k1len )
	{
		int dir = StrCaseCmpEx( (CTEXTSTR)key1, (CTEXTSTR)key2, k1len );
		// is exact match, but only part of key2
		if( dir == 0 )
			return 100;
		// I doubt these will really matter...
		// could compute distance...
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
	else
	{
		int dir = StrCaseCmp( (CTEXTSTR)key1, (CTEXTSTR)key2 );
		if( dir == 0 )
			return 0;
		if( dir > 0 )
			return 1;
		else
			return -1;
	}
}
// the key value passed does not have to be the same as the key in the tree
// it can be an abstrat reference of a strucutre that contains a key for the tree
// result of fuzzy routine is 0 = match.  100 = inexact match
// 1 = no match, actual may be larger
// -1 = no match, actual may be lesser
// 100 = inexact match- checks nodes near for better match.
CPOINTER LocateInBinaryTree( PTREEROOT root, uintptr_t key
								  , int (CPROC*fuzzy)( uintptr_t psv, uintptr_t node_key )
								  )
{
	PTREENODE node;
	node = root->tree;
	if( !fuzzy )
		fuzzy = TextMatchLocate;
	while( node )
	{
		int _dir;
		int dir = fuzzy( key, node->key );
		if( dir == 100 || dir == 101 )
		{
			PTREENODE one_up;
			PTREENODE one_down;
			// this matched, in an inexact length.
			// to be really careful we should match one up and one down.
			// well, we'll match better only if we had exact length
			// so - go up one node, until we find exact length
			//lprintf( " - Found a near match..." );
			one_up = node;
			one_down = node;
			_dir = dir;
			do
			{
				GetLesserNodeExx( root, &one_up );
				if( one_up )
				{
					dir = fuzzy( key, one_up->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_up;
						return (one_up->userdata);
					}
					else
						one_up = NULL;
				}
				GetGreaterNodeExx( root, &one_down );
				if( one_down )
				{
					dir = fuzzy( key, one_down->key );
					if( dir == 100 )
						continue;
					if( dir == 0 )
					{
						root->lastfound = one_down;
						return (one_down->userdata);
					}
					else
						one_down = NULL;
				}
			}
			while( one_up || one_down );
			if( _dir == 101 )
			{
				node = NULL;
			}
			root->lastfound = node;
			if( node )
				return( node->userdata );
			return 0;
		}
		if( dir > 0 )
		{
			node = node->greater;
		}
		else if( dir < 0 )
		{
			node = node->lesser;
		}
		else
			break;
	}
	root->lastfound = node;
	if( node )
		return node->userdata;
	return 0;
}
//---------------------------------------------------------------------------
CPOINTER GetCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return NULL;
	return (*(struct treenode_tag **)cursor)->userdata;
}
CPOINTER GetCurrentNode( PTREEROOT root )
{
	return GetCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
void RemoveLastFoundNode( PTREEROOT root )
{
	if( !root || !root->lastfound )
		return;
	NativeRemoveBinaryNode( root, root->lastfound );
}
//---------------------------------------------------------------------------
void RemoveCurrentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root || !(*cursor) )
		return;
	NativeRemoveBinaryNode( root, (PTREENODE)(*cursor) );
	(*cursor) = NULL;
}
void RemoveCurrentNode( PTREEROOT root )
{
	RemoveCurrentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreaterNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->greater && !(*from)->lesser )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->greater )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->greater )
	{
		// right
		(*from) = (*from)->greater;
		while( (*from)->lesser )
		{
			// Left
			(*from) = (*from)->lesser;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->greater == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetGreaterNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetGreaterNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetGreaterNode( PTREEROOT root )
{
	return GetGreaterNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLesserNodeExx( PTREEROOT root, PTREENODE *from )
{
	if( !root || !(*from) ) return 0;
	if( !(*from)->lesser && !(*from)->greater )
	{
		// Up 1
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root - end
			(*from) = NULL;
			return 0;
		}
		while( root->prior == (*from)->lesser )
		{
			// up 2
			root->prior = (*from);
			(*from) = (*from)->parent;
			if( (*from)->flags.bRoot )
			{
				// Root
				(*from) = NULL;
				return 0;
			}
		}
		// Do it
		return (*from)->userdata;
	}
	if( (*from)->lesser )
	{
		// right
		(*from) = (*from)->lesser;
		while( (*from)->greater )
		{
			// Left
			(*from) = (*from)->greater;
		}
		// Do it 1
		return (*from)->userdata;
	}
	do
	{
		// Up 3
		root->prior = (*from);
		(*from) = (*from)->parent;
		if( (*from)->flags.bRoot )
		{
			// Root
			(*from) = NULL;
			return 0;
		}
	} while( (*from)->lesser == root->prior );
	// Do it 2
	return (*from)->userdata;
}
CPOINTER GetLesserNodeEx( PTREEROOT root, POINTER *cursor )
{
	return GetLesserNodeExx( root, (PTREENODE*)cursor );
}
CPOINTER GetLesserNode( PTREEROOT root )
{
	return GetLesserNodeExx( root, &root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetLeastNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	(*(struct treenode_tag **)cursor) = root->tree;
	root->prior = NULL;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->lesser )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetLeastNode( PTREEROOT root )
{
	return GetLeastNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetGreatestNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	while( (*(struct treenode_tag **)cursor) && (*(struct treenode_tag **)cursor)->greater )
		(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetGreatestNode( PTREEROOT root )
{
	return GetGreatestNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetRootNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	root->prior = NULL;
	(*(struct treenode_tag **)cursor) = root->tree;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetRootNode( PTREEROOT root )
{
	return GetRootNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetParentNodeEx( PTREEROOT root, POINTER *cursor )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( !(*(struct treenode_tag **)cursor)->parent->flags.bRoot )
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->parent;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetParentNode( PTREEROOT root )
{
	return GetParentNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
CPOINTER GetChildNodeEx( PTREEROOT root, POINTER *cursor, int direction )
{
	if( !root ) return 0;
	if( (*(struct treenode_tag **)cursor) )
	{
		root->prior = (*(struct treenode_tag **)cursor);
		if( direction < 0 )
		{
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->lesser;
		}
		else
			(*(struct treenode_tag **)cursor) = (*(struct treenode_tag **)cursor)->greater;
		if( (*(struct treenode_tag **)cursor) )
			return (*(struct treenode_tag **)cursor)->userdata;
	}
	return 0;
}
CPOINTER GetChildNode( PTREEROOT root, int direction )
{
	return GetChildNodeEx( root, (POINTER*)&root->current, direction );
}
//---------------------------------------------------------------------------
CPOINTER GetPriorNodeEx( PTREEROOT root, POINTER *cursor )
{
	PTREENODE cur;
	if( !root ) return 0;
	cur = (*(struct treenode_tag **)cursor);
	(*(struct treenode_tag **)cursor) = root->prior;
	root->prior = cur;
	if( (*(struct treenode_tag **)cursor) )
		return (*(struct treenode_tag **)cursor)->userdata;
	return 0;
}
CPOINTER GetPriorNode( PTREEROOT root )
{
	return GetPriorNodeEx( root, (POINTER*)&root->current );
}
//---------------------------------------------------------------------------
uint32_t GetNodeCount( PTREEROOT root )
{
	return root->children;
}
//---------------------------------------------------------------------------
PTREEROOT ShadowBinaryTree( PTREEROOT Original )
{
	PTREEROOT root;
	Log( WIDE("Use of binary tree shadows is fraught with danger!") );
	root = (PTREEROOT)Allocate( sizeof( TREEROOT ) );
	MemSet( root, 0, sizeof( TREEROOT ) );
	root->flags.bRoot = 1;
	root->flags.bUsed = 1;
	root->flags.bShadow = 1;
	root->children = 0;
	root->Compare = Original->Compare;
	root->Destroy = Original->Destroy;
	root->tree = Original->tree;
	return root;
}
#ifdef __cplusplus
 // namespace BinaryTree {
};
 //namespace containers {
};
 //namespace sack {
};
#endif
//---------------------------------------------------------------------------
// $Log: binarylist.c,v $
// Revision 1.19  2005/01/27 07:18:34  panther
// Linux cleaned.
//
// Revision 1.18  2004/05/04 17:23:44  d3x0r
// Fix getlessernode
//
// Revision 1.17  2004/04/26 09:47:26  d3x0r
// Cleanup some C++ problems, and standard C issues even...
//
// Revision 1.16  2004/01/31 01:30:20  d3x0r
// Mods to extend/test procreglib.
//
// Revision 1.15  2004/01/29 10:13:44  d3x0r
// Remove ifdeffed logging, fix dumpnode to dump to log if no write method
//
// Revision 1.14  2003/10/24 14:50:11  panther
// Fix remove binary node, keep last found for quick delete
//
// Revision 1.13  2003/03/06 09:06:07  panther
// Oops - forgot to decrement the root count itself
//
// Revision 1.12  2003/03/06 08:56:06  panther
// fix code to unwind non-hung nodes
//
// Revision 1.11  2003/03/06 08:39:16  panther
// Stripped \r's.  Added GetNodeCount()
//
// Revision 1.10  2003/03/04 16:28:36  panther
// Cleanup warnings in typecode.  Convert uintptr_t to POINTER literal in binarylist
//
// Revision 1.9  2003/03/02 18:50:21  panther
// Added NO_DUPLICATES opption to  binary trees
//
// Revision 1.8  2003/02/20 02:35:17  panther
// Added debug message option flag
//
// Revision 1.7  2003/01/13 00:40:13  panther
// removed old msvc projects.
// Added new visual studio projects.
// Mods to compile cleanly under msvc.
//
// Revision 1.6  2002/08/12 22:16:02  panther
// Fixed buf in GetGreaterNode - last test tested prior->greater vs current
// which will never be true.
//
//
/*
 *  Crafted by James Buckeyne
 *
 *   (c) Freedom Collective 2000-2006++
 *
 *   A binary tree is often fine for sorting, but for relational things
 *   a Family tree that tracks parent, child, and peers is often required.
 *   The list of peers is a circular linked list based on LinkThing macros
 *   The List is actually broken foward cicularly, but not in a reverse direction
 *
 * see also - include/typelib.h
 *
 */
#define FAMILY_TREE_SOURCE_CODE
#ifdef __cplusplus
namespace sack {
namespace containers {
namespace family {
//	using namespace sack::memory;
#endif
// consider slab allocation... 32 bytes even.
struct familynode_tag {
	struct {
		BIT_FIELD bUsed:1;
	} flags;
	POINTER userdata;
	uintptr_t key;
	struct familynode_tag *elder, *younger, *parent, *child;
};
typedef struct familynode_tag FAMILYNODE;
#define MAXFAMILYNODESPERSET 256
DeclareSet( FAMILYNODE );
struct familyroot_tag {
	struct {
		BIT_FIELD bUsed:1;
		BIT_FIELD bRoot:1;
 // family points to the real FAMILYTREE (not a node)
		BIT_FIELD bShadow:1;
		BIT_FIELD bNoDuplicate : 1;
	} flags;
	void (CPROC *Destroy)( POINTER user, uintptr_t key );
	int (CPROC *Compare)(uintptr_t old,uintptr_t newx);
	PFAMILYNODESET nodes;
	PFAMILYNODE family;
	PFAMILYNODE prior
		// current is where things are added
		// newly added nodes become current?
		// prior is the last state, so after adding
      // a child node, the parent may be returned to.
//, prior
										, current
	// hmm lastfound... enumeration from this value?
	// what sort of enumeration of family trees exist?
										, lastfound;
};
typedef struct familyroot_tag FAMILYTREE;
//----------------------------------------------------------------------------
 PFAMILYTREE  CreateFamilyTree ( int (CPROC*Compare)(uintptr_t old,uintptr_t new_key),
															 void (CPROC*Destroy)( POINTER user, uintptr_t key ) )
{
	PFAMILYTREE root = (PFAMILYTREE)Allocate( sizeof( FAMILYTREE ) );
	MemSet( root, 0, sizeof( FAMILYTREE ) );
	root->Compare = Compare;
	root->Destroy = Destroy;
	return root;
}
//----------------------------------------------------------------------------
enum {
	RELATE_CHILD_OF
      , RELATE
};
//----------------------------------------------------------------------------
 POINTER  FamilyTreeFindChildEx ( PFAMILYTREE root, PFAMILYNODE root_node
													 , uintptr_t psvKey )
{
	PFAMILYNODE node = root_node;
	root->prior = root_node;
	if( node )
		node = node->child;
	else
		node = root->family;
	while( node )
	{
		int d;
		if( root->Compare )
			d = root->Compare( node->key, psvKey );
		else
			d = node->key > psvKey?1:node->key<psvKey?-1:0;
		if( !d )
			break;
		node = node->elder;
	}
	root->current = node;
	if( !node )
		return NULL;
	root->lastfound = node;
	return node->userdata;
}
POINTER  FamilyTreeFindChild ( PFAMILYTREE root, uintptr_t psvKey )
{
	return FamilyTreeFindChildEx( root, root->lastfound, psvKey );
}
//----------------------------------------------------------------------------
// scans the whole tree to find a node
LOGICAL FamilyTreeForEachChild( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData )
			, uintptr_t psvUserData )
{
	if( !node )
		node = root->family;
	else
		node = node->child;
	while( node )
	{
		LOGICAL process_result;
		process_result = ProcessNode( psvUserData, (uintptr_t)node->userdata );
		if( !process_result )
			return process_result;
		node = node->elder;
	}
	return TRUE;
}
// scans the whole tree to find a node
LOGICAL FamilyTreeForEach( PFAMILYTREE root, PFAMILYNODE node
			, LOGICAL (CPROC *ProcessNode)( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
			, uintptr_t psvUserData )
{
	static int level;
	if( !node )
		node = root->family;
	else
		node = node->child;
	level++;
	while( node )
	{
		LOGICAL process_result;
		//lprintf( "node %p", node );
		process_result = ProcessNode( psvUserData, (uintptr_t)node->userdata, level );
		if( !process_result )
			return process_result;
		if( node->child )
			FamilyTreeForEach( root, node, ProcessNode, psvUserData );
		node = node->elder;
	}
	level--;
	return TRUE;
}
static  uintptr_t CPROC DestroyNode(void* p,uintptr_t psvUser )
{
	PFAMILYTREE option_tree = (PFAMILYTREE)psvUser;
	if( option_tree->Destroy )
		option_tree->Destroy( ((PFAMILYNODE)p)->userdata, ((PFAMILYNODE)p)->key );
	DeleteFromSet( FAMILYNODE, option_tree->nodes, p );
	return 0;
}
void  FamilyTreeClear ( PFAMILYTREE option_tree )
{
	ForAllInSet( FAMILYNODE, option_tree->nodes, DestroyNode, (uintptr_t)option_tree );
	DeleteSetEx( FAMILYNODE, &option_tree->nodes );
	option_tree->family = NULL;
//	option_tree->nodes
}
//----------------------------------------------------------------------------
// resets the search conditions, and possibley makes aa tree if it isn't already.
void  FamilyTreeReset ( PFAMILYTREE *option_tree )
{
	if( !option_tree )
		return;
	if( !(*option_tree ) )
		(*option_tree) = CreateFamilyTree( NULL, NULL );
	(*option_tree)->lastfound = NULL;
	(*option_tree)->current = NULL;
}
//----------------------------------------------------------------------------
PFAMILYNODE  FamilyTreeAddChild ( PFAMILYTREE *root, PFAMILYNODE parent, POINTER userdata, uintptr_t key )
{
	if( root )
	{
		PFAMILYNODE node;
		if( !(*root ) )
			(*root) = CreateFamilyTree( NULL, NULL );
 /*Allocate( sizeof( FAMILYNODE )*/
		node = (PFAMILYNODE)GetFromSet( FAMILYNODE, &(*root)->nodes );
		node->child = NULL;
		node->younger = NULL;
		node->flags.bUsed = 0;
		node->userdata = userdata;
		node->key = key;
//(*root)->prior;
		node->parent = parent;
		if( !node->parent )
		{
			if( ( node->elder = (*root)->family ) )
				(*root)->family->younger = node;
			(*root)->family = node;
		}
		else
		{
			if( ( node->elder = (*root)->prior->child ) )
				node->elder->younger = node;
			(*root)->prior->child = node;
		}
		(*root)->prior = node;
		(*root)->lastfound = node;
		(*root)->current = node;
		return node;
	}
	return NULL;
}
#ifdef __cplusplus
 //namespace family {
};
 //namespace containers {
};
 //namespace sack {
};
#endif
/*
 *
 *   Crafted by Jim Buckeyne
 *    Purpose: Provide slab allocated set objects
 *      things like points, lines, etc, are cheaper to store
 *      in sets of 128, 256, instead of one at a time, since the
 *      allocation tracking block is larger than the object itself.
 *      Secondarily, this can result in compact, indexable, arrays
 *      for saving data - these resemble a PDATALIST
 *
 *  (c)1999-2006++ Freedom Collective
 */
//#undef GetFromSet
//#undef GetArrayFromSet
//#undef DeleteFromSet
//#undef DeleteArrayFromSet
//#undef CountUsedInSet
//#undef GetLinearSetArray
//#undef ForAllInSet
//----------------------------------------------------------------------------
 // put into a global structure, and configure.
static int bLog;
#ifdef __cplusplus
namespace sack {
	namespace containers {
	namespace sets {
		using namespace sack::memory;
		using namespace sack::logging;
#endif
#ifndef __NO_OPTIONS__
PRELOAD( InitSetLogging )
{
	bLog = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "type library/sets/Enable Logging" ), 0, TRUE );
}
#endif
void DeleteSet( GENERICSET **ppSet )
{
	GENERICSET *pSet;
	 if( !ppSet )
		 return;
	 pSet = *ppSet;
	if( bLog ) lprintf( WIDE( "Deleted set %p" ), pSet );
	while( pSet )
	{
		GENERICSET *next;
		next = pSet->next;
		Release( pSet );
		pSet = next;
	}
	*ppSet = NULL;
}
//----------------------------------------------------------------------------
PGENERICSET GetFromSetPoolEx( GENERICSET **pSetSet, int setsetsizea, int setunitsize, int setmaxcnt
							 , GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS ){
	PGENERICSET set;
	uint32_t maxbias = 0;
	void *unit = NULL;
	uintptr_t ofs = ( ( ( maxcnt + 31 ) / 32 ) * 4 );
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		if( pSetSet )
		{
			set = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
			set->nBias = 0;
		}
		else
		{
			set = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
			set->nBias = 0;
			//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
			MemSet( set, 0, setsizea );
		}
		*pSet = set;
	}
	{
		int n;
		set = *pSet;
ExtendSet:
		while( (size_t)set->nUsed == (size_t)maxcnt )
		{
			if( !set->next )
			{
				PGENERICSET newset;
				if( pSetSet )
				{
					newset = GetFromSetPoolEx( NULL, 0, 0, 0, pSetSet, setsetsizea, setunitsize, setmaxcnt DBG_RELAY );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
				else
				{
					newset = (PGENERICSET)AllocateEx( setsizea DBG_RELAY );
					//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
					MemSet( newset, 0, setsizea );
					if( set->nBias > maxbias )
						maxbias = set->nBias;
					newset->nBias = maxbias + maxcnt;
				}
#if 1
				if( ( newset->next = (*pSet) ) )
				{
					newset->next->me = &newset->next;
				}
				// insert newset at nead of list - then next time through
				// free ones are the first checked...
				(*(newset->me = pSet)) = newset;
#else
				set->next = newset;
				newset->me = &set->next;
#endif
				set = newset;
				// new, empty set, it's going to fail nUsed == maxcnt
				break;
			}
			else
			{
				if( set->nBias > maxbias )
					maxbias = set->nBias;
			}
			set = set->next;
		}
		while( !unit && set )
		{
			uintptr_t base = ( (uintptr_t)set->bUsed ) + ofs;
			// quick skip for 32 bit blocks of used members...
			n = 0;
			for( n = 0; n < maxcnt && ((maxcnt-n) >= 32) && AllUsed( set,n ); n+=32 );
			if( n == maxcnt )
			{
				// occastionally the 'nUsed' counter may not be in sync with actual usage.
				// this set, after inspecing the bitmasks is actually full.   Update
				// the usage counter and go back up to where the set gets extended.
				set->nUsed = n;
				goto ExtendSet;
			}
			for( n = n; n < maxcnt; n++ )
			{
				if( !IsUsed( set, n ) )
				{
 // go to the appropriate offset
					unit = (void*)( base + n * unitsize );
					SetUsed( set, n );
					return (PGENERICSET)unit;
				}
			}
			if( n == maxcnt )
			{
				if( !set->next ) {
					// synchronize this; obviusly every member IS used.
					set->nUsed = n;
 // for some reason didn't find anything; maybe it's a small set of less than 32 elements?
					goto ExtendSet;
				}
				set = set->next;
			}
		}
#ifdef Z_DEBUG
		if( bLog ) _lprintf( DBG_RELAY )( WIDE( "Unit result: %p from %p %d %d %d %d" ), unit, set, unitsize, maxcnt, n, ( ( (maxcnt +31) / 32 ) * 4 )  );
#endif
	}
	return (PGENERICSET)unit;
}
//----------------------------------------------------------------------------
void *GetFromSetEx( GENERICSET **pSet, int setsizea, int unitsize, int maxcnt DBG_PASS )
{
	return GetFromSetPoolEx( NULL, 0, 0, 0
								  , pSet, setsizea, unitsize, maxcnt DBG_RELAY );
}
static POINTER GetSetMemberExx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt, int *bUsed DBG_PASS )
{
	PGENERICSET set;
	uint32_t maxbias = 0;
	if( nMember == INVALID_INDEX )
		return NULL;
	if( !pSet )
 // can never return something from nothing.
		return NULL;
	if( !(*pSet) )
	{
		set = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
		//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
		MemSet( set, 0, setsize );
		set->nBias = 0;
		*pSet = set;
	}
	else
		set = (*pSet );
	while( 1 )
	{
		if( nMember >= set->nBias &&
			nMember < ( set->nBias + maxcnt ) )
		{
			nMember -= set->nBias;
			break;
		}
		if( !set->next )
		{
			PGENERICSET newset = (PGENERICSET)AllocateEx( setsize DBG_RELAY );
			//Log4( WIDE("Allocating a Set for %d elements sized %d total %d %08x"), maxcnt, unitsize, setsize, set );
			MemSet( newset, 0, setsize );
			if( set->nBias > maxbias )
				maxbias = set->nBias;
			newset->nBias = maxbias + maxcnt;
			set->next = newset;
			newset->me = &set->next;
		}
		else
		{
			if( set->nBias > maxbias )
				maxbias = set->nBias;
		}
		//nMember -= maxcnt;
		set = set->next;
	}
	if( !IsUsed( set, nMember ) )
		(*bUsed) = 0;
	else
		(*bUsed) = 1;
	if( bLog ) _lprintf(DBG_RELAY)( WIDE( "Resulting unit %" ) _PTRSZVALfs,  ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +31) / 32 ) * 4 )
						+ nMember * unitsize );
	return (void*)( ((uintptr_t)(set->bUsed))
 // skip over the bUsed bitbuffer
						+ ( ( (maxcnt +31) / 32 ) * 4 )
 // go to the appropriate offset
						+ nMember * unitsize );
}
//----------------------------------------------------------------------------
POINTER GetUsedSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		return NULL;
	return result;
}
//----------------------------------------------------------------------------
POINTER GetSetMemberEx( GENERICSET **pSet, INDEX nMember, int setsize, int unitsize, int maxcnt DBG_PASS )
{
	POINTER result;
	int bUsed;
	if( nMember == INVALID_INDEX )
		return NULL;
	//if( nMember > 1000 )
	//	DebugBreak();
	result = GetSetMemberExx( pSet, nMember, setsize, unitsize, maxcnt, &bUsed DBG_RELAY );
	if( !bUsed )
		SetUsed( *pSet, nMember );
	return result;
}
//----------------------------------------------------------------------------
#undef GetMemberIndex
INDEX GetMemberIndex(GENERICSET **ppSet, POINTER unit, int unitsize, int max )
{
	GENERICSET *pSet = ppSet?*ppSet:NULL;
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + 31 ) / 32) * 4;
	int base = 0;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( WIDE("Error in set member alignment! %") _PTRSZVALfs WIDE(" of %d"), n % unitsize, unitsize );
				DebugBreak();
				return INVALID_INDEX;
			}
			n /= unitsize;
			return (INDEX)(n + pSet->nBias);
		}
		base += max;
		pSet = pSet->next;
	}
	return INVALID_INDEX;
}
//----------------------------------------------------------------------------
#undef MemberValidInSet
int MemberValidInSet( GENERICSET *pSet, void *unit, int unitsize, int max )
{
	uintptr_t nUnit = (uintptr_t)unit;
	int ofs = ( ( max + 31 ) / 32) * 4;
	while( pSet )
	{
		if( nUnit >= ((uintptr_t)(pSet->bUsed) + ofs ) &&
			 nUnit <= ((uintptr_t)(pSet->bUsed) + ofs + unitsize*max ) )
		{
			uintptr_t n = nUnit - ( ((uintptr_t)(pSet->bUsed)) + ofs );
			if( n % unitsize )
			{
				lprintf( WIDE("Error in set member alignment! %") _PTRSZVALfs WIDE(" of %d"), n % unitsize, unitsize );
				DebugBreak();
				return FALSE;
			}
			n /= unitsize;
			return IsUsed( pSet, n );
		}
		pSet = pSet->next;
	}
	return FALSE;
}
//----------------------------------------------------------------------------
void DeleteFromSetExx( GENERICSET *pSet, void *unit, int unitsize, int max DBG_PASS )
{
	uintptr_t nUnit = (uintptr_t)unit;
	uintptr_t ofs = ( ( max + 31 ) / 32) * 4;
	uintptr_t base;
	//if( bLog ) _lprintf(DBG_RELAY)( WIDE("Deleting from  %p of %p "), pSet, unit );
	while( pSet )
	{
		base = ( (uintptr_t)( pSet->bUsed ) + ofs );
		if( (nUnit >= base) &&
		    (nUnit < ( base + unitsize*max )) )
		{
			uintptr_t n = nUnit - base;
#ifdef Z_DEBUG
			if( n % unitsize )
			{
				lprintf( WIDE("Error in set member alignment! %p %p %p  %d %")_PTRSZVALfs WIDE(" %")_PTRSZVALfs WIDE(" of %d")
						 , unit
						 , pSet
						 , &pSet->bUsed
						, ofs
						 , n, n % unitsize, unitsize );
				DebugBreak();
				return;
			}
#endif
			n /= unitsize;
			ClearUsed( pSet, n );
			break;
		}
		pSet = pSet->next;
	}
#ifdef Z_DEBUG
	if( !pSet )
		Log( WIDE("Failed to find node in set!") );
#endif
}
//----------------------------------------------------------------------------
void DeleteSetMemberEx( GENERICSET *pSet, INDEX iMember, uintptr_t unitsize, INDEX max )
{
	//Log2( WIDE("Deleting from  %08x of %08x "), pSet, iMember );
	while( pSet )
	{
		if( iMember >= max )
		{
			iMember -= max;
			pSet = pSet->next;
			continue;
		}
		break;
	}
	if( pSet )
	{
		if( !IsUsed( pSet, iMember ) )
		{
			DebugBreak();
			lprintf( WIDE("Deleting set member which is already released? not decrementing used counter") );
		}
		else
		{
			ClearUsed( pSet, iMember );
			//pSet->nUsed--; // one not used - quick reference counter
		}
	}
	else
		Log( WIDE("Failed to find node in set!") );
}
#undef DeleteSetMember
void DeleteSetMember( GENERICSET *pSet, INDEX iMember, int unitsize, int max )
{
	DeleteSetMemberEx( pSet, iMember, unitsize, max );
}
//----------------------------------------------------------------------------
int CountUsedInSetEx( GENERICSET *pSet, int max )
{
	int cnt = 0, n;
	while( pSet )
	{
		for( n = 0; n < max; n++ )
			if( IsUsed( pSet, n ) )
				cnt++;
		pSet = pSet->next;
	}
	return cnt;
}
//----------------------------------------------------------------------------
void **GetLinearSetArrayEx( GENERICSET *pSet, int *pCount, int unitsize, int max )
{
	void  **array;
	int items, cnt, n, ofs;
	INDEX nMin, nNewMin;
	GENERICSET *pCur, *pNewMin;
	//Log2( WIDE("Building Array unit size: %d(%08x)"), unitsize, unitsize );
	items = CountUsedInSetEx( pSet, max );
	if( pCount )
		*pCount = items;
	ofs = ( ( max + 31) / 32 ) * 4;
	array = (void**)Allocate( sizeof( void* ) * items );
 // 0
	nMin = 0;
	do
	{
		pCur = pSet;
 // 0xFFFFFFFF (max)
		nNewMin = INVALID_INDEX;
		while( pCur )
		{
			// maybe instead of ordering elements
			// by ID - order by physical memory?
			// that allows findinarray to work better...
			if( (uintptr_t)pCur->nBias < nNewMin &&
				 (uintptr_t)pCur->nBias >= nMin )
			{
				pNewMin = pCur;
				nNewMin = pCur->nBias;
			}
			pCur = pCur->next;
		}
		if( (uintptr_t)nNewMin != INVALID_INDEX )
		{
			cnt = 0;
			for( n = 0; n < max; n++ )
				if( IsUsed( pNewMin, n ) )
				{
					array[cnt] = (void*)( ((uintptr_t)(pNewMin->bUsed))
												  + ofs
												  + n * unitsize );
					cnt++;
				}
		}
		nMin = nNewMin+1;
	}while( nNewMin != INVALID_INDEX );
	return array;
}
//----------------------------------------------------------------------------
int FindInArray( void **pArray, int nArraySize, void *unit )
{
	//int32_t idx;
	if( pArray )
	{
		int i, j, m;
		uintptr_t psvUnit, psvArray;
		i = 0;
		j = nArraySize-1;
		psvUnit = (uintptr_t)unit;
		do
		{
			m = (i+j)/2;
			psvArray = (uintptr_t)pArray[m];
			if( psvUnit < psvArray )
				j = m - 1;
			else if( psvUnit > psvArray )
				i = m + 1;
			else
				break;
		}
		while( i <= j );
		if( i > j )
			return -1;
		return m;
	}
	return -1;
}
//----------------------------------------------------------------------------
uintptr_t _ForAllInSet( GENERICSET *pSet, int unitsize, int max, FAISCallback f, uintptr_t psv )
{
	//Log2( WIDE("Doing all in set - size: %d setsize: %d"), unitsize, max );
	if( f )
	{
		int ofs, n;
		ofs = ( ( max + 31) / 32 ) * 4;
		while( pSet )
		{
			for( n = 0; n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					psvReturn = f( (void*)( ((uintptr_t)(pSet->bUsed))
											  + ofs
											  + n * unitsize ), psv );
					if( psvReturn )
					{
						//Log( WIDE("Return short? "));
						return psvReturn;
					}
				}
			pSet = pSet->next;
		}
	}
	return 0;
}
//----------------------------------------------------------------------------
#undef ForEachSetMember
uintptr_t ForEachSetMember( GENERICSET *pSet, int unitsize, int max, FESMCallback f, uintptr_t psv )
{
	//Log2( WIDE("Doing all in set - size: %d setsize: %d"), unitsize, max );
	if( f )
	{
		int total = 0;
		int n;
		while( pSet )
		{
			int nFound = 0;
			for( n = 0; nFound < (int)pSet->nUsed && n < max; n++ )
				if( IsUsed( pSet, n ) )
				{
					uintptr_t psvReturn;
					nFound++;
					psvReturn = f( total+n, psv );
					if( psvReturn )
					{
						//Log( WIDE("Return short? "));
						return psvReturn;
					}
				}
			total += n;
			pSet = pSet->next;
		}
	}
	return 0;
}
#ifdef __cplusplus
//	namespace sets {
	};
 //	namespace containers {
	};
 //namespace sack {
};
#endif
// $Log: sets.c,v $
// Revision 1.15  2005/05/20 21:47:10  jim
// Add base to get member index... so we don't get index of member in a set, but the actual index of the member in order... also fix a spot of set slab linking.  Also, fix resulting of the member for an index...
//
// Revision 1.14  2005/05/18 21:19:32  jim
// Define a method which will only get a valid set member from a set.
//
// Revision 1.13  2005/03/07 12:53:15  panther
// Only check what's used in a set instead of all memebers.
//
// Revision 1.12  2005/02/09 22:40:22  panther
// allow timers library to steal sets code....
//
// Revision 1.11  2005/02/04 19:25:30  panther
// Added iterator for sets that's a little different
//
// Revision 1.10  2005/01/10 21:43:42  panther
// Unix-centralize makefiles, also modify set container handling of getmember index
//
// Revision 1.9  2004/12/19 15:44:40  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.8  2004/10/04 03:56:26  d3x0r
// protect against null array passed to find_in_array
//
// Revision 1.7  2004/02/18 20:47:04  d3x0r
// Undef MemberInSet
//
// Revision 1.6  2004/02/14 01:19:04  d3x0r
// Extensions of Set structure in containers, C++ interface extension
//
// Revision 1.5  2003/04/11 16:03:53  panther
// Added  LogN for gcc.  Fixed set code to search for first available instead of add at end always.  Added MKCFLAGS MKLDFLAGS for lnx makes.
// Fixed target of APP_DEFAULT_DATA.
// Updated display to use a meta buffer between for soft cursors.
//
// Revision 1.4  2003/03/25 09:37:58  panther
// Fix file tails mangled by CVS logging
//
// Revision 1.3  2003/03/25 08:45:58  panther
// Added CVS logging tag
//
#ifndef NETWORK_HEADER_INCLUDED
#define NETWORK_HEADER_INCLUDED
#ifdef NETWORK_SOURCE
#define NETWORK_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define NETWORK_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
#define _NETWORK_NAMESPACE  namespace network {
#define _NETWORK_NAMESPACE_END }
#define _TCP_NAMESPACE  namespace tcp {
#define _TCP_NAMESPACE_END }
#define USE_TCP_NAMESPACE using namespace tcp;
#define _UDP_NAMESPACE  namespace udp {
#define _UDP_NAMESPACE_END }
#define USE_UDP_NAMESPACE using namespace tcp;
#else
#define _NETWORK_NAMESPACE
#define _NETWORK_NAMESPACE_END
#define _TCP_NAMESPACE
#define _TCP_NAMESPACE_END
#define _UDP_NAMESPACE
#define _UDP_NAMESPACE_END
#define USE_TCP_NAMESPACE
#define USE_UDP_NAMESPACE
#endif
#define SACK_NETWORK_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE
#define SACK_NETWORK_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define SACK_NETWORK_TCP_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE _TCP_NAMESPACE
#define SACK_NETWORK_TCP_NAMESPACE_END _TCP_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define SACK_NETWORK_UDP_NAMESPACE  SACK_NAMESPACE _NETWORK_NAMESPACE _UDP_NAMESPACE
#define SACK_NETWORK_UDP_NAMESPACE_END _UDP_NAMESPACE_END _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
SACK_NAMESPACE
	/* Event based networking interface.
	   Example
	   \Example One : A simple client side application. Reads
	   standard input, and writes it to a server it connects to. Read
	   the network and write as standard output.
	   <code lang="c++">
	   \#include \<network.h\>
	   </code>
	   <code>
	   \#include \<logging.h\>
	   \#include \<sharemem.h\>
	   </code>
	   <code lang="c++">
	   void CPROC ReadComplete( PCLIENT pc, void *bufptr, int sz )
	   {
	      char *buf = (char*)bufptr;
	       if( buf )
	       {
	           buf[sz] = 0;
	           printf( "%s", buf );
	           fflush( stdout );
	       }
	       else
	       {
	           buf = (char*)Allocate( 4097 );
	           //SendTCP( pc, "Yes, I've connected", 12 );
	       }
	       ReadTCP( pc, buf, 4096 );
	   }
	   PCLIENT pc_user;
	   void CPROC Closed( PCLIENT pc )
	   {
	      pc_user = NULL;
	   }
	   int main( int argc, char** argv )
	   {
	       SOCKADDR *sa;
	       if( argc \< 2 )
	       {
	           printf( "usage: %s \<Telnet IP[:port]\>\\n", argv[0] );
	           return 0;
	       }
	       SystemLog( "Starting the network" );
	       NetworkStart();
	       SystemLog( "Started the network" );
	       sa = CreateSockAddress( argv[1], 23 );
	       pc_user = OpenTCPClientAddrEx( sa, ReadComplete, Closed, NULL, 0 );
	       if( !pc_user )
	       {
	           SystemLog( "Failed to open some port as telnet" );
	           printf( "failed to open %s%s\\n", argv[1], strchr(argv[1],':')?"":":telnet[23]" );
	           return 0;
	       }
	      //SendTCP( pc_user, "Some data here...", 12 );
	       while( pc_user )
	       {
	           char buf[256];
	           if( !fgets( buf, 256, stdin ) )
	           {
	               RemoveClient( pc_user );
	               return 0;
	           }
	           SendTCP( pc_user, buf, strlen( buf ) );
	       }
	       return -1;
	   }
	   </code>
	   \Example Two : A server application, opens a socket that it
	   accepts connections on. Reads the socket, and writes the
	   information it reads back to the socket as an echo.
	   <code lang="c++">
	   \#include \<stdhdrs.h\>
	   \#include \<sharemem.h\>
	   \#include \<timers.h\>
	   \#include \<network.h\>
	   void CPROC ServerRecieve( PCLIENT pc, POINTER buf, int size )
	   {
	       //int bytes;
	       if( !buf )
	       {
	           buf = Allocate( 4096 );
	           //SendTCP( pc, (void*)"Hi, welccome to...", 15 );
	       }
	       //else
	           //SendTCP( pc, buf, size );
	       // test for waitread support...
	       // read will not result until the data is read.
	       //bytes = WaitReadTCP( pc, buf, 4096 );
	       //if( bytes \> 0 )
	       //   SendTCP( pc, buf, bytes );
	       ReadTCP( pc, buf, 4095 );
	       // buffer does not have anything in it....
	   }
	   void CPROC ClientConnected( PCLIENT pListen, PCLIENT pNew )
	   {
	       SetNetworkReadComplete( pNew, ServerRecieve );
	   }
	   int main( int argc, char **argv )
	   {
	       PCLIENT pcListen;
	       SOCKADDR *port;
	       if( argc \< 2 )
	       {
	           printf( "usage: %s \<listen port\> (defaulting to telnet)\\n", argv[0] );
	           port = CreateSockAddress( "localhost:23", 23 );
	       }
	       else
	           port = CreateSockAddress( argv[1], 23 );
	       NetworkStart();
	       pcListen = OpenTCPListenerAddrEx( port, ClientConnected );
	       if(pcListen)
	           while(1) WakeableSleep( SLEEP_FOREVER );
	       else
	           printf( "Failed to listen on port %s\\n", argv[1] );
	       return 0;
	   }
	   </code>                                                                                    */
	_NETWORK_NAMESPACE
//#ifndef CLIENT_DEFINED
typedef struct NetworkClient *PCLIENT;
//typedef struct Client
//{
//   unsigned char Private_Structure_information_here;
//}CLIENT, *PCLIENT;
//#endif
NETWORK_PROC( CTEXTSTR, GetSystemName )( void );
NETWORK_PROC( PCLIENT, NetworkLockEx )( PCLIENT pc, int readWrite DBG_PASS );
NETWORK_PROC( void, NetworkUnlockEx )( PCLIENT pc, int readWrite DBG_PASS );
/* <combine sack::network::NetworkLockEx@PCLIENT pc>
   \ \                                               */
#define NetworkLock(pc,rw) NetworkLockEx( pc,rw DBG_SRC )
/* <combine sack::network::NetworkUnlockEx@PCLIENT pc>
   \ \                                                 */
#define NetworkUnlock(pc,rw) NetworkUnlockEx( pc,rw DBG_SRC )
typedef void (CPROC*cReadComplete)(PCLIENT, POINTER, size_t );
typedef void (CPROC*cReadCompleteEx)(PCLIENT, POINTER, size_t, SOCKADDR * );
typedef void (CPROC*cCloseCallback)(PCLIENT);
typedef void (CPROC*cWriteComplete)(PCLIENT );
typedef void (CPROC*cNotifyCallback)(PCLIENT server, PCLIENT newClient);
typedef void (CPROC*cConnectCallback)(PCLIENT, int);
typedef void (CPROC*cppReadComplete)(uintptr_t, POINTER, size_t );
typedef void (CPROC*cppReadCompleteEx)(uintptr_t,POINTER, size_t, SOCKADDR * );
typedef void (CPROC*cppCloseCallback)(uintptr_t);
typedef void (CPROC*cppWriteComplete)(uintptr_t );
typedef void (CPROC*cppNotifyCallback)(uintptr_t, PCLIENT newClient);
typedef void (CPROC*cppConnectCallback)(uintptr_t, int);
NETWORK_PROC( void, SetNetworkWriteComplete )( PCLIENT, cWriteComplete );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkWriteComplete@PCLIENT@cWriteComplete>
   \ \                                                                     */
NETWORK_PROC( void, SetCPPNetworkWriteComplete )( PCLIENT, cppWriteComplete, uintptr_t );
#endif
/* <combine sack::network::SetNetworkWriteComplete@PCLIENT@cWriteComplete>
   \ \                                                                     */
#define SetWriteCallback SetNetworkWriteComplete
NETWORK_PROC( void, SetNetworkReadComplete )( PCLIENT, cReadComplete );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkReadComplete@PCLIENT@cReadComplete>
   \ \                                                                   */
NETWORK_PROC( void, SetCPPNetworkReadComplete )( PCLIENT, cppReadComplete, uintptr_t );
#endif
/* <combine sack::network::SetNetworkReadComplete@PCLIENT@cReadComplete>
   \ \                                                                   */
#define SetReadCallback SetNetworkReadComplete
NETWORK_PROC( void, SetNetworkCloseCallback )( PCLIENT, cCloseCallback );
#ifdef __cplusplus
/* <combine sack::network::SetNetworkCloseCallback@PCLIENT@cCloseCallback>
   \ \                                                                     */
NETWORK_PROC( void, SetCPPNetworkCloseCallback )( PCLIENT, cppCloseCallback, uintptr_t );
#endif
/* <combine sack::network::SetNetworkCloseCallback@PCLIENT@cCloseCallback>
   \ \                                                                     */
#define SetCloseCallback SetNetworkCloseCallback
 // wwords is BYTES and wClients=16 is defaulted to 16
#ifdef __LINUX__
NETWORK_PROC( LOGICAL, NetworkWait )(POINTER unused,uint32_t wClients,int wUserData);
#else
NETWORK_PROC( LOGICAL, NetworkWait )(HWND hWndNotify,uint32_t wClients,int wUserData);
#endif
/* <combine sack::network::NetworkWait@HWND@uint16_t@int>
   \ \                                               */
#define NetworkStart() NetworkWait( NULL, 0, 0 )
 // returns true if network layer still active...
NETWORK_PROC( LOGICAL, NetworkAlive )( void );
/* Shutdown these network services, stop the network thread, and
   close all sockets open, releasing all internal resources.
   Parameters
   None.                                                         */
NETWORK_PROC( int, NetworkQuit )(void);
// preferred method is to call Idle(); if in doubt.
//NETWORK_PROC( int, ProcessNetworkMessages )( void );
// dwIP would be for 1.2.3.4  (0x01020304 - memory 04 03 02 01) - host order
// VERY RARE!
NETWORK_PROC( SOCKADDR *, CreateAddress_hton )( uint32_t dwIP,uint16_t nHisPort);
// dwIP would be for 1.2.3.4  (0x04030201 - memory 01 02 03 04) - network order
#ifndef WIN32
NETWORK_PROC( SOCKADDR *, CreateUnixAddress )( CTEXTSTR path );
#endif
NETWORK_PROC( SOCKADDR *, CreateAddress )( uint32_t dwIP,uint16_t nHisPort);
NETWORK_PROC( SOCKADDR *, SetAddressPort )( SOCKADDR *pAddr, uint16_t nDefaultPort );
NETWORK_PROC( SOCKADDR *, SetNonDefaultPort )( SOCKADDR *pAddr, uint16_t nDefaultPort );
/*
 * this is the preferred method to create an address
 * name may be "* / *" with a slash, then the address result will be a unix socket (if supported)
 * name may have an options ":port" port number associated, if there is no port, then the default
 * port is used.
 *
 */
NETWORK_PROC( SOCKADDR *, CreateSockAddress )( CTEXTSTR name, uint16_t nDefaultPort );
/*
 * set (*data) and (*datalen) to a binary buffer representation of the sockete address.
 */
NETWORK_PROC( void, GetNetworkAddressBinary )( SOCKADDR *addr, uint8_t **data, size_t *datalen );
/*
 * create a socket address form data and datalen binary buffer representation of the sockete address.
 */
NETWORK_PROC( SOCKADDR *, MakeNetworkAddressFromBinary )( uintptr_t *data, size_t datalen );
NETWORK_PROC( SOCKADDR *, CreateRemote )( CTEXTSTR lpName,uint16_t nHisPort);
NETWORK_PROC( SOCKADDR *, CreateLocal )(uint16_t nMyPort);
NETWORK_PROC( int, GetAddressParts )( SOCKADDR *pAddr, uint32_t *pdwIP, uint16_t *pwPort );
 // release a socket resource that has been created by an above routine
NETWORK_PROC( void, ReleaseAddress )(SOCKADDR *lpsaAddr);
// result with TRUE if equal, else FALSE
NETWORK_PROC( LOGICAL, CompareAddress )(SOCKADDR *sa1, SOCKADDR *sa2 );
#define SA_COMPARE_FULL 1
#define SA_COMPARE_IP   0
NETWORK_PROC( LOGICAL, CompareAddressEx )(SOCKADDR *sa1, SOCKADDR *sa2, int method );
/*
 * compare this address to see if it is any of my IPv4 interfaces
 */
NETWORK_PROC( LOGICAL, IsThisAddressMe )( SOCKADDR *addr, uint16_t myport );
/*
 *  Get the list of SOCKADDR addresses that are on this box (for this name)
 */
NETWORK_PROC( PLIST, GetLocalAddresses )( void );
/*
 * Return the text of a socket's IP address
 */
NETWORK_PROC( const char *, GetAddrName )( SOCKADDR *addr );
/*
 * Return the numeric form of the address (might have been created by name).
 */
NETWORK_PROC( const char *, GetAddrString )(SOCKADDR *addr);
/*
 * test an address to see if it is v6 (switch connect From behavior at application level)
 */
NETWORK_PROC( LOGICAL, IsAddressV6 )( SOCKADDR *addr );
/*
 *  Duplicate a sockaddr appropriately for the specified network.
 *  SOCKADDR has in(near) it the size of the address block, so this
 * can safely duplicate the the right amount of memory.
 */
 // return a copy of this address...
NETWORK_PROC( SOCKADDR *, DuplicateAddressEx )( SOCKADDR *pAddr DBG_PASS );
#define DuplicateAddress(a) DuplicateAddressEx( a DBG_SRC )
NETWORK_PROC( void, SackNetwork_SetSocketSecure )( PCLIENT lpClient );
NETWORK_PROC( void, SackNetwork_AllowSecurityDowngrade )( PCLIENT lpClient );
/* Transmission Control Protocol connection methods. This
   controls opening sockets that are based on TCP.        */
_TCP_NAMESPACE
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerAddrExx )( SOCKADDR *, cppNotifyCallback NotifyCallback, uintptr_t psvConnect DBG_PASS );
#define CPPOpenTCPListenerAddrEx(a,b,c)  CPPOpenTCPListenerAddrExx(a,b,c DBG_SRC )
#endif
/* Opens a TCP socket which listens for connections. Other TCP
   sockets may be connected to this one once it has been
   created.
   Parameters
   Address :         address to serve at. See
                     CreateSockAddress().
   Port :            specified the port to listen at. This family
                     that takes just a port FAILS if there are
                     multiple network interfaces and or virtual
                     private networks.
   NotifyCallback :  user callback which will be invoked when a
                     new connection to the TCP server has been
                     made.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, OpenTCPListenerAddrExx )( SOCKADDR *, cNotifyCallback NotifyCallback DBG_PASS );
#define OpenTCPListenerAddrEx(sa,ca) OpenTCPListenerAddrExx( sa, ca DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
#define OpenTCPListenerAddr( pAddr ) OpenTCPListenerAddrEx( paddr, NULL );
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
NETWORK_PROC( PCLIENT, CPPOpenTCPListenerExx )( uint16_t wPort, cppNotifyCallback NotifyCallback, uintptr_t psvConnect DBG_PASS );
#define CPPOpenTCPListenerEx(a,b,c) CPPOpenTCPListenerExx(a,b,c DBG_SRC )
#endif
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
NETWORK_PROC( PCLIENT, OpenTCPListenerExx )( uint16_t wPort, cNotifyCallback NotifyCallback DBG_PASS );
#define OpenTCPListenerEx(a,b) OpenTCPListenerExx(a,b DBG_SRC )
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPListener( wPort )    OpenTCPListenerEx( wPort, NULL )
/* <combine sack::network::tcp::OpenTCPListener>
   \ \                                           */
#define OpenTCPServer OpenTCPListener
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPServerEx OpenTCPListenerEx
/* <combine sack::network::tcp::OpenTCPListenerAddrEx@SOCKADDR *@cNotifyCallback>
   \ \                                                                            */
#define OpenTCPServerAddr OpenTCPListenerAddr
/* <combine sack::network::tcp::OpenTCPListenerEx@uint16_t@cNotifyCallback>
   \ \                                                                 */
#define OpenTCPServerAddrEx OpenTCPListenerAddrEx
#define OPEN_TCP_FLAG_DELAY_CONNECT 1
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrExxx )(SOCKADDR *lpAddr,
																  cppReadComplete  pReadComplete, uintptr_t,
																  cppCloseCallback CloseCallback, uintptr_t,
																  cppWriteComplete WriteComplete, uintptr_t,
																  cppConnectCallback pConnectComplete,  uintptr_t, int DBG_PASS );
#define CPPOpenTCPClientAddrExx(a,b,c,d,e,f,g,h,i,j) CPPOpenTCPClientAddrExxx(a,b,c,d,e,f,g,h,i,j DBG_SRC )
#endif
NETWORK_PROC( PCLIENT, OpenTCPClientAddrFromAddrEx )( SOCKADDR *lpAddr, SOCKADDR *pFromAddr
                                                     , cReadComplete     pReadComplete
                                                     , cCloseCallback    CloseCallback
                                                     , cWriteComplete    WriteComplete
                                                     , cConnectCallback  pConnectComplete
                                                     , int flags
                                                     DBG_PASS
                                                     );
#define OpenTCPClientAddrFromAddr( a,f,r,cl,wr,cc ) OpenTCPClientAddrFromAddrEx( a,f,r,cl,wr,cc, 0 DBG_SRC )
NETWORK_PROC( PCLIENT, OpenTCPClientAddrFromEx )( SOCKADDR *lpAddr, int port
                                                , cReadComplete     pReadComplete
                                                , cCloseCallback    CloseCallback
                                                , cWriteComplete    WriteComplete
                                                , cConnectCallback  pConnectComplete
                                                , int flags
                                                DBG_PASS
                                                );
#define OpenTCPClientAddrFrom( a,f,r,cl,wr,cc ) OpenTCPClientAddrFromEx( a,f,r,cl,wr,cc,0 DBG_SRC )
/* Opens a socket which connects to an already existing,
   listening, socket.
   Parameters
   lpAddr :            _nt_
   lpName :            lpName and wPort are passed to
                       CreateSockAddress, and that address is
                       passed as a lpAddr.
   wPort :             lpName and wPort are passed to
                       CreateSockAddress, and that address is
                       passed as a lpAddr.
   pReadComplete :     user callback which is invoked when a
                       buffer now contains data.
   CloseCallback :     user callback when this socket is closed.
   WriteComplete :     user callback which is invoked when a
                       write operation completes.
   pConnectComplete :  user callback which is called when this
                       client connects. The callback gets this
                       network connection as the first parameter.
   Remarks
   WriteComplete is often unused, unless you are using bMsg
   option on do
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, OpenTCPClientAddrExxx )(SOCKADDR *lpAddr,
                                               cReadComplete  pReadComplete,
                                               cCloseCallback CloseCallback,
                                               cWriteComplete WriteComplete,
                                               cConnectCallback pConnectComplete,
                                               int flags
                                               DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientAddrExx(a,r,clo,w,con) OpenTCPClientAddrExxx( a,r,clo,w,con,0 DBG_SRC )
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrEx )(SOCKADDR *
                                               , cppReadComplete, uintptr_t
                                               , cppCloseCallback, uintptr_t
                                               , cppWriteComplete, uintptr_t
                                               , int flags
                                               );
#endif
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, OpenTCPClientAddrExEx )(SOCKADDR *, cReadComplete,
                         cCloseCallback, cWriteComplete DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientAddrEx(a,b,c,d) OpenTCPClientAddrExEx(a,b,c,d DBG_SRC )
#ifdef __cplusplus
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
NETWORK_PROC( PCLIENT, CPPOpenTCPClientExEx )(CTEXTSTR lpName,uint16_t wPort
                         , cppReadComplete  pReadComplete, uintptr_t
                         , cppCloseCallback CloseCallback, uintptr_t
                         , cppWriteComplete WriteComplete, uintptr_t
															, cppConnectCallback pConnectComplete, uintptr_t, int DBG_PASS );
#define CPPOpenTCPClientExx(name,port,read,rd,close,cd,write,wd,connect,cod,flg) CPPOpenTCPClientExEx(name,port,read,rd,close,cd,write,wd,connect,cod,flg DBG_SRC)
#endif
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
NETWORK_PROC( PCLIENT, OpenTCPClientExxx )(CTEXTSTR lpName,uint16_t wPort
                                           , cReadComplete  pReadComplete
                                           , cCloseCallback CloseCallback
                                           , cWriteComplete WriteComplete
                                           , cConnectCallback pConnectComplete
                                           , int flags
                                           DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientAddrExx@SOCKADDR *@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                        */
#define OpenTCPClientExx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, pConnectComplete ) OpenTCPClientExxx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, pConnectComplete, 0 DBG_SRC )
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
#define OpenTCPClient( name, port, read ) OpenTCPClientExxx(name,port,read,NULL,NULL,NULL,0 DBG_SRC )
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
NETWORK_PROC( PCLIENT, OpenTCPClientExEx )( CTEXTSTR, uint16_t, cReadComplete,
													  cCloseCallback, cWriteComplete DBG_PASS );
/* <combine sack::network::tcp::OpenTCPClientExx@CTEXTSTR@uint16_t@cReadComplete@cCloseCallback@cWriteComplete@cConnectCallback>
   \ \                                                                                                                      */
#define OpenTCPClientEx( addr,port,read,close,write ) OpenTCPClientExEx( addr,port,read,close,write DBG_SRC )
/* Do the connect to
*/
int NetworkConnectTCPEx( PCLIENT pc DBG_PASS );
#define NetworkConnectTCP( pc ) NetworkConnectTCPEx( pc DBG_SRC )
/* Drain is an operation on a TCP socket to just drop the next X
   bytes. They are ignored and not stored into any user buffer.
   Drain reads take precedence over any other queued reads.
   Parameters
   pClient :  network connection to drain data from.
   nLength :  how much data to skip.
   bExact :   if TRUE, will consume all of nLength bytes. if
              FALSE, if there are less than nLength bytes
              available right now, the drain will end when no
              further data is available now.                     */
NETWORK_PROC( LOGICAL, TCPDrainEx )( PCLIENT pClient, size_t nLength, int bExact );
/* <combine sack::network::tcp::TCPDrainEx@PCLIENT@int@int>
   \ \                                                      */
#define TCPDrain(c,l) TCPDrainEx( (c), (l), TRUE )
/* TCP sockets have what is called a NAGLE algorithm that helps
   them gather small packets into larger packets. This implies a
   latency on sent communications, but can provide a boost to
   overall speed.
   Parameters
   pClient :  network client to control the nagle algorithm.
   bEnable :  (TRUE)disable NAGLE or (FALSE)enable NAGLE
              (TRUE)nodelay (FALSE)packet gather delay           */
NETWORK_PROC( void, SetTCPNoDelay )( PCLIENT pClient, int bEnable );
/* TCP Connections have a keep-alive option, that data will be
   automatically sent to make sure the connection is still
   alive.
   Parameters
   pClient :  network connection enable or disable the keep alive
              on.
   bEnable :  TRUE to enable keep\-alive else disable keep\-alive. */
NETWORK_PROC( void, SetClientKeepAlive)( PCLIENT pClient, int bEnable );
/* \    Parameters
   lpClient :   network client to read from
   lpBuffer :   buffer to read into
   nBytes :     size of the buffer to read or maximum amount of
                the read desired.
   bIsStream :  if TRUE, any opportunity to return a packet is
                used to pass data to the user's read callback. If
                FALSE, will read to the complete size nBytes
                specified.
   bWait :      if TRUE, will block in the read until there is
                data, or the buffer is filled completely
                depending on the value of bIsStream. If FALSE,
                \returns immediately, the read completion will be
					 notified later by callback.
	user_timeout : user specified timeout to be used if bWait is specified.
                uses internal configurable timeout if 0.
   Returns
   size of the packet read if bWait is TRUE,
   else TRUE for sent, FALSE if the packet could not be sent.
   This buffer needs to continue existing until the socket is
   closed, or the read callback returns.
   Example
   Used in a normal read callback...
   <code lang="c++">
   void CPROC ReadComplete( PCLIENT pc, POINTER buffer, int size )
   {
       if( buffer == NULL )
           buffer = malloc( 4096 );
       else
       {
          // size will be non 0, process buffer
       }
       ReadTCP( pc, buffer, 4096 );
   }
   </code>                                                         */
NETWORK_PROC( size_t, doReadExx2)(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream, LOGICAL bWait, int user_timeout DBG_PASS );
#define doReadExx(p,b,n,s,w) DoReadExx2( p,b,n,s,w,0 )
/* \    Parameters
   lpClient :   network client to read from
   lpBuffer :   buffer to read into
   nBytes :     size of the buffer to read or maximum amount of
                the read desired.
   bIsStream :  if TRUE, any opportunity to return a packet is
                used to pass data to the user's read callback. If
                FALSE, will read to the complete size nBytes
                specified.
   bWait :      if TRUE, will block in the read until there is
                data, or the buffer is filled completely
                depending on the value of bIsStream. If FALSE,
                \returns immediately, the read completion will be
                notified later by callback.
   Returns
   size of the packet read if bWait is TRUE,
   else TRUE for sent, FALSE if the packet could not be sent.
   This buffer needs to continue existing until the socket is
   closed, or the read callback returns.
   Example
   Used in a normal read callback...
   <code lang="c++">
   void CPROC ReadComplete( PCLIENT pc, POINTER buffer, int size )
   {
       if( buffer == NULL )
           buffer = malloc( 4096 );
       else
       {
          // size will be non 0, process buffer
       }
       ReadTCP( pc, buffer, 4096 );
   }
   </code>                                                         */
//NETWORK_PROC( size_t, doReadExx )(PCLIENT lpClient, POINTER lpBuffer, size_t nBytes
//										, LOGICAL bIsStream, LOGICAL bWait );
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \    Remarks
   if bWait is not specifed, it is passed as FALSE.                            */
//NETWORK_PROC( size_t, doReadEx )(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream DBG_PASS );
#define doReadEx( p,b,n,s )  doReadExx2( p,b,n,s,FALSE, 0 DBG_SRC)
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadStream(pc,pBuf,nSize) doReadExx2( pc, pBuf, nSize, TRUE, FALSE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define doRead(pc,pBuf,nSize)     doReadExx2(pc, pBuf, nSize, FALSE, FALSE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadTCP ReadStream
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define ReadTCPMsg doRead
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define WaitReadTCP(pc,buf,nSize)    doReadExx2(pc,buf, nSize, TRUE, TRUE, 0 DBG_SRC )
/* <combine sack::network::tcp::doReadExx@PCLIENT@POINTER@int@LOGICAL@LOGICAL>
   \ \                                                                         */
#define WaitReadTCPMsg(pc,buf,nSize) doReadExx2(pc,buf, nSize, FALSE, TRUE, 0  DBG_SRC)
/* \#The buffer will be sent in the order of the writes to the
   socket, and released when empty. If the socket is immediatly
   able to write, the buffer will be sent, and any remai
   Parameters
   lpClient :     network connection to write to
   pInBuffer :    buffer to write
   nInLen :       Length of the buffer to send
   bLongBuffer :  if TRUE, then the buffer written is maintained
                  exactly by the network layer. A WriteComplete
                  callback will be invoked when the buffer has
                  been sent so the application might delete the
                  buffer.
   failpending :  Uhmm... maybe if it goes to pending, fail?
   Remarks
   If bLongBuffer is not set, then if the write cannot
   immediately complete, then a new buffer is allocated
   internally, and unsent data is buffered by the network
   collection. This allows the user to not worry about slowdowns
   due to blocking writes. Often writes complete immediately,
   and are not buffered other than in the user's own buffer
   passed to this write.                                         */
NETWORK_PROC( LOGICAL, doTCPWriteExx )( PCLIENT lpClient
						, CPOINTER pInBuffer
						, size_t nInLen, int bLongBuffer
                                   , int failpending
                                   DBG_PASS
                                  );
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define doTCPWriteEx( c,b,l,f1,f2) doTCPWriteExx( (c),(b),(l),(f1),(f2) DBG_SRC )
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCPEx( c,b,l,p) doTCPWriteExx( c,b,l,FALSE,p DBG_SRC)
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCP(c,b,l) doTCPWriteExx(c,b,l, FALSE, FALSE DBG_SRC)
/* <combine sack::network::tcp::doTCPWriteExx@PCLIENT@CPOINTER@int@int@int failpending>
   \ \                                                                                  */
#define SendTCPLong(c,b,l) doTCPWriteExx(c,b,l, TRUE, FALSE DBG_SRC)
_TCP_NAMESPACE_END
NETWORK_PROC( void, SetNetworkLong )(PCLIENT lpClient,int nLong,uintptr_t dwValue);
NETWORK_PROC( void, SetNetworkInt )(PCLIENT lpClient,int nLong, int value);
/* Obsolete. See SetNetworkLong. */
NETWORK_PROC( void, SetNetworkWord )(PCLIENT lpClient,int nLong,uint16_t wValue);
NETWORK_PROC( uintptr_t, GetNetworkLong )(PCLIENT lpClient,int nLong);
NETWORK_PROC( int, GetNetworkInt )(PCLIENT lpClient,int nLong);
NETWORK_PROC( uint16_t, GetNetworkWord )(PCLIENT lpClient,int nLong);
/* Symbols which may be passed to GetNetworkLong to get internal
   parts of the client.                                          */
enum GetNetworkLongAccessInternal{
 GNL_IP      = (-1),
 /* Gets the IP of the remote side of the connection, if
    applicable. UDP Sockets don't have a bound destination. */
 GNL_PORT    = (-4),
 /* Gets the port at the remote side of the connection that is
    being sent to.                                             */
 GNL_MYIP    = (-3),
 /* Gets the 4 byte IPv4 address that is what I am using on my
    side. After a socket has sent, it will have a set source IP
    under windows.                                              */
 GNL_MYPORT  = (-2),
 /* Gets the 16 bit port of the TCP or UDP connection that you
    are sending from locally.                                  */
 GNL_MAC_LOW = (-5),
 GNL_MAC_HIGH= (-6),
 GNL_REMOTE_ADDRESS = (-7),
 GNL_LOCAL_ADDRESS = (-8),
};
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( int, GetMacAddress)(PCLIENT pc, uint8_t* buf, size_t *buflen );
//NETWORK_PROC( int, GetMacAddress)(PCLIENT pc );
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( PLIST, GetMacAddresses)( void );
NETWORK_PROC( void, RemoveClientExx )(PCLIENT lpClient, LOGICAL bBlockNofity, LOGICAL bLinger DBG_PASS );
/* <combine sack::network::RemoveClientExx@PCLIENT@LOGICAL@LOGICAL bLinger>
   \ \                                                                      */
#define RemoveClientEx(c,b,l) RemoveClientExx(c,b,l DBG_SRC)
/* <combine sack::network::RemoveClientExx@PCLIENT@LOGICAL@LOGICAL bLinger>
   \ \                                                                      */
#define RemoveClient(c) RemoveClientEx(c, FALSE, FALSE )
/* Begin an SSL Connection.  This ends up replacing ReadComplete callback with an inbetween layer*/
NETWORK_PROC( LOGICAL, ssl_BeginClientSession )( PCLIENT pc, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen, CPOINTER rootCert, size_t rootCertLen );
NETWORK_PROC( LOGICAL, ssl_BeginServer )( PCLIENT pc, CPOINTER cert, size_t certlen, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen);
NETWORK_PROC( LOGICAL, ssl_GetPrivateKey )(PCLIENT pc, POINTER *keydata, size_t *keysize);
NETWORK_PROC( LOGICAL, ssl_IsClientSecure )(PCLIENT pc);
NETWORK_PROC( void, ssl_SetIgnoreVerification )(PCLIENT pc);
/* use this to send on SSL Connection instead of SendTCP. */
NETWORK_PROC( LOGICAL, ssl_Send )( PCLIENT pc, CPOINTER buffer, size_t length );
/* User Datagram Packet connection methods. This controls
   opening sockets that are based on UDP.                 */
_UDP_NAMESPACE
/* Open a UDP socket. Since the address to send to is implied on
   each message that is sent, all that is required is to setup
   where the UDP socket is listening.
   Parameters
   pAddr :          Pointer to a string address to listen at. Can
                    be NULL to listen on any interface, (also
                    specified as "0.0.0.0"), see
                    CreateSockAddress notes.
   wPort :          16 bit value for the port to listen at.
   pReadComplete :  user callback which is invoked when a read
                    completes on a UDP socket.
   Close :          close callback which is invoked when the new
                    network connection is closed.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
	with a NULL pointer and 0 size, before the connect complete.   */
NETWORK_PROC( PCLIENT, CPPServeUDPAddrEx )( SOCKADDR *pAddr
                  , cReadCompleteEx pReadComplete
                  , uintptr_t psvRead
                  , cCloseCallback Close
													 , uintptr_t psvClose
													 , int bCPP DBG_PASS );
NETWORK_PROC( PCLIENT, ServeUDPEx )( CTEXTSTR pAddr, uint16_t wPort,
                  cReadCompleteEx pReadComplete,
                  cCloseCallback Close DBG_PASS );
#define ServeUDP( addr,port,read,close) ServeUDPEx( addr, port, read, close DBG_SRC )
//NETWORK_PROC( PCLIENT, ServeUDP )( CTEXTSTR pAddr, uint16_t wPort,
//                  cReadCompleteEx pReadComplete,
//                  cCloseCallback Close);
//NETWORK_PROC( PCLIENT, ServeUDP )( CTEXTSTR pAddr, uint16_t wPort,
//                  cReadCompleteEx pReadComplete,
//                  cCloseCallback Close);
/* Creates a client to listen for messages or to send UDP
   messages.
   Parameters
   pAddr :          address to listen for UDP messages on.
   pReadComplete :  user callback to received read events.
   Close :          user callback to be invoked when the network
                    connection is closed. (network interface
                    disabled?)
   Returns
   NULL if no sockets are available, or the bind fails. (consult
   log?)
   \returns a network connection which is listening on the
   specified address. The read complete will be called. if it is
	specified, before this function returns.                      */
NETWORK_PROC( PCLIENT, ServeUDPAddrEx )( SOCKADDR *pAddr,
                     cReadCompleteEx pReadComplete,
													 cCloseCallback Close DBG_PASS );
#define ServeUDPAddr(addr,read,close) ServeUDPAddrEx( addr,read,close DBG_SRC )
/* \    Parameters
   address :         Address to listen at (interface
                     specification). Can be NULL to specify ANY
                     address, See notes on CreateSockAddress.
   port :            16 bit port to listen at
   dest_address :    Address to connect to. Can be NULL to
                     specify ANY address, See notes on
                     CreateSockAddress.
   dest_port :       16 bit port to send to. Ignored if
                     dest_address is NULL.
   read_complete :   User event handler which is invoked when
                     data is read from the socket.
   close_callback :  user event handler which is invoked when
                     this socket is closed.
   Returns
   NULL if no clients available, or if address bind on listen
   side fails.
   otherwise is a valid network connection to send and receive
   UDP data on.
   The read_complete callback, if specified, will be called,
   with a NULL pointer and 0 size, before the connect complete. */
NETWORK_PROC( PCLIENT, ConnectUDPEx )( CTEXTSTR , uint16_t ,
                    CTEXTSTR, uint16_t,
                    cReadCompleteEx,
												  cCloseCallback DBG_PASS );
#define ConnectUDP(a,b,c,d,e,f) ConnectUDPEx(a,b,c,d,e,f DBG_SRC )
/* \    Parameters
   sa :             address to listen for UDP messages at.
   saTo :           address to send UDP messages to, if the sa
                    parameter of send is NULL.
   pReadComplete :  user callback which will be invoked when
                    reads complete on the network connection.
   Close :          user callback which will be invoked when the
                    listening socket closes.
   Returns
   NULL if no sockets are available, or the bind fails. (consult
   log?)
   \returns a network connection which is listening on the
   specified address. The read complete will be called. if it is
   specified, before this function returns.                      */
NETWORK_PROC( PCLIENT, ConnectUDPAddrEx )( SOCKADDR *sa,
                        SOCKADDR *saTo,
                    cReadCompleteEx pReadComplete,
													 cCloseCallback Close DBG_PASS );
#define ConnectUDPAddr(a,b,c,d)  ConnectUDPAddrEx(a,b,c,d DBG_SRC )
/* Specify a different default address to send UDP messages to.
   Parameters
   pc :       network connection to change the default target
              address of.
   pToAddr :  text address to connect to. See notes in
              CreateSockAddress.
   wPort :    16 bit port address to connect to.
   Returns
   TRUE if it was a valid address specification.
   FALSE if it could not set the address.                       */
NETWORK_PROC( LOGICAL, ReconnectUDP )( PCLIENT pc, CTEXTSTR pToAddr, uint16_t wPort );
/* Sets the target default address of a UDP connection.
   Parameters
   pc :  network connection to set the target address of.
   sa :  See CreateSockAddress(), this is a network structure that
         is a struct sockaddr{} something.                         */
NETWORK_PROC( LOGICAL, GuaranteeAddr )( PCLIENT pc, SOCKADDR *sa );
/* A UDP message may be sent to a broadcast address or a subnet
   broadcast address, in either case, this must be called to
   enable broadcast communications, else the address must be a
   direct connection.
   Parameters
   pc :       network connection to enable broadcast on.
   bEnable :  TRUE to enable broadcast ability on this socket. FALSE
              to disable broadcast ability.                          */
NETWORK_PROC( void, UDPEnableBroadcast )( PCLIENT pc, int bEnable );
/* Sends to a UDP Network connection.
   Parameters
   pc :     pointer to a network connection to send on.
   pBuf :   buffer to send
   nSize :  size of the buffer to send
   sa :     pointer to a SOCKADDR which this message is destined
            to. Can be NULL, if GuaranteeAddr, or ConnectUDP is
            used.
   Returns
   The number of bytes in the buffer sent? Probably a TRUE if
   success else failure?                                         */
NETWORK_PROC( LOGICAL, SendUDPEx )( PCLIENT pc, CPOINTER pBuf, size_t nSize, SOCKADDR *sa );
/* <combine sack::network::udp::SendUDPEx@PCLIENT@CPOINTER@int@SOCKADDR *>
   \ \                                                                     */
#define SendUDP(pc,pbuf,size) SendUDPEx( pc, pbuf, size, NULL )
/* Queue a read to a UDP socket. A read cannot complete if it
   does not have a buffer to read into. A UDP socket will stall
   if the read callback returns without queuing a read.
   Parameters
   pc :        network connection to read from.
   lpBuffer :  buffer which the next data available on the network
               connection will be read into.
   nBytes :    size of the buffer.                                 */
NETWORK_PROC( int, doUDPRead )( PCLIENT pc, POINTER lpBuffer, int nBytes );
/* <combine sack::network::udp::doUDPRead@PCLIENT@POINTER@int>
   \ \                                                         */
#define ReadUDP doUDPRead
/* Logs to the log file the content of a socket address.
   Parameters
   name :  text leader to print before the address
   sa :    the socket address to dump.                   */
NETWORK_PROC( void, DumpAddrEx )( CTEXTSTR name, SOCKADDR *sa DBG_PASS );
/* <combine sack::network::udp::DumpAddrEx@CTEXTSTR@SOCKADDR *sa>
   \ \                                                            */
#define DumpAddr(n,sa) DumpAddrEx(n,sa DBG_SRC )
NETWORK_PROC( int, SetSocketReuseAddress )( PCLIENT pClient, int32_t enable );
NETWORK_PROC( int, SetSocketReusePort )( PCLIENT pClient, int32_t enable );
_UDP_NAMESPACE_END
USE_UDP_NAMESPACE
struct interfaceAddress {
	SOCKADDR *sa;
	SOCKADDR *saBroadcast;
	SOCKADDR *saMask;
};
NETWORK_PROC( SOCKADDR*, GetBroadcastAddressForInterface )(SOCKADDR *addr);
NETWORK_PROC( SOCKADDR*, GetInterfaceAddressForBroadcast )(SOCKADDR *addr);
NETWORK_PROC( struct interfaceAddress*, GetInterfaceForAddress )( SOCKADDR *addr );
NETWORK_PROC( LOGICAL, IsBroadcastAddressForInterface )( struct interfaceAddress *address, SOCKADDR *addr );
NETWORK_PROC( void, LoadNetworkAddresses )(void);
//----- PING.C ------
NETWORK_PROC( LOGICAL, DoPing )( CTEXTSTR pstrHost,
             int maxTTL,
             uint32_t dwTime,
             int nCount,
             PVARTEXT pResult,
             LOGICAL bRDNS,
             void (*ResultCallback)( uint32_t dwIP, CTEXTSTR name, int min, int max, int avg, int drop, int hops ) );
NETWORK_PROC( LOGICAL, DoPingEx )( CTEXTSTR pstrHost,
             int maxTTL,
             uint32_t dwTime,
             int nCount,
             PVARTEXT pResult,
             LOGICAL bRDNS,
											 void (*ResultCallback)( uintptr_t psv, uint32_t dwIP, CTEXTSTR name, int min, int max, int avg, int drop, int hops )
											, uintptr_t psv );
//----- WHOIS.C -----
NETWORK_PROC( LOGICAL, DoWhois )( CTEXTSTR pHost, CTEXTSTR pServer, PVARTEXT pvtResult );
#ifdef __cplusplus
typedef class network *PNETWORK;
/* <combine sack::network::network>
   \ \                              */
typedef class network
{
	PCLIENT pc;
	int TCP;
	static void CPROC WrapTCPReadComplete( uintptr_t psv, POINTER buffer, size_t nSize );
	static void CPROC WrapUDPReadComplete( uintptr_t psv, POINTER buffer, size_t nSize, SOCKADDR *sa );
	static void CPROC WrapWriteComplete( uintptr_t psv );
	static void CPROC WrapClientConnectComplete( uintptr_t psv, int nError );
	static void CPROC WrapServerConnectComplete( uintptr_t psv, PCLIENT pcNew );
	static void CPROC WrapCloseCallback( uintptr_t psv );
   // notify == server (listen)
	static void CPROC SetNotify( PCLIENT pc, cppNotifyCallback, uintptr_t psv );
   // connect == client (connect)
   static void CPROC SetConnect( PCLIENT pc, cppConnectCallback, uintptr_t psv );
   static void CPROC SetRead( PCLIENT pc, cppReadComplete, uintptr_t psv );
   static void CPROC SetWrite( PCLIENT pc, cppWriteComplete, uintptr_t psv );
   static void CPROC SetClose( PCLIENT pc, cppCloseCallback, uintptr_t psv );
public:
	network() { NetworkStart(); pc = NULL; TCP = TRUE; };
	network( PCLIENT pc ) { NetworkStart(); this->pc = pc; TCP = TRUE; };
	network( network &cp ) { cp.pc = pc; cp.TCP = TCP; };
	~network() { if( pc ) RemoveClientEx( pc, TRUE, FALSE ); pc = NULL; };
	inline void MakeUDP( void ) { TCP = FALSE; }
	virtual void ReadComplete( POINTER buffer, size_t nSize ) {}
	virtual void ReadComplete( POINTER buffer, size_t nSize, SOCKADDR *sa ) {}
	virtual void WriteComplete( void ) {}
	virtual void ConnectComplete( int nError ) {}
	// received on the server listen object...
	virtual void ConnectComplete( class network &pNewClient ) {}
	virtual void CloseCallback( void ) {}
	inline int Connect( SOCKADDR *sa )
	{
		if( !pc )
		pc = CPPOpenTCPClientAddrExx( sa
									, WrapTCPReadComplete
									, (uintptr_t)this
									, WrapCloseCallback
									, (uintptr_t)this
									, WrapWriteComplete
									, (uintptr_t)this
									, WrapClientConnectComplete
									, (uintptr_t)this
									, 0
									);
		return (int)(pc!=NULL);
	};
	inline int Connect( CTEXTSTR name, uint16_t port )
	{
		if( !pc )
		pc = CPPOpenTCPClientExx( name, port
									, WrapTCPReadComplete
									, (uintptr_t)this
									, WrapCloseCallback
									, (uintptr_t)this
									, WrapWriteComplete
									, (uintptr_t)this
									, WrapClientConnectComplete
									, (uintptr_t)this
									, 0
									);
		return (int)(pc!=NULL);
	};
	inline int Listen( SOCKADDR *sa )
	{
		if( !pc )
		{
			if( ( pc = CPPOpenTCPListenerAddrEx( sa
				                        , (cppNotifyCallback)WrapServerConnectComplete
												, (uintptr_t)this
														)  ) != NULL )
			{
				SetRead( pc, (cppReadComplete)WrapTCPReadComplete, (uintptr_t)this );
				SetWrite( pc, (cppWriteComplete)WrapWriteComplete, (uintptr_t)this );
				SetClose( pc, network::WrapCloseCallback, (uintptr_t)this );
			}
		}
		return (int)(pc!=NULL);
	};
	inline int Listen( uint16_t port )
	{
		if( !pc )
		{
			if( ( pc = CPPOpenTCPListenerEx( port
			                      , (cppNotifyCallback)WrapServerConnectComplete
											 , (uintptr_t)this ) ) )
			{
				SetRead( pc, (cppReadComplete)WrapTCPReadComplete, (uintptr_t)this );
				SetWrite( pc, (cppWriteComplete)WrapWriteComplete, (uintptr_t)this );
				SetClose( pc, network::WrapCloseCallback, (uintptr_t)this );
			}
		}
		return (int)(pc!=NULL);
	};
	inline void Write( POINTER p, int size )
	{
		if( pc ) SendTCP( pc, p, size );
	};
	inline void WriteLong( POINTER p, int size )
	{
		if( pc ) SendTCPLong( pc, p, size );
	};
	inline void Read( POINTER p, int size )
	{
		if( pc ) ReadTCP( pc, p, size );
	};
	inline void ReadBlock( POINTER p, int size )
	{
		if( pc ) ReadTCPMsg( pc, p, size );
	};
	inline void SetLong( int l, uint32_t value )
	{
      if( pc ) SetNetworkLong( pc, l, value );
	}
	inline void SetNoDelay( LOGICAL bTrue )
	{
      if( pc ) SetTCPNoDelay( pc, bTrue );
	}
	inline void SetClientKeepAlive( LOGICAL bTrue )
	{
		if( pc ) sack::network::SetClientKeepAlive( pc, bTrue );
	}
	inline uintptr_t GetLong( int l )
	{
		if( pc )
			return GetNetworkLong( pc, l );
	      return 0;
	}
}NETWORK;
#endif
SACK_NETWORK_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::network;
using namespace sack::network::tcp;
using namespace sack::network::udp;
#endif
#endif
//------------------------------------------------------------------
// $Log: network.h,v $
// Revision 1.36  2005/05/23 19:29:24  jim
// Added definition to support WaitReadTCP...
//
// Revision 1.35  2005/03/15 20:22:32  chrisd
// Declare NotifyCallback with meaningful parameters
//
// Revision 1.34  2005/03/15 20:14:15  panther
// Define a routine to build a PF_UNIX socket for unix... this can be used with TCP_ routines to open a unix socket instead of an IP socket.
//
// Revision 1.33  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.32  2004/08/18 23:52:24  d3x0r
// Cleanups - also enhanced network init to expand if called with larger params.
//
// Revision 1.31  2004/07/28 16:47:18  jim
// added support for get address parts.
//
// Revision 1.31  2004/07/27 18:28:17  d3x0r
// Added definition for getaddressparts
//
// Revision 1.30  2004/01/26 23:47:20  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.29  2003/12/03 10:21:34  panther
// Tinkering with C++ networking
//
// Revision 1.28  2003/11/09 03:32:22  panther
// Added some address functions to set port and override default port
//
// Revision 1.27  2003/09/25 08:34:00  panther
// Restore callback defs to proper place
//
// Revision 1.26  2003/09/25 08:29:16  panther
// ...New test
//
// Revision 1.25  2003/09/25 00:22:35  panther
// Move cpp wrapper functions into network library
//
// Revision 1.24  2003/09/25 00:21:49  panther
// Move cpp wrapper functions into network library
//
// Revision 1.23  2003/09/24 15:10:54  panther
// Much mangling to extend C++ network interface...
//
// Revision 1.22  2003/09/24 02:26:02  panther
// Fix C++ methods, extend and correct.
//
// Revision 1.21  2003/07/29 09:27:14  panther
// Add Keep Alive option, enable use on proxy
//
// Revision 1.20  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.19  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.18  2003/03/25 08:38:11  panther
// Add logging
//
// Revision 1.17  2002/12/22 00:14:11  panther
// Cleanup function declarations and project defines.
//
// Revision 1.16  2002/11/24 21:37:40  panther
// Mods - network - fix server->accepted client method inheritance
// display - fix many things
// types - merge chagnes from verious places
// ping - make function result meaningful yes/no
// controls - fixes to handle lack of image structure
// display - fixes to handle moved image structure.
//
// Revision 1.16  2002/11/21 19:13:11  jim
// Added CreateAddress, CreateAddress_hton
//
// Revision 1.15  2002/07/25 12:59:02  panther
// Added logging, removed logging....
// Network: Added NetworkLock/NetworkUnlock
// Timers: Modified scheduling if the next timer delta was - how do you say -
// to fire again before now.
//
// Revision 1.14  2002/07/23 11:24:26  panther
// Added new function to TCP networking - option on write to disable
// queuing of pending data.
//
// Revision 1.13  2002/07/17 11:33:26  panther
// Added new function to tcp network - dotcpwriteex - allows option to NOT pend
// buffers.
//
// Revision 1.12  2002/07/15 08:34:07  panther
// Include function to set udp broadcast or not.
//
//
// $Log: network.h,v $
// Revision 1.36  2005/05/23 19:29:24  jim
// Added definition to support WaitReadTCP...
//
// Revision 1.35  2005/03/15 20:22:32  chrisd
// Declare NotifyCallback with meaningful parameters
//
// Revision 1.34  2005/03/15 20:14:15  panther
// Define a routine to build a PF_UNIX socket for unix... this can be used with TCP_ routines to open a unix socket instead of an IP socket.
//
// Revision 1.33  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.32  2004/08/18 23:52:24  d3x0r
// Cleanups - also enhanced network init to expand if called with larger params.
//
// Revision 1.31  2004/07/28 16:47:18  jim
// added support for get address parts.
//
// Revision 1.31  2004/07/27 18:28:17  d3x0r
// Added definition for getaddressparts
//
// Revision 1.30  2004/01/26 23:47:20  d3x0r
// Misc edits.  Fixed filemon.  Export net startup, added def to edit frame
//
// Revision 1.29  2003/12/03 10:21:34  panther
// Tinkering with C++ networking
//
// Revision 1.28  2003/11/09 03:32:22  panther
// Added some address functions to set port and override default port
//
// Revision 1.27  2003/09/25 08:34:00  panther
// Restore callback defs to proper place
//
// Revision 1.26  2003/09/25 08:29:16  panther
// ...New test
//
// Revision 1.25  2003/09/25 00:22:35  panther
// Move cpp wrapper functions into network library
//
// Revision 1.24  2003/09/25 00:21:49  panther
// Move cpp wrapper functions into network library
//
// Revision 1.23  2003/09/24 15:10:54  panther
// Much mangling to extend C++ network interface...
//
// Revision 1.22  2003/09/24 02:26:02  panther
// Fix C++ methods, extend and correct.
//
// Revision 1.21  2003/07/29 09:27:14  panther
// Add Keep Alive option, enable use on proxy
//
// Revision 1.20  2003/07/24 16:56:41  panther
// Updates to expliclity define C procedure model for callbacks and assembly modules - incomplete
//
// Revision 1.19  2003/06/04 11:38:01  panther
// Define PACKED
//
// Revision 1.18  2003/03/25 08:38:11  panther
// Add logging
//
/* and then we could be really evil
#define send(s,b,x,t,blah)
#define recv
#define socket
#define getsockopt ?
#define heh yeah these have exact equivalents ....
*/
/* Generalized HTTP Processing. All POST, GET, RESPONSE packets
   all fit within this structure.
                                                                */
#ifndef HTTP_PROCESSING_INCLUDED
/* Multiple inclusion protection symbol */
#define HTTP_PROCESSING_INCLUDED
#ifdef HTTP_SOURCE
#define HTTP_EXPORT EXPORT_METHOD
#else
/* Defines how external functions are referenced
   (dllimport/export/extern)                     */
#define HTTP_EXPORT IMPORT_METHOD
#endif
/* The API type of HTTP functions - default to CPROC. */
#define HTTPAPI CPROC
#ifdef __cplusplus
/* A symbol to define the sub-namespace of HTTP_NAMESPACE  */
#define _HTTP_NAMESPACE namespace http {
/* A macro to end just the HTTP sub namespace. */
#define _HTTP_NAMESPACE_END }
#else
#define _HTTP_NAMESPACE
#define _HTTP_NAMESPACE_END
#endif
/* HTTP full namespace  */
#define HTTP_NAMESPACE TEXT_NAMESPACE _HTTP_NAMESPACE
/* Macro to use to define where http utility namespace ends. */
#define HTTP_NAMESPACE_END _HTTP_NAMESPACE_END TEXT_NAMESPACE_END
SACK_CONTAINER_NAMESPACE
/* Text library functions. PTEXT is kept as a linked list of
   segments of text. Each text segment has a size and the data,
   and additional format flags. PTEXT may also be indirect
   segments (that is this segment points at another list of
   segments that are the actualy content for this place.
                                                                */
_TEXT_NAMESPACE
	/* Simple HTTP Packet processing state. Its only intelligence is
	   that there are fields of http header, and that one of those
	   fields might be content-length; so it can seperate individual
	   fields name-value pairs and the packet content.               */
	_HTTP_NAMESPACE
struct HttpField {
	PTEXT name;
	PTEXT value;
};
typedef struct HttpState *HTTPState;
enum ProcessHttpResult{
	HTTP_STATE_RESULT_NOTHING = 0,
	HTTP_STATE_RESULT_CONTENT = 200,
    HTTP_STATE_RESULT_CONTINUE = 100,
	HTTP_STATE_INTERNAL_SERVER_ERROR=500,
	HTTP_STATE_RESOURCE_NOT_FOUND=404,
   HTTP_STATE_BAD_REQUEST=400,
};
HTTP_EXPORT
 /* Creates an empty http state, the next operation should be
   AddHttpData.                                              */
HTTPState  HTTPAPI CreateHttpState( void );
HTTP_EXPORT
 /* Destroys a http state, releasing all resources associated
   with it.                                                  */
void HTTPAPI DestroyHttpState( HTTPState pHttpState );
HTTP_EXPORT
 /* Add another bit of data to the block. After adding data,
   ProcessHttp should be called to see if the data has completed
   a packet.
   Parameters
   pHttpState :  state to add data to
   buffer :      pointer to some data bytes
   size :        length of data bytes
   Returns: TRUE if content is added... if collecting chunked encoding may return FALSE.
   */
LOGICAL HTTPAPI AddHttpData( HTTPState pHttpState, POINTER buffer, size_t size );
/* \returns TRUE if completed until content-length if
   content-length is not specified, data is still collected, but
   the status never results TRUE.
	Parameters
	pc : Occasionally the http processor needs to send data on the
	     socket without application being aware it did.
   pHttpState :  Http State to process (after having added data to
                 it)
   Return Value List
   TRUE :   A completed HTTP packet has been gathered \- according
            to 'content\-length' meta tag.
   FALSE :  Still collecting full packet                           */
//HTTP_EXPORT int HTTPAPI ProcessHttp( HTTPState pHttpState );
HTTP_EXPORT int HTTPAPI ProcessHttp( PCLIENT pc, HTTPState pHttpState );
HTTP_EXPORT
 /* Gets the specific result code at the header of the packet -
   http 2.0 OK sort of thing.                                  */
PTEXT HTTPAPI GetHttpResponce( HTTPState pHttpState );
/* Get the method of the request in ht e http state.
*/
HTTP_EXPORT PTEXT HTTPAPI GetHttpMethod( struct HttpState *pHttpState );
/*Get the value of a HTTP header field, by name
   Parameters
	pHttpState: the state to get the header field from.
	name: name of the field to get (checked case insensitive)
*/
HTTP_EXPORT PTEXT HTTPAPI GetHTTPField( HTTPState pHttpState, CTEXTSTR name );
/* Gets the specific request code at the header of the packet -
   http 2.0 OK sort of thing.                                  */
HTTP_EXPORT PTEXT HTTPAPI GetHttpRequest( HTTPState pHttpState );
/* \Returns the body of the HTTP packet (the part of data
   specified by content-length or by termination of the
   connection(? think I didn't implement that right)      */
HTTP_EXPORT PTEXT HTTPAPI GetHttpContent( HTTPState pHttpState );
/* \Returns the resource path/name of the HTTP packet (the part of data
   specified by content-length or by termination of the
   connection(? think I didn't implement that right)      */
HTTP_EXPORT PTEXT HTTPAPI GetHttpResource( HTTPState pHttpState );
/* Returns a list of fields that were included in a request header.
   members of the list are of type struct HttpField.
   see also: ProcessHttpFields and ProcessCGIFields
*/
HTTP_EXPORT PLIST HTTPAPI GetHttpHeaderFields( HTTPState pHttpState );
HTTP_EXPORT int HTTPAPI GetHttpVersion( HTTPState pHttpState );
HTTP_EXPORT
 /* Enumerates the various http header fields by passing them
   each sequentially to the specified callback.
   Parameters
   pHttpState :  _nt_
   _nt_ :        _nt_
   psv :         _nt_                                        */
void HTTPAPI ProcessCGIFields( HTTPState pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv );
HTTP_EXPORT
 /* Enumerates the various http header fields by passing them
   each sequentially to the specified callback.
   Parameters
   pHttpState :  _nt_
   _nt_ :        _nt_
   psv :         _nt_                                        */
void HTTPAPI ProcessHttpFields( HTTPState pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv );
HTTP_EXPORT
 /* Resets a processing state, so it can start collecting the
   next state. After a ProcessHttp results with true, this
   should be called after processing the packet content.
   Parameters
   pHttpState :  state to reset for next read...             */
void HTTPAPI EndHttp( HTTPState pHttpState );
HTTP_EXPORT
/* reply message - 200/OK with this body, sent as Content-Type that was requested */
void HTTPAPI SendHttpMessage( HTTPState pHttpState, PCLIENT pc, PTEXT body );
HTTP_EXPORT
/* generate response message, specifies the numeric (200), the text (OK), the content type field value, and the body to send */
void HTTPAPI SendHttpResponse ( HTTPState pHttpState, PCLIENT pc, int numeric, CTEXTSTR text, CTEXTSTR content_type, PTEXT body );
/* Callback type used when creating an http server.
 If there is no registered handler match, then this is called.
 This should return FALSE if there was no content, allowing a 404 status result.
 Additional ways of dispatching need to be implemented (like handlers for paths, wildcards...)
 */
typedef LOGICAL (CPROC *ProcessHttpRequest)( uintptr_t psv
												 , HTTPState pHttpState );
HTTP_EXPORT
/* Intended to create a generic http service, which you can
   attach URL handlers to. Incomplete
   Works mostly?  OnGet has been known to get called....
   */
struct HttpServer *CreateHttpServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv );
HTTP_EXPORT
/* Intended to create a generic http service, which you can
   attach URL handlers to. Incomplete
   Works mostly?  OnGet has been known to get called....
   */
struct HttpServer *CreateHttpsServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI PostHttp( PTEXT site, PTEXT resource, PTEXT content );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI GetHttp( PTEXT site, PTEXT resource, LOGICAL secure );
/* results with just the content of the message; no access to other information avaialble */
HTTP_EXPORT PTEXT HTTPAPI GetHttps( PTEXT address, PTEXT url, const char *certChain );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState  HTTPAPI PostHttpQuery( PTEXT site, PTEXT resource, PTEXT content );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState  HTTPAPI GetHttpQuery( PTEXT site, PTEXT resource );
/* results with the http state of the message response; Allows getting other detailed information about the result */
HTTP_EXPORT HTTPState HTTPAPI GetHttpsQuery( PTEXT site, PTEXT resource, const char *certChain );
/* return the numeric response code of a http reply. */
HTTP_EXPORT int HTTPAPI GetHttpResponseCode( HTTPState pHttpState );
#define CreateHttpServer(interface_address,site,psv) CreateHttpServerEx( interface_address,NULL,site,NULL,psv )
#define CreateHttpServer2(interface_address,site,default_handler,psv) CreateHttpServerEx( interface_address,NULL,site,default_handler,psv )
// receives events for either GET if aspecific OnHttpRequest has not been defined for the specific resource
// Return TRUE if processed, otherwise will attempt to match other Get Handlers
#define OnHttpGet( site, resource )	 __DefineRegistryMethod(WIDE( "SACK/Http/Methods" ),OnHttpGet,site,resource,WIDE( "Get" ),LOGICAL,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
// receives events for either GET if aspecific OnHttpRequest has not been defined for the specific resource
// Return TRUE if processed, otherwise will attempt to match other Get Handlers
#define OnHttpPost( site, resource )	 __DefineRegistryMethod(WIDE( "SACK/Http/Methods" ),OnHttpPost,site,resource,WIDE( "Post" ),LOGICAL,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
// define a specific handler for a specific resource name on a host
#define OnHttpRequest( site, resource )	 __DefineRegistryMethod(WIDE( "SACK/Http/Methods" ),OnHttpRequest,WIDE( "something" ),site WIDE( "/" ) resource,WIDE( "Get" ),void,(uintptr_t,PCLIENT,struct HttpState *,PTEXT),__LINE__)
//--------------------------------------------------------------
//  URL.c  (url parsing utility)
struct url_cgi_data
{
	CTEXTSTR name;
	CTEXTSTR value;
};
struct url_data
{
	CTEXTSTR protocol;
	CTEXTSTR user;
	CTEXTSTR password;
	CTEXTSTR host;
	int default_port;
  // encoding RFC3986 http://tools.ietf.org/html/rfc3986  specifies port characters are in the set of digits.
	int port;
	//CTEXTSTR port_data;  // during collection, the password may be in the place of 'port'
	CTEXTSTR resource_path;
	CTEXTSTR resource_file;
	CTEXTSTR resource_extension;
	CTEXTSTR resource_anchor;
   // list of struct url_cgi_data *
	PLIST cgi_parameters;
};
HTTP_EXPORT struct url_data * HTTPAPI SACK_URLParse( const char *url );
HTTP_EXPORT char *HTTPAPI SACK_BuildURL( struct url_data *data );
HTTP_EXPORT void HTTPAPI SACK_ReleaseURL( struct url_data *data );
	_HTTP_NAMESPACE_END
TEXT_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::containers::text::http;
#endif
#endif
HTTP_NAMESPACE
enum ReadChunkState {
	READ_VALUE, READ_VALUE_CR, READ_VALUE_LF, READ_CR, READ_LF, READ_BYTES
};
struct HttpState {
	// add input into pvt_collector
	PVARTEXT pvt_collector;
  // an accumulator that moves data from collector into whatever we've got leftover
	PTEXT partial;
	PTEXT method;
 // the first line of the http responce... (or request)
	PTEXT response_status;
 // the path of the resource - mostly for when this is used to receive requests.
	PTEXT resource;
 // list of struct HttpField *, these other the other meta fields in the header.
	PLIST fields;
 // list of HttpField *, taken in from the URL or content (get or post)
	PLIST cgi_fields;
	size_t content_length;
 // content of the message, POST,PUT,PATCH and replies have this.
	PTEXT content;
	LOGICAL returned_status;
 // boolean flag - indicates that the header portion of the http request is finished.
	int final;
 //for handling requests, have to read somewhere
	POINTER buffer;
	int numeric_code;
	int response_version;
	TEXTSTR text_code;
 // when a request comes in to the server, it is kept in a new http state, this is set for Send Response
	PCLIENT request_socket;
	LOGICAL ssl;
 // this is filled with a request ready to go out; used for HTTPS
	PVARTEXT pvtOut;
	LOGICAL read_chunks;
	size_t read_chunk_byte;
	size_t read_chunk_length;
	size_t read_chunk_total_length;
	enum ReadChunkState read_chunk_state;
	uint32_t last_read_tick;
	PTHREAD waiter;
	PCLIENT *pc;
	struct httpStateFlags {
		BIT_FIELD keep_alive : 1;
		BIT_FIELD close : 1;
		BIT_FIELD upgrade : 1;
		BIT_FIELD h2c_upgrade : 1;
		BIT_FIELD ws_upgrade : 1;
 // prevent issuing network reads... ssl pushes data from internal buffers
		BIT_FIELD ssl : 1;
		BIT_FIELD success : 1;
	}flags;
	uint32_t lock;
};
struct HttpServer {
	PCLIENT server;
	PLIST clients;
	ProcessHttpRequest handle_request;
	uintptr_t psvRequest;
	CTEXTSTR site;
	PCLASSROOT methods;
};
static struct local_http_data
{
	struct http_data_flags {
		BIT_FIELD bLogReceived : 1;
	} flags;
	PLIST pendingConnects;
}local_http_data;
#define l local_http_data
struct pendingConnect {
	PCLIENT pc;
	struct HttpState *state;
};
PRELOAD( loadOption ) {
#ifndef __NO_OPTIONS__
	l.flags.bLogReceived = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/HTTP/Enable Logging Received Data" ), 0, TRUE );
#endif
}
static void lockHttp( struct HttpState *state ) {
	while( LockedExchange( &state->lock, 1 ) );
}
static void unlockHttp( struct HttpState *state ) {
	state->lock = 0;
}
void GatherHttpData( struct HttpState *pHttpState )
{
	if( pHttpState->content_length )
	{
		PTEXT pMergedLine;
		PTEXT pInput = VarTextGet( pHttpState->pvt_collector );
		PTEXT pNewLine = SegAppend( pHttpState->partial, pInput );
		//lprintf( "Gathering http data with content length..." );
		pMergedLine = SegConcat( NULL, pNewLine, 0, GetTextSize( pHttpState->partial ) + GetTextSize( pInput ) );
		LineRelease( pNewLine );
		pHttpState->partial = pMergedLine;
		if( GetTextSize( pHttpState->partial ) >= pHttpState->content_length )
		{
			//lprintf( "Partial is complete with %d", GetTextSize( pHttpState->partial ) );
			pHttpState->content = SegSplit( &pHttpState->partial, pHttpState->content_length );
			pHttpState->partial = NEXTLINE( pHttpState->partial );
			SegGrab( pHttpState->partial );
			pHttpState->flags.success = 1;
		}
		//else
		//	lprintf( "Partial is only %d", GetTextSize( pHttpState->partial ) );
	}
	else
	{
		PTEXT pMergedLine;
		PTEXT pInput = VarTextGet( pHttpState->pvt_collector );
		PTEXT pNewLine = SegAppend( pHttpState->partial, pInput );
		pMergedLine = SegConcat( NULL, pNewLine, 0, GetTextSize( pHttpState->partial ) + GetTextSize( pInput ) );
		LineRelease( pNewLine );
		pHttpState->partial = pMergedLine;
		//lprintf( "Setting content to partial... " );
		pHttpState->content = pHttpState->partial;
	}
}
static PTEXT  resolvePercents( PTEXT urlword ) {
	PTEXT  url = SegDuplicate( urlword );
	{
		char *_url = GetText(url);
		TEXTRUNE ch;
		int outchar = 0;
		char *newUrl = _url;
		int decode = 0;
		while( _url[0] ) {
			if( decode ) {
				ch *= 16;
				if( _url[0] >= '0' && _url[0] <= '9' )
					ch += _url[0] - '0';
				else if( _url[0] >= 'A' && _url[0] <= 'F' )
					ch += (_url[0] - 'A') + 10;
				else if( _url[0] >= 'a' && _url[0] <= 'f' )
					ch += (_url[0] - 'a') + 10;
				else {
					lprintf( "BAD DECODE CHARACTER: %c %d", _url[0], _url[0] );
					//LineRelease( url );
					return url;
				}
				decode--;
				if( !decode ) {
					newUrl[0] = (char)ch;
					newUrl++;
				}
			}
			else if( _url[0] == '%' ) {
				ch = 0;
				decode = 2;
			}
			else {
				newUrl[0] = _url[0];
				newUrl++;
			}
			_url++;
		}
		newUrl[0] = _url[0];
		SetTextSize( url, _url - GetText( url ) );
		return url;
	}
}
void ProcessURL_CGI( struct HttpState *pHttpState, PTEXT params )
{
	PTEXT start = TextParse( params, WIDE( "&=" ), NULL, 1, 1 DBG_SRC );
	PTEXT next = start;
	PTEXT tmp;
	//lprintf( "Input was %s", GetText( params ) );
	while( ( tmp = next ) )
	{
		PTEXT name = tmp;
		/*PTEXT equals = */
( next = NEXTLINE( tmp ) );
		PTEXT value = ( next = NEXTLINE( next ) );
		/*PTEXT ampersand = */
( next = NEXTLINE( next ) );
		struct HttpField *field = New( struct HttpField );
		field->name = name?resolvePercents( name ):NULL;
		field->value = value?resolvePercents( value ):NULL;
		//lprintf( "Added %s=%s", GetText( field->name ), GetText( field->value ) );
		AddLink( &pHttpState->cgi_fields, field );
		next = NEXTLINE( next );
	}
	LineRelease( start );
}
//int ProcessHttp( struct HttpState *pHttpState )
int ProcessHttp( PCLIENT pc, struct HttpState *pHttpState )
{
	lockHttp( pHttpState );
	if( pHttpState->final )
	{
		GatherHttpData( pHttpState );
		unlockHttp( pHttpState );
		if( pHttpState->flags.success && !pHttpState->returned_status ) {
			pHttpState->returned_status = 1;
			return pHttpState->numeric_code;
		}
		return HTTP_STATE_RESULT_NOTHING;
	}
	else
	{
//, pStart;
		PTEXT pCurrent;
		PTEXT pLine = NULL;
		TEXTCHAR *c, *line;
		size_t size, pos, len;
		size_t bLine;
		INDEX start = 0;
		PTEXT pMergedLine;
		PTEXT pInput = VarTextGet( pHttpState->pvt_collector );
		PTEXT pNewLine = SegAppend( pHttpState->partial, pInput );
		pMergedLine = SegConcat( NULL, pNewLine, 0, GetTextSize( pHttpState->partial ) + GetTextSize( pInput ) );
		LineRelease( pNewLine );
		pHttpState->partial = pMergedLine;
		pCurrent = pHttpState->partial;
		//pStart = pCurrent; // at lest is this block....
		//LogBinary( (const uint8_t*)GetText( pInput ), GetTextSize( pInput ) );
		len = 0;
		// we always start without having a line yet, because all input is already merged
		bLine = 0;
		{
			//lprintf( "%s", GetText( pCurrent ) );
			size = GetTextSize( pCurrent );
			c = GetText( pCurrent );
			if( bLine < 4 )
			{
				//start = 0; // new packet and still collecting header....
				for( pos = 0; ( pos < size ) && !pHttpState->final; pos++ )
				{
					if( (pos - start - bLine) < 0 )
						continue;
					if( c[pos] == '\r' )
						bLine++;
					else if( c[pos] == '\n' )
						bLine++;
 // non end of line character....
					else
					{
	FinalCheck:
 // had an end of line...
						if( bLine >= 2 )
						{
							// response status is the data from the fist bit of the packet (on receiving http 1.1/OK ...)
							if( pHttpState->response_status )
							{
								CTEXTSTR field_start;
								CTEXTSTR colon;
								CTEXTSTR field_end;
								CTEXTSTR val_start;
								PTEXT field_name;
								PTEXT value;
								pLine = SegCreate( pos - start - bLine );
								if( (pos-start) < bLine )
								{
									lprintf( WIDE("Failure.") );
								}
								MemCpy( line = GetText( pLine ), c + start, (pos - start - bLine)*sizeof(TEXTCHAR));
								line[pos-start-bLine] = 0;
								field_start = GetText( pLine );
								// this is a  request field.
								colon = StrChr( field_start, ':' );
								if( colon )
								{
									PTEXT trash;
									val_start = colon + 1;
									field_end = colon;
									while( ( field_end > field_start )&& field_end[-1] == ' ' )
										field_end--;
									while( ( val_start[0] && ( val_start[0] == ' ' ) ) )
										val_start++;
									SegSplit( &pLine, val_start - field_start );
									value = NEXTLINE( pLine );
									field_name = SegSplit( &pLine, field_end - field_start );
									trash = NEXTLINE( field_name );
									{
										struct HttpField *field = New( struct HttpField );
										field->name = SegGrab( field_name );
										field->value = SegGrab( value );
										if( TextLike( field->name, "connection" ) )
										{
											if( TextLike( field->value, "keep-alive" ) ) {
												pHttpState->flags.keep_alive = 1;
											}
											if( TextLike( field->value, "close" ) ) {
												pHttpState->flags.close = 1;
											}
										}
										LineRelease( trash );
										AddLink( &pHttpState->fields, field );
									}
								}
								else
								{
									lprintf( WIDE( "Header field [%s] invalid" ), GetText( pLine ) );
									LineRelease( pLine );
								}
							}
							else
							{
								pLine = SegCreate( pos - start - bLine );
								MemCpy( line = GetText( pLine ), c + start, (pos - start - bLine)*sizeof(TEXTCHAR));
								line[pos-start-bLine] = 0;
								pHttpState->response_status = pLine;
 // initialize to assume it's incomplete; NOT OK.  (requests should be OK)
								pHttpState->numeric_code = 0;
								{
									PTEXT request = TextParse( pHttpState->response_status, WIDE( "?#" ), WIDE( " " ), 1, 1 DBG_SRC );
									{
										PTEXT tmp;
										PTEXT resource_path = NULL;
										PTEXT next;
										if( TextSimilar( request, WIDE( "GET" ) ) )
										{
 // initialize to assume it's incomplete; NOT OK.  (requests should be OK)
											pHttpState->numeric_code = HTTP_STATE_RESULT_CONTENT;
											request = NEXTLINE( request );
											pHttpState->method = SegBreak( request );
										}
										else if( TextSimilar( request, WIDE( "POST" ) ) )
										{
 // initialize to assume it's incomplete; NOT OK.  (requests should be OK)
											pHttpState->numeric_code = HTTP_STATE_RESULT_CONTENT;
											request = NEXTLINE( request );
											pHttpState->method = SegBreak( request );
										}
										// this loop is used for both client and server http requests...
										// this will be the first part of a HTTP response (this one will have a result code, the other is just version)
										else if( TextSimilar( request, WIDE( "HTTP/" ) ) )
										{
											TEXTCHAR *tmp2 = (TEXTCHAR*)StrChr( GetText( request ), '.' );
											pHttpState->response_version = (int)((IntCreateFromText( GetText( request ) + 5 ) * 100) + IntCreateFromText( tmp2 + 1 ));
											{
												PTEXT nextword = NEXTLINE( request );
												if( nextword )
												{
													next = NEXTLINE( nextword );
													// cast from int64_t
													pHttpState->numeric_code = (int)IntCreateFromText( GetText( nextword ) );
													nextword = next;
													if( nextword )
													{
														next = NEXTLINE( nextword );
														if( pHttpState->text_code )
															Release( pHttpState->text_code );
														pHttpState->text_code = StrDup( GetText( nextword ) );
													}
												}
												else
												{
													lprintf( WIDE( "failed to find result code in %s" ), line );
												}
											}
										}
										else {
											lprintf( "Unsupported Command:%s", GetText( request ) );
											request = NEXTLINE( request );
											pHttpState->method = SegBreak( request );
										}
										for( tmp = request; tmp; tmp = next )
										{
											//lprintf( WIDE( "word %s" ), GetText( tmp ) );
											next = NEXTLINE( tmp );
											//lprintf( "Line : %s", GetText( pLine ) );
											if( TextSimilar( tmp, WIDE("HTTP/") ) )
											{
												TEXTCHAR *tmp2 = (TEXTCHAR*)StrChr( GetText( tmp ), '.' );
												pHttpState->response_version = (int)(( IntCreateFromText( GetText( tmp ) + 5 ) * 100 ) + IntCreateFromText( tmp2 + 1 ));
											}
											else if( GetText(tmp)[0] == '?' )
											{
												ProcessURL_CGI( pHttpState, next );
												next = NEXTLINE( next );
											}
											else if( GetText(tmp)[0] == '#' )
											{
												lprintf( WIDE("Page anchor of URL is lost(not saved)... %s"), GetText( next ) );
												next = NEXTLINE( next );
											}
											else
											{
												if( (resource_path && tmp->format.position.offset.spaces) )
												{
													break;
												}
												else
												{
													resource_path = SegAppend( resource_path, SegGrab( tmp ) );
													request = next;
												}
											}
										}
										pHttpState->resource = resource_path;
									}
									LineRelease( request );
								}
								//else
								//	lprintf( "Not Http header?" );
							}
							// could perhaps append a newline segment block...
							// but probably do not need such a thing....
							// since the return should be assumed as a continuous
							// stream of datas....
							start = pos;
							if( bLine == 2 )
								bLine = 0;
						}
						// may not receive anything other than header information?
						if( bLine == 4 )
						{
							// end of header
							// copy the previous line out...
							//pStart = pCurrent;
 // remaing size
							len = size - pos;
							break;
						}
					}
					if( bLine == 4 )
					{
						pos++;
						pHttpState->final = 1;
						goto FinalCheck;
					}
				}
				if( pos == size &&
					bLine == 4 &&
					start != pos )
				{
					pHttpState->final = 1;
					goto FinalCheck;
				}
			}
			else
				len += size;
			//pCurrent = NEXTLINE( pCurrent );
			/* Move the remaining data into a single binary data packet...*/
		}
		if( start )
		{
			/*PTEXT tmp = */
SegSplit( &pCurrent, start );
			pHttpState->partial = NEXTLINE( pCurrent );
			LineRelease( SegGrab( pCurrent ) );
			start = 0;
		}
		// final is having received the end of the HTTP header, not nessecarily all data
		if( pHttpState->final )
		{
			INDEX idx;
			struct HttpField *field;
			LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
			{
				if( TextLike( field->name, WIDE( "content-length" ) ) )
				{
					// down convert from int64_t
					pHttpState->content_length = (int)IntCreateFromSeg( field->value );
					//lprintf( "content lenght: %d", pHttpState->content_length );
				}
				else if( TextLike( field->name, WIDE( "upgrade" ) ) )
				{
					if( TextLike( field->value, "websocket" ) ) {
						pHttpState->flags.ws_upgrade = 1;
					}
					else if( TextLike( field->value, "h2c" ) ) {
						pHttpState->flags.h2c_upgrade = 1;
					}
				}
				else if( TextLike( field->name, WIDE( "connection" ) ) )
				{
					if( StrCaseStr( GetText( field->value ), "upgrade" ) ) {
						pHttpState->flags.upgrade = 1;
					}
				}
				else if( TextLike( field->name, WIDE( "Transfer-Encoding" ) ) )
				{
					if( TextLike( field->value, "chunked" ) )
					{
						pHttpState->content_length = 0xFFFFFFF;
						pHttpState->read_chunks = TRUE;
						pHttpState->read_chunk_state = READ_VALUE;
						pHttpState->read_chunk_length = 0;
						pHttpState->read_chunk_total_length = 0;
					}
				}
				else if( TextLike( field->name, WIDE( "Expect" ) ) )
				{
					if( TextLike( field->value, WIDE( "100-continue" ) ) )
					{
						if( l.flags.bLogReceived )
							lprintf( WIDE("Generating 100-continue response...") );
						SendTCP( pc, "HTTP/1.1 100 Continue\r\n\r\n", 25 );
					}
				}
			}
			// do one gather here... with whatever remainder we had.
			GatherHttpData( pHttpState );
		}
	}
	unlockHttp( pHttpState );
	if( pHttpState->final &&
		( ( pHttpState->content_length
			&& ( ( GetTextSize( pHttpState->partial ) >= pHttpState->content_length )
				||( GetTextSize( pHttpState->content ) >= pHttpState->content_length ) ) )
			|| ( !pHttpState->content_length )
			) )
	{
		pHttpState->returned_status = 1;
		if( pHttpState->numeric_code == 500 )
			return HTTP_STATE_INTERNAL_SERVER_ERROR;
		if( pHttpState->content && (pHttpState->numeric_code == 200) ) {
			return HTTP_STATE_RESULT_CONTENT;
		}
		if( pHttpState->numeric_code == 100 )
			return HTTP_STATE_RESULT_CONTINUE;
		if( pHttpState->numeric_code == 404 )
			return HTTP_STATE_RESOURCE_NOT_FOUND;
		if( pHttpState->numeric_code == 400 )
			return HTTP_STATE_BAD_REQUEST;
		return pHttpState->numeric_code;
	}
	return HTTP_STATE_RESULT_NOTHING;
}
LOGICAL AddHttpData( struct HttpState *pHttpState, POINTER buffer, size_t size )
{
	pHttpState->last_read_tick = GetTickCount();
	if( pHttpState->read_chunks )
	{
		const uint8_t* buf = (const uint8_t*)buffer;
		size_t ofs = 0;
		while( ofs < size )
		{
			switch( pHttpState->read_chunk_state )
			{
			case READ_VALUE:
				if( buf[0] >= '0' && buf[0] <= '9' )
				{
					pHttpState->read_chunk_length *= 16;
					pHttpState->read_chunk_length += buf[0] - '0';
				}
				else if( ( buf[0] | 0x20 ) >= 'a' && (buf[0] | 0x20) <= 'f' )
				{
					pHttpState->read_chunk_length *= 16;
					pHttpState->read_chunk_length += (buf[0] | 0x20) - 'a' + 10;
				}
				else if( buf[0] == '\r' )
				{
					pHttpState->read_chunk_total_length += pHttpState->read_chunk_length;
#ifdef _DEBUG
					if( l.flags.bLogReceived ) {
						lprintf( "Chunck will be %zd", pHttpState->read_chunk_length );
					}
#endif
					pHttpState->read_chunk_state = READ_VALUE_LF;
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\n, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_VALUE_CR:
				// didn't actually implement to get into this state... just looks for newlines really.
				break;
			case READ_VALUE_LF:
				if( buf[0] == '\n' )
				{
					if( pHttpState->read_chunk_length == 0 )
						pHttpState->read_chunk_state = READ_CR;
					else
						pHttpState->read_chunk_state = READ_BYTES;
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\n, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_CR:
				if( buf[0] == '\r' )
				{
					pHttpState->read_chunk_state = READ_LF;
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\r, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_LF:
				if( buf[0] == '\n' )
				{
					if( pHttpState->read_chunk_length )
					{
						pHttpState->read_chunk_length = 0;
						pHttpState->read_chunk_state = READ_VALUE;
					}
					else
					{
						pHttpState->content_length = GetTextSize( VarTextPeek( pHttpState->pvt_collector ) );
						if( pHttpState->waiter ) {
							//lprintf( "Waking waiting to return with result." );
							WakeThread( pHttpState->waiter );
						}
						return TRUE;
					}
				}
				else
				{
					lprintf( "Chunk Processing Error expected \\n, found %d(%c)", buf[0], buf[0] );
					RemoveClient( pHttpState->request_socket );
					return FALSE;
				}
				break;
			case READ_BYTES:
				VarTextAddData( pHttpState->pvt_collector, (CTEXTSTR)(buf), 1 );
				pHttpState->read_chunk_byte++;
				if( pHttpState->read_chunk_byte == pHttpState->read_chunk_length )
					pHttpState->read_chunk_state = READ_CR;
				break;
			}
			ofs++;
			buf++;
		}
		if( l.flags.bLogReceived ) {
			lprintf( "chunk read is %zd of %zd", pHttpState->read_chunk_byte, pHttpState->read_chunk_total_length );
		}
		return FALSE;
	}
	else
	{
		VarTextAddData( pHttpState->pvt_collector, (CTEXTSTR)buffer, size );
		return TRUE;
	}
}
struct HttpState *CreateHttpState( void )
{
	struct HttpState *pHttpState;
	pHttpState = New( struct HttpState );
	MemSet( pHttpState, 0, sizeof( struct HttpState ) );
	pHttpState->pvt_collector = VarTextCreate();
	return pHttpState;
}
void EndHttp( struct HttpState *pHttpState )
{
	lockHttp( pHttpState );
	pHttpState->final = 0;
	pHttpState->content_length = 0;
	LineRelease( pHttpState->method );
	pHttpState->method = NULL;
	LineRelease( pHttpState->content );
	LineRelease( pHttpState->resource );
	pHttpState->resource = NULL;
	if( pHttpState->partial != pHttpState->content )
	{
		LineRelease( pHttpState->partial );
	}
	pHttpState->partial = NULL;
	pHttpState->content = NULL;
	LineRelease( pHttpState->response_status );
	pHttpState->response_status = NULL;
	pHttpState->numeric_code = 0;
	if( pHttpState->text_code )
	{
		Release( pHttpState->text_code );
		pHttpState->text_code = NULL;
	}
	{
		INDEX idx;
		struct HttpField *field;
		LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
		{
			LineRelease( field->name );
			LineRelease( field->value );
			Release( field );
		}
		EmptyList( &pHttpState->fields );
		LIST_FORALL( pHttpState->cgi_fields, idx, struct HttpField *, field )
		{
			LineRelease( field->name );
			LineRelease( field->value );
			Release( field );
		}
		EmptyList( &pHttpState->cgi_fields );
	}
	unlockHttp( pHttpState );
}
PTEXT GetHttpContent( struct HttpState *pHttpState )
{
	if( pHttpState->read_chunks )
	{
		/* did a timeout happen? */
		if( pHttpState->content_length == pHttpState->read_chunk_total_length )
			return pHttpState->content;
		return NULL;
	}
	if( pHttpState->content_length )
		return pHttpState->content;
	return NULL;
}
void ProcessHttpFields( struct HttpState *pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
	{
		f( psv, field->name, field->value );
	}
}
void ProcessCGIFields( struct HttpState *pHttpState, void (CPROC*f)( uintptr_t psv, PTEXT name, PTEXT value ), uintptr_t psv )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->cgi_fields, idx, struct HttpField *, field )
	{
		f( psv, field->name, field->value );
	}
}
PTEXT GetHttpField( struct HttpState *pHttpState, CTEXTSTR name )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
	{
		if( StrCaseCmp( GetText( field->name ), name ) == 0 )
			return field->value;
	}
	return NULL;
}
PTEXT GetHttpResponce( struct HttpState *pHttpState )
{
	if( pHttpState )
		return pHttpState->response_status;
	return NULL;
}
PTEXT GetHttpRequest( struct HttpState *pHttpState )
{
	if( pHttpState )
		return pHttpState->resource;
	return NULL;
}
PTEXT GetHttpResource( struct HttpState *pHttpState )
{
	if( pHttpState )
		return pHttpState->resource;
	return NULL;
}
PTEXT GetHttpMethod( struct HttpState *pHttpState )
{
	if( pHttpState )
		return pHttpState->method;
	return NULL;
}
void DestroyHttpStateEx( struct HttpState *pHttpState DBG_PASS )
{
	//_lprintf(DBG_RELAY)( "Destroy http state... (should clear content too?" );
 // empties variables
	EndHttp( pHttpState );
	DeleteList( &pHttpState->fields );
	DeleteList( &pHttpState->cgi_fields );
	VarTextDestroy( &pHttpState->pvtOut );
	VarTextDestroy( &pHttpState->pvt_collector );
	if( pHttpState->buffer )
		Release( pHttpState->buffer );
	Release( pHttpState );
}
void DestroyHttpState( struct HttpState *pHttpState ) {
	DestroyHttpStateEx( pHttpState DBG_SRC );
}
#define DestroyHttpState(state) DestroyHttpStateEx(state DBG_SRC )
void SendHttpResponse ( struct HttpState *pHttpState, PCLIENT pc, int numeric, CTEXTSTR text, CTEXTSTR content_type, PTEXT body )
{
	//int offset = 0;
	PVARTEXT pvt_message = VarTextCreate();
	PTEXT header;
	PTEXT tmp_content;
	//TEXTCHAR message[500];
	vtprintf( pvt_message, WIDE( "HTTP/1.1 %d %s\r\n" ), numeric, text );
	if( content_type && body )
	{
		vtprintf( pvt_message, WIDE( "Content-Length: %d\r\n" ), GetTextSize(body));
		vtprintf( pvt_message, WIDE( "Content-Type: %s\r\n" )
				  , content_type?content_type
					:(tmp_content=GetHttpField( pHttpState, WIDE("Accept") ))?GetText(tmp_content)
					:WIDE("text/plain; charset=utf-8")  );
	}
	//else
	//	vtprintf( pvt_message, WIDE( "%s\r\n" ), GetText( body ) );
	vtprintf( pvt_message, WIDE( "Server: SACK Core Library 2.x\r\n" )  );
	if( body )
		vtprintf( pvt_message, WIDE( "\r\n" )  );
	header = VarTextPeek( pvt_message );
	//offset += snprintf( message + offset, sizeof( message ) - offset, WIDE( "%s" ),  "Body");
	if( l.flags.bLogReceived )
	{
		lprintf( WIDE("Sending response...") );
		LogBinary( (uint8_t*)GetText( header ), GetTextSize( header ) );
		if( content_type )
			LogBinary( (uint8_t*)GetText( body ), GetTextSize( body ) );
	}
	if( !pc )
		pc = pHttpState->request_socket;
	SendTCP( pc, GetText( header ), GetTextSize( header ) );
	if( content_type )
		SendTCP( pc, GetText( body ), GetTextSize( body ) );
	VarTextDestroy( &pvt_message );
}
void SendHttpMessage ( struct HttpState *pHttpState, PCLIENT pc, PTEXT body )
{
	PTEXT message;
	PVARTEXT pvt_message = VarTextCreate();
	PTEXT content_type;
	vtprintf( pvt_message, WIDE( "%s" ),  WIDE("HTTP/1.1 200 OK\r\n") );
	vtprintf( pvt_message, WIDE( "Content-Length: %d\r\n" ), GetTextSize( body ));
	vtprintf( pvt_message, WIDE( "Content-Type: %s\r\n" )
		, (content_type = GetHttpField( pHttpState, WIDE("Accept") ))?GetText(content_type):WIDE("text/plain" ));
	vtprintf( pvt_message, WIDE( "\r\n" )  );
	vtprintf( pvt_message, WIDE( "%s" ), GetText( body ));
	message = VarTextGet( pvt_message );
	if( l.flags.bLogReceived )
	{
		lprintf( WIDE(" Response Message:" ));
		LogBinary( (uint8_t*)GetText( message ), GetTextSize( message ));
	}
	SendTCP( pc, GetText( message ), GetTextSize( message ));
}
//---------- CLIENT --------------------------------------------
static void CPROC HttpReader( PCLIENT pc, POINTER buffer, size_t size )
{
	struct HttpState *state = (struct HttpState *)GetNetworkLong( pc, 0 );
	if( !buffer )
	{
		//lprintf( "Initial read on HTTP requestor" );
		if( state && state->ssl )
		{
			PTEXT send = VarTextGet( state->pvtOut );
			if( l.flags.bLogReceived )
			{
				lprintf( WIDE("Sending Request...") );
				LogBinary( (uint8_t*)GetText( send ), GetTextSize( send ) );
			}
#ifndef NO_SSL
			// had to wait for handshake, so NULL event
			// on secure has already had time to build the send
			// but had to wait until now to do that.
			ssl_Send( pc, GetText( send ), GetTextSize( send ) );
#endif
			LineRelease( send );
		}
		else
		{
			state->buffer = Allocate( 4096 );
			ReadTCP( pc, state->buffer, 4096 );
		}
	}
	else
	{
		if( l.flags.bLogReceived )
		{
			lprintf( WIDE("Received web request... %zu"), size );
			//LogBinary( buffer, size );
		}
		if( AddHttpData( state, buffer, size ) )
			if( ProcessHttp( pc, state ) )
			{
				RemoveClient( pc );
				return;
			}
	}
	// read is handled by the SSL layer instead of here.  Just trust that someone will give us data later
	if( buffer && ( !state || !state->ssl ) )
	{
		ReadTCP( pc, state->buffer, 4096 );
	}
}
static void CPROC HttpReaderClose( PCLIENT pc )
{
	struct HttpState *data = (struct HttpState *)GetNetworkLong( pc, 0 );
// (PCLIENT*)GetNetworkLong( pc, 0 );
	PCLIENT *ppc = data->pc;
	if( ppc )
		ppc[0] = NULL;
	if( data->waiter ) {
		//lprintf( "(on close) Waking waiting to return with result." );
		WakeThread( data->waiter );
	}
	//if( !data->flags.success )
	//	DestroyHttpState( data );
}
static void CPROC HttpConnected( PCLIENT pc, int error ) {
	INDEX idx;
	struct pendingConnect *connect;
	while( 1 ) {
		LIST_FORALL( l.pendingConnects, idx, struct pendingConnect *, connect ) {
			if( connect->pc == pc ) {
				SetLink( &l.pendingConnects, idx, NULL );
				break;
			}
		}
		if( connect )
			break;
		Relinquish();
	}
	SetNetworkLong( pc, 0, (uintptr_t)connect->state );
	Release( connect );
}
HTTPState PostHttpQuery( PTEXT address, PTEXT url, PTEXT content )
{
	struct HttpState *state = CreateHttpState();
	PCLIENT pc;
	struct pendingConnect *connect = New( struct pendingConnect );
	connect->state = state;
	AddLink( &l.pendingConnects, connect );
	pc = OpenTCPClientExx( GetText( address ), 80, HttpReader, NULL, NULL, HttpConnected );
	connect->pc = pc;
	PVARTEXT pvtOut = VarTextCreate();
	vtprintf( pvtOut, WIDE( "POST %s HTTP/1.1\r\n" ), url );
	vtprintf( pvtOut, WIDE( "content-length:%d\r\n" ), GetTextSize( content ) );
	vtprintf( pvtOut, WIDE( "\r\n\r\n" ) );
	VarTextAddData( pvtOut, GetText( content ), GetTextSize( content ) );
	if( pc )
	{
		PTEXT send = VarTextGet( pvtOut );
		state->pc = &pc;
		state->waiter = MakeThread();
		SetNetworkLong( pc, 0, (uintptr_t)state );
		SetNetworkCloseCallback( pc, HttpReaderClose );
		if( l.flags.bLogReceived )
		{
			lprintf( WIDE("Sending POST...") );
			LogBinary( (uint8_t*)GetText( send ), GetTextSize( send ) );
		}
		SendTCP( pc, GetText( send ), GetTextSize( send ) );
		LineRelease( send );
		while( pc )
		{
			WakeableSleep( 100 );
		}
	}
	VarTextDestroy( &pvtOut );
	return state;
}
PTEXT PostHttp( PTEXT address, PTEXT url, PTEXT content )
{
	HTTPState state = PostHttpQuery( address, url, content );
	if( state )
	{
		PTEXT result = GetHttpContent( state );
		if( result )
			Hold( result );
		DestroyHttpState( state );
		return result;
	}
	return NULL;
}
static void httpConnected( PCLIENT pc, int error ) {
	if( error ) {
		struct HttpState *state = (struct HttpState *)GetNetworkLong( pc, 0 );
		RemoveClient( pc );
		return;
	}
	{
		INDEX idx;
		struct pendingConnect *connect;
		while( 1 ) {
			LIST_FORALL( l.pendingConnects, idx, struct pendingConnect *, connect ) {
				if( connect->pc == pc ) {
					SetLink( &l.pendingConnects, idx, NULL );
					break;
				}
			}
			if( connect )
				break;
			Relinquish();
		}
		SetNetworkLong( pc, 0, (uintptr_t)connect->state );
		Release( connect );
	}
}
HTTPState GetHttpQuery( PTEXT address, PTEXT url )
{
	if( !address )
		return NULL;
	{
		PCLIENT pc;
		SOCKADDR *addr = CreateSockAddress( GetText( address ), 443 );
		struct HttpState *state = CreateHttpState();
		struct pendingConnect *connect = New( struct pendingConnect );
		connect->state = state;
		AddLink( &l.pendingConnects, connect );
		pc = OpenTCPClientAddrExxx( addr, HttpReader, HttpReaderClose, NULL, httpConnected, 0 DBG_SRC );
		connect->pc = pc;
		ReleaseAddress( addr );
		if( pc ) {
			PVARTEXT pvtOut = VarTextCreate();
			SetTCPNoDelay( pc, TRUE );
			vtprintf( pvtOut, WIDE( "GET %s HTTP/1.1\r\n" ), GetText( url ) );
			vtprintf( pvtOut, WIDE( "Host: %s\r\n" ), GetText( address ) );
			vtprintf( pvtOut, WIDE( "\r\n" ) );
			if( pc )
			{
				PTEXT send = VarTextGet( pvtOut );
				state->waiter = MakeThread();
				state->pc = &pc;
				SetNetworkLong( pc, 0, (uintptr_t)state );
				SetNetworkCloseCallback( pc, HttpReaderClose );
				if( l.flags.bLogReceived )
				{
					lprintf( WIDE( "Sending POST..." ) );
					LogBinary( (uint8_t*)GetText( send ), GetTextSize( send ) );
				}
				SendTCP( pc, GetText( send ), GetTextSize( send ) );
				LineRelease( send );
				while( pc )
				{
					WakeableSleep( 100 );
				}
			}
			VarTextDestroy( &pvtOut );
			return state;
		}
	}
	return NULL;
}
HTTPState GetHttpsQuery( PTEXT address, PTEXT url, const char *certChain )
{
	if( !address )
		return NULL;
	{
		struct HttpState *state = CreateHttpState();
		static PCLIENT pc;
		SOCKADDR *addr = CreateSockAddress( GetText( address ), 443 );
		struct pendingConnect *connect = New( struct pendingConnect );
		connect->state = state;
		AddLink( &l.pendingConnects, connect );
		//DumpAddr( "Http Address:", addr );
		pc = OpenTCPClientAddrExxx( addr, HttpReader, HttpReaderClose, NULL, httpConnected, OPEN_TCP_FLAG_DELAY_CONNECT DBG_SRC );
		connect->pc = pc;
		ReleaseAddress( addr );
		if( pc )
		{
			state->last_read_tick = GetTickCount();
			state->waiter = MakeThread();
			state->pc = &pc;
			SetNetworkLong( pc, 0, (uintptr_t)state );
			//SetNetworkConn
			state->ssl = TRUE;
			state->pvtOut = VarTextCreate();
			vtprintf( state->pvtOut, WIDE( "GET %s HTTP/1.1\r\n" ), GetText( url ) );
			vtprintf( state->pvtOut, WIDE( "Host: %s\r\n" ), GetText( address ) );
			vtprintf( state->pvtOut, "User-Agent: SACK(%s)\r\n", "System" );
			vtprintf( state->pvtOut, WIDE( "\r\n" ) );
#ifndef NO_SSL
			if( ssl_BeginClientSession( pc, NULL, 0, NULL, 0, certChain, certChain ? strlen( certChain ) : 0 ) )
			{
				if( !certChain )
					ssl_SetIgnoreVerification( pc );
				if( NetworkConnectTCP( pc ) < 0 ) {
					DestroyHttpState( state );
					return NULL;
				}
				state->waiter = MakeThread();
				while( pc && ( state->last_read_tick > ( GetTickCount() - 20000 ) ) )
				{
					WakeableSleep( 1000 );
				}
				//lprintf( "Request has completed.... %p %p", pc, state->content );
				if( pc )
					RemoveClient( pc );
			}
			else
				RemoveClient( pc );
#endif
			VarTextDestroy( &state->pvtOut );
			if( !pc )
				return state;
		}
		else
		{
			RemoveClient( pc );
			DestroyHttpState( state );
		}
	}
	return NULL;
}
PTEXT GetHttp( PTEXT address, PTEXT url, LOGICAL secure )
{
	if( secure )
		return GetHttps( address, url, NULL );
	else
	{
	HTTPState state = GetHttpQuery( address, url );
	if( state )
	{
		PTEXT result = GetHttpContent( state );
		if( result )
			Hold( result );
		DestroyHttpState( state );
		return result;
	}}
	return NULL;
}
PTEXT GetHttps( PTEXT address, PTEXT url, const char *ca )
{
	HTTPState state = GetHttpsQuery( address, url, ca );
	if( state )
	{
		PTEXT result = GetHttpContent( state );
		if( result )
			Hold( result );
		DestroyHttpState( state );
		return result;
	}
	return NULL;
}
//---------- SERVER --------------------------------------------
static LOGICAL InvokeMethod( PCLIENT pc, struct HttpServer *server, struct HttpState *pHttpState )
{
	PTEXT method = GetHttpMethod( pHttpState );
	//PTEXT request = TextParse( pHttpState->response_status, WIDE( "?#" ), WIDE( " " ), 1, 1 DBG_SRC );
	if( TextLike( method, WIDE( "get" ) ) || TextLike( method, WIDE( "post" ) ) )
	{
		LOGICAL (CPROC *f)(uintptr_t, PCLIENT, struct HttpState *, PTEXT);
		LOGICAL status = FALSE;
		f = (LOGICAL (CPROC*)(uintptr_t, PCLIENT, struct HttpState *, PTEXT))GetRegisteredProcedureExxx( server->methods, (PCLASSROOT)(GetText( pHttpState->resource ) + 1), "LOGICAL", GetText(method), "(uintptr_t, PCLIENT, struct HttpState *, PTEXT)" );
		//lprintf( "got for %s %s", (PCLASSROOT)(GetText( pHttpState->resource ) + 1),  GetText( request ) );
		if( f )
			status = f( server->psvRequest, pc, pHttpState, pHttpState->content );
		if( !status )
		{
			if( server->handle_request )
				status = server->handle_request( server->psvRequest, pHttpState );
		}
		if( !status )
		{
			DECLTEXT( body, WIDE( "<HTML><HEAD><TITLE>Bad Request</TITLE></HEAD><BODY>Resource handler not found" ) );
			SendHttpResponse( pHttpState, NULL, 404, WIDE("NOT FOUND"), WIDE("text/html"), (PTEXT)&body );
		}
		return 1;
	}
	else
		lprintf( WIDE("not a get or a post?") );
	//LineRelease( request );
	return 0;
}
static void CPROC HandleRequest( PCLIENT pc, POINTER buffer, size_t length )
{
	if( !buffer )
	{
		struct HttpState *pHttpStateServer = (struct HttpState *)GetNetworkLong( pc, 0 );
		struct HttpState *pHttpState = CreateHttpState();
		pHttpState->ssl = pHttpStateServer->ssl;
		buffer = pHttpState->buffer = Allocate( 4096 );
		pHttpState->request_socket = pc;
		SetNetworkLong( pc, 1, (uintptr_t)pHttpState );
	}
	else
	{
		int result;
		struct HttpState *pHttpState = (struct HttpState *)GetNetworkLong( pc, 1 );
#ifdef _DEBUG
		if( l.flags.bLogReceived )
		{
			lprintf( WIDE("Received web request...") );
			LogBinary( (uint8_t*)buffer, length );
		}
#endif
		AddHttpData( pHttpState, buffer, length );
		while( ( result = ProcessHttp( pc, pHttpState ) ) )
		{
			int status;
			struct HttpServer *server = (struct HttpServer *)GetNetworkLong( pc, 0 );
			//lprintf( "result = %d", result );
			switch( result )
			{
			case HTTP_STATE_RESULT_CONTENT:
				status = InvokeMethod( pc, server, pHttpState );
				if( status
					&& ( ( pHttpState->response_version == 9 )
					|| (pHttpState->response_version == 100 && !pHttpState->flags.keep_alive)
					||( pHttpState->response_version == 101 && pHttpState->flags.close ) ) ) {
					RemoveClientEx( pc, 0, 1 );
					return;
				}
				else
					EndHttp( pHttpState );
				break;
			case HTTP_STATE_RESULT_CONTINUE:
				break;
			}
		}
		if( !pHttpState->ssl )
			ReadTCP( pc, buffer, 4096 );
	}
}
static void CPROC RequestorClosed( PCLIENT pc )
{
	struct HttpServer *server = (struct HttpServer *)GetNetworkLong( pc, 0 );
	struct HttpState *pHttpState = (struct HttpState *)GetNetworkLong( pc, 1 );
	DeleteLink( &server->clients, pc );
	if( pHttpState )
		DestroyHttpState( pHttpState );
}
static void CPROC AcceptHttpClient( PCLIENT pc_server, PCLIENT pc_new )
{
	struct HttpServer *server;
	while( !(server = (struct HttpServer *)GetNetworkLong( pc_server, 0 )) ) {
		Relinquish();
	}
	AddLink( &server->clients, pc_new );
	SetNetworkLong( pc_new, 0, (uintptr_t)server );
	SetNetworkReadComplete( pc_new, HandleRequest );
	SetNetworkCloseCallback( pc_new, RequestorClosed );
}
#ifndef NO_SSL
struct HttpServer *CreateHttpsServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv ) {
	struct HttpServer *server = New( struct HttpServer );
	SOCKADDR *tmp;
	TEXTCHAR class_name[256];
	server->clients = NULL;
	server->handle_request = handle_request;
	server->psvRequest = psv;
	server->site = StrDup( site );
	tnprintf( class_name, sizeof( class_name ), WIDE( "SACK/Http/Methods/%s%s%s" )
		, TargetName ? TargetName : WIDE( "" )
		, (TargetName && site) ? WIDE( "/" ) : WIDE( "" )
		, site ? site : WIDE( "" ) );
	//lprintf( "Server root = %s", class_name );
	server->methods = GetClassRoot( class_name );
	NetworkStart();
	server->server = OpenTCPListenerAddrEx( tmp = CreateSockAddress( interface_address ? interface_address : WIDE( "0.0.0.0" ), 80 )
		, AcceptHttpClient );
	SetNetworkLong( server->server, 0, (uintptr_t)server );
	ssl_BeginServer( server->server, NULL, 0, NULL, 0, NULL, 0 );
	ReleaseAddress( tmp );
	if( !server->server )
	{
		Release( server );
		return NULL;
	}
	return server;
}
#endif
struct HttpServer *CreateHttpServerEx( CTEXTSTR interface_address, CTEXTSTR TargetName, CTEXTSTR site, ProcessHttpRequest handle_request, uintptr_t psv )
{
	struct HttpServer *server = New( struct HttpServer );
	SOCKADDR *tmp;
	TEXTCHAR class_name[256];
	server->clients = NULL;
	server->handle_request = handle_request;
	server->psvRequest = psv;
	server->site = StrDup( site );
	tnprintf( class_name, sizeof( class_name ), WIDE( "SACK/Http/Methods/%s%s%s" )
			  , TargetName?TargetName:WIDE("")
			  , ( TargetName && site )?WIDE( "/" ):WIDE( "" )
			  , site?site:WIDE( "" ) );
	//lprintf( "Server root = %s", class_name );
	server->methods = GetClassRoot( class_name );
	NetworkStart();
	server->server = OpenTCPListenerAddrEx( tmp = CreateSockAddress( interface_address?interface_address:WIDE( "0.0.0.0" ), 80 )
													  , AcceptHttpClient );
	ReleaseAddress( tmp );
	if( !server->server )
	{
		Release( server );
		return NULL;
	}
	SetNetworkLong( server->server, 0, (uintptr_t)server );
	return server;
}
PTEXT GetHTTPField( struct HttpState *pHttpState, CTEXTSTR name )
{
	INDEX idx;
	struct HttpField *field;
	LIST_FORALL( pHttpState->fields, idx, struct HttpField *, field )
	{
		if( TextLike( field->name, name ) )
			return field->value;
	}
	return NULL;
}
PLIST GetHttpHeaderFields( HTTPState pHttpState )
{
	return pHttpState->fields;
}
int GetHttpVersion( HTTPState pHttpState ) {
	return pHttpState->response_version;
}
int GetHttpResponseCode( HTTPState pHttpState ) {
	return pHttpState->numeric_code;
}
HTTP_NAMESPACE_END
#undef l
// not really, but close enough
#define HTTP_SOURCE
HTTP_NAMESPACE
struct default_port
{
	CTEXTSTR name;
	int number;
};
#define num_defaults (sizeof(default_ports)/sizeof(default_ports[0]))
static struct default_port default_ports[] = { { WIDE("http"), 80 }
															, { WIDE("ftp"), 21 }
															, { WIDE("ssh"), 22 }
															, { WIDE("telnet"), 23 }
															, { WIDE("https"), 443 }
															, { WIDE("ws"), 80 }
															, { WIDE("wss"), 443 }
															, { WIDE("file"), 0 }
															};
// TEXTSTR result = ConvertURIText( addr, length )
// SACK_ParseURL takes a URL string and gets the peices it can identify
// if a peice is not specified, the result will be NULL.
enum URLParseState
{
  // find ':', store characters in buffer
	PARSE_STATE_COLLECT_PROTOCOL = 0
  // find '/', eat /
	, PARSE_STATE_COLLECT_PROTOCOL_1
  // eat '/', eat /
	, PARSE_STATE_COLLECT_PROTOCOL_2
	, PARSE_STATE_COLLECT_USER
	, PARSE_STATE_COLLECT_PASSWORD
	, PARSE_STATE_COLLECT_ADDRESS
	, PARSE_STATE_COLLECT_PORT
	, PARSE_STATE_COLLECT_RESOURCE_PATH
	, PARSE_STATE_COLLECT_RESOURCE_NAME
	, PARSE_STATE_COLLECT_RESOURCE_EXTENSION
	, PARSE_STATE_COLLECT_RESOURCE_ANCHOR
	, PARSE_STATE_COLLECT_CGI_NAME
	, PARSE_STATE_COLLECT_CGI_VALUE
	, PARSE_STATE_COLLECT_IPV6
};
static void AppendBuffer( CTEXTSTR *output, CTEXTSTR seperator, CTEXTSTR input )
{
	CTEXTSTR tmpbuf = ConvertURIText( input, StrLen( input ) + 1 );
	TEXTSTR newout;
	if( *output )
	{
		size_t len;
		len = StrLen( *output ) + StrLen( tmpbuf ) + 1;
		if( seperator )
			len += StrLen( seperator );
		newout = NewArray( TEXTCHAR, len );
		tnprintf( newout, len, WIDE("%s%s%s"), (*output), seperator?seperator:WIDE(""), tmpbuf );
		Release( (POINTER)*output );
		(*output) = newout;
		Release( (POINTER)tmpbuf );
	}
	else
	{
		(*output) = tmpbuf;
	}
}
struct url_data * SACK_URLParse( const char *url )
{
	const char *_url = url;;
	struct url_data *data = New( struct url_data );
	struct url_cgi_data *cgi_data;
	TEXTRUNE ch;
	int outchar = 0;
	char * outbuf = NewArray( TEXTCHAR, StrLen( url ) + 1 );
	char *_outbuf = outbuf;
	int _state, state;
	char *newUrl = outbuf;
	int decode = 0;
	while( _url[0] ) {
		if( decode ) {
			ch *= 16;
			if( _url[0] >= '0' && _url[0] <= '9' )
				ch += _url[0] - '0';
			else if( _url[0] >= 'A' && _url[0] <= 'A' )
				ch += (_url[0] - 'A') + 10;
			else if( _url[0] >= '0' && _url[0] <= '9' )
				ch += (_url[0] - 'a' ) + 10;
			else {
				Deallocate( char *, outbuf );
				return NULL;
			}
			decode--;
			if( !decode )
				newUrl[0] = (char)decode;
			newUrl++;
		}
		else if( _url[0] == '%' ) {
			ch = 0;
			decode = 2;
		}
		else {
			newUrl[0] = _url[0];
			newUrl++;
		}
		_url++;
	}
	newUrl[0] = _url[0];
	_url = url = outbuf;
	_state = -1;
	state = PARSE_STATE_COLLECT_PROTOCOL;
	MemSet( data, 0, sizeof( struct url_data ) );
	while( ch = GetUtfChar(&url) )
	{
		int use_char;
		use_char = 0;
		switch( ch )
		{
		case '[':
			if( ( state == PARSE_STATE_COLLECT_ADDRESS )
				||( state == PARSE_STATE_COLLECT_USER ) ) {
				state = PARSE_STATE_COLLECT_IPV6;
				use_char = 1;
			}
			break;
		case ']':
			if( state == PARSE_STATE_COLLECT_IPV6 ) {
				// hit the colon between address and port
				outbuf[outchar++] = ch;
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
				continue;
			}
			break;
		case '&':
			if( state == PARSE_STATE_COLLECT_CGI_NAME )
			{
				cgi_data = New( struct url_cgi_data );
				cgi_data->name = NULL;
				cgi_data->value = NULL;
				AddLink( &data->cgi_parameters, cgi_data );
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->name, NULL, outbuf );
  // same state, just a blank cgi param
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			if( state == PARSE_STATE_COLLECT_CGI_VALUE )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->value, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			break;
		case '=':
			if( state == PARSE_STATE_COLLECT_CGI_NAME )
			{
				cgi_data = New( struct url_cgi_data );
				cgi_data->name = NULL;
				cgi_data->value = NULL;
				AddLink( &data->cgi_parameters, cgi_data );
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &cgi_data->name, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_VALUE;
			}
			break;
		case '?':
			if( state == PARSE_STATE_COLLECT_RESOURCE_EXTENSION )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_extension, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
				continue;
			}
			if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			if( state == PARSE_STATE_COLLECT_RESOURCE_ANCHOR )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_anchor, NULL, outbuf );
				state = PARSE_STATE_COLLECT_CGI_NAME;
			}
			break;
		case '#':
			if( state == PARSE_STATE_COLLECT_RESOURCE_EXTENSION )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_extension, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_ANCHOR;
			}
			else if( ( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
				|| ( state == PARSE_STATE_COLLECT_RESOURCE_PATH ) )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_ANCHOR;
			}
			break;
		case '.':
			// I just want to process the '.' when finding the extension.
			// just because we will always want to know it for other reasons later
			if( state == PARSE_STATE_COLLECT_RESOURCE_PATH
				|| state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_file, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_EXTENSION;
			}
			else
				use_char = 1;
			break;
		case '/':
			if( state == PARSE_STATE_COLLECT_PROTOCOL_1 )
			{
				if( outchar > 0 )
					lprintf( WIDE("Characters between protocol ':' and first slash") );
				state = PARSE_STATE_COLLECT_PROTOCOL_2;
			}
			else if( state == PARSE_STATE_COLLECT_PROTOCOL_2 )
			{
				if( outchar > 0 )
					lprintf( WIDE("Characters between protocol first and second slash") );
				state = PARSE_STATE_COLLECT_USER;
			}
			else if( state == PARSE_STATE_COLLECT_USER )
			{
				// what was collected was really
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_PASSWORD )
			{
				// what was collected was really the ip:port not user:password
				data->host = data->user;
				data->user = NULL;
				outbuf[outchar] = 0;
				outchar = 0;
				// should validate port is in numeric.
				data->port = (int)IntCreateFromText( outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_ADDRESS )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_PORT )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				data->port = (int)IntCreateFromText( outbuf );
				//AppendBuffer( &data->port, NULL, outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_PATH;
			}
			else if( state == PARSE_STATE_COLLECT_RESOURCE_PATH )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, WIDE("/"), outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			else if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				// this isn't really the name, it's another part of the resource path
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, WIDE("/"), outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			break;
		case '@':
  // hit the colon between user and password
			if( state == PARSE_STATE_COLLECT_USER )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->user, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
			}
			if( state == PARSE_STATE_COLLECT_PASSWORD )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->password, NULL, outbuf );
				state = PARSE_STATE_COLLECT_ADDRESS;
			}
			break;
		case ':':
			if( state == PARSE_STATE_COLLECT_PROTOCOL )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->protocol, NULL, outbuf );
				{
					size_t n;
					for( n = 0; n < num_defaults; n++ )
					{
						if( strcmp( outbuf, default_ports[n].name ) == 0 )
						{
							data->default_port = default_ports[n].number;
						}
					}
				}
				state = PARSE_STATE_COLLECT_PROTOCOL_1;
				continue;
			}
  // hit the colon between user and password
			else if( state == PARSE_STATE_COLLECT_USER )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->user, NULL, outbuf );
				state = PARSE_STATE_COLLECT_PASSWORD;
				continue;
			}
  // hit the colon between address and port
			else if( state == PARSE_STATE_COLLECT_IPV6 )
			{
				use_char = 1;
			}
  // hit the colon between address and port
			else if( state == PARSE_STATE_COLLECT_ADDRESS )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->host, NULL, outbuf );
				state = PARSE_STATE_COLLECT_PORT;
				continue;
			}
			else
			{
 // error
				;
			}
			break;
		default:
			switch( state )
			{
			case PARSE_STATE_COLLECT_PROTOCOL_1:
				// the thing after the ':' was not a '/', so this isn't the protocol.
				break;
			case PARSE_STATE_COLLECT_PROTOCOL_2:
				break;
			default:
				use_char = 1;
			}
			break;
		}
		if( use_char )
			outchar += ConvertToUTF8( outbuf + outchar, ch );
		else
		{
			if( _state == state
  // after starting the path, look for fliename, if the extension or other is not found
				&& ( state != PARSE_STATE_COLLECT_RESOURCE_NAME )
 // blank cgi names go & to & and stay in the same state
				&& ( state != PARSE_STATE_COLLECT_CGI_NAME )
				)
				lprintf( WIDE("Dropping character (%d) '%c' in %s"), url - _outbuf, ch, _outbuf );
		}
		_state = state;
	}
	switch( state )
	{
	// this means user name, but if we hit the end of the buffer, it's the address
	case PARSE_STATE_COLLECT_USER:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &data->host, NULL, outbuf );
		break;
	// this is the first colon, but no @ found, but end of buffer name is host and this is port.
	case PARSE_STATE_COLLECT_PASSWORD:
		data->host = data->user;
		data->user = NULL;
		outbuf[outchar] = 0;
		outchar = 0;
		data->port = (int)IntCreateFromText( outbuf );
		//AppendBuffer( &data->port, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_CGI_NAME:
		cgi_data = New( struct url_cgi_data );
		cgi_data->name = NULL;
		cgi_data->value = NULL;
		AddLink( &data->cgi_parameters, cgi_data );
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &cgi_data->name, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_CGI_VALUE:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &cgi_data->value, NULL, outbuf );
		break;
	case PARSE_STATE_COLLECT_RESOURCE_PATH:
		outbuf[outchar] = 0;
		outchar = 0;
		AppendBuffer( &data->resource_file, NULL, outbuf );
		// this would be one word, no slashes, collecting a path . this is resource name
		break;
	default:
		if( outchar )
		{
			if( state == PARSE_STATE_COLLECT_RESOURCE_NAME )
			{
				outbuf[outchar] = 0;
				outchar = 0;
				AppendBuffer( &data->resource_path, WIDE("/"), outbuf );
				state = PARSE_STATE_COLLECT_RESOURCE_NAME;
			}
			else
			{
				outbuf[outchar] = 0;
				lprintf( WIDE("Unused output: state %d [%s]"), state, outbuf );
			}
		}
		break;
	}
	Release( outbuf );
	return data;
}
char *SACK_BuildURL( struct url_data *data )
{
	PVARTEXT pvt = VarTextCreate();
	CTEXTSTR tmp = NULL;
	CTEXTSTR tmp2 = NULL;
	if( data->protocol )
		vtprintf( pvt, WIDE("%s://"), tmp = ConvertTextURI( data->protocol, StrLen( data->protocol ), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	// must be a user to use the password, setting just a password is an error really
	if( data->user )
		vtprintf( pvt, WIDE("%s%s%s@")
				  , tmp = ConvertTextURI( data->user, StrLen( data->user ), 0 )
				  , data->password?WIDE(":"):WIDE("")
				  , data->password?(tmp2 = ConvertTextURI( data->password, StrLen( data->password ), 0 )):WIDE("") );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( tmp2 )
	{
		Release( (POINTER)tmp2 );
		tmp2 = NULL;
	}
	if( data->host )
		vtprintf( pvt, WIDE("%s")
				  , tmp = ConvertTextURI( data->host, StrLen( data->host ), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->port )
		vtprintf( pvt, WIDE(":%d"), data->port );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_path )
		vtprintf( pvt, WIDE("/%s")
				  , tmp = ConvertTextURI( data->resource_path, StrLen( data->resource_path), 1 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_file )
		vtprintf( pvt, WIDE("/%s")
				  , tmp = ConvertTextURI( data->resource_file, StrLen( data->resource_file), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_extension )
		vtprintf( pvt, WIDE(".%s")
				  , tmp = ConvertTextURI( data->resource_extension, StrLen( data->resource_extension), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->resource_anchor )
		vtprintf( pvt, WIDE("#%s")
				  , tmp = ConvertTextURI( data->resource_anchor, StrLen( data->resource_anchor), 0 ) );
	if( tmp )
	{
		Release( (POINTER)tmp );
		tmp = NULL;
	}
	if( data->cgi_parameters )
	{
		int first = 1;
		INDEX idx;
		struct url_cgi_data *cgi_data;
		LIST_FORALL( data->cgi_parameters, idx, struct url_cgi_data *, cgi_data )
		{
			if( cgi_data->value )
				vtprintf( pvt, WIDE("%s%s=%s"), first?WIDE("?"):WIDE("&"), cgi_data->name, cgi_data->value );
			else
				vtprintf( pvt, WIDE("%s%s"), first?WIDE("?"):WIDE("&"), cgi_data->name );
			first = 0;
		}
	}
	{
		PTEXT text_result = VarTextGet( pvt );
		char *result = StrDup( GetText( text_result ) );
		return result;
	}
}
void SACK_ReleaseURL( struct url_data *data )
{
	struct url_cgi_data *cgi_data;
	INDEX idx;
	LIST_FORALL( data->cgi_parameters, idx, struct url_cgi_data *, cgi_data )
	{
		Release( (POINTER)cgi_data->name );
		Release( (POINTER)cgi_data->value );
	}
	DeleteList( &data->cgi_parameters );
	Release( (POINTER)data->protocol );
	Release( (POINTER)data->user );
	Release( (POINTER)data->password );
	Release( (POINTER)data->host );
	Release( (POINTER)data->resource_path );
	Release( (POINTER)data->resource_file );
	Release( (POINTER)data->resource_extension );
	Release( (POINTER)data->resource_anchor );
	Release( data );
}
HTTP_NAMESPACE_END
#define USES_OPTION_INTERFACE
#define DO_LOGGING
#ifndef SACKCOMM_SOURCE
#define SACKCOMM_SOURCE
#endif
 // show in and out data literally...
#define _TRACE_DATA_
//#define _TRACE_DATA_MIN
//#include <windows.h>
#if defined( _WIN32 ) || defined( __LINUX__ )
#endif
#if defined( __LINUX__ )
#include <sys/ioctl.h>
#include <termios.h>
 // O_RDWR
#endif
#define USE_REAL_FUNCTIONS
#ifndef SACKCOMM_PROTECT_ME_AGAINST_DOBULE_INCLUSION
#define SACKCOMM_PROTECT_ME_AGAINST_DOBULE_INCLUSION
#ifdef SACKCOMM_SOURCE
#define SACKCOMM_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SACKCOMM_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#define SACKCOMM_ERR_NONE_MORE (   2)
#define SACKCOMM_ERR_NONE_DONE (   1)
#define SACKCOMM_ERR_NONE      (   0)
#define SACKCOMM_ERR_ALLOC     (  -1)
#define SACKCOMM_ERR_COMM      (  -2)
#define SACKCOMM_ERR_TIMEOUT   (  -3)
#define SACKCOMM_ERR_PARTIAL   (  -4)
#define SACKCOMM_ERR_BUFSIZE   (  -5)
#define SACKCOMM_ERR_MORE      (  -6)
#define SACKCOMM_ERR_POINTER   (  -7)
#define SACKCOMM_ERR_UNDERFLOW ( -11)
#define SACKCOMM_ERR_BUSY      ( -12)
#define SACKCOMM_ERR_NOTOPEN   ( -13)
#define SACKCOMM_ERR_MIN -20
#ifdef __LINUX__
typedef void DCB;
typedef void COMSTAT;
#define STDPROC
#endif
SACKCOMM_PROC( void, SetCommRTS )( int nCommID, int iRTS );
SACKCOMM_PROC( int, SackFlushComm )(int iCommId, int iInOut);
SACKCOMM_PROC( int, SackGetCommState)(int iCommId, DCB FAR *lpDcb);
SACKCOMM_PROC( int, SackGetCommError)(int iCommId, COMSTAT FAR *lpStat);
SACKCOMM_PROC( int, SackSetCommState)(DCB FAR *lpDcb);
SACKCOMM_PROC( int, SackWriteComm)(int iCommId, void far *pBuf, int iChars);
SACKCOMM_PROC( int, SackReadComm)(int iCommId, void far *pBuf, int iChars);
SACKCOMM_PROC( int, SackCloseComm)(int iCommId);
typedef void (CPROC* CommReadCallback)( uintptr_t psv, int nCommId, POINTER buffer, int len );
SACKCOMM_PROC( int, SackOpenCommEx)(CTEXTSTR szPort, uint32_t uiRcvQ, uint32_t uiSendQ
											, CommReadCallback ReadCallback
					                  , uintptr_t psv );
#define SackOpenComm( szport, rq, sq ) SackOpenCommEx( szport, rq, sq, NULL, 0 )
SACKCOMM_PROC( void, SackSetReadCallback )( int nCommId
                                          , CommReadCallback Callback
                                          , uintptr_t psvRead );
SACKCOMM_PROC( int, SackClearReadCallback )( int iCommId
                                          , CommReadCallback );
SACKCOMM_PROC( int, SackCommReadBufferEx)( int iCommId, char *buffer, int len
						 , uint32_t timeout, int *pnCharsRead
									 DBG_PASS );
#define SackCommReadBuffer(c,b,l,t,pl) SackCommReadBufferEx( c,b,l,t,pl DBG_SRC )
SACKCOMM_PROC( int, SackCommReadDataEx)( int iCommId
						 , uint32_t timeout
						 , char **pBuffer
						 , int *pnCharsRead
						 DBG_PASS
					  );
#define SackCommReadData(c,t,pb,pn) SackCommReadDataEx( c,t,pb,pn DBG_SRC )
SACKCOMM_PROC( int,  SackCommWriteBufferEx)( int iCommId, char *buffer, int len
							  , uint32_t timeout DBG_PASS );
#define SackCommWriteBuffer(c,b,l,t) SackCommWriteBufferEx(c,b,l,t DBG_SRC)
SACKCOMM_PROC( void, SackCommFlush )( int nCommID );
// changes the read buffer size from 1024 to (bytes?)
SACKCOMM_PROC( void, SackSetBufferSize )( int iCommId
													 , int readlen );
#define WM_COMM_OPEN      WM_USER + 100
#define WM_COMM_CLOSE     WM_USER + 101
#define WM_COMM_WRITE     WM_USER + 102
#define WM_COMM_DATA      WM_USER + 103
#define WM_COMM_GETERROR  WM_USER + 104
#define WM_COMM_FLUSH     WM_USER + 105
#define WM_COMM_CLOSE_ALL WM_USER + 106
#define WM_COMM_PING      WM_USER + 107
// normal mode - everyone gets same data notifications
#define COM_PORT_OWN_SHARE 0
// exclusive - only this channel callback will get notification
#define COM_PORT_OWN_EXCLUSIVE 1
// normal mode but all channels except this one will get notification
#define COM_PORT_IGNORE 2
SACKCOMM_PROC( void, SackCommOwnPort )( int nCommID, CommReadCallback func, int own_flags );
#endif
int bLogDataXfer;
int gbLog;
 // if using real comm functions - this is not needed.
#ifndef USE_REAL_FUNCTIONS
#ifndef __LINUX__
static DCB stDcb;
#else
#endif
#endif
#ifdef __LINUX__
#ifndef B230400
#define B230400 230400
#endif
#endif
typedef struct callback_tag {
	CommReadCallback func;
	uintptr_t psvUserRead;
	int iTimer;
	struct callback_tag *next, **me;
	struct {
		BIT_FIELD skip_read : 1;
	} flags;
} CHANNEL_CALLBACK, *PCHANNEL_CALLBACK;
#define DEFAULT_READ_BUFFER 1024
typedef struct com_tracking_tag {
	TEXTCHAR  portname[24];
	uintptr_t     iCommId;
	int     iUsers;
	struct {
		BIT_FIELD bUseCarrierDetect : 1;
		BIT_FIELD bHaveCarrier : 1;
		BIT_FIELD bInRead : 1;
		BIT_FIELD bOutputOnly : 1;
		BIT_FIELD bDestroy : 1;
		BIT_FIELD bInTimer : 1;
		BIT_FIELD bOwned : 1;
   } flags;
   struct {
		char mybuffer[1024];
		char *buffer;
		int len;
		uint32_t timeout;
		  // this time will be set initially when the read starts,
		  // and will never be surpassed.
 // this is the presence of info here indicator.
		uint32_t dwEnd;
		int *pnCharsRead;
 // minor delay to glob reads...
		uint32_t dwLastRead;
 // current accumulator of total read.
		int nTotalRead;
	} current;
	PCHANNEL_CALLBACK callbacks;
   PCHANNEL_CALLBACK exclusive;
	char *pReadBuffer;
   int  nReadTotal;
	int  nReadLen;
#ifndef __LINUX__
	DCB     dcb;
	COMSTAT cs;
#endif
	struct com_tracking_tag *next;
	struct com_tracking_tag **me;
   CRITICALSECTION csOp;
} COM_TRACK, *PCOM_TRACK;
PCOM_TRACK pTracking;
static struct commlib_local_tag
{
	struct {
		BIT_FIELD bInited : 1;
	} flags;
} sack_com_local;
static void ComLocalInit( void )
{
	if( !sack_com_local.flags.bInited )
	{
#ifdef __NO_OPTIONS__
		bLogDataXfer = 0;
		gbLog = 0;
#else
		bLogDataXfer = SACK_GetPrivateProfileInt( WIDE("COM PORTS"), WIDE("Log IO"), 0, WIDE("comports.ini") );
		gbLog = SACK_GetPrivateProfileIntEx( WIDE("COM PORTS"), WIDE("allow logging"), 0, WIDE("comports.ini"), TRUE );
#endif
		sack_com_local.flags.bInited = 1;
	}
}
#if !defined( BCC16 ) && defined( _WIN32 )
//-----------------------------------------------------------------------
 int  ReadComm ( int nCom, POINTER buffer, int nSize )
{
	uint32_t nRead = 0;
	char *pBytes = (char*)buffer;
	int offset = 0;
	OVERLAPPED ovl;
	PCOM_TRACK FindComByNumber( int iCommId );
	PCOM_TRACK pct = FindComByNumber( nCom );
	if( !pct || pct->flags.bOutputOnly )
      return 0;
	ovl.Offset = 0;
	ovl.OffsetHigh = 0;
	ovl.hEvent = NULL;
   //if( gbLog )
	//	lprintf( "Reading... %d", nSize );
	while( offset < nSize &&
	       ReadFile( (HANDLE)(intptr_t)nCom, pBytes + offset, 1, (DWORD*)&nRead, NULL ) &&
	       nRead )
	{
		offset += nRead;
		nRead = 0;
	}
	return nRead + offset;
}
//-----------------------------------------------------------------------
int WriteComm( int nCom, POINTER buffer, uint32_t nSize )
{
	uint32_t nWritten;
   if( bLogDataXfer & 1 )
   {
	    int nOut = nSize;
		lprintf( WIDE("Send COM: dump buffer (%d)"), nSize );
		#if defined( _TRACE_DATA_MIN )
		   if( nOut > 16 ) nOut = 16;
		#endif
		LogBinary( (uint8_t*)buffer, nOut );
	}
	if( WriteFile( (HANDLE)(intptr_t)nCom, buffer, nSize, (DWORD*)&nWritten, NULL ) )
		return nWritten;
	return -1;
}
//-----------------------------------------------------------------------
uintptr_t OpenComm( CTEXTSTR name, int nInQueue, int nOutQueue )
{
   ComLocalInit();
	if( gbLog )
		Log1( WIDE("Going to open:%s"), name );
	{
		COMMTIMEOUTS timeout;
		HANDLE hCom = CreateFile( name, GENERIC_READ|GENERIC_WRITE
									  , FILE_SHARE_READ|FILE_SHARE_WRITE
									  , NULL
									  , OPEN_EXISTING
									  , FILE_ATTRIBUTE_NORMAL
									  , NULL );
		timeout.ReadIntervalTimeout =
#ifndef __NO_OPTIONS__
					SACK_GetPrivateProfileInt( name, WIDE( "port timeout" ), 100, WIDE( "comports.ini" ) );
#else
					100;
#endif
		timeout.ReadTotalTimeoutMultiplier = 1;
		timeout.ReadTotalTimeoutConstant = 1;
		timeout.WriteTotalTimeoutMultiplier = 1;
		timeout.WriteTotalTimeoutConstant = 1;
		SetCommTimeouts(hCom, &timeout);
		if( gbLog )
			Log2( WIDE("Result: %p %d"), hCom, GetLastError() );
		return (uintptr_t)hCom;
	}
}
//-----------------------------------------------------------------------
int CloseComm( int nDevice )
{
	return CloseHandle( (HANDLE)(intptr_t)nDevice );
}
//-----------------------------------------------------------------------
int GetCommError( int nCom, COMSTAT *pcs )
{
	uint32_t dwErrors;
	return ClearCommError( (HANDLE)(intptr_t)nCom, (DWORD*)&dwErrors, pcs );
}
//-----------------------------------------------------------------------
int FlushComm( int nComm, int nQueues )
{
	// hmm not sure how to implement this one...
	//xlprintf(LOG_NOISE)( WIDE("Flush comm - the fake one...") );
	return 0;
}
//-----------------------------------------------------------------------
#else
#if defined( __LINUX__ )
// Weee! Implement the messy system/core/base level functions here
// open/close/read/write...
//-----------------------------------------------------------------------
 int  ReadComm ( int nCom, POINTER buffer, int nSize )
{
	// single select?
	int n = 1024;
	if( ( ioctl( nCom, FIONREAD, &n ) ) >= 0 )
	{
		if( n )
		{
			//if( gbLog )
			//	lprintf( WIDE("Received data %d"), n );
			if( nSize < n )
				n = nSize;
			n = read( nCom, buffer, n );
			if( n < 0 && errno == EAGAIN )
			{
				if( gbLog )
					 lprintf( WIDE("wait for more data...") );
				return 0;
			}
			return n;
		}
	}
	else
	{
		lprintf( WIDE("read ioctl error: %d"), errno );
	}
	if( n == 0 )
	{
		errno = EAGAIN;
		return 0;
	}
	// else return ioctl errno...
	return -1;
}
//-----------------------------------------------------------------------
int WriteComm( int nCom, POINTER buffer, uint32_t nSize )
{
   return write( nCom, buffer, nSize );
}
//-----------------------------------------------------------------------
uintptr_t OpenComm( CTEXTSTR name, int nInQueue, int nOutQueue )
{
   ComLocalInit();
	if( gbLog )
		Log1( WIDE("Going to open:%s"), name );
   return open( name, O_RDWR|O_NONBLOCK|O_NOCTTY );
}
//-----------------------------------------------------------------------
int CloseComm( int nDevice )
{
   return close( nDevice );
}
//-----------------------------------------------------------------------
int GetCommError( int nCom, COMSTAT *pcs )
{
   return errno;
}
//-----------------------------------------------------------------------
int FlushComm( int nComm, int nQueues )
{
	// hmm not sure how to implement this one...
	//xlprintf(LOG_NOISE)( WIDE("Flush comm - the fake one...") );
	return 0;
}
#endif
#endif
//-----------------------------------------------------------------------
PCOM_TRACK FindComByName( CTEXTSTR szPort )
{
	PCOM_TRACK check = pTracking;
	while( check )
	{
		if( !check->flags.bDestroy )
			if( StrCaseCmpEx( szPort, check->portname, sizeof(check->portname) ) == 0 )
				return check;
		check = check->next;
	}
	return NULL;
}
//-----------------------------------------------------------------------
PCOM_TRACK FindComByNumber( int iCommId )
{
	PCOM_TRACK check = pTracking;
	while( check )
	{
		if( check->iCommId == (uintptr_t)iCommId )
			return check;
		check = check->next;
	}
	return NULL;
}
//-----------------------------------------------------------------------
PCOM_TRACK AddComTracking( CTEXTSTR szPort, uintptr_t iCommId )
{
	PCOM_TRACK pComTrack = New( COM_TRACK );
	memset( pComTrack, 0, sizeof( *pComTrack ) );
	if( ( pComTrack->next = pTracking ) )
		pTracking->me = &pComTrack->next;
	pComTrack->me = &pTracking;
	pComTrack->iUsers = 1;
	pTracking = pComTrack;
	StrCpyEx( pComTrack->portname, szPort, sizeof(pComTrack->portname)  );
	pComTrack->portname[sizeof( pComTrack->portname) - 1] = 0;
	pComTrack->iCommId = iCommId;
	pComTrack->pReadBuffer = NewArray( char, DEFAULT_READ_BUFFER );
	pComTrack->nReadTotal = DEFAULT_READ_BUFFER;
   InitializeCriticalSec( &pComTrack->csOp );
	return pComTrack;
}
//-----------------------------------------------------------------------
void RemoveComTracking( PCOM_TRACK pComTrack )
{
	if( pComTrack->flags.bInTimer )
	{
		pComTrack->flags.bDestroy = 1;
		return;
	}
	//Log2( WIDE("Unlink... %p %p"),pComTrack->me, pComTrack->next );
	if( ( (*pComTrack->me) = pComTrack->next ) )
		pComTrack->next->me = pComTrack->me;
	//xlprintf(LOG_NOISE)( WIDE("Release redbuffer...") );
	Release( pComTrack->pReadBuffer );
	//xlprintf(LOG_NOISE)( WIDE("Release comtrack..") );
	Release( pComTrack );
}
//-----------------------------------------------------------------------
static int
    ParseComString ( const TEXTCHAR far *p
                   , uint32_t far *pBaud
                   , int far *pPar
                   , int far *pData
                   , int far *pStop
                   , int *piCarrier
                   , int *piRTS
                   , int *piRTSFlow
                   , const TEXTCHAR far * far *ppErr
                   )
{
  int iPar = 0, iData, iStop;
  uint32_t dwBaud;
//#if defined( _WIN32 ) || defined( BCC16 )
  dwBaud = (uint32_t)IntCreateFromText( p );
  p = strchr( p, ',' );
  if ( *p != ',' )
  {
    if ( ppErr )
      *ppErr = WIDE( "{baud}?" );
    return -5;
  }
  p++;
  if ( *p == 'e' || *p == 'E' )
  {
#ifdef __LINUX__
     iPar = PARENB;
#else
		iPar = EVENPARITY;
#endif
  }
  else if ( *p == 'm' || *p == 'M' )
  {
#define CNSPAR 010000000000
#ifdef __LINUX__
		iPar = CNSPAR|PARENB|PARODD;
#else
		iPar = MARKPARITY;
#endif
  }
  else
  if ( *p == 'n' || *p == 'N' )
  {
#ifdef __LINUX__
     iPar = 0;
#else
    iPar = NOPARITY;
#endif
  }
  else
  if ( *p == 'o' || *p == 'O' )
  {
#ifdef __LINUX__
		iPar = PARODD|PARENB;
#else
    iPar = ODDPARITY;
#endif
  }
  else
  if ( *p == 's' || *p == 'S' )
  {
#ifdef __LINUX__
		iPar = CNSPAR|PARENB;
#else
    iPar = ODDPARITY;
#endif
  }
  else
  {
    if ( ppErr )
      *ppErr = WIDE( "{baud},?" );
    return -6;
  }
  p++;
  if ( *p != ',' )
  {
    if ( ppErr )
      *ppErr = WIDE( "{baud},{parity}?" );
    return -7;
  }
  p++;
  if ( *p < '4' || *p > '8' )
  {
    if ( ppErr )
      *ppErr = WIDE( "{baud},{parity},?" );
    return -8;
  }
#ifdef __LINUX__
  switch( *p )
  {
  case '5':
		iData = CS5;
     break;
  case '6':
		iData = CS6;
     break;
  case '7':
		iData = CS7;
     break;
  case '8':
		iData = CS8;
     break;
  }
#else
  iData = *p - '0';
#endif
  p++;
  if ( *p != ',' )
  {
    if ( ppErr )
      *ppErr = WIDE( "{baud},{parity},{data}?" );
    return -9;
  }
  p++;
  if ( p[0] == '2' && p[1] != '.' )
  {
    p++;
#ifdef __LINUX__
    iStop = CSTOPB;
#else
    iStop = TWOSTOPBITS;
#endif
  }
  else
  if ( p[0] == '1' && p[1] != '.' )
  {
    p++;
#ifdef __LINUX__
    iStop = 0;
#else
    iStop = ONESTOPBIT;
#endif
  }
  else
  if ( p[0] == '1' && p[1] == '.' && p[2] == '5' )
  {
	   p+= 3;
#ifdef __LINUX__
    iStop = CSTOPB;
#else
	 iStop = ONE5STOPBITS;
#endif
  }
  else
  {
    if ( ppErr )
      *ppErr = WIDE( "{baud},{parity},{data},?" );
    return -10;
  }
  if( p[0] == ',' )
  {
		  p++;
		  if( p[0] == 'C' )
		  {
				  if( piCarrier ) *piCarrier = 1;
		  }
		  else
				  if( piCarrier ) *piCarrier = 0;
		  while( p[0] && p[0] != ',' ) p++;
  }
  if( p[0] == ',' )
  {
		  p++;
		  if( p[0] == 'R' )
		  {
				  if( piRTS ) *piRTS = 1;
		  }
		  else
				  if( piRTS ) *piRTS = 0;
		  while( p[0] && p[0] != ',' ) p++;
  }
  if( p[0] == ',' )
  {
		  p++;
		  if( p[0] == 'R' )
		  {
				  if( piRTSFlow ) *piRTSFlow = 1;
		  }
		  else
				  if( piRTSFlow ) *piRTSFlow = 0;
		  while( p[0] && p[0] != ',' ) p++;
  }
  if( dwBaud & 0xFFFF8000 )
  {
#ifdef __LINUX__
		if( dwBaud == 230400ul )
		{
        dwBaud = B230400;
		}
		else
#endif
		  if( dwBaud == 256000ul )
		{
#ifndef __LINUX__
			dwBaud = CBR_256000;
#endif
		  }
		  else if( dwBaud == 115200ul )
		{
#ifdef __LINUX__
        dwBaud = B115200;
#else
#if defined( WIN32 )
			dwBaud = CBR_115200;
#elif defined( BCC16 )
			dwBaud = 0xFEFF;
#else
#error no baud defined for this compiler.
#endif
#endif
		  }
		  else if( dwBaud == 128000ul )
		{
#ifndef __LINUX__
			dwBaud = CBR_128000;
#endif
		  }
		  else
		  {
				  if( (dwBaud != 57600ul) && (dwBaud != 38400ul) )
				  {
		       static TEXTCHAR buf[64];
		       tnprintf( buf, sizeof( buf ), WIDE("Invalid Baud rate %08x"), dwBaud );
				  if ( ppErr )
					    *ppErr = buf;
				return -15;
			}
#ifdef __LINUX__
			else
				if( dwBaud == 57600ul )
					dwBaud = B57600;
				else if( dwBaud == 38400ul )
					dwBaud = B38400;
#endif
     }
   }
   else
		switch ( dwBaud )
		{
#ifdef __LINUX__
		case 19200ul:  dwBaud = B19200;  break;
		case 9600ul:   dwBaud = B9600;   break;
		case 4800ul:   dwBaud = B4800;   break;
		case 2400ul:   dwBaud = B2400;   break;
		case 1200ul:   dwBaud = B1200;   break;
		case 600ul:    dwBaud = B600;    break;
		case 300ul:    dwBaud = B300;    break;
		case 110ul:    dwBaud = B110;    break;
#else
//  case 28000ul:  dwBaud = CBR_28000;  break;
    case 19200ul:  dwBaud = CBR_19200;  break;
    case 14400ul:  dwBaud = CBR_14400;  break;
    case 9600ul:   dwBaud = CBR_9600;   break;
//  case 9200ul:   dwBaud = CBR_9200;   break;
//  case 8400ul:   dwBaud = CBR_8400;   break;
//  case 6000ul:   dwBaud = CBR_6000;   break;
    case 4800ul:   dwBaud = CBR_4800;   break;
//  case 4400ul:   dwBaud = CBR_4400;   break;
    case 2400ul:   dwBaud = CBR_2400;   break;
    case 1200ul:   dwBaud = CBR_1200;   break;
    case 600ul:    dwBaud = CBR_600;    break;
    case 300ul:    dwBaud = CBR_300;    break;
		case 110ul:    dwBaud = CBR_110;    break;
#endif
    default:
#ifndef HIWORD
#define HIWORD(n) (((n)>>16)&0xFFFF)
#endif
      if ( HIWORD(dwBaud) )
      {
	      static TEXTCHAR buf[64];
	      tnprintf( buf, sizeof( buf ), WIDE("Invalid Baud rate %08x"), dwBaud );
			  if ( ppErr )
			    *ppErr = buf;
          return -15;
      }
      break;
  }
  if ( pBaud ) *pBaud = (uint32_t)dwBaud;
  if ( pPar ) *pPar = iPar;
  if ( pData ) *pData = iData;
  if ( pStop ) *pStop = iStop;
//#endif
  return 0;
}
//-----------------------------------------------------------------------
int iTimerId;
#if defined _WIN32 || defined( __LINUX__ )
static void CPROC ReadTimer( uintptr_t psv )
#else
CALLBACKPROC( void, ReadTimer)( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
#endif
{
	PCOM_TRACK pct;
	//static uint32_t timer_ticks;
   static uint32_t start;
	for( pct = pTracking; pct; pct = pct->next )
	{
		if( pct->flags.bOutputOnly )
         continue;
		if( pct->callbacks )
		{
			int len;
			pct->flags.bInTimer = 1;
         EnterCriticalSec( &pct->csOp );
			len = ReadComm( (int)pct->iCommId
							  , pct->pReadBuffer + pct->nReadLen
							  , pct->nReadTotal - pct->nReadLen);
			LeaveCriticalSec( &pct->csOp );
			if( ( len > 0 ) || ( len < 0 ) )
			{
				if( len < 0 )
				{
					if( gbLog )
						lprintf( WIDE("!!!!!!! Some sort of com error occured...%d"), errno );
					// flush this data out...
					goto issue_callbacks;
					len = -len;
				}
				else
					start = GetTickCount() + 10;
				pct->nReadLen += len;
			}
			// if we didn't read anything, and have previosly read...
									// or if the buffer is totally full now...
         //lprintf( WIDE("len %d last %d start %d max %d"), len, pct->nReadLen, start, DEFAULT_READ_BUFFER );
			if( ( !len && pct->nReadLen && (start < GetTickCount()) ) ||
			    pct->nReadLen == pct->nReadTotal )
			{
				PCHANNEL_CALLBACK pcc, pccNext;
issue_callbacks:
				pcc = pct->callbacks;
				//lprintf( WIDE("log %d and log %d"), gbLog, bLogDataXfer );
				if( gbLog )
				{
					//Log1( WIDE("Dump information to people with callbacks...%d"), pct->nReadLen );
					if( bLogDataXfer & 2 )
					{
						lprintf( WIDE("COM Receive") );
						LogBinary( (uint8_t*)pct->pReadBuffer
								  , pct->nReadLen );
					}
				}
				while( pcc )
				{
					pccNext = pcc->next;
					// THIS pcc may go away, hopefully the NEXT won't...
					//lprintf( "pcc is %p exclus %p owned %d", pcc, pct->exclusive, pct->flags.bOwned );
					if( ( pct->flags.bOwned && ( pcc == pct->exclusive ) )
						|| !pct->flags.bOwned )
					{
						if( pcc->func )
						{
							if( !pcc->flags.skip_read )
								pcc->func( pcc->psvUserRead
											, (int)pct->iCommId
											, pct->pReadBuffer
											, pct->nReadLen );
						}
					}
					pcc = pccNext;
				}
				// reset amount of data read.
				pct->nReadLen = 0;
			}
			pct->flags.bInTimer = 0;
			if( pct->flags.bDestroy )
			{
				RemoveComTracking( pct );
				// just get out... we probably lost the tracking in process
				// pointers are all mislinked...
				// and it's just bad.
				return;
			}
		}
	}
}
//-----------------------------------------------------------------------
uintptr_t CPROC ReadThread( PTHREAD thread )
{
   iTimerId = 1;
	while( 1 )
	{
		ReadTimer(0);
      WakeableSleep( 10 );
	}
   return 0;
}
#ifdef __LINUX__
void DumpTermios( struct termios *opts )
{
	if( !gbLog )
      return;
   lprintf( WIDE("iflag %x"), opts->c_iflag );
   lprintf( WIDE("oflag %x"), opts->c_oflag );
   lprintf( WIDE("cflag %x"), opts->c_cflag );
	lprintf( WIDE("lflag %x"), opts->c_lflag );
#ifndef __ARM__
	lprintf( WIDE("ispeed: %x"), opts->c_ispeed );
	lprintf( WIDE("ospeed: %x"), opts->c_ospeed );
#endif
}
#endif
//-----------------------------------------------------------------------
 int  SackOpenCommEx(CTEXTSTR szPort, uint32_t uiRcvQ, uint32_t uiSendQ
              , CommReadCallback func
              , uintptr_t psvRead
                  )
{
#ifdef USE_REAL_FUNCTIONS
	PCOM_TRACK pct;
	ComLocalInit();
	{
		int iPar, iData, iStop, iCarrier, iRTS, iRTSFlow;
		uint32_t wBaud;
		const TEXTCHAR far *szErr;
		TEXTCHAR szInit[64];
		// capital letters on carrier, rts, rtsflow mean to enable - otherwise
		// don't pay attention to those signals.
#ifndef __NO_OPTIONS__
		SACK_GetPrivateProfileString( WIDE("COM PORTS"), szPort, WIDE("57600,N,8,1,cARRIER,RTS,rTSFLOW"), szInit, sizeof( szInit ), WIDE("comports.ini") );
#else
#ifdef _WIN32
		GetPrivateProfileString( WIDE("COM PORTS"), szPort, WIDE(""), szInit, sizeof( szInit ), WIDE("comports.ini") );
		if( !szPort[0] ) {
			WritePrivateProfileString( WIDE("COM PORTS"), szPort, WIDE("57600,N,8,1,cARRIER,RTS,rTSFLOW"), WIDE("comports.ini") );
		}
#else
		StrCpy( szInit, "57600,N,8,1,cARRIER,RTS,rTSFLOW" );
#endif
#endif
#if defined(  _WIN32 ) || defined( __LINUX__ )
		if( !iTimerId )
		{
			// this timer is constantly getting scheduled later than it thinks it should be.
			ThreadTo( ReadThread, 0 );
			//iTimerId = AddTimer( 10, ReadTimer, 0 );
		}
#else
		if( !iTimerId )
		    iTimerId = SetTimer( NULL, 100, 10, (TIMERPROC)ReadTimer );
#endif
		if ( ParseComString ( szInit, &wBaud, &iPar
	                      , &iData, &iStop
	                      , &iCarrier
	                      , &iRTS, &iRTSFlow
	                      , &szErr ) )
		{
#ifndef __LINUX__
	    MessageBox ( (HWND)NULL, szErr, WIDE("SackOpenComm: invalid init string")
		             , MB_OK | MB_ICONHAND );
	    MessageBox ( (HWND)NULL, szInit, WIDE("SackOpenComm: invalid init string")
						, MB_OK | MB_ICONHAND );
#endif
	    return FALSE;
		}
		if( ( pct = FindComByName( szPort ) ) )
		{
			if( func )
			{
				PCHANNEL_CALLBACK pcc = New( CHANNEL_CALLBACK );
				pcc->flags.skip_read = 0;
				pcc->iTimer = 0;
				pcc->func = func;
				pcc->psvUserRead = psvRead;
				if( ( pcc->next = pct->callbacks ) )
					pct->callbacks->me = &pcc->next;
				pcc->me = &pct->callbacks;
				pct->callbacks = pcc;
			}
			if( gbLog )
				Log1( WIDE("Resulting in comm already open...: %s"), szPort );
			pct->iUsers++;
			return (int)pct->iCommId;
		}
		else
		{
			uintptr_t iCommId = OpenComm( szPort, uiRcvQ, uiSendQ );
			if( gbLog )
				lprintf( WIDE("attempted to open: %s result %p"), szPort, (void*)iCommId );
			if( (int)iCommId >= 0 )
			{
				pct = AddComTracking( szPort, iCommId );
				if( StrCaseCmpEx( szPort, WIDE("lpt"), 3 ) != 0 )
				{
					pct->flags.bOutputOnly = 0;
					SackFlushComm( (int)iCommId, 0 );
					SackFlushComm( (int)iCommId, 1 );
#ifndef __LINUX__
#ifdef BCC16
					pct->dcb.Id          = iCommId;
#else
					pct->dcb.DCBlength   = sizeof( pct->dcb );
#endif
					pct->dcb.BaudRate    = wBaud;
					pct->dcb.ByteSize    = iData;
					pct->dcb.Parity      = iPar;
					pct->dcb.StopBits    = iStop;
 // yes! we want binary.
					pct->dcb.fBinary     = 1;
#ifdef BCC16
					pct->dcb.fRtsDisable = iRTS;
					pct->dcb.fRtsflow    = iRTSFlow;
#else
					if( iRTS && iRTSFlow )
						pct->dcb.fRtsControl = RTS_CONTROL_TOGGLE;
					else if( iRTS )
						pct->dcb.fRtsControl = RTS_CONTROL_ENABLE;
					else
						pct->dcb.fRtsControl = RTS_CONTROL_DISABLE;
#endif
					pct->dcb.fDtrControl = DTR_CONTROL_ENABLE;
 // try this - remove maybe.
					pct->flags.bUseCarrierDetect = iCarrier;
					lprintf( WIDE( " pct->dcb.BaudRate is %lu pct->dcb.ByteSize is %lu pct->dcb.Parity is %lu pct->dcb.fRtsControl is %lu " )
					       , pct->dcb.BaudRate
					       , pct->dcb.ByteSize
					       , pct->dcb.Parity
					       , pct->dcb.fRtsControl
					);
				//EscapeCommFunction( (HANDLE)(intptr_t)iCommId, SETDTR );
				//EscapeCommFunction( (HANDLE)(intptr_t)iCommId, SETRTS );
				//SETDTR
#ifdef BCC16
					if ( SetCommState( &pct->dcb ) )
#else
					 if ( !SetCommState( (HANDLE)(intptr_t)iCommId, &pct->dcb ) )
#endif
					{
#ifdef _WIN32
						lprintf( WIDE("Open: Invalid initialization string %d"), GetLastError() );
#endif
						SackCloseComm( (int)iCommId );
						iCommId = -1;
					}
#else
					{
						struct termios opts;
						tcgetattr( iCommId, &opts );
						DumpTermios(&opts);
						//opts.c_iflag &= ~(BRKINT|PARMRK|INPCK|ISTRIP|INLCR|IXON|IXOFF|IMAXBEL);
						opts.c_iflag = 0;
						opts.c_iflag |= IGNBRK|IGNPAR|IGNCR|IXANY;
						//opts.c_oflag &= ~(OLCUC|ONLCR|OCRNL|ONOCR|ONLRET|OFILL|OFDEL|NLDLY|TABDLY|BSDLY|VTDLY|FFDLY);
						opts.c_oflag = 0;
 // looks like nothing special to output...
						opts.c_oflag |= 0;
						//opts.c_cflag &= ~(CNSPAR|PARENB|PARODD|CSIZE|CSTOPB|CRTSCTS|CLOCAL);
						opts.c_cflag = 0;
						opts.c_cflag |= iPar | iData | iStop | wBaud | CREAD | CLOCAL;
						//opts.c_lflag &= ~(ISIG|ICANON|XCASE|ECHO|ECHOE|ECHOK|ECHONL|ECHOCTL...);
						opts.c_lflag = 0;
						opts.c_lflag |= 0;
						opts.c_cc[VMIN] = 1;
						opts.c_cc[VTIME] = 0;
						cfsetospeed( &opts, wBaud );
						cfsetispeed( &opts, 0 );
						DumpTermios(&opts);
						if( tcsetattr( iCommId, TCSANOW, &opts ) )
							lprintf( WIDE("tcsetattr failed: %d"), errno );
					}
					// setup the com port here (termios)
#endif
				}
				else
				{
					pct->flags.bOutputOnly = 1;
				}
			}
			//else
			//	xlprintf(LOG_NOISE)( WIDE("Failed!") );
			if( (int)iCommId >= 0 )
			{
				if( func )
				{
					PCHANNEL_CALLBACK pcc = New( CHANNEL_CALLBACK );
					pcc->flags.skip_read = 0;
					pcc->iTimer = 0;
					pcc->func = func;
					pcc->psvUserRead = psvRead;
					if( ( pcc->next = pct->callbacks ) )
						pct->callbacks->me = &pcc->next;
					pcc->me = &pct->callbacks;
					pct->callbacks = pcc;
				}
			}
			//xlprintf(LOG_NOISE)( WIDE("Resulting to the client...") );
			return  (int)iCommId;
		}
	}
#else
 //some non-zero comm id
	return 42;
#endif
}
//-----------------------------------------------------------------------
 void  SackSetBufferSize ( int iCommId
													 , int readlen )
{
	PCOM_TRACK pct;
	pct = FindComByNumber( iCommId );
	lprintf( WIDE( "updating read length to %d %p %d" ), iCommId, pct, pct->nReadTotal );
	if( pct )
	{
		if( readlen < DEFAULT_READ_BUFFER )
		{
         lprintf( WIDE( "updating read length to %d" ), pct->nReadTotal );
			pct->nReadTotal = readlen;
		}
	}
}
 void  SackSetReadCallback ( int iCommId
                                          , CommReadCallback f
										              , uintptr_t psvRead )
{
	PCOM_TRACK pct;
	pct = FindComByNumber( iCommId );
	if( pct )
	{
		PCHANNEL_CALLBACK pcc = New( CHANNEL_CALLBACK );
		pcc->flags.skip_read = 0;
		pcc->iTimer = 0;
		pcc->func = f;
		pcc->psvUserRead = psvRead;
		if( ( pcc->next = pct->callbacks ) )
			pct->callbacks->me = &pcc->next;
		pcc->me = &pct->callbacks;
		pct->callbacks = pcc;
	}
	else
	{
		Log1( WIDE("Comm ID %d is not open?"), iCommId );
	}
}
 int  SackClearReadCallback ( int iCommId
                                          ,  CommReadCallback func )
{
	PCOM_TRACK pct;
	pct = FindComByNumber( iCommId );
	if( pct )
	{
		PCHANNEL_CALLBACK pcc = pct->callbacks;
		while( pcc )
		{
			if( pcc->func == func )
			{
				if( ( *(pcc->me) = pcc->next ) )
					pcc->next->me = pcc->me;
				break;
			}
			pcc = pcc->next;
		}
		if( pcc )
		{
			Release( pcc );
			Log1( WIDE("Comm ID %d had the callback, successfully removed"), iCommId );
			return TRUE;
		}
		else
		{
			Log1( WIDE("Comm ID %d did not have the specified read callback"), iCommId );
		}
	}
	else
	{
		Log1( WIDE("Comm ID %d is not open?"), iCommId );
	}
	return FALSE;
}
//-----------------------------------------------------------------------
 int  SackCloseComm(int iCommId)
{
#ifdef USE_REAL_FUNCTIONS
	 PCOM_TRACK pct = FindComByNumber( iCommId );
	 if( pct && !(--pct->iUsers ) )
	 {
		 // destroy pct here...
		 CloseComm( iCommId );
		 RemoveComTracking( pct );
		 return 1;
	 }
	 else
		 return 0;
#else
 //0 means success
    return 0;
#endif
}
//-----------------------------------------------------------------------
 int  SackReadComm(int iCommId, void far *pBuf, int iChars)
{
#ifdef USE_REAL_FUNCTIONS
    return ReadComm( iCommId, pBuf, iChars );
#else
 //Always return zero characters read
    return 0;
#endif
}
//-----------------------------------------------------------------------
 int  SackWriteComm(int iCommId, void far *pBuf, int iChars)
{
#ifdef USE_REAL_FUNCTIONS
	return WriteComm( iCommId, pBuf, iChars );
#else
 //All supplied characters successfully written!
    return iChars;
#endif
}
//-----------------------------------------------------------------------
#ifndef __LINUX__
 int  SackSetCommState(DCB FAR *lpDcb)
{
#ifdef USE_REAL_FUNCTIONS
#ifdef BCC16
	 return SetCommState( lpDcb );
#else
	xlprintf(LOG_NOISE)( WIDE("SackSetCommState cannot work in 32 bit system") );
	return 0;
#endif
#else
  //Save DCB for possible
    if (!IsBadReadPtr(lpDcb, sizeof(DCB)))
 //Later retrieval
        memcpy(&stDcb, lpDcb, sizeof(DCB));
 //0 means success
    return 0;
#endif
}
#endif
//-----------------------------------------------------------------------
#ifndef __LINUX__
 int  SackGetCommState(int iCommId, DCB FAR *lpDcb)
{
#ifdef USE_REAL_FUNCTIONS
#ifdef BCC16
	return GetCommState( iCommId, lpDcb );
#else
	return GetCommState( (HANDLE)(intptr_t)iCommId, lpDcb );
#endif
#else
 //Return passed DCB
    if (!IsBadWritePtr(lpDcb, sizeof(DCB)))
 //See! It matches!
        memcpy(lpDcb, &stDcb, sizeof(DCB));
 //0 means success
    return 0;
#endif
}
#endif
//-----------------------------------------------------------------------
 int  SackFlushComm(int iCommId, int iInOut)
{
#ifdef USE_REAL_FUNCTIONS
	 return FlushComm( iCommId, iInOut );
#else
 //0 means success
    return 0;
#endif
}
//-----------------------------------------------------------------------
 int  SackGetCommError(int iCommId, COMSTAT FAR *lpStat)
{
#ifdef USE_REAL_FUNCTIONS
	return GetCommError( iCommId, lpStat );
#else
    if (lpStat != NULL && !IsBadWritePtr(lpStat, sizeof(COMSTAT)))
    {
      //
        lpStat->status = 0;
     // Return all is well
        lpStat->cbInQue = 0;
    //
        lpStat->cbOutQue = 0;
    }
    return 0;
#endif
}
//-----------------------------------------------------------------------
 int  SackCommReadBufferEx( int iCommId, char *buffer, int len
												 , uint32_t timeout, int *pnCharsRead
												 DBG_PASS
												 )
{
   int iResult = SACKCOMM_ERR_NONE;
   int nCharsRead;
	PCOM_TRACK pComTrack = FindComByNumber( iCommId );
	uint32_t dwEnd = GetTickCount() + timeout;
	if( !pComTrack )
		return SACKCOMM_ERR_NOTOPEN;
	if( pComTrack->flags.bInRead )
	{
		xlprintf(LOG_NOISE)( WIDE("Result busy in comm read buffer") );
		return SACKCOMM_ERR_BUSY;
	}
  /********************************************************************  * ASSERT pointer(s)                                                  *
  \********************************************************************/
  if( !pnCharsRead )
  {
	  xlprintf(LOG_NOISE)( WIDE("Failing - bad return count") );
	  return SACKCOMM_ERR_BUFSIZE;
  }
  if( !buffer )
  {
		  xlprintf(LOG_NOISE)( WIDE("Failing - bad buffer") );
		  return SACKCOMM_ERR_POINTER;
  }
   pComTrack->flags.bInRead = 1;
   if( gbLog )
		Log2( DBG_FILELINEFMT WIDE("comm read buffer len:%d timeout:%d") DBG_RELAY, len, timeout );
   if( !pComTrack->current.dwEnd )
   {
	   // save this information for later use...
	   pComTrack->current.dwEnd = dwEnd;
	   pComTrack->current.buffer = buffer;
	   pComTrack->current.len = len;
      pComTrack->current.timeout = timeout;
      pComTrack->current.pnCharsRead = pnCharsRead;
      pComTrack->current.dwLastRead = 0;
 // nothing read.
      pComTrack->current.nTotalRead = 0;
   }
   else
   {
	   if( buffer != pComTrack->current.buffer ||
	       len != pComTrack->current.len ||
          timeout != pComTrack->current.timeout )
      {
         // hmm...
	      xlprintf(LOG_NOISE)( WIDE("********* Read is not the same as the exsiting read.") );
	      pComTrack->flags.bInRead = 0;
	      return SACKCOMM_ERR_BUSY;
      }
	   if( gbLog )
			xlprintf(LOG_NOISE)( WIDE("Resuming previous read...") );
   }
  //assert_far_call ( ! IsBadWritePtr(pnCharsRead,sizeof(*pnCharsRead))
  //                , WIDE("SackCommReadBuffer: bad pnCharsRead") );
  /*********************************************************************  * As per the original code, the communications channel is checked for *
  * a pre-existing error condition.  This is done to clear the error    *
  * before any reading is done.  Otherwise, the error condition will    *
  * persist for any further communication.                              *
  * NOTE: the original code assigned the result to the static variable  *
  * nCommError inside of ReadCommandBlock.  At this stage, this served  *
  * no purpose and the result was never used, so the assignment has been*
  * removed                                                             *
  \*********************************************************************/
#ifndef __LINUX__
			SackGetCommError ( iCommId, &pComTrack->cs );
#endif
  /*********************************************************************  * Presumeably, this call is being made in a response to a request for *
  * data.  So, give the unit a chance to respond by waiting until either*
  * there is data to be read, until the unit has "timed out", or until  *
  * the unit is no longer connected.                                    *
  \*********************************************************************/
	if(  pComTrack->flags.bUseCarrierDetect &&
	    !pComTrack->flags.bHaveCarrier )
	{
#ifndef __LINUX__
#ifdef BCC16
		uint32_t iEvents;
		iEvents = GetCommEventMask( iCommId, 0xFFFF );
		if( iEvents & EV_RLSDS )
#else
		uint32_t iEvents;
		GetCommMask( (HANDLE)(intptr_t)iCommId, (DWORD*)&iEvents );
		if( !(iEvents & EV_RLSD ) )
#endif
		{
			pComTrack->flags.bHaveCarrier = 1;
		}
		else
		{
			xlprintf(LOG_NOISE)( WIDE("No Carrier - failing read. ") );
			*pnCharsRead = 0;
			pComTrack->flags.bInRead = 0;
			if( gbLog )
				xlprintf(LOG_NOISE)( WIDE("Leave comm read buffer") );
			pComTrack->current.dwEnd = 0;
			return SACKCOMM_ERR_TIMEOUT;
		}
#endif
	}
   do
   {
    /*****************************************************************    * The order here has been carefully chosen to minimize delays.    *
    * First, read the communications port.                            *
    \*****************************************************************/
    // don't call stub version - no change - but less confusion.
		nCharsRead = ReadComm ( iCommId
                          , buffer + pComTrack->current.nTotalRead
                          , len - pComTrack->current.nTotalRead );
    /*****************************************************************    * If data was read in without error (the normal condition), then  *
    * go ahead and break out of the loop, we're done.                 *
    \*****************************************************************/
		if ( nCharsRead > 0 )
		{
			if( bLogDataXfer & 2 )
			{
				xlprintf(LOG_NOISE)( WIDE("Recv COM: dump buffer") );
				//xlprintf(LOG_NOISE)( buffer + pComTrack->current.nTotalRead, nCharsRead );
			}
			pComTrack->current.dwLastRead = GetTickCount();
			pComTrack->current.nTotalRead += nCharsRead;
			if( pComTrack->current.nTotalRead == len )
			{
				*pnCharsRead = pComTrack->current.nTotalRead;
				pComTrack->flags.bInRead = 0;
				xlprintf(LOG_NOISE)( WIDE("Return buffer full.") );
				pComTrack->current.dwEnd = 0;
				return SACKCOMM_ERR_NONE;
			}
			//Log1( WIDE("SackCommReadBuffer => SUCCESS : %d"), nCharsRead );
 // try reading some more...
			continue;
		}
    /*****************************************************************    * If the read was an error, then display the error message(s) to  *
    * the user and break with an error.                               *
    \*****************************************************************/
		if ( nCharsRead < 0 )
		{
			TEXTCHAR cOut[128];
			int  nCommError;
#ifndef __LINUX__
			nCommError = SackGetCommError ( iCommId, &pComTrack->cs );
#else
			nCommError = 0;
#endif
			tnprintf ( cOut, sizeof( cOut ), WIDE("SackCommReadBuffer: read %d chars, error=%d")
               , nCharsRead, nCommError );
			xlprintf(LOG_NOISE)( WIDE("%s"), cOut );
#ifndef __LINUX__
			lprintf ( WIDE("    cs.status=%u,0x%02X  cs.in=%u  cs.out=%u")
#ifdef BCC_16
               , pComTrack->cs.status
#else
               , *(uint32_t*)&pComTrack->cs
#endif
               , pComTrack->cs.cbInQue
					, pComTrack->cs.cbOutQue );
#endif
			iResult = SACKCOMM_ERR_COMM;
		}
 // no data, check timeout
		else if( GetTickCount() >= pComTrack->current.dwEnd )
		{
			/*****************************************************************			* If we have exceeded the timeout limit, then set the error.      *
			\*****************************************************************/
			if( pComTrack->current.nTotalRead )
			{
		    // can't get this message - the above code leaves with any data.
				_lprintf( DBG_RELAY )( WIDE( "SackCommReadBuffer() => TIMEOUT (WITH DATA %d)" )
	                 , pComTrack->current.nTotalRead );
				iResult = SACKCOMM_ERR_NONE;
 // get out of this loop.
				break;
			}
			else
			{
				if( pComTrack->flags.bUseCarrierDetect )
				{
#ifndef __LINUX__
#ifdef BCC16
					uint32_t iEvents;
					iEvents = GetCommEventMask( iCommId, 0xFFFF );
					if( !(iEvents & EV_RLSDS) )
#else
					uint32_t iEvents;
					GetCommMask( (HANDLE)(intptr_t)iCommId, (DWORD*)&iEvents );
					if( !(iEvents & EV_RLSD ) )
#endif
					{
						lprintf( WIDE("SackCommReadBuffer() => TIMEOUT(No Carrier)") );
						pComTrack->flags.bHaveCarrier = 0;
					}
					else
					{
						lprintf( WIDE("SackCommReadBuffer() => TIMEOUT(With carrier)") );
						iResult = SACKCOMM_ERR_TIMEOUT;
					}
#endif
				}
				else
				{
					lprintf( WIDE("SackCommReadBuffer() => TIMEOUT(ignore carrier)") );
					iResult = SACKCOMM_ERR_TIMEOUT;
				}
			}
		}
 // not timed out, nothing read.
		else
		{
#ifndef __LINUX__
			MSG msg;
			// check to see if we ever ready any
			if( pComTrack->current.nTotalRead &&
	        ( GetTickCount() > ( pComTrack->current.dwLastRead + 25 ) ) )
			{
				*pnCharsRead = pComTrack->current.nTotalRead;
				pComTrack->flags.bInRead = 0;
				//xlprintf(LOG_NOISE)( WIDE("Leave comm read buffer") );
				iResult = SACKCOMM_ERR_NONE_MORE;
			}
			if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) )
			{
				// unlock ourselves... think we can come back in and resume...
				pComTrack->flags.bInRead = 0;
				if( gbLog )
					Log1( WIDE("Dispatching Message.. %d"), msg.message );
				DispatchMessage( &msg );
				pComTrack->flags.bInRead = 1;
			}
#endif
		}
	}
	while ( iResult == SACKCOMM_ERR_NONE );
	*pnCharsRead = pComTrack->current.nTotalRead;
	pComTrack->flags.bInRead = 0;
	pComTrack->current.dwEnd = 0;
	//xlprintf(LOG_NOISE)( WIDE("Leave comm read buffer") );
	return iResult;
}
//-----------------------------------------------------------------------
int  SackCommReadDataEx( int iCommId
												 , uint32_t timeout
												 , char **pBuffer
												 , int *pnCharsRead
												 DBG_PASS
											  )
{
	PCOM_TRACK pComTrack = FindComByNumber( iCommId );
	int iResult =
	       SackCommReadBufferEx( iCommId
	                           , pComTrack->current.mybuffer
	                           , sizeof( pComTrack->current.mybuffer )
	                           , timeout
	                           , pnCharsRead
	                           DBG_RELAY );
	if( pBuffer )
		*pBuffer = pComTrack->current.mybuffer;
	return iResult;
}
//-----------------------------------------------------------------------
 int  SackCommWriteBufferEx( int iCommId, char *buffer, int len
												  , uint32_t timeout DBG_PASS)
{
#ifndef __LINUX__
	PCOM_TRACK pComTrack = FindComByNumber( iCommId );
#endif
	int sendofs = 0;
	int sendlen = len;
	uint32_t dwEnd = GetTickCount() + timeout;
	// clear error...
    /*check for no error*/
#ifndef __LINUX__
	SackGetCommError ( iCommId, &pComTrack->cs );
#endif
    //nCommError = _GetCommError( gnCommID, NULL );
	/*attempt comm write*/
    //if( fnuiIsUnitConnected() || gbyTimeOut == 0 || gfDoCommAnyway)
	if( !len )
	{
		lprintf( WIDE("Sorry, no, you cannot SEND nothing.") );
      return SACKCOMM_ERR_BUFSIZE;
	}
   do
   {
	   {
	     int thissend;
		 int dosend = sendlen;
       //xlprintf(LOG_NOISE)( WIDE("Write") );
		 thissend = SackWriteComm( iCommId, buffer + sendofs, dosend );
       //xlprintf(LOG_NOISE)( WIDE("Did Write") );
	     if( thissend <= 0 )
	     {
#ifdef _WIN32
			 return SACKCOMM_ERR_TIMEOUT;
#endif
			  Log1( WIDE("Send Error occured: %d"), GetCommError( iCommId, NULL ) );
#ifndef __LINUX__
			 SackGetCommError ( iCommId, &pComTrack->cs );
#else
       // probably need something here...
          thissend = 0;
#endif
			 thissend = -thissend;
			 if( thissend == 0 )
			 {
				 xlprintf(LOG_NOISE)( WIDE("Data is not going anywhere - bail out.") );
				 return SACKCOMM_ERR_COMM;
			 }
	     }
	     sendofs += thissend;
	     sendlen -= thissend;
	    }
   }
   while( sendlen && dwEnd > GetTickCount() );
   //Log1( WIDE("SackCommWriteBuffer Leave : %d"), sendlen );
   if( sendlen )
	   return SACKCOMM_ERR_TIMEOUT;
   return SACKCOMM_ERR_NONE;
}
//-----------------------------------------------------------------------
/****************************************************************************** SACKCommFlush                                                               *
*    Attempt to read from the portable until no more characters appear.       *
*    The read will last at least as long as 100ms, but no longer then 5000ms. *
\*****************************************************************************/
void  SackCommFlush ( int nCommID )
{
	PCOM_TRACK pct = FindComByNumber( nCommID );
	if( pct )
	{
		FlushComm( (int)pct->iCommId, 0 );
		FlushComm( (int)pct->iCommId, 1 );
	}
	{
//#if 0
    uint32_t   dwTicks = GetTickCount();
	 uint32_t   dwWaitUntilAtLeast = dwTicks + 100UL;
	 uint32_t   dwWaitNoMoreThan   = dwTicks + 5000UL;
    int     nCharsRead;
	 char    cBuf[100];
    PCOM_TRACK pComTrack = FindComByNumber( nCommID );
	 do
	 {
		 nCharsRead = ReadComm ( (int)pComTrack->iCommId
                , cBuf
                , 100 );
		 //Log1( WIDE("Read com chars: %d"), nCharsRead );
		 if ( nCharsRead < 0 )
			 nCharsRead = -nCharsRead;
		 else if( nCharsRead > 0 )
			 dwWaitUntilAtLeast = GetTickCount() + 100;
		 if ( GetTickCount() > dwWaitNoMoreThan )
			 break;
	 }
	 while (  ( nCharsRead > 0 )
          || ( GetTickCount() < dwWaitUntilAtLeast )
          );
   }
//#endif
}
void SetCommRTS( int nCommID, int iRTS )
{
	PCOM_TRACK pct = FindComByNumber( nCommID );
	if( pct )
	{
#ifdef WIN32
		//if( iRTS && iRTSFlow )
		//	pct->dcb.fRtsControl = RTS_CONTROL_TOGGLE;
		//	else
		if( iRTS )
			pct->dcb.fRtsControl = RTS_CONTROL_ENABLE;
		else
			pct->dcb.fRtsControl = RTS_CONTROL_DISABLE;
      EnterCriticalSec( &pct->csOp );
		if ( SetCommState( (HANDLE)(intptr_t)nCommID, &pct->dcb ) )
		{
		}
      LeaveCriticalSec( &pct->csOp );
#endif
	}
}
void SackCommOwnPort( int nCommID, CommReadCallback func, int own_flags )
{
	PCOM_TRACK pct = FindComByNumber( nCommID );
	if( pct )
	{
		PCHANNEL_CALLBACK pcc = pct->callbacks;
		while( pcc )
		{
			if( pcc->func == func )
			{
				switch( own_flags )
				{
				case COM_PORT_OWN_SHARE:
					pcc->flags.skip_read = 0;
					pct->flags.bOwned = 0;
               pct->exclusive = NULL;
					break;
				case COM_PORT_OWN_EXCLUSIVE:
					pcc->flags.skip_read = 0;
					pct->flags.bOwned = 1;
               pct->exclusive = pcc;
					break;
				case COM_PORT_IGNORE:
					pcc->flags.skip_read = 1;
					pct->flags.bOwned = 0;
					pct->exclusive = NULL;
					break;
				}
				break;
			}
			pcc = pcc->next;
		}
	}
}
//-----------------------------------------------------------------------
//PRELOAD( InitCommSack )
//{
//}
//-------------------------------------------------------------
#define SACK_WEBSOCKET_CLIENT_SOURCE
#define WEBSOCKET_COMMON_SOURCE
#ifndef SACK_HTML5_WEBSOCKET_COMMON_DEFINED
#define SACK_HTML5_WEBSOCKET_COMMON_DEFINED
#ifndef HTML5_WEBSOCKET_CLIENT_INCLUDED
#define HTML5_WEBSOCKET_CLIENT_INCLUDED
/*****************************************************
so... what does the client provide?
websocket protocol is itself wrapped in a frame, so messages are described with exact
length, and what is received will be exactly like the block that was sent.
*****************************************************/
#ifdef __cplusplus
#else
#endif
#ifdef SACK_WEBSOCKET_CLIENT_SOURCE
#define WEBSOCKET_EXPORT EXPORT_METHOD
#else
#define WEBSOCKET_EXPORT IMPORT_METHOD
#endif
// the result returned from the web_socket_opened event will
// become the new value used for future uintptr_t parameters to other events.
typedef uintptr_t (*web_socket_opened)( PCLIENT pc, uintptr_t psv );
typedef void (*web_socket_closed)( PCLIENT pc, uintptr_t psv, int code, const char *reason );
typedef void( *web_socket_http_close )(PCLIENT pc, uintptr_t psv);
typedef void (*web_socket_error)( PCLIENT pc, uintptr_t psv, int error );
typedef void (*web_socket_event)( PCLIENT pc, uintptr_t psv, LOGICAL binary, CPOINTER buffer, size_t msglen );
// protocolsAccepted value set can be released in opened callback, or it may be simply assigned as protocols passed...
typedef LOGICAL ( *web_socket_accept )(PCLIENT pc, uintptr_t psv, const char *protocols, const char *resource, char **protocolsAccepted);
typedef void (*web_socket_completion)( PCLIENT pc, uintptr_t psv, int binary, int bytesRead );
 // passed psv used in server create; since it is sort of an open, return a psv for next states(if any)
typedef uintptr_t ( *web_socket_http_request )(PCLIENT pc, uintptr_t psv);
// these should be a combination of bit flags
// options used for WebSocketOpen
enum WebSocketOptions {
	WS_DELAY_OPEN = 1,
};
//enum WebSockClientOptions {
//   WebSockClientOption_Protocols
//};
// create a websocket connection.
//  If web_socket_opened is passed as NULL, this function will wait until the negotiation has passed.
//  since these packets are collected at a lower layer, buffers passed to receive event are allocated for
//  the application, and the application does not need to setup an  initial read.
//  if protocols is NULL none are specified, otherwise the list of
//  available protocols is sent to the server.
WEBSOCKET_EXPORT PCLIENT WebSocketOpen( CTEXTSTR address
                                      , enum WebSocketOptions options
                                      , web_socket_opened
                                      , web_socket_event
                                      , web_socket_closed
                                      , web_socket_error
                                      , uintptr_t psv
                                      , const char *protocols );
// if WS_DELAY_OPEN is used, WebSocketOpen does not do immediate connect.
// calling this begins the connection sequence.
WEBSOCKET_EXPORT void WebSocketConnect( PCLIENT );
// end a websocket connection nicely.
// code must be 1000, or 3000-4999, and reason must be less than 123 characters (125 bytes with code)
WEBSOCKET_EXPORT void WebSocketClose( PCLIENT, int code, const char *reason );
// there is a control bit for whether the content is text or binary or a continuation
 // UTF8 RFC3629
WEBSOCKET_EXPORT void WebSocketBeginSendText( PCLIENT, const char *, size_t );
// literal binary sending; this may happen to be base64 encoded too
WEBSOCKET_EXPORT void WebSocketBeginSendBinary( PCLIENT, const uint8_t *, size_t );
// there is a control bit for whether the content is text or binary or a continuation
 // UTF8 RFC3629
WEBSOCKET_EXPORT void WebSocketSendText( PCLIENT, const char *, size_t );
// literal binary sending; this may happen to be base64 encoded too
WEBSOCKET_EXPORT void WebSocketSendBinary( PCLIENT, const uint8_t *, size_t );
WEBSOCKET_EXPORT void WebSocketEnableAutoPing( PCLIENT websock, uint32_t delay );
WEBSOCKET_EXPORT void WebSocketPing( PCLIENT websock, uint32_t timeout );
WEBSOCKET_EXPORT void SetWebSocketAcceptCallback( PCLIENT pc, web_socket_accept callback );
WEBSOCKET_EXPORT void SetWebSocketReadCallback( PCLIENT pc, web_socket_event callback );
WEBSOCKET_EXPORT void SetWebSocketCloseCallback( PCLIENT pc, web_socket_closed callback );
WEBSOCKET_EXPORT void SetWebSocketErrorCallback( PCLIENT pc, web_socket_error callback );
WEBSOCKET_EXPORT void SetWebSocketHttpCallback( PCLIENT pc, web_socket_http_request callback );
WEBSOCKET_EXPORT void SetWebSocketHttpCloseCallback( PCLIENT pc, web_socket_http_close callback );
// if set in server accept callback, this will return without extension set
// on client socket (default), does not request permessage-deflate
#define WEBSOCK_DEFLATE_DISABLE 0
// if set in server accept callback (or if not set, default); accept client request to deflate per message
// if set on client socket, sends request for permessage-deflate to server.
#define WEBSOCK_DEFLATE_ENABLE 1
// if set in server accept callback; accept client request to deflate per message, but do not deflate outbound messages
// if set on client socket, sends request for permessage-deflate to server, but does not deflate outbound messages(?)
#define WEBSOCK_DEFLATE_ALLOW 2
// set permessage-deflate option for client requests.
// allow server side to disable this when responding to a client.
WEBSOCKET_EXPORT void SetWebSocketDeflate( PCLIENT pc, int enable_flags );
// default is client masks, server does not
// this can be used to disable masking on client or enable on server
// (masked output from server to client is not supported by browsers)
WEBSOCKET_EXPORT void SetWebSocketMasking( PCLIENT pc, int enable );
// Set callback to get completed fragment size (total packet size collected so far)
WEBSOCKET_EXPORT void SetWebSocketDataCompletion( PCLIENT pc, web_socket_completion callback );
#endif
#include <zlib.h>
#ifndef WEBSOCKET_COMMON_SOURCE
#define EXTERN extern
#else
#define EXTERN
#endif
typedef struct web_socket_input_state *WebSocketInputState;
struct web_socket_input_state
{
	struct web_socket_common_flags
	{
		BIT_FIELD closed : 1;
		BIT_FIELD received_pong : 1;
		BIT_FIELD sent_ping : 1;
 // set on server if client requested permessage-deflate; can be overridden by SetWebSocketDeflate() during accept
		BIT_FIELD deflate : 1;
  // do not deflate outbound messages; inbound message might still be inflated
		BIT_FIELD do_not_deflate : 1;
		BIT_FIELD sent_type : 1;
		// apparently clients did not implement back masking??
		// I get a close; probably because of the length exception
		BIT_FIELD expect_masking : 1;
		BIT_FIELD use_ssl : 1;
	} flags;
 // (last message tick) for automatic ping/keep alive/idle death
	uint32_t last_reception;
  // max bits used on (deflater if server, inflater if client)
	int client_max_bits;
  // max bits used on (inflater if server, deflater if client)
	int server_max_bits;
	z_stream deflater;
	POINTER deflateBuf;
	size_t deflateBufLen;
	z_stream inflater;
	POINTER inflateBuf;
	size_t inflateBufLen;
	size_t inflateBufUsed;
	// expandable buffer for collecting input messages from client.
	size_t fragment_collection_avail;
	size_t fragment_collection_length;
  // used for selecting mask byte
	size_t fragment_collection_index;
	size_t fragment_collection_buffer_size;
	uint8_t* fragment_collection;
	LOGICAL final;
	LOGICAL mask;
	uint8_t mask_key[4];
	int opcode;
  // input bit of RSV1 bit on each message
	int RSV1;
 // input bit of the first RSV1 bit on a fragmented packet; used for permessage-deflate
	int _RSV1;
	int input_msg_state;
 // text or binary
	int input_type;
	size_t frame_length;
	web_socket_event on_event;
	web_socket_closed on_close;
	web_socket_http_close on_http_close;
	web_socket_opened on_open;
	web_socket_error on_error;
  // server socket event
	web_socket_accept on_accept;
	web_socket_http_request on_request;
	web_socket_completion on_fragment_done;
	uintptr_t psv_on;
 // result of the open, to pass to read
	uintptr_t psv_open;
	int close_code;
	char *close_reason;
};
EXTERN void SendWebSocketMessage( PCLIENT pc, int opcode, int final, int do_mask, const uint8_t* payload, size_t length, int use_ssl );
EXTERN void ProcessWebSockProtocol( WebSocketInputState websock, PCLIENT pc, const uint8_t* msg, size_t length );
struct html5_web_socket {
 // this value must be 0x20130912
	uint32_t Magic;
	struct web_socket_flags
	{
		BIT_FIELD initial_handshake_done : 1;
		BIT_FIELD rfc6455 : 1;
		BIT_FIELD accepted : 1;
		BIT_FIELD http_request_only : 1;
 // set when sent to client, which can write and close before return; no further read must be done.
		BIT_FIELD in_open_event : 1;
 // was already closed (during in_read_event)
		BIT_FIELD closed : 1;
	} flags;
	HTTPState http_state;
	PCLIENT pc;
	POINTER buffer;
	char *protocols;
	struct web_socket_input_state input_state;
};
struct web_socket_client
{
 // this value must be 0x20130911
	uint32_t Magic;
	struct web_socket_client_flags
	{
 // if not connected, then parse data as http, otherwise process as websock protocol.
		BIT_FIELD connected : 1;
 // schedule to close
		BIT_FIELD want_close : 1;
		//BIT_FIELD use_ssl : 1;
	} flags;
	PCLIENT pc;
	CTEXTSTR host;
	CTEXTSTR address_url;
	struct url_data *url;
	CTEXTSTR protocols;
	POINTER buffer;
	HTTPState pHttpState;
 // when set by enable auto_ping is the delay between packets to generate a ping
	uint32_t ping_delay;
	struct web_socket_input_state input_state;
};
#endif
#ifdef __ANDROID_OLD_PLATFORM_SUPPORT__
#define rand lrand48
#endif
static void _SendWebSocketMessage( PCLIENT pc, int opcode, int final, int do_mask, const uint8_t* payload, size_t length, int use_ssl )
{
	uint8_t* msgout;
	uint8_t* use_mask;
	uint32_t zero = 0;
 // minimum additional is the opcode and tiny payload length (2 bytes)
	size_t length_out = length + 2;
	if( ( opcode & 8 ) && ( length > 125 ) )
	{
		lprintf( WIDE("Invalid send, control packet with large payload. (opcode %d  length %") _size_f WIDE(")"), opcode, length );
		return;
	}
	if( length > 125 )
	{
		if( length > 32767 )
		{
 // need 8 more bytes for a really long length
			length_out += 8;
		}
		else
 // need 2 more bytes for a longer length
			length_out += 2;
	}
	if( do_mask )
	{
		static uint32_t newmask;
		newmask ^= rand() ^ ( rand() << 13 ) ^ ( rand() << 26 );
		use_mask = (uint8_t*)&newmask;
 // need 4 more bytes for the mask
		length_out += 4;
	}
	else
	{
		use_mask = (uint8_t*)&zero;
	}
	msgout = NewArray( uint8_t, length_out );
	msgout[0] = opcode;
	if( length > 125 )
	{
		if( length > 32767 )
		{
			msgout[1] = 127;
#if __64__
			// size_t will be 32 bits on non 64 bit builds
			msgout[2] = (uint8_t)(length >> 56);
			msgout[3] = (uint8_t)(length >> 48);
			msgout[4] = (uint8_t)(length >> 40);
			msgout[5] = (uint8_t)(length >> 32);
#else
			msgout[2] = 0;
			msgout[3] = 0;
			msgout[4] = 0;
			msgout[5] = 0;
#endif
			msgout[6] = (uint8_t)(length >> 24);
			msgout[7] = (uint8_t)(length >> 16);
			msgout[8] = (uint8_t)(length >> 8);
			msgout[9] = (uint8_t)length;
		}
		else
		{
			msgout[1] = 126;
			msgout[2] = (uint8_t)(length >> 8);
			msgout[3] = (uint8_t)(length);
		}
	}
	else
		msgout[1] = (uint8_t)length;
	if( do_mask && length )
	{
		int mask_offset = (int)(length_out-length) - 4;
		msgout[1] |= 0x80;
		msgout[mask_offset+0] = (uint8_t)(use_mask[3]);
		msgout[mask_offset+1] = (uint8_t)(use_mask[2]);
		msgout[mask_offset+2] = (uint8_t)(use_mask[1]);
		msgout[mask_offset+3] = (uint8_t)(use_mask[0]);
		use_mask = msgout + mask_offset;
	}
	{
		size_t n;
		uint8_t* data_out = msgout + (length_out-length);
		size_t mlen = length / 4;
		for( n = 0; n < mlen; n++ )
		{
			(*data_out++) = (*payload++) ^ use_mask[0];
			(*data_out++) = (*payload++) ^ use_mask[1];
			(*data_out++) = (*payload++) ^ use_mask[2];
			(*data_out++) = (*payload++) ^ use_mask[3];
		}
		n <<= 2;
		if( n < length ) {
			(*data_out++) = (*payload++) ^ use_mask[0];
			n++;
		}
		if( n < length ) {
			(*data_out++) = (*payload++) ^ use_mask[1];
			n++;
		}
		if( n < length ) {
			(*data_out++) = (*payload++) ^ use_mask[2];
			n++;
		}
	}
	if( use_ssl )
		ssl_Send( pc, msgout, length_out );
	else
		SendTCP( pc, msgout, length_out );
	Deallocate( uint8_t*, msgout );
}
void SendWebSocketMessage( PCLIENT pc, int opcode, int final, int do_mask, const uint8_t* payload, size_t length, int use_ssl ) {
	struct web_socket_input_state *input = (struct web_socket_input_state *)GetNetworkLong( pc, 1 );
#ifndef __NO_WEBSOCK_COMPRESSION__
	if( (!input->flags.do_not_deflate) && input->flags.deflate && opcode < 3 ) {
		int r;
		if( opcode ) opcode |= 0x40;
		input->deflater.next_in = (Bytef*)payload;
		input->deflater.avail_in = (uInt)length;
		input->deflater.next_out = (Bytef*)input->deflateBuf;
		input->deflater.avail_out = (uInt)input->deflateBufLen;
		do {
			r = deflate( &input->deflater, Z_FINISH );
			if( r == Z_STREAM_END )
				break;
			if( r == Z_BUF_ERROR ) {
				lprintf( "Zlib error: buffer error" );
				//Z_BUF_ERROR( )
			}
			else if( r ) {
				lprintf( "Unhandled ZLIB error: %d", r );
			}
			if( input->deflater.avail_out == 0 ) {
				input->deflateBuf = Reallocate( input->deflateBuf, input->deflateBufLen + 4096 );
				input->deflater.next_out = (Bytef*)(((uintptr_t)input->deflateBuf) + input->deflateBufLen);
				input->deflateBufLen += 4096;
				input->deflater.avail_out += 4096;
				continue;
			}
			else
				break;
		} while( 1 );
		opcode = (final ? 0x80 : 0x00) | opcode;
		_SendWebSocketMessage( pc, opcode, final, do_mask, (uint8_t*)input->deflateBuf, input->deflater.total_out, use_ssl );
		deflateReset( &input->deflater );
	}
	else
#endif
	{
		opcode = (final ? 0x80 : 0x00) | opcode;
		_SendWebSocketMessage( pc, opcode, final, do_mask, payload, length, use_ssl );
	}
}
static void ResetInputState( WebSocketInputState websock )
{
	//lprintf( "Reset input state?" );
	websock->input_msg_state = 0;
	websock->final = 0;
	websock->mask = 0;
	websock->fragment_collection_avail = 0;
 // mask index counter
	websock->fragment_collection_index = 0;
 // assume text input; binary will set flag opposite
	websock->input_type = 0;
	// just always process the mask key, so set it to 0 for a no-op on XOR
	websock->mask_key[0] = 0;
	websock->mask_key[1] = 0;
	websock->mask_key[2] = 0;
	websock->mask_key[3] = 0;
}
#ifndef __NO_WEBSOCK_COMPRESSION__
//typedef unsigned( *in_func ) OF( (void FAR *,
//		z_const unsigned char FAR * FAR *) );
//typedef int( *out_func ) OF( (void FAR *, unsigned char FAR *, unsigned) );
static unsigned CPROC inflateBackInput( void* state, unsigned char **output ) {
	WebSocketInputState websock = (WebSocketInputState)state;
	(*output) = (unsigned char *)websock->fragment_collection;
	return (unsigned)websock->fragment_collection_avail;
}
static int CPROC inflateBackOutput( void* state, unsigned char *output, unsigned outlen ) {
	WebSocketInputState websock = (WebSocketInputState)state;
	memcpy( websock->inflateBuf, output, outlen );
	websock->inflateBufUsed += outlen;
	return Z_OK;
}
#endif
/* opcodes
 *  %x0 denotes a continuation frame
 *  %x1 denotes a text frame
 *  %x2 denotes a binary frame
 *  %x3-7 are reserved for further non-control frames
 *  %x8 denotes a connection close
 *  %x9 denotes a ping
 *  %xA denotes a pong
 *  %xB-F are reserved for further control frames
*/
void ProcessWebSockProtocol( WebSocketInputState websock, PCLIENT pc, const uint8_t* msg, size_t length )
{
	size_t n;
	for( n = 0; n < length; n++ )
	{
		switch( websock->input_msg_state )
		{
 // opcode/final
		case 0:
			if( msg[n] & 0x80 )
				websock->final = 1;
			websock->opcode = ( msg[n] & 0xF );
			websock->_RSV1 = (msg[n] & 0x40);
			if( websock->opcode == 1 ) websock->input_type = 0;
			else if( websock->opcode == 2 ) websock->input_type = 1;
			websock->input_msg_state++;
			break;
 // mask bit, and 7 bits of frame_length(payload)
		case 1:
			websock->mask = (msg[n] & 0x80) != 0;
			websock->frame_length = (msg[n] & 0x7f );
			// control opcodes are limited to the one byte size limit; they can never be encoded with extended payload length
			if( websock->opcode & 0x8 )
			{
				if( websock->frame_length > 125 )
				{
					lprintf( WIDE("Bad length of control packet: %")_size_f, length );
					// RemoveClient( websock->pc );
					ResetInputState( websock );
					// drop the rest of the data, maybe the beginning of the next packet will make us happy
					return;
				}
			}
			if( !websock->frame_length ) {
				websock->input_msg_state = 17;
				// re-process this byte but in the new state.
				n--;
			}
			if( websock->frame_length == 126 )
			{
				websock->frame_length = 0;
				websock->input_msg_state = 2;
			}
			else if( websock->frame_length == 127 )
			{
				websock->frame_length = 0;
				websock->input_msg_state = 4;
			}
			else
			{
				if( websock->mask )
					websock->input_msg_state = 12;
				else
					websock->input_msg_state = 16;
			}
			break;
 // byte 1, extended payload uint16_t
		case 2:
			websock->frame_length = msg[n] << 8;
			websock->input_msg_state++;
			break;
 // byte 1, extended payload uint16_t
		case 3:
			websock->frame_length |= msg[n];
			if( websock->mask )
				websock->input_msg_state = 12;
			else
				websock->input_msg_state = 16;
			break;
 // byte 1, extended payload uint64_t
		case 4:
 // byte 2, extended payload uint64_t
		case 5:
 // byte 3, extended payload uint64_t
		case 6:
 // byte 4, extended payload uint64_t
		case 7:
 // byte 5, extended payload uint64_t
		case 8:
 // byte 6, extended payload uint64_t
		case 9:
 // byte 7, extended payload uint64_t
		case 10:
			websock->frame_length |= msg[n] << ( ( 11 - websock->input_msg_state ) * 8 );
			websock->input_msg_state++;
			break;
 // byte 8, extended payload uint64_t
		case 11:
			websock->frame_length |= msg[n];
			if( websock->mask )
				websock->input_msg_state++;
			else
				websock->input_msg_state = 16;
			break;
 // mask data byte 1
		case 12:
 // mask data byte 2
		case 13:
 // mask data byte 3
		case 14:
 // mask data byte 4
		case 15:
			websock->mask_key[websock->input_msg_state-12] = msg[n];
			websock->input_msg_state++;
			break;
 // extended data or application data byte 1.
		case 16:
			// might have already collected fragments (non final packets, so increase the full buffer )
			// first byte of data, check we have enough room for the remaining bytes; the frame_length is valid now.
			//lprintf( "Received... and need %d  %d  %d", websock->fragment_collection_avail, websock->fragment_collection_length, websock->frame_length, websock->fragment_collection_length + websock->frame_length );
			if( websock->fragment_collection_avail < ( websock->fragment_collection_length + websock->frame_length ) )
			{
				uint8_t* new_fragbuf;
				websock->fragment_collection_avail += websock->frame_length;
				if( websock->fragment_collection_avail > websock->fragment_collection_buffer_size ) {
					new_fragbuf = (uint8_t*)Allocate( websock->fragment_collection_avail * 2 );
					if( websock->fragment_collection_length )
						MemCpy( new_fragbuf, websock->fragment_collection, websock->fragment_collection_length );
					Deallocate( uint8_t*, websock->fragment_collection );
					websock->fragment_collection = new_fragbuf;
					websock->fragment_collection_buffer_size = websock->fragment_collection_avail * 2;
				}
 // start with mask byte 0 on this new packet
				websock->fragment_collection_index = 0;
			}
			websock->input_msg_state++;
			// fall through, no break statement; add the byte to the buffer
		case 17:
			// if there was no data, then there's nothing to demask
			if( websock->fragment_collection && (websock->fragment_collection_length < websock->fragment_collection_avail) )
			{
				websock->fragment_collection[websock->fragment_collection_length++]
					= msg[n] ^ websock->mask_key[(websock->fragment_collection_index++) % 4];
			}
			// if final packet, and we have all the bytes for this packet
			// dispatch the opcode.
			if( websock->final && ( websock->fragment_collection_length == websock->fragment_collection_avail) )
			{
				//lprintf( "Final: %d  opcode %d  length %d ", websock->final, websock->opcode, websock->fragment_collection_length );
				websock->last_reception = timeGetTime();
				switch( websock->opcode )
				{
 //binary
				case 0x02:
 //text
				case 0x01:
					websock->RSV1 = websock->_RSV1;
 // continuation
				case 0x00:
					/// single packet, final...
					//LogBinary( websock->fragment_collection, websock->fragment_collection_length );
					if( websock->on_event ) {
#ifndef __NO_WEBSOCK_COMPRESSION__
						if( websock->flags.deflate && ( websock->RSV1 & 0x40 ) ) {
							int r;
							websock->inflateBufUsed = 0;
							websock->inflater.next_in = websock->fragment_collection;
							websock->inflater.avail_in = (uInt)websock->fragment_collection_length;
							websock->inflater.next_out = (Bytef*)websock->inflateBuf;
							websock->inflater.avail_out = (uInt)websock->inflateBufLen;
							do {
								//r = inflateBack( &websock->inflater, inflateBackInput, websock, inflateBackOutput, websock );
								r = inflate( &websock->inflater, Z_FINISH );
								if( r == Z_DATA_ERROR ) {
									lprintf( "zlib Data Error..." );
								}
								else if( r != Z_OK && r != Z_BUF_ERROR )
									lprintf( "unhandle zlib inflate error... %d", r );
								if( websock->inflater.avail_out == 0 ) {
									websock->inflateBuf = Reallocate( websock->inflateBuf, websock->inflateBufLen + 4096 );
									websock->inflater.next_out = (Bytef*)(((uintptr_t)websock->inflateBuf) + websock->inflateBufLen);
									websock->inflateBufLen += 4096;
									websock->inflater.avail_out += 4096;
									continue;
								}
								else
									break;
							} while( r != Z_STREAM_END || r != Z_BUF_ERROR );
							websock->inflateBufUsed = websock->inflater.total_out;
							websock->on_event( pc, websock->psv_open, websock->input_type
								, websock->inflateBuf, websock->inflateBufUsed );
							inflateReset( &websock->inflater );
						}
						else
#endif
						{
							//lprintf( "Completed packet; %d %d", websock->input_type, websock->fragment_collection_length );
							websock->on_event( pc, websock->psv_open, websock->input_type, websock->fragment_collection, websock->fragment_collection_length );
						}
					}
					websock->fragment_collection_length = 0;
					break;
 // close
				case 0x08:
					// close may have app data with a reason.
					// if it has a reason, then the first two bytes are a code
					//  1000 - normal
					//  1001 - end point going away (page close, server shutdown)
					//  1002 - termination from protocol error
					//  1003 - binary/text mismatch (if supported)
					// 1004 - reserved
					// 1005 - No status code (reserved, must not send in close)
					// 1006 - reserved for not in clude; connection terminated unexpected ( guess there are local-only, not sent)
					// 1007 - inconsistant data for data in message
					// 1008 - ereceived a message that violates policy (generic message for nothing better)
					// 1009 - message too big
					// 1010 - server did not negotiate extension
					// 1011 - excpetion in handling message.
					// 1015 - reservd, must not send in close; failure to perform TLS handshake (or bad server verification)
					//  0-999 = not used;
					// 1000-2999 - reserved for this protocol, reserved for specification
					// 3000-3999 - libarry/framework/application.  Registered with IANA.  Defined by protocol.
					// 4000-4999 - reserved for private use; cannot be registerd;
					//lprintf( "Got close...%d", websock->flags.closed );
					if( !websock->flags.closed )
					{
						struct web_socket_input_state *output = (struct web_socket_input_state *)GetNetworkLong( pc, 1 );
						//lprintf( "reply close with same payload." );
						SendWebSocketMessage( pc, 0x08, 1, output->flags.expect_masking, websock->fragment_collection, websock->frame_length, output->flags.use_ssl );
						websock->flags.closed = 1;
					}
					if( websock->on_close ) {
						int code;
						char buf[128];
						if( websock->frame_length > 2 ) {
							StrCpyEx( buf, (char*)(websock->fragment_collection + 2), websock->frame_length - 2 );
							buf[websock->frame_length - 2] = 0;
							code = ((int)buf[0] << 8) + buf[1];
						}
						else if( websock->frame_length ) {
							code = ((int)buf[0] << 8) + buf[1];
							buf[0] = 0;
						}
						else {
							code = 1000;
							buf[0] = 0;
						}
						websock->close_code = code;
						websock->close_reason = StrDup( buf );
						websock->on_close( pc, websock->psv_open, code, buf );
						websock->on_close = NULL;
					}
					websock->fragment_collection_length = 0;
 // this should not linger; client already sent closed, nothing more to receive.
					RemoveClientEx( pc, 0, 0 );
					// resetInputstate after this would squash next memory....
					return;
					break;
 // ping
				case 0x09:
					{
						struct web_socket_input_state *output = (struct web_socket_input_state *)GetNetworkLong(pc, 1);
						SendWebSocketMessage( pc, 0x0a, 1, output->flags.expect_masking, websock->fragment_collection, websock->frame_length, output->flags.use_ssl );
						websock->fragment_collection_length = 0;
					}
					break;
 // pong
				case 0x0A:
					{
						// this is for the ping routine to wait (or rather to end wait)
						websock->flags.received_pong = 1;
					}
					websock->fragment_collection_length = 0;
					break;
				default:
					lprintf( WIDE("Bad WebSocket opcode: %d"), websock->opcode );
					RemoveClient( pc );
					return;
				}
				// after processing any opcode (this is IN final, and length match) we're done, start next message
				ResetInputState( websock );
			} else if( websock->fragment_collection_length == websock->fragment_collection_avail ) {
				//lprintf( "Completed packet; still not final fragment though.... %d", websock->fragment_collection_avail );
				websock->input_msg_state = 0;
				if( websock->on_fragment_done )
					websock->on_fragment_done( pc, websock->psv_open, websock->input_type, (int)websock->fragment_collection_length );
			}
			break;
		}
	}
}
void WebSocketPing( PCLIENT pc, uint32_t timeout )
{
	uint32_t start_at = timeGetTime();
	uint32_t target = start_at + timeout;
	uint32_t now;
	struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
	SendWebSocketMessage( pc, 9, 1, input_state->flags.expect_masking, NULL, 0, input_state->flags.use_ssl );
	while( !input_state->flags.received_pong
			&& ( ( ( now=timeGetTime() ) - start_at ) < timeout ) )
		IdleFor( target-now );
	input_state->flags.received_pong = 0;
}
// there is a control bit for whether the content is text or binary or a continuation
 // UTF8 RFC3629
void WebSocketSendText( PCLIENT pc, const char *buffer, size_t length )
{
	struct web_socket_input_state *input = (struct web_socket_input_state *)GetNetworkLong( pc, 1 );
	if( length > 8100 ) {
		size_t sentLen;
		size_t maxLen = length - 8100;
		for( sentLen = 0; sentLen < maxLen; sentLen += 8100 )
			WebSocketBeginSendText( pc, buffer + sentLen, 8100 );
		length = length - ( sentLen );
		buffer = buffer + ( sentLen );
	}
	SendWebSocketMessage( pc, input->flags.sent_type?0:1, 1, input->flags.expect_masking, (uint8_t*)buffer, length, input->flags.use_ssl );
	input->flags.sent_type = 0;
}
// there is a control bit for whether the content is text or binary or a continuation
 // UTF8 RFC3629
void WebSocketBeginSendText( PCLIENT pc, const char *buffer, size_t length )
{
	struct web_socket_input_state *output = (struct web_socket_input_state *)GetNetworkLong(pc, 1);
	if( length > 8100 ) {
		size_t sentLen;
		size_t maxLen = length - 8100;
		for( sentLen = 0; sentLen < maxLen; sentLen += 8100 )
			WebSocketBeginSendText( pc, buffer + sentLen, 8100 );
		length = length - ( sentLen );
		buffer = buffer + ( sentLen );
	}
	SendWebSocketMessage( pc, output->flags.sent_type?0:1, 0, output->flags.expect_masking, (const uint8_t*)buffer, length, output->flags.use_ssl );
	output->flags.sent_type = 1;
}
// literal binary sending; this may happen to be base64 encoded too
void WebSocketSendBinary( PCLIENT pc, const uint8_t *buffer, size_t length )
{
	struct web_socket_input_state *output = (struct web_socket_input_state *)GetNetworkLong(pc, 1);
	if( length > 8100 ) {
		size_t sentLen;
		size_t maxLen = length - 8100;
		for( sentLen = 0; sentLen < maxLen; sentLen += 8100 )
			WebSocketBeginSendBinary( pc, buffer + sentLen, 8100 );
		length = length - ( sentLen );
		buffer = buffer + ( sentLen );
	}
	SendWebSocketMessage( pc, output->flags.sent_type?0:2, 1, output->flags.expect_masking, (const uint8_t*)buffer, length, output->flags.use_ssl );
	output->flags.sent_type = 0;
}
// literal binary sending; this may happen to be base64 encoded too
void WebSocketBeginSendBinary( PCLIENT pc, const uint8_t *buffer, size_t length )
{
	struct web_socket_input_state *output = (struct web_socket_input_state *)GetNetworkLong(pc, 1);
	if( length > 8100 ) {
		size_t sentLen;
		size_t maxLen = length - 8100;
		for( sentLen = 0; sentLen < maxLen; sentLen += 8100 )
			WebSocketBeginSendBinary( pc, buffer + sentLen, 8100 );
		length = length - ( sentLen );
		buffer = buffer + ( sentLen );
	}
	SendWebSocketMessage( pc, output->flags.sent_type?0:2, 0, output->flags.expect_masking, (const uint8_t*)buffer, length, output->flags.use_ssl );
	output->flags.sent_type = 1;
}
void SetWebSocketAcceptCallback( PCLIENT pc, web_socket_accept callback )
{
	if( pc ) {
		 struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_accept = callback;
	}
}
void SetWebSocketReadCallback( PCLIENT pc, web_socket_event callback )
{
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_event = callback;
	}
}
void SetWebSocketCloseCallback( PCLIENT pc, web_socket_closed callback )
{
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_close = callback;
	}
}
void SetWebSocketHttpCallback( PCLIENT pc, web_socket_http_request callback )
{
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_request = callback;
	}
}
void SetWebSocketHttpCloseCallback( PCLIENT pc, web_socket_http_close callback )
{
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_http_close = callback;
	}
}
void SetWebSocketErrorCallback( PCLIENT pc, web_socket_error callback )
{
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_error = callback;
	}
}
void SetWebSocketDeflate( PCLIENT pc, int enable ) {
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->flags.deflate = enable?1:0;
		input_state->flags.do_not_deflate = enable==2?1:0;
	}
}
void SetWebSocketMasking( PCLIENT pc, int enable ) {
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->flags.expect_masking = enable;
	}
}
void SetWebSocketDataCompletion( PCLIENT pc, web_socket_completion callback ) {
	if( pc ) {
		struct web_socket_input_state *input_state = (struct web_socket_input_state*)GetNetworkLong( pc, 1 );
		input_state->on_fragment_done = callback;
	}
}
#define SACK_WEBSOCKET_CLIENT_SOURCE
#ifndef SACK_HTML5_WEBSOCKET_COMMON_DEFINED
#define SACK_HTML5_WEBSOCKET_COMMON_DEFINED
#ifndef WEBSOCKET_COMMON_SOURCE
#define EXTERN extern
#else
#define EXTERN
#endif
typedef struct web_socket_input_state *WebSocketInputState;
struct web_socket_input_state
{
	struct web_socket_common_flags
	{
		BIT_FIELD closed : 1;
		BIT_FIELD received_pong : 1;
		BIT_FIELD sent_ping : 1;
 // set on server if client requested permessage-deflate; can be overridden by SetWebSocketDeflate() during accept
		BIT_FIELD deflate : 1;
  // do not deflate outbound messages; inbound message might still be inflated
		BIT_FIELD do_not_deflate : 1;
		BIT_FIELD sent_type : 1;
		// apparently clients did not implement back masking??
		// I get a close; probably because of the length exception
		BIT_FIELD expect_masking : 1;
		BIT_FIELD use_ssl : 1;
	} flags;
 // (last message tick) for automatic ping/keep alive/idle death
	uint32_t last_reception;
  // max bits used on (deflater if server, inflater if client)
	int client_max_bits;
  // max bits used on (inflater if server, deflater if client)
	int server_max_bits;
	z_stream deflater;
	POINTER deflateBuf;
	size_t deflateBufLen;
	z_stream inflater;
	POINTER inflateBuf;
	size_t inflateBufLen;
	size_t inflateBufUsed;
	// expandable buffer for collecting input messages from client.
	size_t fragment_collection_avail;
	size_t fragment_collection_length;
  // used for selecting mask byte
	size_t fragment_collection_index;
	size_t fragment_collection_buffer_size;
	uint8_t* fragment_collection;
	LOGICAL final;
	LOGICAL mask;
	uint8_t mask_key[4];
	int opcode;
  // input bit of RSV1 bit on each message
	int RSV1;
 // input bit of the first RSV1 bit on a fragmented packet; used for permessage-deflate
	int _RSV1;
	int input_msg_state;
 // text or binary
	int input_type;
	size_t frame_length;
	web_socket_event on_event;
	web_socket_closed on_close;
	web_socket_http_close on_http_close;
	web_socket_opened on_open;
	web_socket_error on_error;
  // server socket event
	web_socket_accept on_accept;
	web_socket_http_request on_request;
	web_socket_completion on_fragment_done;
	uintptr_t psv_on;
 // result of the open, to pass to read
	uintptr_t psv_open;
	int close_code;
	char *close_reason;
};
EXTERN void SendWebSocketMessage( PCLIENT pc, int opcode, int final, int do_mask, const uint8_t* payload, size_t length, int use_ssl );
EXTERN void ProcessWebSockProtocol( WebSocketInputState websock, PCLIENT pc, const uint8_t* msg, size_t length );
struct html5_web_socket {
 // this value must be 0x20130912
	uint32_t Magic;
	struct web_socket_flags
	{
		BIT_FIELD initial_handshake_done : 1;
		BIT_FIELD rfc6455 : 1;
		BIT_FIELD accepted : 1;
		BIT_FIELD http_request_only : 1;
 // set when sent to client, which can write and close before return; no further read must be done.
		BIT_FIELD in_open_event : 1;
 // was already closed (during in_read_event)
		BIT_FIELD closed : 1;
	} flags;
	HTTPState http_state;
	PCLIENT pc;
	POINTER buffer;
	char *protocols;
	struct web_socket_input_state input_state;
};
struct web_socket_client
{
 // this value must be 0x20130911
	uint32_t Magic;
	struct web_socket_client_flags
	{
 // if not connected, then parse data as http, otherwise process as websock protocol.
		BIT_FIELD connected : 1;
 // schedule to close
		BIT_FIELD want_close : 1;
		//BIT_FIELD use_ssl : 1;
	} flags;
	PCLIENT pc;
	CTEXTSTR host;
	CTEXTSTR address_url;
	struct url_data *url;
	CTEXTSTR protocols;
	POINTER buffer;
	HTTPState pHttpState;
 // when set by enable auto_ping is the delay between packets to generate a ping
	uint32_t ping_delay;
	struct web_socket_input_state input_state;
};
#endif
typedef struct web_socket_client *WebSocketClient;
struct web_socket_client_local
{
	uint32_t timer;
	PLIST clients;
	CRITICALSECTION cs_opening;
	struct web_socket_client *opening_client;
	struct random_context *rng;
} wsc_local;
static const TEXTCHAR *wscbase64 = WIDE( "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=" );
static void wscencodeblock( unsigned char in[3], TEXTCHAR out[4], int len )
{
	out[0] = wscbase64[in[0] >> 2];
	out[1] = wscbase64[((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4)];
	out[2] = (unsigned char)(len > 1 ? wscbase64[((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6)] : '=');
	out[3] = (unsigned char)(len > 2 ? wscbase64[in[2] & 0x3f] : '=');
}
static void SendRequestHeader( WebSocketClient websock )
{
	PVARTEXT pvtHeader = VarTextCreate();
	vtprintf( pvtHeader, WIDE("GET /%s%s%s%s%s HTTP/1.1\r\n")
			  , websock->url->resource_path?websock->url->resource_path:WIDE("")
			  , websock->url->resource_path?WIDE("/"):WIDE("")
			  , websock->url->resource_file?websock->url->resource_file:WIDE("")
			  , websock->url->resource_extension?WIDE("."):WIDE("")
			  , websock->url->resource_extension?websock->url->resource_extension:WIDE("")
			  );
	vtprintf( pvtHeader, WIDE("Host: %s:%d\r\n")
			  , websock->url->host
			  , websock->url->port?websock->url->port:websock->url->default_port );
	vtprintf( pvtHeader, WIDE("Upgrade: websocket\r\n"));
	vtprintf( pvtHeader, WIDE("Connection: Upgrade\r\n"));
	if( websock->protocols )
		vtprintf( pvtHeader, WIDE("Sec-WebSocket-Protocol: %s\r\n"), websock->protocols );
	vtprintf( pvtHeader, WIDE( "Sec-WebSocket-Key:" ) );
	{
		uint8_t buf[16];
		TEXTCHAR output[32];
		int n;
		SRG_GetEntropyBuffer( wsc_local.rng, (uint32_t*)buf, 16 * 8 );
		for( n = 0; n < (16 + 2) / 3; n++ )
		{
			int blocklen;
			blocklen = 16 - n * 3;
			if( blocklen > 3 )
				blocklen = 3;
			wscencodeblock( buf + n * 3, output + n * 4, blocklen );
		}
		output[n * 4 + 0] = 0;
		vtprintf( pvtHeader, "%s\r\n", output );
	}
	//x3JJHMbDL1EzLkh9GBhXDw == \r\n") );
	vtprintf( pvtHeader, WIDE("Sec-WebSocket-Version: 13\r\n") );
	if( websock->input_state.flags.deflate ) {
		vtprintf( pvtHeader, WIDE( "Sec-WebSocket-Extensions: permessage-deflate\r\n" ) );
	}
	vtprintf( pvtHeader, WIDE("\r\n") );
	{
 // just leave the buffer in-place
		PTEXT text = VarTextPeek( pvtHeader );
		if( websock->input_state.flags.use_ssl )
			ssl_Send( websock->pc, GetText( text ), GetTextSize( text ) );
		else
			SendTCP( websock->pc, GetText( text ), GetTextSize( text ) );
	}
	VarTextDestroy( &pvtHeader );
}
static void CPROC WebSocketTimer( uintptr_t psv )
{
	uint32_t now;
	INDEX idx;
	WebSocketClient websock;
	LIST_FORALL( wsc_local.clients, idx, WebSocketClient, websock )
	{
		now = timeGetTime();
		// close is delay notified
		if( websock->flags.want_close )
		{
			struct {
				uint16_t reason;
			} msg;
 // normal
			msg.reason = 1000;
			websock->input_state.flags.closed = 1;
			SendWebSocketMessage( websock->pc, 8, 1, 0, (uint8_t*)&msg, 2, websock->input_state.flags.use_ssl );
		}
		// do auto ping...
		if( !websock->input_state.flags.closed )
		{
			if( websock->ping_delay ) {
				if( !websock->input_state.flags.sent_ping )
				{
					if( ( now - websock->input_state.last_reception ) > websock->ping_delay )
					{
						SendWebSocketMessage( websock->pc, 0x09, 1, 0, NULL, 0, websock->input_state.flags.use_ssl );
					}
				}
				else
				{
					if( ( now - websock->input_state.last_reception ) > ( websock->ping_delay * 2 ) )
					{
						websock->flags.want_close = 1;
						// send close immediately
						RescheduleTimerEx( wsc_local.timer, 0 );
					}
				}
			}
		}
	}
}
static void CPROC WebSocketClientReceive( PCLIENT pc, POINTER buffer, size_t len )
{
	WebSocketClient websock = (WebSocketClient)GetNetworkLong( pc, 0 );
	if( !buffer )
	{
		if( !websock )
		{
			if( websock = wsc_local.opening_client )
			{
				//SetTCPNoDelay( pc, TRUE );
				SetNetworkLong( pc, 0, (uintptr_t)wsc_local.opening_client );
				SetNetworkLong( pc, 1, (uintptr_t)&wsc_local.opening_client->input_state );
 // clear this to allow open to return.
				wsc_local.opening_client = NULL;
			}
			else
			{
				lprintf( WIDE("Fatality; didn't have a related structure, and no client opening") );
			}
		}
		else
			buffer = websock->buffer;
		SendRequestHeader( websock );
	}
	else
	{
		WebSocketClient websock = (WebSocketClient)GetNetworkLong( pc, 0 );
		if( !websock->flags.connected )
		{
			int result;
			// this is HTTP state...
			AddHttpData( websock->pHttpState, buffer, len );
			result = ProcessHttp( pc, websock->pHttpState );
			//lprintf( WIDE("reply is %d"), result );
			if( (int)result == 101 )
			{
				websock->flags.connected = 1;
				{
					PTEXT content = GetHttpContent( websock->pHttpState );
					if( websock->input_state.on_open )
						websock->input_state.psv_open = websock->input_state.on_open( pc, websock->input_state.psv_on );
					if( content )
						ProcessWebSockProtocol( &websock->input_state, websock->pc, (uint8_t*)GetText( content ), GetTextSize( content ) );
				}
			}
			else if( (int)result >= 300 && (int)result < 400 )
			{
				lprintf( WIDE("Redirection of some sort") );
				// redirect, disconnect, reconnect to new address offered.
			}
			else if( (int)result )
			{
				lprintf( WIDE("Some other error: %d"), result );
			}
			else
			{
				// not a full header yet. (something about no content-length?)
			}
		}
		else
		{
			ProcessWebSockProtocol( &websock->input_state, websock->pc, (uint8_t*)buffer, len );
		}
		// process buffer?
	}
	if( !websock->input_state.flags.use_ssl ) {
		ReadTCP( pc, buffer, 4096 );
	}
}
static void CPROC WebSocketClientClosed( PCLIENT pc )
{
	WebSocketClient websock = (WebSocketClient)GetNetworkLong( pc, 0 );
   //lprintf( "WebSocketClientClosed event." );
	if( websock )
	{
		//lprintf( "Send to application." );
		if( websock->input_state.on_close ) {
			websock->input_state.on_close( pc, websock->input_state.psv_on, websock->input_state.close_code, websock->input_state.close_reason );
			websock->input_state.on_close = NULL;
		}
		if( websock->input_state.close_reason )
			Deallocate( char*, websock->input_state.close_reason );
		Deallocate( uint8_t*, websock->input_state.fragment_collection );
		Release( websock->buffer );
		DestroyHttpState( websock->pHttpState );
		SACK_ReleaseURL( websock->url );
		Release( websock );
	}
	else
		lprintf( "websocket handle is gone from socket|" );
}
static void CPROC WebSocketClientConnected( PCLIENT pc, int error )
{
	WebSocketClient websock;
	while( !( websock = (WebSocketClient)GetNetworkLong( pc, 0 ) ) )
		Relinquish();
	if( !error )
	{
		if( websock->input_state.flags.use_ssl && !ssl_IsClientSecure( websock->pc ) )
			ssl_BeginClientSession( websock->pc, NULL, 0, NULL, 0, NULL, 0 );
	}
	else
	{
		wsc_local.opening_client = NULL;
		RemoveClient( pc );
	}
}
static void getRandomSalt( uintptr_t inst, POINTER *salt, size_t *salt_size ) {
	static uint32_t tick;
	tick = GetTickCount();
	(*salt) = &tick;
	(*salt_size) = 4;
}
// create a websocket connection.
//  If web_socket_opened is passed as NULL, this function will wait until the negotiation has passed.
//  since these packets are collected at a lower layer, buffers passed to receive event are allocated for
//  the application, and the application does not need to setup an  initial read.
PCLIENT WebSocketOpen( CTEXTSTR url_address
							, enum WebSocketOptions options
							, web_socket_opened on_open
							, web_socket_event on_event
							, web_socket_closed on_closed
							, web_socket_error on_error
							, uintptr_t psv
	, const char *protocols )
{
	WebSocketClient websock = New( struct web_socket_client );
	if( !wsc_local.rng ) {
		wsc_local.rng = SRG_CreateEntropy2( getRandomSalt, 0 );
	}
	MemSet( websock, 0, sizeof( struct web_socket_client ) );
	websock->Magic = 0x20130911;
	//va_arg args;
	//va_start( args, psv );
	if( !wsc_local.timer )
		wsc_local.timer = AddTimer( 2000, WebSocketTimer, 0 );
	websock->buffer = Allocate( 4096 );
	websock->pHttpState = CreateHttpState();
	websock->input_state.on_open = on_open;
	websock->input_state.on_event = on_event;
	websock->input_state.on_close = on_closed;
	websock->input_state.on_error = on_error;
	websock->input_state.psv_on = psv;
	websock->protocols = protocols;
 // client to server is MUST mask because of proxy handling in that direction
	websock->input_state.flags.expect_masking = 1;
	websock->input_state.close_code = 1006;
	websock->url = SACK_URLParse( url_address );
	if( !websock->url->host ) {
		SACK_ReleaseURL( websock->url );
		DestroyHttpState( websock->pHttpState );
		Deallocate( POINTER, websock->buffer );
		Deallocate( WebSocketClient, websock );
		return NULL;
	}
	EnterCriticalSec( &wsc_local.cs_opening );
	wsc_local.opening_client = websock;
	{
		SOCKADDR *lpsaDest = CreateSockAddress( websock->url->host, websock->url->port ? websock->url->port : websock->url->default_port );
		websock->pc = OpenTCPClientAddrExxx( lpsaDest
												, WebSocketClientReceive
												, WebSocketClientClosed
												, NULL
 // if there is an on-open event, then register for async open
												, WebSocketClientConnected
												, (options&WS_DELAY_OPEN)?OPEN_TCP_FLAG_DELAY_CONNECT:0
												DBG_SRC
												);
		if( websock->pc )
		{
			SetNetworkLong( websock->pc, 0, (uintptr_t)websock );
			SetNetworkLong( websock->pc, 1, (uintptr_t)&websock->input_state );
#ifndef NO_SSL
			if( StrCaseCmp( websock->url->protocol, "wss" ) == 0 )
				websock->input_state.flags.use_ssl = 1;
#endif
			if( !on_open )
			{
				while( !websock->flags.connected && !websock->input_state.flags.closed )
					Idle();
			}
		}
		else
			wsc_local.opening_client = NULL;
	}
	LeaveCriticalSec( &wsc_local.cs_opening );
	return  websock->pc;
}
void WebSocketConnect( PCLIENT pc ) {
	NetworkConnectTCP( pc );
}
// end a websocket connection nicely.
void WebSocketClose( PCLIENT pc, int code, const char *reason )
{
	WebSocketClient websock = (WebSocketClient)GetNetworkLong( pc, 0 );
	char buf[130];
	size_t buflen;
  // maybe already closed?
	if( !websock )
		return;
	if( code ) {
		buf[0] = code / 256;
		buf[1] = code % 256;
		StrCpyEx( buf + 2, reason, 124 );
		buflen = 2 + strlen( buf + 2 );
	}
	else {
		buflen = 0;
	}
 // struct html5_web_socket
	if( websock->Magic == 0x20130912 ) {
		struct html5_web_socket *serverSock = (struct html5_web_socket*)websock;
		if( serverSock->flags.initial_handshake_done ) {
			//lprintf( "Send server side close with no payload." );
			SendWebSocketMessage( pc, 8, 1, serverSock->input_state.flags.expect_masking, (const uint8_t*)buf, buflen, serverSock->input_state.flags.use_ssl );
			serverSock->input_state.flags.closed = 1;
		}
		else {
			//lprintf( "Negotiation incomplete, don't send close; just close." );
			RemoveClientEx( pc, 0, 1 );
		}
	}
	else {
 // struct web_socket_client
		if( websock->Magic == 0x20130911 ) {
			//lprintf( "send client side close?" );
			if( websock->flags.connected ) {
				while( !NetworkLockEx( pc, 1 DBG_SRC ) )
					Relinquish();
				SendWebSocketMessage( pc, 8, 1, websock->input_state.flags.expect_masking, (const uint8_t*)buf, buflen, websock->input_state.flags.use_ssl );
				websock->input_state.flags.closed = 1;
				NetworkUnlock( pc, 1 );
			}
			else {
				//lprintf( "Negotiation incomplete, don't send close; just close." );
				RemoveClientEx( pc, 0, 1 );
			}
		}
	}
}
void WebSocketEnableAutoPing( PCLIENT pc, uint32_t delay )
{
	WebSocketClient websock = (WebSocketClient)GetNetworkLong( pc, 0 );
	if( websock->Magic == 0x20130911 )
	{
		websock->ping_delay = delay;
	}
}
PRELOAD( InitWebSocketServer )
{
//   wsc_local.timer = AddTimer( 2000, WebSocketTimer, 0 );
	InitializeCriticalSec( &wsc_local.cs_opening );
}
#define NO_UNICODE_C
#ifdef SACK_CORE_BUILD
#define MD5_SOURCE
#endif
#define HTML5_WEBSOCKET_SOURCE
 // websocketclose is a common...
#define SACK_WEBSOCKET_CLIENT_SOURCE
/* MD5.H - header file for MD5C.C
 */
/* Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
rights reserved.
License to copy and use this software is granted provided that it
is identified as the "RSA Data Security, Inc. MD5 Message-Digest
Algorithm" in all material mentioning or referencing this software
or this function.
License is also granted to make and use derivative works provided
that such works are identified as "derived from the RSA Data
Security, Inc. MD5 Message-Digest Algorithm" in all material
mentioning or referencing the derived work.
RSA Data Security, Inc. makes no representations concerning either
the merchantability of this software or the suitability of this
software for any particular purpose. It is provided "as is"
without express or implied warranty of any kind.
These notices must be retained in any copies of any part of this
documentation and/or software.
 */
#ifndef MD5_ALGORITHM_DEFINED
#define MD5_ALGORITHM_DEFINED
#ifdef MD5_SOURCE
#define MD5_PROC(type,name) EXPORT_METHOD type name
#else
#define MD5_PROC(type,name) IMPORT_METHOD type name
#endif
/* MD5 context. */
typedef struct {
	uint32_t state[4];
	uint32_t count[2];
  unsigned char buffer[64];
} MD5_CTX;
MD5_PROC( void, MD5Init )(MD5_CTX *);
MD5_PROC( void, MD5Update )(MD5_CTX *, unsigned char *, unsigned int);
MD5_PROC( void, MD5Final )(unsigned char [16], MD5_CTX *);
#endif
/*
 * SACK extension to define methods to render to javascript/HTML5 WebSocket event interface
 *
 * Crafted by: Jim Buckeyne
 *
 * Purpose: Provide a well defined, concise structure to
 *   provide websocket server support to C applications.
 *
 *
 *
 * (c)Freedom Collective, Jim Buckeyne 2012+; SACK Collection.
 *
 */
#ifndef HTML5_WEBSOCKET_STUFF_DEFINED
#define HTML5_WEBSOCKET_STUFF_DEFINED
//#include <controls.h>
// should consider merging these headers(?)
#ifdef __cplusplus
#define _HTML5_WEBSOCKET_NAMESPACE namespace Html5WebSocket {
#define HTML5_WEBSOCKET_NAMESPACE SACK_NAMESPACE _NETWORK_NAMESPACE _HTML5_WEBSOCKET_NAMESPACE
#define HTML5_WEBSOCKET_NAMESPACE_END } _NETWORK_NAMESPACE_END SACK_NAMESPACE_END
#define USE_HTML5_WEBSOCKET_NAMESPACE using namespace sack::network::Html5WebSocket;
#else
#define _HTML5_WEBSOCKET_NAMESPACE
#define HTML5_WEBSOCKET_NAMESPACE
#define HTML5_WEBSOCKET_NAMESPACE_END
#define USE_HTML5_WEBSOCKET_NAMESPACE
#endif
HTML5_WEBSOCKET_NAMESPACE
#ifdef HTML5_WEBSOCKET_SOURCE
#define HTML5_WEBSOCKET_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define HTML5_WEBSOCKET_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
// need some sort of other methods to work with an HTML5WebSocket...
// server side.
	HTML5_WEBSOCKET_PROC( PCLIENT, WebSocketCreate )( CTEXTSTR server_url
																	, web_socket_opened on_open
																	, web_socket_event on_event
																	, web_socket_closed on_closed
																	, web_socket_error on_error
																	, uintptr_t psv
																	);
// during open, server may need to switch behavior based on protocols
// this can be used to return the protocols requested by the client.
HTML5_WEBSOCKET_PROC( const char *, WebSocketGetProtocols )( PCLIENT pc );
// after examining protocols, this is a reply to the client which protocol has been accepted.
HTML5_WEBSOCKET_PROC( PCLIENT, WebSocketSetProtocols )( PCLIENT pc, const char *protocols );
/* define a callback which uses a HTML5WebSocket collector to build javascipt to render the control.
 * example:
 *       static int OnDrawToHTML("Control Name")(CONTROL, HTML5WebSocket ){ }
 */
//#define OnDrawToHTML(name)  //	__DefineRegistryMethodP(PRELOAD_PRIORITY,ROOT_REGISTRY,_OnDrawCommon,WIDE("control"),name WIDE("/rtti"),WIDE("draw_to_canvas"),int,(CONTROL, HTML5WebSocket ), __LINE__)
/* a server side utility to get the request headers that came in.
this is for going through proxy agents mostly where the header might have x-forwarded-for
*/
HTML5_WEBSOCKET_PROC( PLIST, GetWebSocketHeaders )( PCLIENT pc );
/* for server side sockets, get the requested resource path from the client request.
*/
HTML5_WEBSOCKET_PROC( PTEXT, GetWebSocketResource )( PCLIENT pc );
HTML5_WEBSOCKET_PROC( HTTPState, GetWebSocketHttpState )( PCLIENT pc );
HTML5_WEBSOCKET_PROC( void, ResetWebsocketRequestHandler )( PCLIENT pc_client );
HTML5_WEBSOCKET_PROC( uintptr_t, WebSocketGetServerData )( PCLIENT pc );
HTML5_WEBSOCKET_NAMESPACE_END
USE_HTML5_WEBSOCKET_NAMESPACE
#endif
HTML5_WEBSOCKET_NAMESPACE
#define WSS_DEFAULT_BUFFER_SIZE 4096
typedef struct html5_web_socket *HTML5WebSocket;
const TEXTCHAR *wssbase64 = WIDE("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=");
static void wssencodeblock( unsigned char in[3], TEXTCHAR out[4], int len )
{
    out[0] = wssbase64[ in[0] >> 2 ];
    out[1] = wssbase64[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
    out[2] = (unsigned char) (len > 1 ? wssbase64[ ((in[1] & 0x0f) << 2) | ((in[2] & 0xc0) >> 6) ] : '=');
    out[3] = (unsigned char) (len > 2 ? wssbase64[ in[2] & 0x3f ] : '=');
}
static LOGICAL ComputeReplyKey2( PVARTEXT pvt_output, HTML5WebSocket socket, PTEXT key1, PTEXT key2 )
{
	TEXTCHAR buf1[24];
	int buf1_idx = 0;
	uint64_t number1;
	TEXTCHAR buf2[24];
	int buf2_idx = 0;
	uint64_t number2;
	int spaces1 = 0;
	int spaces2 = 0;
	size_t c;
	size_t len;
	TEXTCHAR *check;
	// test overrides
	//key1 = SegCreateFromText( WIDE("4 @1  46546xW%0l 1 5" ) );
	//key2 = SegCreateFromText( WIDE("12998 5 Y3 1  .P00" ) );
	len = GetTextSize( key1 );
	check = GetText( key1 );
	for( c = 0; c < len; c++ )
	{
		if( check[c] == ' ' )
			spaces1++;
		if( check[c] >= '0' && check[c] <= WIDE( '9' ) )
			buf1[buf1_idx++] = check[c];
	}
	buf1[buf1_idx++] = 0;
	number1 = IntCreateFromText( buf1 );
	len = GetTextSize( key2 );
	check = GetText( key2 );
	for( c = 0; c < len; c++ )
	{
		if( check[c] == ' ' )
			spaces2++;
		if( check[c] >= '0' && check[c] <= WIDE( '9' ) )
			buf2[buf2_idx++] = check[c];
	}
	buf2[buf2_idx++] = 0;
	number2 = IntCreateFromText( buf2 );
	if( !spaces1 || !spaces2 )
		return FALSE;
	{
		int a = number1 % spaces1;
		int b = number2 % spaces2;
		if( a || b )
			return FALSE;
	}
	if( number1 % spaces1 || number2 % spaces2 )
		return FALSE;
	number1 = number1 / spaces1;
	number2 = number2 / spaces2;
	{
		struct replybuf
		{
			uint8_t result1[4];
			uint8_t result2[4];
			uint8_t extra[8];
		} buf;
		buf.result1[0] = (uint8_t)(( number1 & 0xFF000000 ) >> 24);
		buf.result1[1] = (uint8_t)(( number1 & 0xFF0000 ) >> 16);
		buf.result1[2] = (uint8_t)(( number1 & 0xFF00 ) >> 8);
		buf.result1[3] = (uint8_t)(( number1 & 0xFF ) >> 0);
		buf.result2[0] = (uint8_t)(( number2 & 0xFF000000 ) >> 24);
		buf.result2[1] = (uint8_t)(( number2 & 0xFF0000 ) >> 16);
		buf.result2[2] = (uint8_t)(( number2 & 0xFF00 ) >> 8);
		buf.result2[3] = (uint8_t)(( number2 & 0xFF ) >> 0);
		{
			int n;
			// override text_content with....
			//SegCreateFromText( WIDE("^n:ds[4U" ) );
			PTEXT text_content = GetHttpContent( socket->http_state );
			TEXTCHAR *content = GetText( text_content );
			for( n = 0; n < 8; n++ )
			{
				buf.extra[n] = ((char*)content)[n];
			}
		}
		{
			MD5_CTX ctx;
			uint8_t result[16];
			int n;
			MD5Init( &ctx );
			if( sizeof( buf ) != 16 )
				xlprintf(LOG_ALWAYS)( WIDE("padding has been injected, and all will be bad.") );
			MD5Update( &ctx, (unsigned char*)&buf, 16 );
			MD5Final(result, &ctx);
			for( n = 0; n < 16; n++ )
				VarTextAddCharacter( pvt_output, result[n] );
		}
		//md5( buf );
		//vtprintf(
	}
// passes test here
//	Sec-WebSocket-Key1: 18x 6]8vM;54 *(5:  {   U1]8  z [  8
//  Sec-WebSocket-Key2: 1_ tx7X d  <  nw  334J702) 7]o}` 0
//  Tm[K T2u
//  fQJ,fN/4F4!~K~MH
// passes test here
// 4 @1  46546xW%0l 1 5
// 12998 5 Y3 1  .P00
// ^n:ds[4U
// 8jKS'y:G*Co,Wxa-
// not sure all example data lined up.
//  Sec-WebSocket-Key1: 3e6b263  4 17 80
              //Sec-WebSocket-Key2: 17  9 G`ZD9   2 2b 7X 3 /r90
              //WjN}|M(6
//
//result:	 0x09 0x65 0x65 0x0A 0xB9 0x67 0x33 0x57 0x6A 0x4E 0x7D 0x7C 0x4D
//        0x28 0x36.
	return TRUE;
}
/* opcodes
      *  %x0 denotes a continuation frame
      *  %x1 denotes a text frame
      *  %x2 denotes a binary frame
      *  %x3-7 are reserved for further non-control frames
      *  %x8 denotes a connection close
      *  %x9 denotes a ping
      *  %xA denotes a pong
      *  %xB-F are reserved for further control frames
*/
static void HandleData( HTML5WebSocket socket, PCLIENT pc, POINTER buffer, size_t length )
{
	size_t n;
	//int randNum;
	//TEXTCHAR output[25];
	uint8_t* bytes = (uint8_t*)buffer;
	for( n = 0; n < length; n++ )
	{
		if( bytes[n] == 0 )
		{
			if( socket->input_state.fragment_collection_length )
			{
				lprintf( WIDE("Message start with a message outstanding, double null chars?!") );
				socket->input_state.fragment_collection_length = 0;
			}
		}
		if( bytes[n] == 0xFF )
		{
			lprintf( WIDE("Completed message...") );
			LogBinary( socket->input_state.fragment_collection, socket->input_state.fragment_collection_length );
			socket->input_state.fragment_collection_length = 0;
		}
		{
			if( socket->input_state.fragment_collection_avail == socket->input_state.fragment_collection_length )
			{
				uint8_t* new_fragment = NewArray( uint8_t, socket->input_state.fragment_collection_avail + 64 );
				socket->input_state.fragment_collection_avail += 64;
				MemCpy( new_fragment, socket->input_state.fragment_collection, socket->input_state.fragment_collection_length );
				Deallocate( POINTER, socket->input_state.fragment_collection );
				socket->input_state.fragment_collection = new_fragment;
			}
			socket->input_state.fragment_collection[socket->input_state.fragment_collection_length++] = bytes[n];
		}
	}
}
void ResetWebsocketRequestHandler( PCLIENT pc ) {
	HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
 // closing/closed....
	if( !socket ) return;
	socket->flags.initial_handshake_done = 0;
	socket->flags.http_request_only = 0;
	EndHttp( socket->http_state );
}
uintptr_t WebSocketGetServerData( PCLIENT pc ) {
	HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
 // closing/closed....
	if( !socket ) return 0;
	return socket->input_state.psv_on;
}
static void CPROC destroyHttpState( HTML5WebSocket socket, PCLIENT pc_client ) {
	//HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc_client, 0 );
	if( socket->flags.in_open_event ) {
		socket->flags.closed = 1;
		return;
	}
	//lprintf( "ServerWebSocket Connection closed event..." );
	if( pc_client && socket->input_state.on_close && socket->input_state.psv_open  ) {
		socket->input_state.on_close( pc_client, socket->input_state.psv_open, socket->input_state.close_code, socket->input_state.close_reason );
	}
	else if( pc_client && socket->input_state.on_http_close ) {
		socket->input_state.on_http_close( pc_client, socket->input_state.psv_on );
	}
	if( socket->input_state.close_reason )
		Deallocate( char*, socket->input_state.close_reason );
#ifndef __NO_WEBSOCK_COMPRESSION__
	if( socket->input_state.flags.deflate ) {
		deflateEnd( &socket->input_state.deflater );
		inflateEnd( &socket->input_state.inflater );
		Deallocate( POINTER, socket->input_state.inflateBuf );
		Deallocate( POINTER, socket->input_state.deflateBuf );
	}
#endif
	Deallocate( uint8_t*, socket->input_state.fragment_collection );
	DestroyHttpState( socket->http_state );
	Deallocate( POINTER, socket->buffer );
	Deallocate( HTML5WebSocket, socket );
	SetNetworkLong( pc_client, 0, 0 );
}
static void CPROC closed( PCLIENT pc_client ) {
	HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc_client, 0 );
	destroyHttpState( socket, pc_client );
}
static void CPROC read_complete( PCLIENT pc, POINTER buffer, size_t length )
{
	HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
 // closing/closed....
	if( !socket ) return;
	if( buffer )
	{
		int result;
#ifdef _UNICODE
		TEXTSTR tmp = CharWConvertExx( (const char*)buffer, length DBG_SRC );
#else
		TEXTSTR tmp = (TEXTSTR)buffer;
#endif
		//LogBinary( buffer, length );
		//lprintf( "handle data: handshake: %d",socket->flags.initial_handshake_done );
		if( !socket->flags.initial_handshake_done || socket->flags.http_request_only )
		{
			//lprintf( WIDE("Initial handshake is not done...") );
			AddHttpData( socket->http_state, tmp, length );
			while( ( result = ProcessHttp( pc, socket->http_state ) ) )
			{
				switch( result )
				{
				default:
					lprintf( WIDE("unexpected result is %d"), result );
					break;
				case HTTP_STATE_RESULT_CONTENT:
				{
					PVARTEXT pvt_output = VarTextCreate();
					PTEXT value, value2;
					PTEXT key1, key2;
					value = GetHTTPField( socket->http_state, WIDE( "Connection" ) );
					value2 = GetHTTPField( socket->http_state, WIDE( "Upgrade" ) );
					if( !value || !value2
						|| !StrCaseStr( GetText(value), "upgrade" )
						|| !TextLike( value2, "websocket" ) ) {
						//lprintf( "request is not an upgrade for websocket." );
						socket->flags.initial_handshake_done = 1;
						socket->flags.http_request_only = 1;
						socket->flags.in_open_event = 1;
						if( socket->input_state.on_request ) {
							socket->input_state.on_request( pc, socket->input_state.psv_on );
						} else {
							socket->flags.in_open_event = 0;
							RemoveClient( pc );
							return;
						}
						socket->flags.in_open_event = 0;
						if( socket->flags.closed ) {
							destroyHttpState( socket, NULL );
							return;
						}
						break;
					}
					value = GetHTTPField( socket->http_state, WIDE( "Sec-WebSocket-Extensions" ) );
					if( value )
					{
						PTEXT options = TextParse( value, "=", "; ", 0, 0 DBG_SRC );
						PTEXT opt = options;
						while( opt ) {
							// "server_no_context_takeover"
							// "client_no_context_takeover"
							// "server_max_window_bits"
							// "client_max_window_bits"
#ifndef __NO_WEBSOCK_COMPRESSION__
							if( TextLike( opt, "permessage-deflate" ) ) {
								socket->input_state.flags.deflate = socket->input_state.flags.deflate & 1;
								if( socket->input_state.flags.deflate ) {
									socket->input_state.server_max_bits = 15;
									socket->input_state.client_max_bits = 15;
								}
							}
							else
#endif
							if( TextLike( opt, "client_max_window_bits" ) ) {
								opt = NEXTLINE( opt );
								if( opt ) {
									if( GetText( opt )[0] == '=' ) {
										opt = NEXTLINE( opt );
										socket->input_state.client_max_bits = (int)IntCreateFromSeg( opt );
									}
									else
										opt = PRIORLINE( opt );
								}
								//socket->flags.max_window_bits = 1;
							}
							else if( TextLike( opt, "server_max_window_bits" ) ) {
								opt = NEXTLINE( opt );
								if( opt ) {
									if( GetText( opt )[0] == '=' ) {
										opt = NEXTLINE( opt );
										socket->input_state.server_max_bits = (int)IntCreateFromSeg( opt );
									}
								}
								else {
									lprintf( "required server_max_window_bits value is missing" );
								}
								//socket->flags.max_window_bits = 1;
							}
							else if( TextLike( opt, "client_no_context_takeover" ) ) {
								//socket->flags.max_window_bits = 1;
							}
							else if( TextLike( opt, "server_no_context_takeover" ) ) {
								//socket->flags.max_window_bits = 1;
							}
							opt = NEXTLINE( opt );
						}
						LineRelease( options );
#ifndef __NO_WEBSOCK_COMPRESSION__
						if( socket->input_state.flags.deflate && !socket->input_state.flags.do_not_deflate ) {
							if( deflateInit2( &socket->input_state.deflater
								, Z_BEST_SPEED, Z_DEFLATED
								, -socket->input_state.server_max_bits
								, 8
								, Z_DEFAULT_STRATEGY ) != Z_OK )
								socket->input_state.flags.deflate = 0;
						}
						if( socket->input_state.flags.deflate ) {
							//socket->inflateWindow = NewArray( uint8_t, (size_t)(1 << (socket->client_max_bits&0x1f)) );
							if( inflateInit2( &socket->input_state.inflater, -socket->input_state.client_max_bits ) != Z_OK ) {
							//if( inflateBackInit( &socket->input_state.inflater, socket->client_max_bits, socket->inflateWindow ) != Z_OK ) {
								deflateEnd( &socket->input_state.deflater );
								socket->input_state.flags.deflate = 0;
							}
							else {
								socket->input_state.inflateBuf = NewArray( uint8_t, 4096 );
								socket->input_state.inflateBufLen = 4096;
								socket->input_state.deflateBuf = NewArray( uint8_t, 4096 );
								socket->input_state.deflateBufLen = 4096;
							}
						}
#endif
					}
					else {
						socket->input_state.flags.deflate = 0;
					}
					value = GetHTTPField( socket->http_state, WIDE( "Sec-WebSocket-Protocol" ) );
					if( value ) {
						socket->protocols = GetText( value );
					}
					else socket->protocols = NULL;
					{
						PTEXT protocols = GetHTTPField( socket->http_state, WIDE( "Sec-WebSocket-Protocol" ) );
						PTEXT resource = GetHttpResource( socket->http_state );
						if( socket->input_state.on_accept ) {
							socket->flags.accepted = socket->input_state.on_accept( pc, socket->input_state.psv_on, GetText( protocols ), GetText( resource ), &socket->protocols );
						}
						else
							socket->flags.accepted = 1;
					}
					key1 = GetHTTPField( socket->http_state, WIDE( "Sec-WebSocket-Key1" ) );
					key2 = GetHTTPField( socket->http_state, WIDE( "Sec-WebSocket-Key2" ) );
					if( key1 && key2 )
						socket->flags.rfc6455 = 0;
					else
						socket->flags.rfc6455 = 1;
					if( !socket->flags.accepted ) {
						vtprintf( pvt_output, WIDE( "HTTP/1.1 403 Connection refused\r\n" ) );
					}
					else
					{
						if( key1 && key2 )
							vtprintf( pvt_output, WIDE( "HTTP/1.1 101 WebSocket Protocol Handshake\r\n" ) );
						else
							vtprintf( pvt_output, WIDE( "HTTP/1.1 101 Switching Protocols\r\n" ) );
						vtprintf( pvt_output, WIDE( "Upgrade: WebSocket\r\n" ) );
						vtprintf( pvt_output, WIDE( "Connection: Upgrade\r\n" ) );
					}
					value = GetHTTPField( socket->http_state, WIDE( "Origin" ) );
					if( value )
					{
						if( key1 && key2 )
							vtprintf( pvt_output, WIDE( "Sec-WebSocket-Origin: %s\r\n" ), GetText( value ) );
						else
							vtprintf( pvt_output, WIDE( "WebSocket-Origin: %s\r\n" ), GetText( value ) );
					}
					if( key1 && key2 )
					{
						vtprintf( pvt_output, WIDE( "Sec-WebSocket-Location: ws://%s%s\r\n" )
							, GetText( GetHTTPField( socket->http_state, WIDE( "Host" ) ) )
							, GetText( GetHttpRequest( socket->http_state ) )
						);
					}
					if( socket->flags.accepted ) {
						value = GetHTTPField( socket->http_state, WIDE( "Sec-webSocket-Key" ) );
						if( value )
						{
							{
								const char guid[] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
								size_t len;
								char *resultval = NewArray( char, len = (GetTextSize( value ) + sizeof( guid ) ) );
								snprintf( resultval, len, WIDE( "%s%s" )
									, GetText( value )
									, guid );
								{
									TEXTCHAR output[32];
									SHA1Context context;
									int n;
									uint8_t Message_Digest[SHA1HashSize + 2];
									SHA1Reset( &context );
									SHA1Input( &context, (uint8_t*)resultval, len - 1 );
									SHA1Result( &context, Message_Digest );
									Message_Digest[SHA1HashSize] = 0;
									Message_Digest[SHA1HashSize + 1] = 0;
									for( n = 0; n < (SHA1HashSize + 2) / 3; n++ )
									{
										int blocklen;
										blocklen = SHA1HashSize - n * 3;
										if( blocklen > 3 )
											blocklen = 3;
										wssencodeblock( Message_Digest + n * 3, output + n * 4, blocklen );
									}
									output[n * 4 + 0] = 0;
									// s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
									vtprintf( pvt_output, WIDE( "Sec-WebSocket-Accept: %s\r\n" ), output );
								}
								Deallocate( char *, resultval );
							}
						}
						if( socket->input_state.flags.deflate ) {
							vtprintf( pvt_output, WIDE( "Sec-WebSocket-Extensions: permessage-deflate; client_no_context_takeover; server_max_window_bits=%d\r\n" ), socket->input_state.server_max_bits );
						}
						if( socket->protocols )
							vtprintf( pvt_output, WIDE( "Sec-WebSocket-Protocol: %s\r\n" ), socket->protocols );
						vtprintf( pvt_output, WIDE( "WebSocket-Server: sack\r\n" ) );
						vtprintf( pvt_output, WIDE( "\r\n" ) );
						if( key1 && key2 )
						{
							ComputeReplyKey2( pvt_output, socket, key1, key2 );
						}
						value = VarTextPeek( pvt_output );
#ifdef _UNICODE
						{
							char *output;
							output = DupTextToChar( GetText( value ) );
							//LogBinary( output, GetTextSize( value ) );
							if( socket->input_state.flags.use_ssl )
								ssl_Send( pc, output, GetTextSize( value ) );
							else
								SendTCP( pc, output, GetTextSize( value ) );
						}
#else
						if( socket->input_state.flags.use_ssl )
							ssl_Send( pc, GetText( value ), GetTextSize( value ) );
						else
							SendTCP( pc, GetText( value ), GetTextSize( value ) );
#endif
						//lprintf( "Sent http reply." );
						VarTextDestroy( &pvt_output );
						socket->flags.in_open_event = 1;
						if( socket->input_state.on_open )
							socket->input_state.psv_open = socket->input_state.on_open( pc, socket->input_state.psv_on );
						socket->flags.in_open_event = 0;
						if( socket->flags.closed ) {
							destroyHttpState( socket, NULL );
							return;
						}
					}
					else {
						WebSocketClose( pc, 0, NULL );
						return;
					}
					// keep this until close, application might want resource and/or headers from this.
					//EndHttp( socket->http_state );
					socket->flags.initial_handshake_done = 1;
					break;
				}
				case HTTP_STATE_RESULT_CONTINUE:
					break;
				}
			}
		}
		else
		{
			//lprintf( WIDE("Okay then hand this as data to process... within protocol") );
			if( socket->flags.rfc6455 )
			{
				ProcessWebSockProtocol( &socket->input_state, pc, (uint8_t*)buffer, length );
			}
			else
				HandleData( socket, pc, buffer, length );
		}
	}
	else
	{
		//HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
		buffer = socket->buffer = Allocate( WSS_DEFAULT_BUFFER_SIZE );
	}
	if( !socket->input_state.flags.use_ssl )
		ReadTCP( pc, buffer, WSS_DEFAULT_BUFFER_SIZE );
}
static void CPROC connected( PCLIENT pc_server, PCLIENT pc_new )
{
	HTML5WebSocket server_socket = (HTML5WebSocket)GetNetworkLong( pc_server, 0 );
	HTML5WebSocket socket = New( struct html5_web_socket );
	MemSet( socket, 0, sizeof( struct html5_web_socket ) );
	socket->Magic = 0x20130912;
	socket->pc = pc_new;
 // clone callback methods and config flags
	socket->input_state = server_socket->input_state;
	socket->input_state.close_code = 1006;
	if( ssl_IsClientSecure( pc_new ) )
		socket->input_state.flags.use_ssl = 1;
 // start a new http state collector
	socket->http_state = CreateHttpState();
	//lprintf( "Init socket: handshake: %p %p  %d", pc_new, socket, socket->flags.initial_handshake_done );
	SetNetworkLong( pc_new, 0, (uintptr_t)socket );
	SetNetworkLong( pc_new, 1, (uintptr_t)&socket->input_state );
	SetNetworkReadComplete( pc_new, read_complete );
	SetNetworkCloseCallback( pc_new, closed );
}
static LOGICAL CPROC HandleWebsockRequest( uintptr_t psv, HTTPState pHttpState )
{
	return 0;
}
PCLIENT WebSocketCreate( CTEXTSTR hosturl
							, web_socket_opened on_open
							, web_socket_event on_event
							, web_socket_closed on_closed
							, web_socket_error on_error
							, uintptr_t psv )
{
	struct url_data *url;
	HTML5WebSocket socket = New( struct html5_web_socket );
	MemSet( socket, 0, sizeof( struct html5_web_socket ) );
	socket->Magic = 0x20130912;
	socket->input_state.flags.deflate = 0;
	socket->input_state.on_open = on_open;
	socket->input_state.on_event = on_event;
	socket->input_state.on_close = on_closed;
	socket->input_state.on_error = on_error;
	socket->input_state.psv_on = psv;
	socket->input_state.close_code = 1006;
	url = SACK_URLParse( hosturl );
	socket->pc = OpenTCPListenerAddrEx( CreateSockAddress( url->host, url->port?url->port:url->default_port ), connected );
	SACK_ReleaseURL( url );
  if( !socket->pc ) {
    Deallocate( HTML5WebSocket, socket );
    return NULL;
  }
	socket->http_state = CreateHttpState();
	SetNetworkLong( socket->pc, 0, (uintptr_t)socket );
	SetNetworkLong( socket->pc, 1, (uintptr_t)&socket->input_state );
	return socket->pc;
}
PLIST GetWebSocketHeaders( PCLIENT pc ) {
	HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
	if( socket && socket->Magic == 0x20130912 ) {
		return GetHttpHeaderFields( socket->http_state );
	}
	return NULL;
}
PTEXT GetWebSocketResource( PCLIENT pc ) {
	HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
	if( socket && socket->Magic == 0x20130912 ) {
		return GetHttpResource( socket->http_state );
	}
	return NULL;
}
HTTPState GetWebSocketHttpState( PCLIENT pc ) {
	if( pc ) {
		HTML5WebSocket socket = (HTML5WebSocket)GetNetworkLong( pc, 0 );
		if( socket && socket->Magic == 0x20130912 ) {
			return socket->http_state;
		}
	}
	return NULL;
}
HTML5_WEBSOCKET_NAMESPACE_END
#ifndef JSON_EMITTER_SOURCE
#  define JSON_EMITTER_SOURCE
#endif
#ifndef JSON_PARSER_MAIN_SOURCE
#  define JSON_PARSER_MAIN_SOURCE
#endif
#ifndef JSON_EMITTER_HEADER_INCLUDED
#define JSON_EMITTER_HEADER_INCLUDED
#ifdef JSON_EMITTER_SOURCE
#define JSON_EMITTER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define JSON_EMITTER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace json {
#endif
enum JSON_ObjectElementTypes
{
   JSON_Element_Integer_8,
   JSON_Element_Integer_16,
   JSON_Element_Integer_32,
   JSON_Element_Integer_64,
   JSON_Element_Unsigned_Integer_8,
   JSON_Element_Unsigned_Integer_16,
   JSON_Element_Unsigned_Integer_32,
   JSON_Element_Unsigned_Integer_64,
   JSON_Element_String,
   JSON_Element_CharArray,
   JSON_Element_Float,
   JSON_Element_Double,
  // result will fill a PLIST
   JSON_Element_Array,
   JSON_Element_Object,
   JSON_Element_ObjectPointer,
   JSON_Element_List,
  // ptext type
   JSON_Element_Text,
   JSON_Element_PTRSZVAL,
   JSON_Element_PTRSZVAL_BLANK_0,
	JSON_Element_UserRoutine,
 // unparsed object remainder.  Includes bounding { } object indicator for re-parsing
	JSON_Element_Raw_Object,
   //JSON_Element_StaticText,  // text type; doesn't happen very often.
};
struct json_context_object_element;
struct json_context_object;
struct json_context;
#define JSON_NO_OFFSET (size_t)-1
// Get a context, which can track message formats.
// Will eventually expose the low level routines so one can use a context
// and the simple message building utility functions to product json output
// without defining objects and members....
JSON_EMITTER_PROC( struct json_context *, json_create_context )( void );
// Begin the definition of a json formatting object.
// the root element must be a array or an object
JSON_EMITTER_PROC( struct json_context_object *, json_create_object )( struct json_context *context
                                                                     , size_t object_size );
// Begin the definition of a json formatting object.
// the root element must be a array or an object
JSON_EMITTER_PROC( struct json_context_object *, json_create_array )( struct json_context *context
                                                                    , size_t offset
                                                                    , enum JSON_ObjectElementTypes type
                                                                    , size_t count
                                                                    , size_t count_offset
                                                                    );
// add a member element to a json object
// if the member element is a object type, then a new context_object results, to which members may be added.
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member )( struct json_context_object *object
                                                                         , CTEXTSTR name
                                                                         , size_t offset
                                                                         , enum JSON_ObjectElementTypes type
                                                                         , size_t object_size
                                                                         );
// more complex method; add_object_member actually calls this to implement a 0 byte array of the same type.
//  object_size is used if the type is JSON_Element_ObjectPointer for the parsing to be able to allocate
// the message part.
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_array )( struct json_context_object *format
                                                                               , CTEXTSTR name
                                                                               , size_t offset
                                                                               , enum JSON_ObjectElementTypes type
                                                                               , size_t object_size
                                                                               , size_t count
                                                                               , size_t count_offset
                                                                               );
// more complex method; add_object_member actually calls this to implement a 0 byte array of the same type.
//  object_size is used if the type is JSON_Element_ObjectPointer for the parsing to be able to allocate
// the message part.  array is represented as a pointer, which will be dynamically allocated
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_array_pointer )( struct json_context_object *format
                                                                                       , CTEXTSTR name
                                                                                       , size_t offset
                                                                                       , enum JSON_ObjectElementTypes type
                                                                                       , size_t count_offset
                                                                                       );
// adds a reference to a PLIST as an array with the content of the array specified as the type
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_list )( struct json_context_object *object
                                                                              , CTEXTSTR name
  // offset of the list
                                                                              , size_t offset
 // of of the members of the list
                                                                              , enum JSON_ObjectElementTypes content_type
  // object size if required
                                                                              , size_t object_size
                                                                              );
// this allows recursive structures, so the structure may contain a reference to itself.
// this allows buildling other objects and referencing them instead of building them in-place
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_object )( struct json_context_object *object
                                                                                , CTEXTSTR name
                                                                                , size_t offset
                                                                                , enum JSON_ObjectElementTypes type
                                                                                , struct json_context_object *child_object
                                                                                );
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_user_routine )( struct json_context_object *object
                                                                                      , CTEXTSTR name
                                                                                      , size_t offset, enum JSON_ObjectElementTypes type
                                                                                      , size_t object_size
                                                                                      , void (*user_formatter)(PVARTEXT,CPOINTER) );
// take a object format and a pointer to data and return a json message string
JSON_EMITTER_PROC( TEXTSTR, json_build_message )( struct json_context_object *format
                                                , POINTER msg );
// take a json string and a format and fill in a structure from the text.
// tests all formats, to first-match;
// take a json string and a format and fill in a structure from the text.
// if object does not fit all members (may have extra, but must have at least all members in message in format to return TRUE)
// then it returns false; that is if a member is in the 'msg' parameter that is not in
// the format, then the result is FALSE.
//  PDATALIST is full of struct json_value_container
// turns out numbers can be  hex, octal and binary numbers  (0x[A-F,a-f,0-9]*, 0b[0-1]*, 0[0-9]*)
// slightly faster (17%) than json6_parse_message because of fewer possible checks.
JSON_EMITTER_PROC( LOGICAL, json_parse_message )(const char * msg
                                                , size_t msglen
                                                , PDATALIST *msg_data_out
                                                );
// allocates a parsing context and begins parsing data.
JSON_EMITTER_PROC( struct json_parse_state *, json_begin_parse )( void );
// return TRUE when a completed value/object is available.
// after returning TRUE, call json_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns FALSE, then ther is no further object
// to retrieve.
JSON_EMITTER_PROC( int, json_parse_add_data )( struct json_parse_state *context
                                             , const char * msg
                                             , size_t msglen
                                             );
// these are common functions that work for json or json6 stream parsers
JSON_EMITTER_PROC( PDATALIST, json_parse_get_data )( struct json_parse_state *context );
JSON_EMITTER_PROC( void, json_parse_dispose_state )( struct json_parse_state **context );
JSON_EMITTER_PROC( void, json_parse_clear_state )(struct json_parse_state *context);
JSON_EMITTER_PROC( PTEXT, json_parse_get_error )(struct json_parse_state *context);
// take a json string and a format and fill in a structure from the text.
// tests all formats, to first-match;
// take a json string and a format and fill in a structure from the text.
// if object does not fit all members (may have extra, but must have at least all members in message in format to return TRUE)
// then it returns false; that is if a member is in the 'msg' parameter that is not in
// the format, then the result is FALSE.
//  PDATALIST is full of struct json_value_container
//   JSON5 support - Infinity/Nan, string continuations, and comments,unquoted field names; hex, octal and binary numbers
//       unquoted field names must be a valid javascript keyword using unicode ID_Start/ID_Continue states to determine valid characters.
//       this is arbitrary though; and could be reverted to just accepting any character other than ':'.
//   JSON(6?) support - undefined keyword value
//       accept \uXXXX, \xXX, \[0-3]xx octal, \u{xxxxx} encodings in strings
//       allow underscores in numbers to separate number groups ( works as ZWNBSP )
JSON_EMITTER_PROC( LOGICAL, json6_parse_message )( const char * msg
                                                 , size_t msglen
                                                 , PDATALIST *msg_data_out
                                                 );
JSON_EMITTER_PROC( LOGICAL, _json6_parse_message )( char * msg
                                                  , size_t msglen
                                                  , PDATALIST *msg_data_out
                                                  );
// Add some data to parse for json stream (which may consist of multiple values)
// return 1 when a completed value/object is available.
// after returning 1, call json_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns 0, then there is no further object
// to retrieve.
// if this returns -1, an error in parsing has occured, and no further parsing can happen.
JSON_EMITTER_PROC( int, json6_parse_add_data )( struct json_parse_state *context
                                              , const char * msg
                                              , size_t msglen
                                              );
JSON_EMITTER_PROC( LOGICAL, json_decode_message )( struct json_context *format
                                                 , PDATALIST parsedMsg
                                                 , struct json_context_object **result_format
                                                 , POINTER *msg_data_out
                                                 );
enum json_value_types {
	VALUE_UNDEFINED = -1
	, VALUE_UNSET = 0
 //= 1 no data
	, VALUE_NULL
 //= 2 no data
	, VALUE_TRUE
 //= 3 no data
	, VALUE_FALSE
 //= 4 string
	, VALUE_STRING
 //= 5 string + result_d | result_n
	, VALUE_NUMBER
 //= 6 contains
	, VALUE_OBJECT
 //= 7 contains
	, VALUE_ARRAY
	// up to here is supported in JSON
 //= 8 no data
	, VALUE_NEG_NAN
 //= 9 no data
	, VALUE_NAN
 //= 10 no data
	, VALUE_NEG_INFINITY
 //= 11 no data
	, VALUE_INFINITY
  // = 12 comes in as a number, string is data.
	, VALUE_DATE
 // = 13 no data; used in [,,,] as place holder of empty
	, VALUE_EMPTY
  // = 14 string is base64 encoding of bytes.
	, VALUE_TYPED_ARRAY
  // = 14 string is base64 encoding of bytes.
	, VALUE_TYPED_ARRAY_MAX = 14+12
};
struct json_value_container {
  // name of this value (if it's contained in an object)
	char * name;
	size_t nameLen;
 // value from above indiciating the type of this value
	enum json_value_types value_type;
   // the string value of this value (strings and number types only)
	char *string;
	size_t stringLen;
  // boolean whether to use result_n or result_d
	int float_result;
	union {
		double result_d;
		int64_t result_n;
		//struct json_value_container *nextToken;
	};
  // list of struct json_value_container that this contains.
	PDATALIST contains;
  // acutal source datalist(?)
	PDATALIST *_contains;
};
// any allocate mesage parts are released.
JSON_EMITTER_PROC( void, json_dispose_message )( PDATALIST *msg_data );
// any allocate mesage parts are released.
JSON_EMITTER_PROC( void, json6_dispose_message )( PDATALIST *msg_data );
JSON_EMITTER_PROC( void, json_dispose_decoded_message )(struct json_context_object *format
	, POINTER msg_data);
// sanitize strings to send in JSON so quotes don't prematurely end strings and output is still valid.
// require Release the result.
JSON_EMITTER_PROC( char*, json_escape_string )( const char * string );
// sanitize strings to send in JSON so quotes don't prematurely end strings and output is still valid.
// require Release the result.  pass by length so \0 characters can be kept and don't early terminate.  Result with new length also.
JSON_EMITTER_PROC( char*, json_escape_string_length )( const char *string, size_t length, size_t *outlen );
// sanitize strings to send in JSON6 so quotes don't prematurely end strings and output is still valid.
// require Release the result.  Also escapes not just double-quotes ("), but also single and ES6 Format quotes (', `)
// this does not translate control chararacters like \n, \t, since strings are allowed to be muliline.
JSON_EMITTER_PROC( char*, json6_escape_string )( const char * string );
// sanitize strings to send in JSON6 so quotes don't prematurely end strings and output is still valid.
// require Release the result.  pass by length so \0 characters can be kept and don't early terminate.  Result with new length also.
// this does not translate control chararacters like \n, \t, since strings are allowed to be muliline.
JSON_EMITTER_PROC( char*, json6_escape_string_length )( const char *string, size_t len, size_t *outlen );
#ifdef __cplusplus
} } SACK_NAMESPACE_END
using namespace sack::network::json;
#endif
#endif
#define JSON_PARSER_INCLUDED
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace json {
#endif
struct json_context_object_element
{
     // type of the element at this offset
	enum JSON_ObjectElementTypes type;
     // type of the element at this offset
	enum JSON_ObjectElementTypes content_type;
  // how big this element is.
	size_t object_size;
   // offset into the structure
	size_t offset;
 // name of this element in the object
	CTEXTSTR name;
 // at offset, this number of these is there; (array)
	size_t count;
 // at count_offset, is the number of elements that the pointer at this offset
	size_t count_offset;
	void (*user_formatter)(PVARTEXT pvt_output,CPOINTER msg_data);
	struct json_context_object *object;
};
struct json_context_object
{
	struct json_context *context;
   // list of members of this object struct json_context_object_element *
	PLIST members;
 // if set is an array format, otherwise is an object format.
	int is_array;
	size_t object_size;
	size_t offset;
	struct json_context_object_flags
	{
  // this is not a root object
		BIT_FIELD keep_phrase : 1;
		BIT_FIELD dynamic_size : 1;
	} flags;
	struct json_context_object *parent;
};
struct json_context
{
	int levels;
	PVARTEXT pvt;
	PLIST object_types;
	int human_readable;
};
enum word_char_states {
 // not in a keyword
	WORD_POS_RESET = 0,
  // at end of a word, waiting for separator
	WORD_POS_END,
	WORD_POS_TRUE_1,
	WORD_POS_TRUE_2,
	WORD_POS_TRUE_3,
	WORD_POS_TRUE_4,
 // 11
	WORD_POS_FALSE_1,
	WORD_POS_FALSE_2,
	WORD_POS_FALSE_3,
	WORD_POS_FALSE_4,
 // 21  get u
	WORD_POS_NULL_1,
 //  get l
	WORD_POS_NULL_2,
 //  get l
	WORD_POS_NULL_3,
  // 31
	WORD_POS_UNDEFINED_1,
	WORD_POS_UNDEFINED_2,
	WORD_POS_UNDEFINED_3,
	WORD_POS_UNDEFINED_4,
	WORD_POS_UNDEFINED_5,
	WORD_POS_UNDEFINED_6,
	WORD_POS_UNDEFINED_7,
	WORD_POS_UNDEFINED_8,
	//WORD_POS_UNDEFINED_9, // instead of stepping to this value here, go to RESET
	WORD_POS_NAN_1,
	WORD_POS_NAN_2,
	//WORD_POS_NAN_3,// instead of stepping to this value here, go to RESET
	WORD_POS_INFINITY_1,
	WORD_POS_INFINITY_2,
	WORD_POS_INFINITY_3,
	WORD_POS_INFINITY_4,
	WORD_POS_INFINITY_5,
	WORD_POS_INFINITY_6,
	WORD_POS_INFINITY_7,
	//WORD_POS_INFINITY_8,// instead of stepping to this value here, go to RESET
	WORD_POS_FIELD,
	WORD_POS_AFTER_FIELD,
	WORD_POS_DOT_OPERATOR,
	WORD_POS_PROPER_NAME,
	WORD_POS_AFTER_PROPER_NAME,
	WORD_POS_AFTER_GET,
	WORD_POS_AFTER_SET,
};
enum parse_context_modes {
 CONTEXT_UNKNOWN = 0,
 CONTEXT_IN_ARRAY = 1,
 CONTEXT_IN_OBJECT = 2,
 CONTEXT_OBJECT_FIELD = 3,
 CONTEXT_OBJECT_FIELD_VALUE = 4,
 };
struct json_parse_context {
	enum parse_context_modes context;
	PDATALIST *elements;
	char *name;
	size_t nameLen;
	struct json_value_container valState;
	struct json_context_object *object;
};
#define RESET_VAL()  {	  val.value_type = VALUE_UNSET;	 val.contains = NULL;	              val._contains = NULL;	             val.name = NULL;	                  val.string = NULL;	                negative = FALSE; }
#define RESET_STATE_VAL()  {	  state->val.value_type = VALUE_UNSET;	 state->val.contains = NULL;	              state->val._contains = NULL;	             state->val.name = NULL;	                  state->val.string = NULL;	                state->negative = FALSE; }
typedef struct json_parse_context PARSE_CONTEXT, *PPARSE_CONTEXT;
#define MAXPARSE_CONTEXTSPERSET 128
DeclareSet( PARSE_CONTEXT );
struct json_input_buffer {
      // prior input buffer
	char const * buf;
 // size of prior input buffer
	size_t       size;
  // last position in _input if context closed before end of buffer
	char const * pos;
};
struct json_output_buffer {
      // prior input buffer
	char * buf;
 // size of prior input buffer
	size_t  size;
  // last position in _input if context closed before end of buffer
	char * pos;
};
typedef struct json_input_buffer PARSE_BUFFER, *PPARSE_BUFFER;
#define MAXPARSE_BUFFERSPERSET 128
DeclareSet( PARSE_BUFFER );
// this is the stack state that can be saved between parsing for streaming.
struct json_parse_state {
	//TEXTRUNE c;
	PDATALIST *elements;
 //
	PLINKSTACK *outBuffers;
 // matches input queue
	PLINKQUEUE *outQueue;
	PLIST *outValBuffers;
	//TEXTSTR mOut;// = NewArray( char, msglen );
	size_t line;
	size_t col;
 // character index;
	size_t n;
	//size_t _n = 0; // character index; (restore1)
	enum word_char_states word;
	LOGICAL status;
	LOGICAL negative;
	LOGICAL literalString;
	PLINKSTACK *context_stack;
	LOGICAL first_token;
	PPARSE_CONTEXT context;
	enum parse_context_modes parse_context;
	struct json_value_container val;
	int comment;
	TEXTRUNE operatorAccum;
	PLINKQUEUE *inBuffers;
	//char const * input;     // current input buffer start
	//char const * msg_input; // current input buffer position (incremented while reading)
	LOGICAL completed;
	LOGICAL complete_at_end;
	LOGICAL gatheringString;
	TEXTRUNE gatheringStringFirstChar;
	TEXTRUNE gatheringCodeLastChar;
	int codeDepth;
	LOGICAL gatheringNumber;
	LOGICAL numberExponent;
	LOGICAL numberFromHex;
	LOGICAL numberFromDate;
	PVARTEXT pvtError;
	LOGICAL fromHex;
	LOGICAL exponent;
	LOGICAL exponent_sign;
	LOGICAL exponent_digit;
	LOGICAL escape;
	LOGICAL cr_escaped;
	LOGICAL unicodeWide;
	LOGICAL stringUnicode;
	LOGICAL stringHex;
	TEXTRUNE hex_char;
	int hex_char_len;
	LOGICAL stringOct;
	LOGICAL weakSpace;
	PDATALIST root;
	//char *token_begin;
};
typedef struct json_parse_state PARSE_STATE, *PPARSE_STATE;
#define MAXPARSE_STATESPERSET 32
DeclareSet( PARSE_STATE );
typedef PLIST *PPLIST;
#define MAXPLISTSPERSET 256
DeclareSet( PLIST );
typedef PLINKSTACK *PPLINKSTACK;
#define MAXPLINKSTACKSPERSET 256
DeclareSet( PLINKSTACK );
typedef PLINKQUEUE *PPLINKQUEUE;
#define MAXPLINKQUEUESPERSET 256
DeclareSet( PLINKQUEUE );
typedef PDATALIST *PPDATALIST;
#define MAXPDATALISTSPERSET 256
DeclareSet( PDATALIST );
struct json_parser_shared_data {
	PPARSE_CONTEXTSET parseContexts;
	PPARSE_BUFFERSET parseBuffers;
	struct json_parse_state *last_parse_state;
	PPARSE_STATESET parseStates;
	PPLISTSET listSet;
	PPLINKSTACKSET linkStacks;
	PPLINKQUEUESET linkQueues;
	PPDATALISTSET dataLists;
};
#ifndef JSON_PARSER_MAIN_SOURCE
extern
#endif
struct json_parser_shared_data jpsd;
void _json_dispose_message( PDATALIST *msg_data );
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace json {
#endif
char *json_escape_string_length( const char *string, size_t length, size_t *outlen ) {
	size_t m = 0;
	size_t ch;
	const char *input;
	TEXTSTR output, _output;
	if( !(input = string) ) return NULL;
	for( ch = 0; ch < length; ch++, input++ ) {
		if( input[0] == '"' || input[0] == '\\' )
			m++;
		else if( input[0] == '\n' )
			m++;
		else if( input[0] == '\t' )
			m++;
	}
	_output = output = NewArray( char, length+m+1 );
	for( (ch = 0), (input = string); ch < length; ch++, input++ ) {
		if( input[0] == '"' || input[0] == '\\' ) {
			(*output++) = '\\';
		}
		else if( input[0] == '\n' ) {
			(*output++) = '\\'; (*output++) = 'n'; continue;
		}
		else if( input[0] == '\t' ) {
			(*output++) = '\\'; (*output++) = 't'; continue;
		}
		(*output++) = input[0];
	}
 // include nul character terminator.
	(*output) = 0;
	if( outlen ) (*outlen) = output - _output;
	return _output;
}
char *json_escape_string( const char *string ) {
	return json_escape_string_length( string, strlen( string ), NULL );
}
#define _2char(result,from) (((*from) += 2),( ( result & 0x1F ) << 6 ) | ( ( result & 0x3f00 )>>8))
#define _zero(result,from)  ((*from)++,0)
#define _3char(result,from) ( ((*from) += 3),( ( ( result & 0xF ) << 12 ) | ( ( result & 0x3F00 ) >> 2 ) | ( ( result & 0x3f0000 ) >> 16 )) )
#define _4char(result,from)  ( ((*from) += 4), ( ( ( result & 0x7 ) << 18 )						     | ( ( result & 0x3F00 ) << 4 )						   | ( ( result & 0x3f0000 ) >> 10 )						    | ( ( result & 0x3f000000 ) >> 24 ) ) )
#define __GetUtfChar( result, from )           ((result = ((TEXTRUNE*)*from)[0]),		     ( ( !(result & 0xFF) )              ?_zero(result,from)	                                                    :( ( result & 0x80 )		                       ?( ( result & 0xE0 ) == 0xC0 )			   ?( ( ( result & 0xC000 ) == 0x8000 ) ?_2char(result,from) : _zero(result,from)  )			    :( ( ( result & 0xF0 ) == 0xE0 )				                           ?( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) ) ? _3char(result,from) : _zero(result,from)  )				   :( ( ( result & 0xF8 ) == 0xF0 )		                       ? ( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) && ( ( result & 0xC0000000 ) == 0x80000000 ) )					  ?_4char(result,from):_zero(result,from) )				                                                                                                                  :( ( ( result & 0xC0 ) == 0x80 )					                                                                                                  ?_zero(result,from)					                                                                                                                       : ( (*from)++, (result & 0x7F) ) ) ) )		                                                                                       : ( (*from)++, (result & 0x7F) ) ) ) )
#define GetUtfChar(x) __GetUtfChar(c,x)
static int gatherString( CTEXTSTR msg, CTEXTSTR *msg_input, size_t msglen, TEXTSTR *pmOut, size_t *line, size_t *col, TEXTRUNE start_c, struct json_parse_state *state ) {
	char *mOut = (*pmOut);
	// collect a string
	int status = 0;
	size_t n;
	int escape;
	LOGICAL cr_escaped;
	TEXTRUNE c;
	escape = 0;
	cr_escaped = FALSE;
	while( (n = (*msg_input) - msg), ((n < msglen) && (c = GetUtfChar( msg_input ))) && (status >= 0) )
	{
		(*col)++;
		if( c == '\\' )
		{
			if( escape ) {
				(*mOut++) = '\\';
				escape = 0;
			}
			else escape = 1;
		}
		else if( (c == '"') || (c == '\'') || (c == '`') )
		{
			if( escape ) { (*mOut++) = c; escape = FALSE; }
			else if( c == start_c ) {
				status = 1;
				break;
			}
 // other else is not valid close quote; just store as content.
			else (*mOut++) = c;
		}
		else
		{
			if( cr_escaped ) {
				cr_escaped = FALSE;
				if( c == '\n' ) {
					line[0]++;
					col[0] = 1;
					escape = FALSE;
					continue;
				}
			}
			if( escape )
			{
				switch( c )
				{
				case '\r':
					cr_escaped = TRUE;
					continue;
				case '\n':
					line[0]++;
					col[0] = 1;
					if( cr_escaped ) cr_escaped = FALSE;
					// fall through to clear escape status <CR><LF> support.
 // LS (Line separator)
				case 2028:
 // PS (paragraph separate)
				case 2029:
					escape = FALSE;
					continue;
				case '/':
					(*mOut++) = c;
					escape = FALSE;
					break;
				case 't':
					(*mOut++) = '\t';
					escape = FALSE;
					break;
				case 'b':
					(*mOut++) = '\b';
					escape = FALSE;
					break;
				case 'n':
					(*mOut++) = '\n';
					escape = FALSE;
					break;
				case 'r':
					(*mOut++) = '\r';
					escape = FALSE;
					break;
				case 'f':
					(*mOut++) = '\f';
					escape = FALSE;
					break;
				case '0': case '1': case '2': case '3':
				{
					TEXTRUNE oct_char = c - '0';
					int ofs;
					for( ofs = 0; ofs < 2; ofs++ )
					{
						c = GetUtfChar( msg_input );
						oct_char *= 8;
						if( c >= '0' && c <= '9' )  oct_char += c - '0';
						else { msg_input--; break; }
					}
					if( oct_char > 255 ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "(escaped character, parsing octal escape val=%d) fault while parsing; )" ) WIDE( " (near %*.*s[%c]%s)" )
							, oct_char
							, (int)((n>3) ? 3 : n), (int)((n>3) ? 3 : n)
							, (*msg_input) - ((n>3) ? 3 : n)
							, c
							, (*msg_input) + 1
// fault
						);
						status = -1;
						break;
					}
					else {
						if( oct_char < 128 ) (*mOut++) = oct_char;
						else mOut += ConvertToUTF8( mOut, oct_char );
					}
					escape = FALSE;
				}
				break;
				case 'x':
				{
					TEXTRUNE hex_char;
					int ofs;
					hex_char = 0;
					for( ofs = 0; ofs < 2; ofs++ )
					{
						c = GetUtfChar( msg_input );
						hex_char *= 16;
						if( c >= '0' && c <= '9' )      hex_char += c - '0';
						else if( c >= 'A' && c <= 'F' ) hex_char += (c - 'A') + 10;
						else if( c >= 'a' && c <= 'f' ) hex_char += (c - 'a') + 10;
						else {
							if( !state->pvtError ) state->pvtError = VarTextCreate();
							vtprintf( state->pvtError, WIDE( "(escaped character, parsing hex of \\x) fault while parsing; '%c' unexpected at %" )_size_f WIDE( " (near %*.*s[%c]%s)" ), c, n
								, (int)((n>3) ? 3 : n), (int)((n>3) ? 3 : n)
								, (*msg_input) - ((n>3) ? 3 : n)
								, c
								, (*msg_input) + 1
// fault
							);
							status = -1;
						}
					}
					if( hex_char < 128 ) (*mOut++) = hex_char;
					else mOut += ConvertToUTF8( mOut, hex_char );
					escape = FALSE;
				}
				break;
				case 'u':
				{
					TEXTRUNE hex_char;
					int ofs;
					int codePointLen;
					TEXTRUNE endCode;
					hex_char = 0;
					codePointLen = 4;
					endCode = 0;
					for( ofs = 0; ofs < codePointLen && (c != endCode); ofs++ )
					{
						c = GetUtfChar( msg_input );
						if( !ofs && c == '{' ) {
 // collect up to 5 chars.
							codePointLen = 5;
							endCode = '}';
							continue;
						}
						if( c == '}' ) continue;
						hex_char *= 16;
						if( c >= '0' && c <= '9' )      hex_char += c - '0';
						else if( c >= 'A' && c <= 'F' ) hex_char += (c - 'A') + 10;
						else if( c >= 'a' && c <= 'f' ) hex_char += (c - 'a') + 10;
						else {
							if( !state->pvtError ) state->pvtError = VarTextCreate();
							vtprintf( state->pvtError, WIDE( "(escaped character, parsing hex of \\u) fault while parsing; '%c' unexpected at %" )_size_f WIDE( " (near %*.*s[%c]%s)" ), c, n
								, (int)((n > 3) ? 3 : n), (int)((n > 3) ? 3 : n)
								, (*msg_input) - ((n > 3) ? 3 : n)
								, c
								, (*msg_input) + 1
// fault
							);
						}
					}
					mOut += ConvertToUTF8( mOut, hex_char );
					escape = FALSE;
				}
				break;
				default:
					if( cr_escaped ) {
						cr_escaped = FALSE;
						escape = FALSE;
						mOut += ConvertToUTF8( mOut, c );
					}
					else {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "(escaped character) fault while parsing; '%c' unexpected %" )_size_f WIDE( " (near %*.*s[%c]%s)" ), c, n
							, (int)((n>3) ? 3 : n), (int)((n>3) ? 3 : n)
							, (*msg_input) - ((n>3) ? 3 : n)
							, c
							, (*msg_input) + 1
// fault
						);
						status = -1;
					}
					break;
				}
				escape = 0;
			}
			else {
				mOut += ConvertToUTF8( mOut, c );
			}
		}
	}
	if( status )
  // terminate the string.
		(*mOut++) = 0;
	(*pmOut) = mOut;
	return status;
}
static void json_state_init( struct json_parse_state *state )
{
	PPDATALIST ppElements;
	PPLIST ppList;
	PPLINKQUEUE ppQueue;
	PPLINKSTACK ppStack;
	ppElements = GetFromSet( PDATALIST, &jpsd.dataLists );
	if( !ppElements[0] ) ppElements[0] = CreateDataList( sizeof( state->val ) );
	state->elements = ppElements;
	state->elements[0]->Cnt = 0;
	ppStack = GetFromSet( PLINKSTACK, &jpsd.linkStacks );
	if( !ppStack[0] ) ppStack[0] = CreateLinkStack();
	state->outBuffers = ppStack;
	state->outBuffers[0]->Top = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &jpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->inBuffers = ppQueue;
	state->inBuffers[0]->Top = state->inBuffers[0]->Bottom = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &jpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->outQueue = ppQueue;
	state->outQueue[0]->Top = state->outQueue[0]->Bottom = 0;
	ppList = GetFromSet( PLIST, &jpsd.listSet );
	if( ppList[0] ) ppList[0]->Cnt = 0;
	state->outValBuffers = ppList;
	state->line = 1;
	state->col = 1;
 // character index;
	state->n = 0;
	state->word = WORD_POS_RESET;
	state->status = TRUE;
	state->negative = FALSE;
// NULL;
	state->context_stack = GetFromSet( PLINKSTACK, &jpsd.linkStacks );
	if( state->context_stack[0] ) state->context_stack[0]->Top = 0;
	//state->first_token = TRUE;
	state->context = GetFromSet( PARSE_CONTEXT, &jpsd.parseContexts );
	state->parse_context = CONTEXT_UNKNOWN;
	state->comment = 0;
	state->completed = FALSE;
	//state->mOut = msg;// = NewArray( char, msglen );
	//state->msg_input = (char const *)msg;
	state->val.value_type = VALUE_UNSET;
	state->val.contains = NULL;
	state->val._contains = NULL;
	state->val.name = NULL;
	state->val.string = NULL;
	state->complete_at_end = FALSE;
	state->gatheringString = FALSE;
	state->gatheringNumber = FALSE;
	state->pvtError = NULL;
}
/* I guess this is a good parser */
struct json_parse_state * json_begin_parse( void )
{
//New( struct json_parse_state );
	struct json_parse_state *state = GetFromSet( PARSE_STATE, &jpsd.parseStates );
	json_state_init( state );
	return state;
}
/* I guess this is a good parser */
int json_parse_add_data( struct json_parse_state *state
	, const char *msg
	, size_t msglen )
{
	TEXTRUNE c;
	struct json_input_buffer *input;
	struct json_output_buffer *output;
	int retval = 0;
	int string_status;
	if( msg && msglen ) {
		input = GetFromSet( PARSE_BUFFER, &jpsd.parseBuffers );
		input->pos = input->buf = msg;
		input->size = msglen;
		EnqueLinkNL( state->inBuffers, input );
		if( state->gatheringString || state->gatheringNumber || state->parse_context == CONTEXT_OBJECT_FIELD ) {
			// have to extend the previous output buffer to include this one instead of allocating a split string.
			size_t offset;
			size_t offset2;
			output = (struct json_output_buffer*)DequeLinkNL( state->outQueue );
			//lprintf( "output from before is %p", output );
			offset = (output->pos - output->buf);
			offset2 = state->val.string - output->buf;
			AddLink( state->outValBuffers, output->buf );
			output->buf = NewArray( char, output->size + msglen + 1 );
			MemCpy( output->buf + offset2, state->val.string, offset-offset2 );
			output->size += msglen;
			//lprintf( "previous val:%s", state->val.string, state->val.string );
			state->val.string = output->buf + offset2;
			output->pos = output->buf + offset;
			PrequeLink( state->outQueue, output );
		}
		else {
			output = (struct json_output_buffer*)GetFromSet( PARSE_BUFFER, &jpsd.parseBuffers );
			output->pos = output->buf = NewArray( char, msglen + 1 );
			output->size = msglen;
			EnqueLinkNL( state->outQueue, output );
		}
	}
	while( state->status && (input = (PPARSE_BUFFER)DequeLinkNL( state->inBuffers )) ) {
		output = (struct json_output_buffer*)DequeLinkNL( state->outQueue );
		//lprintf( "output is %p", output );
		state->n = input->pos - input->buf;
		if( state->gatheringString ) {
			string_status = gatherString( input->buf, &input->pos, input->size, &output->pos, &state->line, &state->col, state->gatheringStringFirstChar, state );
			if( string_status < 0 )
				state->status = FALSE;
			else if( string_status > 0 )
			{
				state->gatheringString = FALSE;
				state->n = input->pos - input->buf;
				state->val.stringLen = ( output->pos - state->val.string ) - 1;
				if( state->status ) state->val.value_type = VALUE_STRING;
			}
			else {
				state->n = input->pos - input->buf;
			}
		}
		if( state->gatheringNumber ) {
			//lprintf( "continue gathering a string" );
			goto continueNumber;
		}
		while( state->status && (state->n < input->size) && (c = GetUtfChar( &input->pos )) )
		{
			state->n = input->pos - input->buf;
			switch( c )
			{
			case '{':
			{
				struct json_parse_context *old_context = GetFromSet( PARSE_CONTEXT, &jpsd.parseContexts );
				old_context->context = state->parse_context;
				old_context->elements = state->elements;
				old_context->name = state->val.name;
				old_context->nameLen = state->val.nameLen;
// CreateDataList( sizeof( state->val ) );
				state->elements = GetFromSet( PDATALIST, &jpsd.dataLists );
				if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
				else state->elements[0]->Cnt = 0;
				PushLink( state->context_stack, old_context );
				RESET_STATE_VAL();
				state->parse_context = CONTEXT_IN_OBJECT;
			}
			break;
			case '[':
			{
				struct json_parse_context *old_context = GetFromSet( PARSE_CONTEXT, &jpsd.parseContexts );
				old_context->context = state->parse_context;
				old_context->elements = state->elements;
				old_context->name = state->val.name;
				old_context->nameLen = state->val.nameLen;
// CreateDataList( sizeof( state->val ) );
				state->elements = GetFromSet( PDATALIST, &jpsd.dataLists );
				if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
				else state->elements[0]->Cnt = 0;
				PushLink( state->context_stack, old_context );
				RESET_STATE_VAL();
				state->parse_context = CONTEXT_IN_ARRAY;
			}
			break;
			case ':':
				if( state->parse_context == CONTEXT_IN_OBJECT )
				{
					if( state->val.name ) {
						lprintf( "two names single value?" );
					}
					state->val.name = state->val.string;
					state->val.nameLen = state->val.stringLen;
					state->val.string = NULL;
					state->val.value_type = VALUE_UNSET;
				}
				else
				{
					if( state->parse_context == CONTEXT_IN_ARRAY ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "(in array, got colon out of string):parsing fault; unexpected %c at %" ) _size_f, c, state->n );
					}
					else {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "(outside any object, got colon out of string):parsing fault; unexpected %c at %" ) _size_f, c, state->n );
					}
					state->status = FALSE;
				}
				break;
			case '}':
				if( state->word == WORD_POS_END ) {
					// allow starting a new word
					state->word = WORD_POS_RESET;
				}
				if( state->parse_context == CONTEXT_IN_OBJECT || state->parse_context == CONTEXT_OBJECT_FIELD_VALUE )
				{
					// first, add the last value
					if( state->val.value_type != VALUE_UNSET ) {
						AddDataItem( state->elements, &state->val );
					}
					//RESET_STATE_VAL();
					state->val.value_type = VALUE_OBJECT;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					state->val.string = NULL;
					{
						struct json_parse_context *old_context = (struct json_parse_context *)PopLink( state->context_stack );
						//struct json_value_container *oldVal = (struct json_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						DeleteFromSet( PARSE_CONTEXT, jpsd.parseContexts, old_context );
					}
					//n++;
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					vtprintf( state->pvtError, WIDE( "Fault while parsing; unexpected %c at %" ) _size_f, c, state->n );
					state->status = FALSE;
				}
				break;
			case ']':
				if( state->word == WORD_POS_END ) {
					// allow starting a new word
					state->word = WORD_POS_RESET;
				}
				if( state->parse_context == CONTEXT_IN_ARRAY )
				{
					if( state->val.value_type != VALUE_UNSET ) {
						AddDataItem( state->elements, &state->val );
					}
					//RESET_STATE_VAL();
					state->val.value_type = VALUE_ARRAY;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					state->val.string = NULL;
					{
						struct json_parse_context *old_context = (struct json_parse_context *)PopLink( state->context_stack );
						//struct json_value_container *oldVal = (struct json_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						DeleteFromSet( PARSE_CONTEXT, jpsd.parseContexts, old_context );					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "bad context %d; fault while parsing; '%c' unexpected at %" ) _size_f, state->parse_context, c, state->n );
					state->status = FALSE;
				}
				break;
			case ',':
				if( state->word == WORD_POS_END ) {
					// allow starting a new word
					state->word = WORD_POS_RESET;
				}
				if( (state->parse_context == CONTEXT_IN_ARRAY)
					|| (state->parse_context == CONTEXT_IN_OBJECT) )
				{
					if( state->val.value_type != VALUE_UNSET ) {
						AddDataItem( state->elements, &state->val );
					}
					RESET_STATE_VAL();
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "bad context; fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n );
				}
				break;
			default:
				switch( c )
				{
				case '"':
				//case '\'':
					state->val.string = output->pos;
					state->gatheringString = TRUE;
					state->gatheringStringFirstChar = c;
					string_status = gatherString( input->buf, &input->pos, input->size, &output->pos, &state->line, &state->col, c, state );
					//lprintf( "string gather status:%d", string_status );
					if( string_status < 0 )
						state->status = FALSE;
					else if( string_status > 0 ) {
						state->gatheringString = FALSE;
						state->val.stringLen = ( output->pos - state->val.string ) - 1;
					} else if( state->complete_at_end ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "End of string fail." );
						state->status = FALSE;
					}
					state->n = input->pos - input->buf;
					if( state->status ) {
						state->val.value_type = VALUE_STRING;
						state->word = WORD_POS_END;
						if( state->complete_at_end ) {
							if( state->parse_context == CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					break;
				case ' ':
				case '\t':
				case '\r':
				case '\n':
				case 0xFEFF:
					if( state->word == WORD_POS_END ) {
						state->word = WORD_POS_RESET;
						if( state->parse_context == CONTEXT_UNKNOWN ) {
							state->completed = TRUE;
						}
						break;
					}
					if( state->word == WORD_POS_RESET ) {
						break;
					}
					state->status = FALSE;
					if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; whitespace unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n );
					// skip whitespace
					//n++;
					//lprintf( "whitespace skip..." );
					break;
					//----------------------------------------------------------
					//  catch characters for true/false/null/undefined which are values outside of quotes
				case 't':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_TRUE_1;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'r':
					if( state->word == WORD_POS_TRUE_1 ) state->word = WORD_POS_TRUE_2;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'u':
					if( state->word == WORD_POS_TRUE_2 ) state->word = WORD_POS_TRUE_3;
					else if( state->word == WORD_POS_NULL_1 ) state->word = WORD_POS_NULL_2;
					else if( state->word == WORD_POS_RESET ) state->word = WORD_POS_UNDEFINED_1;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'e':
					if( state->word == WORD_POS_TRUE_3 ) {
						state->val.value_type = VALUE_TRUE;
						state->word = WORD_POS_END;
					}
					else if( state->word == WORD_POS_FALSE_4 ) {
						state->val.value_type = VALUE_FALSE;
						state->word = WORD_POS_END;
					}
					else if( state->word == WORD_POS_UNDEFINED_3 ) state->word = WORD_POS_UNDEFINED_4;
					else if( state->word == WORD_POS_UNDEFINED_7 ) state->word = WORD_POS_UNDEFINED_8;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'n':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_NULL_1;
					else if( state->word == WORD_POS_UNDEFINED_1 ) state->word = WORD_POS_UNDEFINED_2;
					else if( state->word == WORD_POS_UNDEFINED_6 ) state->word = WORD_POS_UNDEFINED_7;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'd':
					if( state->word == WORD_POS_UNDEFINED_2 ) state->word = WORD_POS_UNDEFINED_3;
					else if( state->word == WORD_POS_UNDEFINED_8 ) { state->val.value_type = VALUE_UNDEFINED; state->word = WORD_POS_END; }
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'i':
					if( state->word == WORD_POS_UNDEFINED_5 ) state->word = WORD_POS_UNDEFINED_6;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'l':
					if( state->word == WORD_POS_NULL_2 ) state->word = WORD_POS_NULL_3;
					else if( state->word == WORD_POS_NULL_3 ) {
						state->val.value_type = VALUE_NULL;
						state->word = WORD_POS_END;
					}
					else if( state->word == WORD_POS_FALSE_2 ) state->word = WORD_POS_FALSE_3;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'f':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_FALSE_1;
					else if( state->word == WORD_POS_UNDEFINED_4 ) state->word = WORD_POS_UNDEFINED_5;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 'a':
					if( state->word == WORD_POS_FALSE_1 ) state->word = WORD_POS_FALSE_2;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
				case 's':
					if( state->word == WORD_POS_FALSE_3 ) state->word = WORD_POS_FALSE_4;
					else { state->status = FALSE; if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f, c, state->n ); }
					break;
					//
					//----------------------------------------------------------
				case '-':
					state->negative = !state->negative;
					break;
				default:
					if( (c >= '0' && c <= '9') || (c == '+') )
					{
						const char *_msg_input;
				continueNumber:
						// always reset this here....
						// keep it set to determine what sort of value is ready.
						if( !state->gatheringNumber ) {
							state->exponent = FALSE;
							state->fromHex = FALSE;
							//fromDate = FALSE;
							state->val.float_result = 0;
							state->val.string = output->pos;
  // terminate the string.
							(*output->pos++) = c;
						}
						else
						{
							//exponent = state->numberExponent;
							//fromDate = state->numberFromDate;
						}
						while( (_msg_input = input->pos), ((state->n < input->size) && (c = GetUtfChar( &input->pos ))) )
						{
							if( c == '_' )
								continue;
							state->n = (input->pos - input->buf);
							// leading zeros should be forbidden.
							if( (c >= '0' && c <= '9')
								|| (c == '-')
								|| (c == '+')
								)
							{
								(*output->pos++) = c;
							}
							else if( c == 'x' ) {
								// hex conversion.
								if( !state->fromHex ) {
									state->fromHex = TRUE;
									(*output->pos++) = c;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault wile parsing; '%c' unexpected at %" ) _size_f, c, state->n );
									break;
								}
							}
							else if( (c == 'e') || (c == 'E') )
							{
								if( !state->exponent ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
									state->exponent = TRUE;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault wile parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( c == '-' ) {
								if( !state->exponent ) {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault wile parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
								else {
									(*output->pos++) = c;
								}
							}
							else if( c == '.' )
							{
								state->val.float_result = 1;
								(*output->pos++) = c;
							}
							else
							{
								// in non streaming mode; these would be required to follow
								/*
								if( c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == 0xFEFF
								|| c == ',' || c == '\'' || c == '\"' || c == '`' ) {
								}
								*/
								//lprintf( "Non numeric character received; push the value we have" );
								(*output->pos++) = 0;
								state->val.stringLen = ( output->pos - state->val.string ) - 1;
								break;
							}
						}
						input->pos = _msg_input;
						state->n = input->pos - input->buf;
						//LogBinary( (uint8_t*)output->buf, output->size );
						if( (!state->complete_at_end) && state->n == input->size )
						{
							//lprintf( "completion mode is not end of string; and at end of string" );
							state->gatheringNumber = TRUE;
							//state->numberExponent = exponent;
							//state->numberFromDate = fromDate;
						}
						else
						{
							state->gatheringNumber = FALSE;
							(*output->pos++) = 0;
							state->val.stringLen = ( output->pos - state->val.string ) - 1;
							if( state->val.float_result )
							{
								CTEXTSTR endpos;
								state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
								if( state->negative & 1 ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
							}
							else
							{
								state->val.result_n = IntCreateFromText( state->val.string );
								if( state->negative & 1 ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
							}
							state->val.value_type = VALUE_NUMBER;
							if( state->parse_context == CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					else
					{
						// fault, illegal characer (whitespace?)
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault parsing '%c' unexpected %" )_size_f WIDE( " (near %*.*s[%c]%s)" ), c, state->n
							, (int)((state->n > 4) ? 3 : (state->n - 1)), (int)((state->n > 4) ? 3 : (state->n - 1))
							, input->pos + state->n - ((state->n > 4) ? 4 : state->n)
							, c
							, input->pos + state->n
// fault
						);
					}
 // default
					break;
				}
 // default of high level switch
				break;
			}
			// got a completed value; skip out
			if( state->completed ) {
				if( state->word == WORD_POS_END ) {
					state->word = WORD_POS_RESET;
				}
				break;
			}
		}
		if( state->n == input->size ) {
			DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, input );
			if( state->gatheringString || state->gatheringNumber || state->parse_context == CONTEXT_OBJECT_FIELD ) {
				//lprintf( "output is still incomplete? " );
				PrequeLink( state->outQueue, output );
				retval = 0;
			}
			else {
				PushLink( state->outBuffers, output );
					if( state->parse_context == CONTEXT_UNKNOWN
					  && ( state->val.value_type != VALUE_UNSET
					     || state->elements[0]->Cnt ) ) {
					state->completed = TRUE;
					retval = 1;
				}
			}
			//lprintf( "Is complete already?%d", state->completed );
		}
		else {
			// put these back into the stack.
			//lprintf( "put buffers back into queues..." );
			PrequeLink( state->inBuffers, input );
			PrequeLink( state->outQueue, output );
  // if returning buffers, then obviously there's more in this one.
			retval = 2;
		}
		if( state->completed )
			break;
	}
	if( !state->status ) {
		// some error condition; cannot resume parsing.
		return -1;
	}
	if( !state->gatheringNumber && !state->gatheringString )
		if( state->val.value_type != VALUE_UNSET ) {
			AddDataItem( state->elements, &state->val );
			RESET_STATE_VAL();
		}
	if( state->completed ) {
		state->completed = FALSE;
	}
	return retval;
}
LOGICAL json_parse_message( const char * msg
	, size_t msglen
	, PDATALIST *_msg_output ) {
	struct json_parse_state *state = json_begin_parse();
	static struct json_parse_state *_state;
	state->complete_at_end = TRUE;
	int result = json_parse_add_data( state, msg, msglen );
	if( _state ) json_parse_dispose_state( &_state );
	if( result > 0 ) {
		(*_msg_output) = json_parse_get_data( state );
		_state = state;
		//json6_parse_dispose_state( &state );
		return TRUE;
	}
	(*_msg_output) = NULL;
	json_parse_dispose_state( &state );
	return FALSE;
}
void json_dispose_decoded_message( struct json_context_object *format
                                 , POINTER msg_data )
{
	// a complex format might have sub-parts .... but for now we'll assume simple flat structures
	Release( msg_data );
}
void _json_dispose_message( PDATALIST *msg_data )
{
	struct json_value_container *val;
	INDEX idx;
	if( !msg_data ) return;
	DATA_FORALL( (*msg_data), idx, struct json_value_container*, val )
	{
		// names and string buffers for JSON parsed values in a single buffer
		// associated with the root message.
		//if( val->name ) Release( val->name );
		//if( val->string ) Release( val->string );
		if( val->contains )
			_json_dispose_message( val->_contains );
	}
	// quick method
	DeleteDataList( msg_data );
	DeleteFromSet( PDATALIST, jpsd.dataLists, msg_data );
}
static uintptr_t FindDataList( void*p, uintptr_t psv ) {
	if( ((PPDATALIST)p)[0] == (PDATALIST)psv )
		return (uintptr_t)p;
	return 0;
}
void json_dispose_message( PDATALIST *msg_data ) {
	uintptr_t actual = ForAllInSet( PDATALIST, jpsd.dataLists, FindDataList, (uintptr_t)msg_data[0] );
	_json_dispose_message( (PDATALIST*)actual );
	msg_data[0] = NULL;
}
// puts the current collected value into the element; assumes conversion was correct
static void FillDataToElement( struct json_context_object_element *element
							    , size_t object_offset
								, struct json_value_container *val
								, POINTER msg_output )
{
	if( !val->name )
		return;
	// remove name; indicate that the value has been used.
	Release( val->name );
	val->name = NULL;
	switch( element->type )
	{
	case JSON_Element_String:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_NULL:
				((CTEXTSTR*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = NULL;
				break;
			case VALUE_STRING:
				((CTEXTSTR*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = StrDup( val->string );
				break;
			default:
				lprintf( WIDE("Expected a string, but parsed result was a %d"), val->value_type );
				break;
			}
		}
		break;
	case JSON_Element_Integer_64:
	case JSON_Element_Integer_32:
	case JSON_Element_Integer_16:
	case JSON_Element_Integer_8:
	case JSON_Element_Unsigned_Integer_64:
	case JSON_Element_Unsigned_Integer_32:
	case JSON_Element_Unsigned_Integer_16:
	case JSON_Element_Unsigned_Integer_8:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_TRUE:
				switch( element->type )
				{
				case JSON_Element_String:
				case JSON_Element_CharArray:
				case JSON_Element_Float:
				case JSON_Element_Double:
				case JSON_Element_Array:
				case JSON_Element_Object:
				case JSON_Element_ObjectPointer:
				case JSON_Element_List:
				case JSON_Element_Text:
				case JSON_Element_PTRSZVAL:
				case JSON_Element_PTRSZVAL_BLANK_0:
				case JSON_Element_UserRoutine:
				case JSON_Element_Raw_Object:
					lprintf( "Uhandled element conversion." );
					break;
				case JSON_Element_Integer_64:
				case JSON_Element_Unsigned_Integer_64:
					((int8_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				case JSON_Element_Integer_32:
				case JSON_Element_Unsigned_Integer_32:
					((int16_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				case JSON_Element_Integer_16:
				case JSON_Element_Unsigned_Integer_16:
					((int32_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				case JSON_Element_Integer_8:
				case JSON_Element_Unsigned_Integer_8:
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				}
				break;
			case VALUE_FALSE:
				switch( element->type )
				{
				case JSON_Element_String:
				case JSON_Element_CharArray:
				case JSON_Element_Float:
				case JSON_Element_Double:
				case JSON_Element_Array:
				case JSON_Element_Object:
				case JSON_Element_ObjectPointer:
				case JSON_Element_List:
				case JSON_Element_Text:
				case JSON_Element_PTRSZVAL:
				case JSON_Element_PTRSZVAL_BLANK_0:
				case JSON_Element_UserRoutine:
				case JSON_Element_Raw_Object:
					lprintf( "Uhandled element conversion." );
					break;
				case JSON_Element_Integer_64:
				case JSON_Element_Unsigned_Integer_64:
					((int8_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				case JSON_Element_Integer_32:
				case JSON_Element_Unsigned_Integer_32:
					((int16_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				case JSON_Element_Integer_16:
				case JSON_Element_Unsigned_Integer_16:
					((int32_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				case JSON_Element_Integer_8:
				case JSON_Element_Unsigned_Integer_8:
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				}
				break;
			case VALUE_NUMBER:
				if( val->float_result )
				{
					lprintf( WIDE("warning received float, converting to int") );
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (int64_t)val->result_d;
				}
				else
				{
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = val->result_n;
				}
				break;
			default:
				lprintf( WIDE("Expected a string, but parsed result was a %d"), val->value_type );
				break;
			}
		}
		break;
	case JSON_Element_Float:
	case JSON_Element_Double:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_NUMBER:
				if( val->float_result )
				{
					if( element->type == JSON_Element_Float )
						((float*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (float)val->result_d;
					else
						((double*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = val->result_d;
				}
				else
				{
               // this is probably common (0 for instance)
					lprintf( WIDE("warning received int, converting to float") );
					if( element->type == JSON_Element_Float )
						((float*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (float)val->result_n;
					else
						((double*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (double)val->result_n;
				}
				break;
			default:
				lprintf( WIDE("Expected a float, but parsed result was a %d"), val->value_type );
				break;
			}
		}
		break;
	case JSON_Element_PTRSZVAL_BLANK_0:
	case JSON_Element_PTRSZVAL:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_NUMBER:
				if( val->float_result )
				{
					lprintf( WIDE("warning received float, converting to int (uintptr_t)") );
					((uintptr_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (uintptr_t)val->result_d;
				}
				else
				{
					// this is probably common (0 for instance)
					((uintptr_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (uintptr_t)val->result_n;
				}
				break;
			}
		}
		break;
	}
}
LOGICAL json_decode_message( struct json_context *format
								, PDATALIST msg_data
								, struct json_context_object **result_format
								, POINTER *_msgbuf )
{
	#if 0
	PLIST elements = format->elements;
	struct json_context_object_element *element;
	// message is allcoated +7 bytes in case last part is a uint8_t type
	// all integer stores use uint64_t type to store the collected value.
	if( !msg_output )
		msg_output = (*_msg_output)
			= NewArray( uint8_t, format->object_size + 7  );
	LOGICAL first_token = TRUE;
				if( first_token )
				{
					// begin an object.
					// content is
					elements = format->members;
					PushLink( &element_lists, elements );
					first_token = 0;
					//n++;
				}
				else
				{
					INDEX idx;
					// begin a sub object, we should have just had a name for it
					// since this will be the value of that name.
					// this will eet 'element' to NULL (fall out of loop) or the current one to store values into
					LIST_FORALL( elements, idx, struct json_context_object_element *, element )
					{
						if( StrCaseCmp( element->name, GetText( val.name ) ) == 0 )
						{
							if( ( element->type == JSON_Element_Object )
								|| ( element->type == JSON_Element_ObjectPointer ) )
							{
								if( element->object )
								{
									// save prior element list; when we return to this one?
									struct json_parse_context *old_context = New( struct json_parse_context );
									old_context->context = parse_context;
									old_context->elements = elements;
									old_context->object = format;
									PushLink( &context_stack, old_context );
									format = element->object;
									elements = element->object->members;
									//n++;
									break;
								}
								else
								{
									lprintf( WIDE("Error; object type does not have an object") );
									status = FALSE;
								}
							}
							else
							{
								lprintf( WIDE("Incompatible value expected object type, type is %d"), element->type );
							}
						}
					}
				}
#endif
	return FALSE;
}
#undef GetUtfChar
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
#define JSON_EMITTER_SOURCE
static struct unicodeNonIdentifierBitSet{ int firstChar, lastChar; int bits[16]; } nonIdentifierBits[] =
{ { 0,384,{ 0xffd9ff,0xff6aff,0x1fc00,0x380000,0x0,0xfffff8,0xffffff,0x7fffff,0x800000,0x0,0x80,0x0,0x0,0x0,0x0,0x0 } },
{ 384,768,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c00,0xe0fffc,0xffffaf } },
{ 768,1152,{ 0x0,0x0,0x0,0x0,0x200000,0x3040,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0 } },
{ 1152,1536,{ 0x304,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc,0x0,0xe6,0x0,0x4940,0x0,0x1800 } },
{ 1536,1920,{ 0xffff,0xd8,0x0,0x0,0x3c00,0x0,0x0,0x0,0x100000,0x20060,0xff6000,0xbf,0x0,0x0,0x0,0x0 } },
{ 1920,2304,{ 0x0,0x0,0x0,0x0,0xc00000,0x3,0x0,0x7fff00,0x0,0x40,0x0,0x0,0x0,0x0,0x40000,0x0 } },
{ 2304,2688,{ 0x0,0x0,0x0,0x0,0x10030,0x0,0x0,0x0,0x0,0x0,0x2ffc,0x0,0x0,0x0,0x0,0x0 } },
{ 2688,3072,{ 0x0,0x0,0x0,0x0,0x30000,0x0,0x0,0x0,0x0,0x0,0xfd,0x0,0x0,0x0,0x0,0x7ff00 } },
{ 3072,3456,{ 0x0,0x0,0x0,0x0,0x0,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x800000,0x7f00,0x3ff00 } },
{ 3456,3840,{ 0x0,0x0,0x0,0x0,0x100000,0x0,0x0,0x800000,0x8000,0xc,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 3840,4224,{ 0xfffffe,0xfc00fc,0x3d5f,0x0,0x0,0x2000,0x0,0xc00000,0xffdfbf,0x7,0x0,0x0,0x0,0xfc0000,0x0,0x0 } },
{ 4224,4608,{ 0x0,0xc0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 4608,4992,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff0000,0x1ffc01 } },
{ 4992,5376,{ 0xff0000,0x3,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 5376,5760,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x60 } },
{ 5760,6144,{ 0x1,0x18,0x0,0x0,0x3800,0x0,0x0,0x6000,0x0,0x0,0x0,0x0,0x0,0x0,0xf70,0x3ff00 } },
{ 6144,6528,{ 0x47ff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3100,0x0,0x0 } },
{ 6528,6912,{ 0x0,0x0,0x0,0xc00000,0xffffff,0xff,0xc000,0x0,0x0,0x0,0x0,0x0,0x3f7f,0x40,0x0,0x0 } },
{ 6912,7296,{ 0x0,0x0,0x0,0xfc0000,0xf007ff,0x1f,0x0,0x0,0x0,0x0,0xf000,0x0,0x0,0xf8,0x0,0xc00000 } },
{ 7296,7680,{ 0x0,0x0,0xff0000,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 8064,8448,{ 0x0,0x0,0x3a000,0xe000e0,0xe000,0xffff60,0xffffff,0x7fffff,0xeffffe,0xffdfff,0xff7ff1,0x7f,0xffffff,0xff,0x1de000,0x0 } },
{ 8448,8832,{ 0xd0037b,0x2afc0,0x1f0c00,0xffffbc,0x0,0xe0000,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 8832,9216,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 9216,9600,{ 0xffffff,0x7fff,0xff0000,0x7,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 9600,9984,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 9984,10368,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 10368,10752,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 10752,11136,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffcfff } },
{ 11136,11520,{ 0x3fffff,0xffffff,0xffe3ff,0x7fd,0xf000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe00000,0xfe0007 } },
{ 11520,11904,{ 0x0,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x0,0x0,0xff0000,0xffffff,0xffffff,0x3ffff,0x0,0x0 } },
{ 11904,12288,{ 0xffffff,0xfffffb,0xffffff,0xffffff,0xfffff,0xffff00,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0x3f,0xfff00 } },
{ 12288,12672,{ 0xffff1f,0x1ff,0xe0c1,0x0,0x0,0x0,0x10000,0x0,0x0,0x0,0x800,0x0,0x0,0x0,0x0,0x0 } },
{ 12672,13056,{ 0xff0000,0xff,0xff0000,0xffffff,0xf,0xffff00,0xff7fff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0x7fffff } },
{ 13056,13440,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffff,0x0,0x0,0x0,0x0,0x0 } },
{ 19584,19968,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0xffffff } },
{ 41856,42240,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0x7fff,0x0,0xc00000 } },
{ 42240,42624,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xe0,0x0,0x0,0x0,0x400f00 } },
{ 42624,43008,{ 0x0,0x0,0x0,0x0,0xfc0000,0xffff00,0x3007f,0x0,0x0,0x0,0x0,0x6,0x0,0x0,0x0,0x0 } },
{ 43008,43392,{ 0x0,0xf0000,0x3ff,0x0,0xf00000,0x0,0x0,0x0,0xc000,0x0,0x1700,0x0,0xc000,0x0,0x8000,0x0 } },
{ 43392,43776,{ 0x0,0x0,0xfe0000,0xc0003f,0x0,0x0,0x0,0x0,0x0,0xf0,0x380,0x0,0x0,0x0,0xc000,0x300 } },
{ 43776,44160,{ 0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 64128,64512,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0xfc0000,0x3ff,0x0,0x0 } },
{ 64512,64896,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0x0,0x0 } },
{ 64896,65280,{ 0x0,0x0,0x0,0x0,0x0,0x30,0x3ff,0xffe700,0xf71fff,0xf7fff,0x0,0x0,0x0,0x0,0x0,0x800000 } },
{ 65280,65664,{ 0xfffe,0x1fc,0x17800,0xf80000,0x3f,0x0,0x0,0x0,0x0,0x7f7f00,0x3e00,0x0,0x0,0x0,0x0,0x0 } },
{ 65664,66048,{ 0x0,0x0,0x0,0x0,0x0,0xff8700,0xffffff,0xff8fff,0x0,0x0,0xffffe0,0xfff7f,0x1,0x0,0xffffff,0x1fffff } },
{ 66048,66432,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffe00,0xfff,0x0,0xf,0x0,0x0,0x0 } },
{ 66432,66816,{ 0x0,0x80,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 66816,67200,{ 0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 67584,67968,{ 0x0,0x0,0x0,0xff8000,0x800000,0xff,0x800000,0xff,0x0,0x0,0xf800,0x8fc000,0x0,0x80,0x0,0x0 } },
{ 67968,68352,{ 0x0,0x0,0xff3000,0xfffcff,0xffffff,0xff,0x0,0x0,0xff00ff,0x1,0xe000,0xe00000,0x0,0x10000,0x0,0x7ff8 } },
{ 68352,68736,{ 0x0,0x0,0xfe00,0xff0000,0x0,0xff,0x1e00,0xfe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 68736,69120,{ 0x0,0x0,0x0,0x0,0x0,0xfc,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 69120,69504,{ 0x0,0x0,0x0,0x0,0xffffff,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 69504,69888,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfc3f80,0x3fff,0x0,0x0,0x0,0x3f8,0x0,0x0 } },
{ 69888,70272,{ 0x0,0x0,0xf0000,0x0,0x300000,0x0,0x0,0x0,0x23e0,0xfffee8,0x1f,0x0,0x0,0x3f,0x0,0x0 } },
{ 70272,70656,{ 0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 70656,71040,{ 0x0,0x0,0x0,0x2800f8,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 71040,71424,{ 0x0,0x0,0xfe0000,0xffff,0x0,0x0,0x0,0x0,0xe,0x1fff00,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 71424,71808,{ 0x0,0x0,0xfc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 71808,72192,{ 0x0,0x0,0x0,0x0,0x7fc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 72192,72576,{ 0x0,0x0,0x7f8000,0x0,0x0,0x0,0x7dc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 72576,72960,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e,0x1ffffc,0x3,0x0,0x0,0x0,0x0,0x0 } },
{ 74496,74880,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f00 } },
{ 92544,92928,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x0,0x0,0x2000 } },
{ 92928,93312,{ 0x0,0x0,0x30ff80,0xf80000,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 113664,114048,{ 0x0,0x0,0x0,0x0,0x0,0x0,0xf9000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 118656,119040,{ 0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0x3fff } },
{ 119040,119424,{ 0xffffff,0xfe7fff,0xffffff,0xffffff,0xf81c1f,0xf01807,0xffffff,0xffffc3,0xffffff,0x1ffff,0xff0000,0xffffff,0xffffff,0x23ff,0x0,0x0 } },
{ 119424,119808,{ 0x0,0x0,0x0,0x0,0x0,0xffff00,0xffffff,0xffffff,0x7fffff,0xffff00,0x3,0x0,0x0,0x0,0x0,0x0 } },
{ 120192,120576,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x800,0x80000 } },
{ 120576,120960,{ 0x200000,0x0,0x20,0x80,0x8000,0x20000,0x0,0x2,0x8,0x0,0xff0000,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 120960,121344,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 121344,121728,{ 0x0,0x0,0x780,0x0,0xdfe000,0xfefff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 124800,125184,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff8000,0x0,0x0 } },
{ 125184,125568,{ 0x0,0x0,0x0,0xc00000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 126336,126720,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x300 } },
{ 126720,127104,{ 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xff0000,0xffffff,0xff0fff,0xffffff,0xffffff,0xffffff } },
{ 127104,127488,{ 0xfffff,0x7fff00,0xfefffe,0xfffeff,0x3fffff,0x1fff00,0xffffff,0xffff7f,0xffffff,0xfffff,0xffffff,0xffffff,0x1fff,0x0,0xc00000,0xffffff } },
{ 127488,127872,{ 0xff0007,0xffffff,0xff0fff,0x301,0x3f,0x0,0x0,0x0,0x0,0x0,0xff0000,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 127872,128256,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 128256,128640,{ 0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff,0xffffff } },
{ 128640,129024,{ 0xffffff,0xffffff,0xffffff,0x1fff,0xff1fff,0xffff01,0xffffff,0xffffff,0xffffff,0xffffff,0xff000f,0xffffff,0xffffff,0xffffff,0x1f,0x0 } },
{ 129024,129408,{ 0xff0fff,0xffffff,0xffffff,0x3ff00,0xffffff,0xffff,0xffffff,0x3f,0x0,0x0,0xff0000,0xffff0f,0xffffff,0x1fff7f,0xffffff,0xf } },
{ 129408,129792,{ 0xffffff,0x0,0x10000,0xffff00,0x7f,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0 } },
{ 917376,917760,{ 0x0,0x0,0x0,0x0,0x0,0x200,0xff0000,0xffffff,0xffffff,0xffffff } }
};
static uint8_t const nonIdentifiers8[255] = {
	 1,1,1,1,1,1,1,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0,1,1,0
	,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1
	,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0
	,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
	,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0
};
/*
static TEXTRUNE const nonIdentifiers[] = {
 0x02C2,0x02C3,0x02C4,0x02C5,0x02D2,0x02D3,0x02D4,0x02D5,0x02D6,0x02D7,0x02D8,0x02D9,0x02DA
,0x02DB,0x02DC,0x02DD,0x02DE,0x02DF,0x02E5,0x02E6,0x02E7,0x02E8,0x02E9,0x02EA,0x02EB,0x02ED
,0x02EF,0x02F0,0x02F1,0x02F2,0x02F3,0x02F4,0x02F5,0x02F6,0x02F7,0x02F8,0x02F9,0x02FA,0x02FB
,0x02FC,0x02FD,0x02FE,0x02FF,0x0375,0x037E,0x0384,0x0385,0x03F6,0x0482,0x0488,0x0489,0x055A
,0x055B,0x055C,0x055D,0x055E,0x055F,0x0589,0x058A,0x058D,0x058E,0x058F,0x05BE,0x05C0,0x05C3
,0x05C6,0x05F3,0x05F4,0x0600,0x0601,0x0602,0x0603,0x0604,0x0605,0x0606,0x0607,0x0608,0x0609
,0x060A,0x060B,0x060C,0x060D,0x060E,0x060F,0x061B,0x061C,0x061E,0x061F,0x066A,0x066B,0x066C
,0x066D,0x06D4,0x06DD,0x06DE,0x06E9,0x06FD,0x06FE,0x0700,0x0701,0x0702,0x0703,0x0704,0x0705
,0x0706,0x0707,0x0708,0x0709,0x070A,0x070B,0x070C,0x070D,0x070F,0x07F6,0x07F7,0x07F8,0x07F9
,0x0830,0x0831,0x0832,0x0833,0x0834,0x0835,0x0836,0x0837,0x0838,0x0839,0x083A,0x083B,0x083C
,0x083D,0x083E,0x085E,0x08E2,0x0964,0x0965,0x0970,0x09F2,0x09F3,0x09F4,0x09F5,0x09F6,0x09F7
,0x09F8,0x09F9,0x09FA,0x09FB,0x09FD,0x0AF0,0x0AF1,0x0B70,0x0B72,0x0B73,0x0B74,0x0B75,0x0B76
,0x0B77,0x0BF0,0x0BF1,0x0BF2,0x0BF3,0x0BF4,0x0BF5,0x0BF6,0x0BF7,0x0BF8,0x0BF9,0x0BFA,0x0C78
,0x0C79,0x0C7A,0x0C7B,0x0C7C,0x0C7D,0x0C7E,0x0C7F,0x0D4F,0x0D58,0x0D59,0x0D5A,0x0D5B,0x0D5C
,0x0D5D,0x0D5E,0x0D70,0x0D71,0x0D72,0x0D73,0x0D74,0x0D75,0x0D76,0x0D77,0x0D78,0x0D79,0x0DF4
,0x0E3F,0x0E4F,0x0E5A,0x0E5B,0x0F01,0x0F02,0x0F03,0x0F04,0x0F05,0x0F06,0x0F07,0x0F08,0x0F09
,0x0F0A,0x0F0B,0x0F0C,0x0F0D,0x0F0E,0x0F0F,0x0F10,0x0F11,0x0F12,0x0F13,0x0F14,0x0F15,0x0F16
,0x0F17,0x0F1A,0x0F1B,0x0F1C,0x0F1D,0x0F1E,0x0F1F,0x0F2A,0x0F2B,0x0F2C,0x0F2D,0x0F2E,0x0F2F
,0x0F30,0x0F31,0x0F32,0x0F33,0x0F34,0x0F36,0x0F38,0x0F3A,0x0F3B,0x0F3C,0x0F3D,0x0F85,0x0FBE
,0x0FBF,0x0FC0,0x0FC1,0x0FC2,0x0FC3,0x0FC4,0x0FC5,0x0FC7,0x0FC8,0x0FC9,0x0FCA,0x0FCB,0x0FCC
,0x0FCE,0x0FCF,0x0FD0,0x0FD1,0x0FD2,0x0FD3,0x0FD4,0x0FD5,0x0FD6,0x0FD7,0x0FD8,0x0FD9,0x0FDA
,0x104A,0x104B,0x104C,0x104D,0x104E,0x104F,0x109E,0x109F,0x10FB,0x1360,0x1361,0x1362,0x1363
,0x1364,0x1365,0x1366,0x1367,0x1368,0x1372,0x1373,0x1374,0x1375,0x1376,0x1377,0x1378,0x1379
,0x137A,0x137B,0x137C,0x1390,0x1391,0x1392,0x1393,0x1394,0x1395,0x1396,0x1397,0x1398,0x1399
,0x1400,0x166D,0x166E,0x1680,0x169B,0x169C,0x16EB,0x16EC,0x16ED,0x1735,0x1736,0x17D4,0x17D5
,0x17D6,0x17D8,0x17D9,0x17DA,0x17DB,0x17F0,0x17F1,0x17F2,0x17F3,0x17F4,0x17F5,0x17F6,0x17F7
,0x17F8,0x17F9,0x1800,0x1801,0x1802,0x1803,0x1804,0x1805,0x1806,0x1807,0x1808,0x1809,0x180A
,0x180E,0x1940,0x1944,0x1945,0x19DE,0x19DF,0x19E0,0x19E1,0x19E2,0x19E3,0x19E4,0x19E5,0x19E6
,0x19E7,0x19E8,0x19E9,0x19EA,0x19EB,0x19EC,0x19ED,0x19EE,0x19EF,0x19F0,0x19F1,0x19F2,0x19F3
,0x19F4,0x19F5,0x19F6,0x19F7,0x19F8,0x19F9,0x19FA,0x19FB,0x19FC,0x19FD,0x19FE,0x19FF,0x1A1E
,0x1A1F,0x1AA0,0x1AA1,0x1AA2,0x1AA3,0x1AA4,0x1AA5,0x1AA6,0x1AA8,0x1AA9,0x1AAA,0x1AAB,0x1AAC
,0x1AAD,0x1ABE,0x1B5A,0x1B5B,0x1B5C,0x1B5D,0x1B5E,0x1B5F,0x1B60,0x1B61,0x1B62,0x1B63,0x1B64
,0x1B65,0x1B66,0x1B67,0x1B68,0x1B69,0x1B6A,0x1B74,0x1B75,0x1B76,0x1B77,0x1B78,0x1B79,0x1B7A
,0x1B7B,0x1B7C,0x1BFC,0x1BFD,0x1BFE,0x1BFF,0x1C3B,0x1C3C,0x1C3D,0x1C3E,0x1C3F,0x1C7E,0x1C7F
,0x1CC0,0x1CC1,0x1CC2,0x1CC3,0x1CC4,0x1CC5,0x1CC6,0x1CC7,0x1CD3,0x1FBD,0x1FBF,0x1FC0,0x1FC1
,0x1FCD,0x1FCE,0x1FCF,0x1FDD,0x1FDE,0x1FDF,0x1FED,0x1FEE,0x1FEF,0x1FFD,0x1FFE,0x2000,0x2001
,0x2002,0x2003,0x2004,0x2005,0x2006,0x2007,0x2008,0x2009,0x200A,0x200B,0x200C,0x200D,0x200E
,0x200F,0x2010,0x2011,0x2012,0x2013,0x2014,0x2015,0x2016,0x2017,0x2018,0x2019,0x201A,0x201B
,0x201C,0x201D,0x201E,0x201F,0x2020,0x2021,0x2022,0x2023,0x2024,0x2025,0x2026,0x2027,0x2028
,0x2029,0x202A,0x202B,0x202C,0x202D,0x202E,0x202F,0x2030,0x2031,0x2032,0x2033,0x2034,0x2035
,0x2036,0x2037,0x2038,0x2039,0x203A,0x203B,0x203C,0x203D,0x203E,0x2041,0x2042,0x2043,0x2044
,0x2045,0x2046,0x2047,0x2048,0x2049,0x204A,0x204B,0x204C,0x204D,0x204E,0x204F,0x2050,0x2051
,0x2052,0x2053,0x2055,0x2056,0x2057,0x2058,0x2059,0x205A,0x205B,0x205C,0x205D,0x205E,0x205F
,0x2060,0x2061,0x2062,0x2063,0x2064,0x2066,0x2067,0x2068,0x2069,0x206A,0x206B,0x206C,0x206D
,0x206E,0x206F,0x2070,0x2074,0x2075,0x2076,0x2077,0x2078,0x2079,0x207A,0x207B,0x207C,0x207D
,0x207E,0x2080,0x2081,0x2082,0x2083,0x2084,0x2085,0x2086,0x2087,0x2088,0x2089,0x208A,0x208B
,0x208C,0x208D,0x208E,0x20A0,0x20A1,0x20A2,0x20A3,0x20A4,0x20A5,0x20A6,0x20A7,0x20A8,0x20A9
,0x20AA,0x20AB,0x20AC,0x20AD,0x20AE,0x20AF,0x20B0,0x20B1,0x20B2,0x20B3,0x20B4,0x20B5,0x20B6
,0x20B7,0x20B8,0x20B9,0x20BA,0x20BB,0x20BC,0x20BD,0x20BE,0x20BF,0x20DD,0x20DE,0x20DF,0x20E0
,0x20E2,0x20E3,0x20E4,0x2100,0x2101,0x2103,0x2104,0x2105,0x2106,0x2108,0x2109,0x2114,0x2116
,0x2117,0x211E,0x211F,0x2120,0x2121,0x2122,0x2123,0x2125,0x2127,0x2129,0x213A,0x213B,0x2140
,0x2141,0x2142,0x2143,0x2144,0x214A,0x214B,0x214C,0x214D,0x214F,0x2150,0x2151,0x2152,0x2153
,0x2154,0x2155,0x2156,0x2157,0x2158,0x2159,0x215A,0x215B,0x215C,0x215D,0x215E,0x215F,0x2189
,0x218A,0x218B,0x2190,0x2191,0x2192,0x2193,0x2194,0x2195,0x2196,0x2197,0x2198,0x2199,0x219A
,0x219B,0x219C,0x219D,0x219E,0x219F,0x21A0,0x21A1,0x21A2,0x21A3,0x21A4,0x21A5,0x21A6,0x21A7
,0x21A8,0x21A9,0x21AA,0x21AB,0x21AC,0x21AD,0x21AE,0x21AF,0x21B0,0x21B1,0x21B2,0x21B3,0x21B4
,0x21B5,0x21B6,0x21B7,0x21B8,0x21B9,0x21BA,0x21BB,0x21BC,0x21BD,0x21BE,0x21BF,0x21C0,0x21C1
,0x21C2,0x21C3,0x21C4,0x21C5,0x21C6,0x21C7,0x21C8,0x21C9,0x21CA,0x21CB,0x21CC,0x21CD,0x21CE
,0x21CF,0x21D0,0x21D1,0x21D2,0x21D3,0x21D4,0x21D5,0x21D6,0x21D7,0x21D8,0x21D9,0x21DA,0x21DB
,0x21DC,0x21DD,0x21DE,0x21DF,0x21E0,0x21E1,0x21E2,0x21E3,0x21E4,0x21E5,0x21E6,0x21E7,0x21E8
,0x21E9,0x21EA,0x21EB,0x21EC,0x21ED,0x21EE,0x21EF,0x21F0,0x21F1,0x21F2,0x21F3,0x21F4,0x21F5
,0x21F6,0x21F7,0x21F8,0x21F9,0x21FA,0x21FB,0x21FC,0x21FD,0x21FE,0x21FF,0x2200,0x2201,0x2202
,0x2203,0x2204,0x2205,0x2206,0x2207,0x2208,0x2209,0x220A,0x220B,0x220C,0x220D,0x220E,0x220F
,0x2210,0x2211,0x2212,0x2213,0x2214,0x2215,0x2216,0x2217,0x2218,0x2219,0x221A,0x221B,0x221C
,0x221D,0x221E,0x221F,0x2220,0x2221,0x2222,0x2223,0x2224,0x2225,0x2226,0x2227,0x2228,0x2229
,0x222A,0x222B,0x222C,0x222D,0x222E,0x222F,0x2230,0x2231,0x2232,0x2233,0x2234,0x2235,0x2236
,0x2237,0x2238,0x2239,0x223A,0x223B,0x223C,0x223D,0x223E,0x223F,0x2240,0x2241,0x2242,0x2243
,0x2244,0x2245,0x2246,0x2247,0x2248,0x2249,0x224A,0x224B,0x224C,0x224D,0x224E,0x224F,0x2250
,0x2251,0x2252,0x2253,0x2254,0x2255,0x2256,0x2257,0x2258,0x2259,0x225A,0x225B,0x225C,0x225D
,0x225E,0x225F,0x2260,0x2261,0x2262,0x2263,0x2264,0x2265,0x2266,0x2267,0x2268,0x2269,0x226A
,0x226B,0x226C,0x226D,0x226E,0x226F,0x2270,0x2271,0x2272,0x2273,0x2274,0x2275,0x2276,0x2277
,0x2278,0x2279,0x227A,0x227B,0x227C,0x227D,0x227E,0x227F,0x2280,0x2281,0x2282,0x2283,0x2284
,0x2285,0x2286,0x2287,0x2288,0x2289,0x228A,0x228B,0x228C,0x228D,0x228E,0x228F,0x2290,0x2291
,0x2292,0x2293,0x2294,0x2295,0x2296,0x2297,0x2298,0x2299,0x229A,0x229B,0x229C,0x229D,0x229E
,0x229F,0x22A0,0x22A1,0x22A2,0x22A3,0x22A4,0x22A5,0x22A6,0x22A7,0x22A8,0x22A9,0x22AA,0x22AB
,0x22AC,0x22AD,0x22AE,0x22AF,0x22B0,0x22B1,0x22B2,0x22B3,0x22B4,0x22B5,0x22B6,0x22B7,0x22B8
,0x22B9,0x22BA,0x22BB,0x22BC,0x22BD,0x22BE,0x22BF,0x22C0,0x22C1,0x22C2,0x22C3,0x22C4,0x22C5
,0x22C6,0x22C7,0x22C8,0x22C9,0x22CA,0x22CB,0x22CC,0x22CD,0x22CE,0x22CF,0x22D0,0x22D1,0x22D2
,0x22D3,0x22D4,0x22D5,0x22D6,0x22D7,0x22D8,0x22D9,0x22DA,0x22DB,0x22DC,0x22DD,0x22DE,0x22DF
,0x22E0,0x22E1,0x22E2,0x22E3,0x22E4,0x22E5,0x22E6,0x22E7,0x22E8,0x22E9,0x22EA,0x22EB,0x22EC
,0x22ED,0x22EE,0x22EF,0x22F0,0x22F1,0x22F2,0x22F3,0x22F4,0x22F5,0x22F6,0x22F7,0x22F8,0x22F9
,0x22FA,0x22FB,0x22FC,0x22FD,0x22FE,0x22FF,0x2300,0x2301,0x2302,0x2303,0x2304,0x2305,0x2306
,0x2307,0x2308,0x2309,0x230A,0x230B,0x230C,0x230D,0x230E,0x230F,0x2310,0x2311,0x2312,0x2313
,0x2314,0x2315,0x2316,0x2317,0x2318,0x2319,0x231A,0x231B,0x231C,0x231D,0x231E,0x231F,0x2320
,0x2321,0x2322,0x2323,0x2324,0x2325,0x2326,0x2327,0x2328,0x2329,0x232A,0x232B,0x232C,0x232D
,0x232E,0x232F,0x2330,0x2331,0x2332,0x2333,0x2334,0x2335,0x2336,0x2337,0x2338,0x2339,0x233A
,0x233B,0x233C,0x233D,0x233E,0x233F,0x2340,0x2341,0x2342,0x2343,0x2344,0x2345,0x2346,0x2347
,0x2348,0x2349,0x234A,0x234B,0x234C,0x234D,0x234E,0x234F,0x2350,0x2351,0x2352,0x2353,0x2354
,0x2355,0x2356,0x2357,0x2358,0x2359,0x235A,0x235B,0x235C,0x235D,0x235E,0x235F,0x2360,0x2361
,0x2362,0x2363,0x2364,0x2365,0x2366,0x2367,0x2368,0x2369,0x236A,0x236B,0x236C,0x236D,0x236E
,0x236F,0x2370,0x2371,0x2372,0x2373,0x2374,0x2375,0x2376,0x2377,0x2378,0x2379,0x237A,0x237B
,0x237C,0x237D,0x237E,0x237F,0x2380,0x2381,0x2382,0x2383,0x2384,0x2385,0x2386,0x2387,0x2388
,0x2389,0x238A,0x238B,0x238C,0x238D,0x238E,0x238F,0x2390,0x2391,0x2392,0x2393,0x2394,0x2395
,0x2396,0x2397,0x2398,0x2399,0x239A,0x239B,0x239C,0x239D,0x239E,0x239F,0x23A0,0x23A1,0x23A2
,0x23A3,0x23A4,0x23A5,0x23A6,0x23A7,0x23A8,0x23A9,0x23AA,0x23AB,0x23AC,0x23AD,0x23AE,0x23AF
,0x23B0,0x23B1,0x23B2,0x23B3,0x23B4,0x23B5,0x23B6,0x23B7,0x23B8,0x23B9,0x23BA,0x23BB,0x23BC
,0x23BD,0x23BE,0x23BF,0x23C0,0x23C1,0x23C2,0x23C3,0x23C4,0x23C5,0x23C6,0x23C7,0x23C8,0x23C9
,0x23CA,0x23CB,0x23CC,0x23CD,0x23CE,0x23CF,0x23D0,0x23D1,0x23D2,0x23D3,0x23D4,0x23D5,0x23D6
,0x23D7,0x23D8,0x23D9,0x23DA,0x23DB,0x23DC,0x23DD,0x23DE,0x23DF,0x23E0,0x23E1,0x23E2,0x23E3
,0x23E4,0x23E5,0x23E6,0x23E7,0x23E8,0x23E9,0x23EA,0x23EB,0x23EC,0x23ED,0x23EE,0x23EF,0x23F0
,0x23F1,0x23F2,0x23F3,0x23F4,0x23F5,0x23F6,0x23F7,0x23F8,0x23F9,0x23FA,0x23FB,0x23FC,0x23FD
,0x23FE,0x23FF,0x2400,0x2401,0x2402,0x2403,0x2404,0x2405,0x2406,0x2407,0x2408,0x2409,0x240A
,0x240B,0x240C,0x240D,0x240E,0x240F,0x2410,0x2411,0x2412,0x2413,0x2414,0x2415,0x2416,0x2417
,0x2418,0x2419,0x241A,0x241B,0x241C,0x241D,0x241E,0x241F,0x2420,0x2421,0x2422,0x2423,0x2424
,0x2425,0x2426,0x2440,0x2441,0x2442,0x2443,0x2444,0x2445,0x2446,0x2447,0x2448,0x2449,0x244A
,0x2460,0x2461,0x2462,0x2463,0x2464,0x2465,0x2466,0x2467,0x2468,0x2469,0x246A,0x246B,0x246C
,0x246D,0x246E,0x246F,0x2470,0x2471,0x2472,0x2473,0x2474,0x2475,0x2476,0x2477,0x2478,0x2479
,0x247A,0x247B,0x247C,0x247D,0x247E,0x247F,0x2480,0x2481,0x2482,0x2483,0x2484,0x2485,0x2486
,0x2487,0x2488,0x2489,0x248A,0x248B,0x248C,0x248D,0x248E,0x248F,0x2490,0x2491,0x2492,0x2493
,0x2494,0x2495,0x2496,0x2497,0x2498,0x2499,0x249A,0x249B,0x249C,0x249D,0x249E,0x249F,0x24A0
,0x24A1,0x24A2,0x24A3,0x24A4,0x24A5,0x24A6,0x24A7,0x24A8,0x24A9,0x24AA,0x24AB,0x24AC,0x24AD
,0x24AE,0x24AF,0x24B0,0x24B1,0x24B2,0x24B3,0x24B4,0x24B5,0x24B6,0x24B7,0x24B8,0x24B9,0x24BA
,0x24BB,0x24BC,0x24BD,0x24BE,0x24BF,0x24C0,0x24C1,0x24C2,0x24C3,0x24C4,0x24C5,0x24C6,0x24C7
,0x24C8,0x24C9,0x24CA,0x24CB,0x24CC,0x24CD,0x24CE,0x24CF,0x24D0,0x24D1,0x24D2,0x24D3,0x24D4
,0x24D5,0x24D6,0x24D7,0x24D8,0x24D9,0x24DA,0x24DB,0x24DC,0x24DD,0x24DE,0x24DF,0x24E0,0x24E1
,0x24E2,0x24E3,0x24E4,0x24E5,0x24E6,0x24E7,0x24E8,0x24E9,0x24EA,0x24EB,0x24EC,0x24ED,0x24EE
,0x24EF,0x24F0,0x24F1,0x24F2,0x24F3,0x24F4,0x24F5,0x24F6,0x24F7,0x24F8,0x24F9,0x24FA,0x24FB
,0x24FC,0x24FD,0x24FE,0x24FF,0x2500,0x2501,0x2502,0x2503,0x2504,0x2505,0x2506,0x2507,0x2508
,0x2509,0x250A,0x250B,0x250C,0x250D,0x250E,0x250F,0x2510,0x2511,0x2512,0x2513,0x2514,0x2515
,0x2516,0x2517,0x2518,0x2519,0x251A,0x251B,0x251C,0x251D,0x251E,0x251F,0x2520,0x2521,0x2522
,0x2523,0x2524,0x2525,0x2526,0x2527,0x2528,0x2529,0x252A,0x252B,0x252C,0x252D,0x252E,0x252F
,0x2530,0x2531,0x2532,0x2533,0x2534,0x2535,0x2536,0x2537,0x2538,0x2539,0x253A,0x253B,0x253C
,0x253D,0x253E,0x253F,0x2540,0x2541,0x2542,0x2543,0x2544,0x2545,0x2546,0x2547,0x2548,0x2549
,0x254A,0x254B,0x254C,0x254D,0x254E,0x254F,0x2550,0x2551,0x2552,0x2553,0x2554,0x2555,0x2556
,0x2557,0x2558,0x2559,0x255A,0x255B,0x255C,0x255D,0x255E,0x255F,0x2560,0x2561,0x2562,0x2563
,0x2564,0x2565,0x2566,0x2567,0x2568,0x2569,0x256A,0x256B,0x256C,0x256D,0x256E,0x256F,0x2570
,0x2571,0x2572,0x2573,0x2574,0x2575,0x2576,0x2577,0x2578,0x2579,0x257A,0x257B,0x257C,0x257D
,0x257E,0x257F,0x2580,0x2581,0x2582,0x2583,0x2584,0x2585,0x2586,0x2587,0x2588,0x2589,0x258A
,0x258B,0x258C,0x258D,0x258E,0x258F,0x2590,0x2591,0x2592,0x2593,0x2594,0x2595,0x2596,0x2597
,0x2598,0x2599,0x259A,0x259B,0x259C,0x259D,0x259E,0x259F,0x25A0,0x25A1,0x25A2,0x25A3,0x25A4
,0x25A5,0x25A6,0x25A7,0x25A8,0x25A9,0x25AA,0x25AB,0x25AC,0x25AD,0x25AE,0x25AF,0x25B0,0x25B1
,0x25B2,0x25B3,0x25B4,0x25B5,0x25B6,0x25B7,0x25B8,0x25B9,0x25BA,0x25BB,0x25BC,0x25BD,0x25BE
,0x25BF,0x25C0,0x25C1,0x25C2,0x25C3,0x25C4,0x25C5,0x25C6,0x25C7,0x25C8,0x25C9,0x25CA,0x25CB
,0x25CC,0x25CD,0x25CE,0x25CF,0x25D0,0x25D1,0x25D2,0x25D3,0x25D4,0x25D5,0x25D6,0x25D7,0x25D8
,0x25D9,0x25DA,0x25DB,0x25DC,0x25DD,0x25DE,0x25DF,0x25E0,0x25E1,0x25E2,0x25E3,0x25E4,0x25E5
,0x25E6,0x25E7,0x25E8,0x25E9,0x25EA,0x25EB,0x25EC,0x25ED,0x25EE,0x25EF,0x25F0,0x25F1,0x25F2
,0x25F3,0x25F4,0x25F5,0x25F6,0x25F7,0x25F8,0x25F9,0x25FA,0x25FB,0x25FC,0x25FD,0x25FE,0x25FF
,0x2600,0x2601,0x2602,0x2603,0x2604,0x2605,0x2606,0x2607,0x2608,0x2609,0x260A,0x260B,0x260C
,0x260D,0x260E,0x260F,0x2610,0x2611,0x2612,0x2613,0x2614,0x2615,0x2616,0x2617,0x2618,0x2619
,0x261A,0x261B,0x261C,0x261D,0x261E,0x261F,0x2620,0x2621,0x2622,0x2623,0x2624,0x2625,0x2626
,0x2627,0x2628,0x2629,0x262A,0x262B,0x262C,0x262D,0x262E,0x262F,0x2630,0x2631,0x2632,0x2633
,0x2634,0x2635,0x2636,0x2637,0x2638,0x2639,0x263A,0x263B,0x263C,0x263D,0x263E,0x263F,0x2640
,0x2641,0x2642,0x2643,0x2644,0x2645,0x2646,0x2647,0x2648,0x2649,0x264A,0x264B,0x264C,0x264D
,0x264E,0x264F,0x2650,0x2651,0x2652,0x2653,0x2654,0x2655,0x2656,0x2657,0x2658,0x2659,0x265A
,0x265B,0x265C,0x265D,0x265E,0x265F,0x2660,0x2661,0x2662,0x2663,0x2664,0x2665,0x2666,0x2667
,0x2668,0x2669,0x266A,0x266B,0x266C,0x266D,0x266E,0x266F,0x2670,0x2671,0x2672,0x2673,0x2674
,0x2675,0x2676,0x2677,0x2678,0x2679,0x267A,0x267B,0x267C,0x267D,0x267E,0x267F,0x2680,0x2681
,0x2682,0x2683,0x2684,0x2685,0x2686,0x2687,0x2688,0x2689,0x268A,0x268B,0x268C,0x268D,0x268E
,0x268F,0x2690,0x2691,0x2692,0x2693,0x2694,0x2695,0x2696,0x2697,0x2698,0x2699,0x269A,0x269B
,0x269C,0x269D,0x269E,0x269F,0x26A0,0x26A1,0x26A2,0x26A3,0x26A4,0x26A5,0x26A6,0x26A7,0x26A8
,0x26A9,0x26AA,0x26AB,0x26AC,0x26AD,0x26AE,0x26AF,0x26B0,0x26B1,0x26B2,0x26B3,0x26B4,0x26B5
,0x26B6,0x26B7,0x26B8,0x26B9,0x26BA,0x26BB,0x26BC,0x26BD,0x26BE,0x26BF,0x26C0,0x26C1,0x26C2
,0x26C3,0x26C4,0x26C5,0x26C6,0x26C7,0x26C8,0x26C9,0x26CA,0x26CB,0x26CC,0x26CD,0x26CE,0x26CF
,0x26D0,0x26D1,0x26D2,0x26D3,0x26D4,0x26D5,0x26D6,0x26D7,0x26D8,0x26D9,0x26DA,0x26DB,0x26DC
,0x26DD,0x26DE,0x26DF,0x26E0,0x26E1,0x26E2,0x26E3,0x26E4,0x26E5,0x26E6,0x26E7,0x26E8,0x26E9
,0x26EA,0x26EB,0x26EC,0x26ED,0x26EE,0x26EF,0x26F0,0x26F1,0x26F2,0x26F3,0x26F4,0x26F5,0x26F6
,0x26F7,0x26F8,0x26F9,0x26FA,0x26FB,0x26FC,0x26FD,0x26FE,0x26FF,0x2700,0x2701,0x2702,0x2703
,0x2704,0x2705,0x2706,0x2707,0x2708,0x2709,0x270A,0x270B,0x270C,0x270D,0x270E,0x270F,0x2710
,0x2711,0x2712,0x2713,0x2714,0x2715,0x2716,0x2717,0x2718,0x2719,0x271A,0x271B,0x271C,0x271D
,0x271E,0x271F,0x2720,0x2721,0x2722,0x2723,0x2724,0x2725,0x2726,0x2727,0x2728,0x2729,0x272A
,0x272B,0x272C,0x272D,0x272E,0x272F,0x2730,0x2731,0x2732,0x2733,0x2734,0x2735,0x2736,0x2737
,0x2738,0x2739,0x273A,0x273B,0x273C,0x273D,0x273E,0x273F,0x2740,0x2741,0x2742,0x2743,0x2744
,0x2745,0x2746,0x2747,0x2748,0x2749,0x274A,0x274B,0x274C,0x274D,0x274E,0x274F,0x2750,0x2751
,0x2752,0x2753,0x2754,0x2755,0x2756,0x2757,0x2758,0x2759,0x275A,0x275B,0x275C,0x275D,0x275E
,0x275F,0x2760,0x2761,0x2762,0x2763,0x2764,0x2765,0x2766,0x2767,0x2768,0x2769,0x276A,0x276B
,0x276C,0x276D,0x276E,0x276F,0x2770,0x2771,0x2772,0x2773,0x2774,0x2775,0x2776,0x2777,0x2778
,0x2779,0x277A,0x277B,0x277C,0x277D,0x277E,0x277F,0x2780,0x2781,0x2782,0x2783,0x2784,0x2785
,0x2786,0x2787,0x2788,0x2789,0x278A,0x278B,0x278C,0x278D,0x278E,0x278F,0x2790,0x2791,0x2792
,0x2793,0x2794,0x2795,0x2796,0x2797,0x2798,0x2799,0x279A,0x279B,0x279C,0x279D,0x279E,0x279F
,0x27A0,0x27A1,0x27A2,0x27A3,0x27A4,0x27A5,0x27A6,0x27A7,0x27A8,0x27A9,0x27AA,0x27AB,0x27AC
,0x27AD,0x27AE,0x27AF,0x27B0,0x27B1,0x27B2,0x27B3,0x27B4,0x27B5,0x27B6,0x27B7,0x27B8,0x27B9
,0x27BA,0x27BB,0x27BC,0x27BD,0x27BE,0x27BF,0x27C0,0x27C1,0x27C2,0x27C3,0x27C4,0x27C5,0x27C6
,0x27C7,0x27C8,0x27C9,0x27CA,0x27CB,0x27CC,0x27CD,0x27CE,0x27CF,0x27D0,0x27D1,0x27D2,0x27D3
,0x27D4,0x27D5,0x27D6,0x27D7,0x27D8,0x27D9,0x27DA,0x27DB,0x27DC,0x27DD,0x27DE,0x27DF,0x27E0
,0x27E1,0x27E2,0x27E3,0x27E4,0x27E5,0x27E6,0x27E7,0x27E8,0x27E9,0x27EA,0x27EB,0x27EC,0x27ED
,0x27EE,0x27EF,0x27F0,0x27F1,0x27F2,0x27F3,0x27F4,0x27F5,0x27F6,0x27F7,0x27F8,0x27F9,0x27FA
,0x27FB,0x27FC,0x27FD,0x27FE,0x27FF,0x2800,0x2801,0x2802,0x2803,0x2804,0x2805,0x2806,0x2807
,0x2808,0x2809,0x280A,0x280B,0x280C,0x280D,0x280E,0x280F,0x2810,0x2811,0x2812,0x2813,0x2814
,0x2815,0x2816,0x2817,0x2818,0x2819,0x281A,0x281B,0x281C,0x281D,0x281E,0x281F,0x2820,0x2821
,0x2822,0x2823,0x2824,0x2825,0x2826,0x2827,0x2828,0x2829,0x282A,0x282B,0x282C,0x282D,0x282E
,0x282F,0x2830,0x2831,0x2832,0x2833,0x2834,0x2835,0x2836,0x2837,0x2838,0x2839,0x283A,0x283B
,0x283C,0x283D,0x283E,0x283F,0x2840,0x2841,0x2842,0x2843,0x2844,0x2845,0x2846,0x2847,0x2848
,0x2849,0x284A,0x284B,0x284C,0x284D,0x284E,0x284F,0x2850,0x2851,0x2852,0x2853,0x2854,0x2855
,0x2856,0x2857,0x2858,0x2859,0x285A,0x285B,0x285C,0x285D,0x285E,0x285F,0x2860,0x2861,0x2862
,0x2863,0x2864,0x2865,0x2866,0x2867,0x2868,0x2869,0x286A,0x286B,0x286C,0x286D,0x286E,0x286F
,0x2870,0x2871,0x2872,0x2873,0x2874,0x2875,0x2876,0x2877,0x2878,0x2879,0x287A,0x287B,0x287C
,0x287D,0x287E,0x287F,0x2880,0x2881,0x2882,0x2883,0x2884,0x2885,0x2886,0x2887,0x2888,0x2889
,0x288A,0x288B,0x288C,0x288D,0x288E,0x288F,0x2890,0x2891,0x2892,0x2893,0x2894,0x2895,0x2896
,0x2897,0x2898,0x2899,0x289A,0x289B,0x289C,0x289D,0x289E,0x289F,0x28A0,0x28A1,0x28A2,0x28A3
,0x28A4,0x28A5,0x28A6,0x28A7,0x28A8,0x28A9,0x28AA,0x28AB,0x28AC,0x28AD,0x28AE,0x28AF,0x28B0
,0x28B1,0x28B2,0x28B3,0x28B4,0x28B5,0x28B6,0x28B7,0x28B8,0x28B9,0x28BA,0x28BB,0x28BC,0x28BD
,0x28BE,0x28BF,0x28C0,0x28C1,0x28C2,0x28C3,0x28C4,0x28C5,0x28C6,0x28C7,0x28C8,0x28C9,0x28CA
,0x28CB,0x28CC,0x28CD,0x28CE,0x28CF,0x28D0,0x28D1,0x28D2,0x28D3,0x28D4,0x28D5,0x28D6,0x28D7
,0x28D8,0x28D9,0x28DA,0x28DB,0x28DC,0x28DD,0x28DE,0x28DF,0x28E0,0x28E1,0x28E2,0x28E3,0x28E4
,0x28E5,0x28E6,0x28E7,0x28E8,0x28E9,0x28EA,0x28EB,0x28EC,0x28ED,0x28EE,0x28EF,0x28F0,0x28F1
,0x28F2,0x28F3,0x28F4,0x28F5,0x28F6,0x28F7,0x28F8,0x28F9,0x28FA,0x28FB,0x28FC,0x28FD,0x28FE
,0x28FF,0x2900,0x2901,0x2902,0x2903,0x2904,0x2905,0x2906,0x2907,0x2908,0x2909,0x290A,0x290B
,0x290C,0x290D,0x290E,0x290F,0x2910,0x2911,0x2912,0x2913,0x2914,0x2915,0x2916,0x2917,0x2918
,0x2919,0x291A,0x291B,0x291C,0x291D,0x291E,0x291F,0x2920,0x2921,0x2922,0x2923,0x2924,0x2925
,0x2926,0x2927,0x2928,0x2929,0x292A,0x292B,0x292C,0x292D,0x292E,0x292F,0x2930,0x2931,0x2932
,0x2933,0x2934,0x2935,0x2936,0x2937,0x2938,0x2939,0x293A,0x293B,0x293C,0x293D,0x293E,0x293F
,0x2940,0x2941,0x2942,0x2943,0x2944,0x2945,0x2946,0x2947,0x2948,0x2949,0x294A,0x294B,0x294C
,0x294D,0x294E,0x294F,0x2950,0x2951,0x2952,0x2953,0x2954,0x2955,0x2956,0x2957,0x2958,0x2959
,0x295A,0x295B,0x295C,0x295D,0x295E,0x295F,0x2960,0x2961,0x2962,0x2963,0x2964,0x2965,0x2966
,0x2967,0x2968,0x2969,0x296A,0x296B,0x296C,0x296D,0x296E,0x296F,0x2970,0x2971,0x2972,0x2973
,0x2974,0x2975,0x2976,0x2977,0x2978,0x2979,0x297A,0x297B,0x297C,0x297D,0x297E,0x297F,0x2980
,0x2981,0x2982,0x2983,0x2984,0x2985,0x2986,0x2987,0x2988,0x2989,0x298A,0x298B,0x298C,0x298D
,0x298E,0x298F,0x2990,0x2991,0x2992,0x2993,0x2994,0x2995,0x2996,0x2997,0x2998,0x2999,0x299A
,0x299B,0x299C,0x299D,0x299E,0x299F,0x29A0,0x29A1,0x29A2,0x29A3,0x29A4,0x29A5,0x29A6,0x29A7
,0x29A8,0x29A9,0x29AA,0x29AB,0x29AC,0x29AD,0x29AE,0x29AF,0x29B0,0x29B1,0x29B2,0x29B3,0x29B4
,0x29B5,0x29B6,0x29B7,0x29B8,0x29B9,0x29BA,0x29BB,0x29BC,0x29BD,0x29BE,0x29BF,0x29C0,0x29C1
,0x29C2,0x29C3,0x29C4,0x29C5,0x29C6,0x29C7,0x29C8,0x29C9,0x29CA,0x29CB,0x29CC,0x29CD,0x29CE
,0x29CF,0x29D0,0x29D1,0x29D2,0x29D3,0x29D4,0x29D5,0x29D6,0x29D7,0x29D8,0x29D9,0x29DA,0x29DB
,0x29DC,0x29DD,0x29DE,0x29DF,0x29E0,0x29E1,0x29E2,0x29E3,0x29E4,0x29E5,0x29E6,0x29E7,0x29E8
,0x29E9,0x29EA,0x29EB,0x29EC,0x29ED,0x29EE,0x29EF,0x29F0,0x29F1,0x29F2,0x29F3,0x29F4,0x29F5
,0x29F6,0x29F7,0x29F8,0x29F9,0x29FA,0x29FB,0x29FC,0x29FD,0x29FE,0x29FF,0x2A00,0x2A01,0x2A02
,0x2A03,0x2A04,0x2A05,0x2A06,0x2A07,0x2A08,0x2A09,0x2A0A,0x2A0B,0x2A0C,0x2A0D,0x2A0E,0x2A0F
,0x2A10,0x2A11,0x2A12,0x2A13,0x2A14,0x2A15,0x2A16,0x2A17,0x2A18,0x2A19,0x2A1A,0x2A1B,0x2A1C
,0x2A1D,0x2A1E,0x2A1F,0x2A20,0x2A21,0x2A22,0x2A23,0x2A24,0x2A25,0x2A26,0x2A27,0x2A28,0x2A29
,0x2A2A,0x2A2B,0x2A2C,0x2A2D,0x2A2E,0x2A2F,0x2A30,0x2A31,0x2A32,0x2A33,0x2A34,0x2A35,0x2A36
,0x2A37,0x2A38,0x2A39,0x2A3A,0x2A3B,0x2A3C,0x2A3D,0x2A3E,0x2A3F,0x2A40,0x2A41,0x2A42,0x2A43
,0x2A44,0x2A45,0x2A46,0x2A47,0x2A48,0x2A49,0x2A4A,0x2A4B,0x2A4C,0x2A4D,0x2A4E,0x2A4F,0x2A50
,0x2A51,0x2A52,0x2A53,0x2A54,0x2A55,0x2A56,0x2A57,0x2A58,0x2A59,0x2A5A,0x2A5B,0x2A5C,0x2A5D
,0x2A5E,0x2A5F,0x2A60,0x2A61,0x2A62,0x2A63,0x2A64,0x2A65,0x2A66,0x2A67,0x2A68,0x2A69,0x2A6A
,0x2A6B,0x2A6C,0x2A6D,0x2A6E,0x2A6F,0x2A70,0x2A71,0x2A72,0x2A73,0x2A74,0x2A75,0x2A76,0x2A77
,0x2A78,0x2A79,0x2A7A,0x2A7B,0x2A7C,0x2A7D,0x2A7E,0x2A7F,0x2A80,0x2A81,0x2A82,0x2A83,0x2A84
,0x2A85,0x2A86,0x2A87,0x2A88,0x2A89,0x2A8A,0x2A8B,0x2A8C,0x2A8D,0x2A8E,0x2A8F,0x2A90,0x2A91
,0x2A92,0x2A93,0x2A94,0x2A95,0x2A96,0x2A97,0x2A98,0x2A99,0x2A9A,0x2A9B,0x2A9C,0x2A9D,0x2A9E
,0x2A9F,0x2AA0,0x2AA1,0x2AA2,0x2AA3,0x2AA4,0x2AA5,0x2AA6,0x2AA7,0x2AA8,0x2AA9,0x2AAA,0x2AAB
,0x2AAC,0x2AAD,0x2AAE,0x2AAF,0x2AB0,0x2AB1,0x2AB2,0x2AB3,0x2AB4,0x2AB5,0x2AB6,0x2AB7,0x2AB8
,0x2AB9,0x2ABA,0x2ABB,0x2ABC,0x2ABD,0x2ABE,0x2ABF,0x2AC0,0x2AC1,0x2AC2,0x2AC3,0x2AC4,0x2AC5
,0x2AC6,0x2AC7,0x2AC8,0x2AC9,0x2ACA,0x2ACB,0x2ACC,0x2ACD,0x2ACE,0x2ACF,0x2AD0,0x2AD1,0x2AD2
,0x2AD3,0x2AD4,0x2AD5,0x2AD6,0x2AD7,0x2AD8,0x2AD9,0x2ADA,0x2ADB,0x2ADC,0x2ADD,0x2ADE,0x2ADF
,0x2AE0,0x2AE1,0x2AE2,0x2AE3,0x2AE4,0x2AE5,0x2AE6,0x2AE7,0x2AE8,0x2AE9,0x2AEA,0x2AEB,0x2AEC
,0x2AED,0x2AEE,0x2AEF,0x2AF0,0x2AF1,0x2AF2,0x2AF3,0x2AF4,0x2AF5,0x2AF6,0x2AF7,0x2AF8,0x2AF9
,0x2AFA,0x2AFB,0x2AFC,0x2AFD,0x2AFE,0x2AFF,0x2B00,0x2B01,0x2B02,0x2B03,0x2B04,0x2B05,0x2B06
,0x2B07,0x2B08,0x2B09,0x2B0A,0x2B0B,0x2B0C,0x2B0D,0x2B0E,0x2B0F,0x2B10,0x2B11,0x2B12,0x2B13
,0x2B14,0x2B15,0x2B16,0x2B17,0x2B18,0x2B19,0x2B1A,0x2B1B,0x2B1C,0x2B1D,0x2B1E,0x2B1F,0x2B20
,0x2B21,0x2B22,0x2B23,0x2B24,0x2B25,0x2B26,0x2B27,0x2B28,0x2B29,0x2B2A,0x2B2B,0x2B2C,0x2B2D
,0x2B2E,0x2B2F,0x2B30,0x2B31,0x2B32,0x2B33,0x2B34,0x2B35,0x2B36,0x2B37,0x2B38,0x2B39,0x2B3A
,0x2B3B,0x2B3C,0x2B3D,0x2B3E,0x2B3F,0x2B40,0x2B41,0x2B42,0x2B43,0x2B44,0x2B45,0x2B46,0x2B47
,0x2B48,0x2B49,0x2B4A,0x2B4B,0x2B4C,0x2B4D,0x2B4E,0x2B4F,0x2B50,0x2B51,0x2B52,0x2B53,0x2B54
,0x2B55,0x2B56,0x2B57,0x2B58,0x2B59,0x2B5A,0x2B5B,0x2B5C,0x2B5D,0x2B5E,0x2B5F,0x2B60,0x2B61
,0x2B62,0x2B63,0x2B64,0x2B65,0x2B66,0x2B67,0x2B68,0x2B69,0x2B6A,0x2B6B,0x2B6C,0x2B6D,0x2B6E
,0x2B6F,0x2B70,0x2B71,0x2B72,0x2B73,0x2B76,0x2B77,0x2B78,0x2B79,0x2B7A,0x2B7B,0x2B7C,0x2B7D
,0x2B7E,0x2B7F,0x2B80,0x2B81,0x2B82,0x2B83,0x2B84,0x2B85,0x2B86,0x2B87,0x2B88,0x2B89,0x2B8A
,0x2B8B,0x2B8C,0x2B8D,0x2B8E,0x2B8F,0x2B90,0x2B91,0x2B92,0x2B93,0x2B94,0x2B95,0x2B98,0x2B99
,0x2B9A,0x2B9B,0x2B9C,0x2B9D,0x2B9E,0x2B9F,0x2BA0,0x2BA1,0x2BA2,0x2BA3,0x2BA4,0x2BA5,0x2BA6
,0x2BA7,0x2BA8,0x2BA9,0x2BAA,0x2BAB,0x2BAC,0x2BAD,0x2BAE,0x2BAF,0x2BB0,0x2BB1,0x2BB2,0x2BB3
,0x2BB4,0x2BB5,0x2BB6,0x2BB7,0x2BB8,0x2BB9,0x2BBD,0x2BBE,0x2BBF,0x2BC0,0x2BC1,0x2BC2,0x2BC3
,0x2BC4,0x2BC5,0x2BC6,0x2BC7,0x2BC8,0x2BCA,0x2BCB,0x2BCC,0x2BCD,0x2BCE,0x2BCF,0x2BD0,0x2BD1
,0x2BD2,0x2BEC,0x2BED,0x2BEE,0x2BEF,0x2CE5,0x2CE6,0x2CE7,0x2CE8,0x2CE9,0x2CEA,0x2CF9,0x2CFA
,0x2CFB,0x2CFC,0x2CFD,0x2CFE,0x2CFF,0x2D70,0x2E00,0x2E01,0x2E02,0x2E03,0x2E04,0x2E05,0x2E06
,0x2E07,0x2E08,0x2E09,0x2E0A,0x2E0B,0x2E0C,0x2E0D,0x2E0E,0x2E0F,0x2E10,0x2E11,0x2E12,0x2E13
,0x2E14,0x2E15,0x2E16,0x2E17,0x2E18,0x2E19,0x2E1A,0x2E1B,0x2E1C,0x2E1D,0x2E1E,0x2E1F,0x2E20
,0x2E21,0x2E22,0x2E23,0x2E24,0x2E25,0x2E26,0x2E27,0x2E28,0x2E29,0x2E2A,0x2E2B,0x2E2C,0x2E2D
,0x2E2E,0x2E2F,0x2E30,0x2E31,0x2E32,0x2E33,0x2E34,0x2E35,0x2E36,0x2E37,0x2E38,0x2E39,0x2E3A
,0x2E3B,0x2E3C,0x2E3D,0x2E3E,0x2E3F,0x2E40,0x2E41,0x2E42,0x2E43,0x2E44,0x2E45,0x2E46,0x2E47
,0x2E48,0x2E49,0x2E80,0x2E81,0x2E82,0x2E83,0x2E84,0x2E85,0x2E86,0x2E87,0x2E88,0x2E89,0x2E8A
,0x2E8B,0x2E8C,0x2E8D,0x2E8E,0x2E8F,0x2E90,0x2E91,0x2E92,0x2E93,0x2E94,0x2E95,0x2E96,0x2E97
,0x2E98,0x2E99,0x2E9B,0x2E9C,0x2E9D,0x2E9E,0x2E9F,0x2EA0,0x2EA1,0x2EA2,0x2EA3,0x2EA4,0x2EA5
,0x2EA6,0x2EA7,0x2EA8,0x2EA9,0x2EAA,0x2EAB,0x2EAC,0x2EAD,0x2EAE,0x2EAF,0x2EB0,0x2EB1,0x2EB2
,0x2EB3,0x2EB4,0x2EB5,0x2EB6,0x2EB7,0x2EB8,0x2EB9,0x2EBA,0x2EBB,0x2EBC,0x2EBD,0x2EBE,0x2EBF
,0x2EC0,0x2EC1,0x2EC2,0x2EC3,0x2EC4,0x2EC5,0x2EC6,0x2EC7,0x2EC8,0x2EC9,0x2ECA,0x2ECB,0x2ECC
,0x2ECD,0x2ECE,0x2ECF,0x2ED0,0x2ED1,0x2ED2,0x2ED3,0x2ED4,0x2ED5,0x2ED6,0x2ED7,0x2ED8,0x2ED9
,0x2EDA,0x2EDB,0x2EDC,0x2EDD,0x2EDE,0x2EDF,0x2EE0,0x2EE1,0x2EE2,0x2EE3,0x2EE4,0x2EE5,0x2EE6
,0x2EE7,0x2EE8,0x2EE9,0x2EEA,0x2EEB,0x2EEC,0x2EED,0x2EEE,0x2EEF,0x2EF0,0x2EF1,0x2EF2,0x2EF3
,0x2F00,0x2F01,0x2F02,0x2F03,0x2F04,0x2F05,0x2F06,0x2F07,0x2F08,0x2F09,0x2F0A,0x2F0B,0x2F0C
,0x2F0D,0x2F0E,0x2F0F,0x2F10,0x2F11,0x2F12,0x2F13,0x2F14,0x2F15,0x2F16,0x2F17,0x2F18,0x2F19
,0x2F1A,0x2F1B,0x2F1C,0x2F1D,0x2F1E,0x2F1F,0x2F20,0x2F21,0x2F22,0x2F23,0x2F24,0x2F25,0x2F26
,0x2F27,0x2F28,0x2F29,0x2F2A,0x2F2B,0x2F2C,0x2F2D,0x2F2E,0x2F2F,0x2F30,0x2F31,0x2F32,0x2F33
,0x2F34,0x2F35,0x2F36,0x2F37,0x2F38,0x2F39,0x2F3A,0x2F3B,0x2F3C,0x2F3D,0x2F3E,0x2F3F,0x2F40
,0x2F41,0x2F42,0x2F43,0x2F44,0x2F45,0x2F46,0x2F47,0x2F48,0x2F49,0x2F4A,0x2F4B,0x2F4C,0x2F4D
,0x2F4E,0x2F4F,0x2F50,0x2F51,0x2F52,0x2F53,0x2F54,0x2F55,0x2F56,0x2F57,0x2F58,0x2F59,0x2F5A
,0x2F5B,0x2F5C,0x2F5D,0x2F5E,0x2F5F,0x2F60,0x2F61,0x2F62,0x2F63,0x2F64,0x2F65,0x2F66,0x2F67
,0x2F68,0x2F69,0x2F6A,0x2F6B,0x2F6C,0x2F6D,0x2F6E,0x2F6F,0x2F70,0x2F71,0x2F72,0x2F73,0x2F74
,0x2F75,0x2F76,0x2F77,0x2F78,0x2F79,0x2F7A,0x2F7B,0x2F7C,0x2F7D,0x2F7E,0x2F7F,0x2F80,0x2F81
,0x2F82,0x2F83,0x2F84,0x2F85,0x2F86,0x2F87,0x2F88,0x2F89,0x2F8A,0x2F8B,0x2F8C,0x2F8D,0x2F8E
,0x2F8F,0x2F90,0x2F91,0x2F92,0x2F93,0x2F94,0x2F95,0x2F96,0x2F97,0x2F98,0x2F99,0x2F9A,0x2F9B
,0x2F9C,0x2F9D,0x2F9E,0x2F9F,0x2FA0,0x2FA1,0x2FA2,0x2FA3,0x2FA4,0x2FA5,0x2FA6,0x2FA7,0x2FA8
,0x2FA9,0x2FAA,0x2FAB,0x2FAC,0x2FAD,0x2FAE,0x2FAF,0x2FB0,0x2FB1,0x2FB2,0x2FB3,0x2FB4,0x2FB5
,0x2FB6,0x2FB7,0x2FB8,0x2FB9,0x2FBA,0x2FBB,0x2FBC,0x2FBD,0x2FBE,0x2FBF,0x2FC0,0x2FC1,0x2FC2
,0x2FC3,0x2FC4,0x2FC5,0x2FC6,0x2FC7,0x2FC8,0x2FC9,0x2FCA,0x2FCB,0x2FCC,0x2FCD,0x2FCE,0x2FCF
,0x2FD0,0x2FD1,0x2FD2,0x2FD3,0x2FD4,0x2FD5,0x2FF0,0x2FF1,0x2FF2,0x2FF3,0x2FF4,0x2FF5,0x2FF6
,0x2FF7,0x2FF8,0x2FF9,0x2FFA,0x2FFB,0x3000,0x3001,0x3002,0x3003,0x3004,0x3008,0x3009,0x300A
,0x300B,0x300C,0x300D,0x300E,0x300F,0x3010,0x3011,0x3012,0x3013,0x3014,0x3015,0x3016,0x3017
,0x3018,0x3019,0x301A,0x301B,0x301C,0x301D,0x301E,0x301F,0x3020,0x3030,0x3036,0x3037,0x303D
,0x303E,0x303F,0x30A0,0x30FB,0x3190,0x3191,0x3192,0x3193,0x3194,0x3195,0x3196,0x3197,0x3198
,0x3199,0x319A,0x319B,0x319C,0x319D,0x319E,0x319F,0x31C0,0x31C1,0x31C2,0x31C3,0x31C4,0x31C5
,0x31C6,0x31C7,0x31C8,0x31C9,0x31CA,0x31CB,0x31CC,0x31CD,0x31CE,0x31CF,0x31D0,0x31D1,0x31D2
,0x31D3,0x31D4,0x31D5,0x31D6,0x31D7,0x31D8,0x31D9,0x31DA,0x31DB,0x31DC,0x31DD,0x31DE,0x31DF
,0x31E0,0x31E1,0x31E2,0x31E3,0x3200,0x3201,0x3202,0x3203,0x3204,0x3205,0x3206,0x3207,0x3208
,0x3209,0x320A,0x320B,0x320C,0x320D,0x320E,0x320F,0x3210,0x3211,0x3212,0x3213,0x3214,0x3215
,0x3216,0x3217,0x3218,0x3219,0x321A,0x321B,0x321C,0x321D,0x321E,0x3220,0x3221,0x3222,0x3223
,0x3224,0x3225,0x3226,0x3227,0x3228,0x3229,0x322A,0x322B,0x322C,0x322D,0x322E,0x322F,0x3230
,0x3231,0x3232,0x3233,0x3234,0x3235,0x3236,0x3237,0x3238,0x3239,0x323A,0x323B,0x323C,0x323D
,0x323E,0x323F,0x3240,0x3241,0x3242,0x3243,0x3244,0x3245,0x3246,0x3247,0x3248,0x3249,0x324A
,0x324B,0x324C,0x324D,0x324E,0x324F,0x3250,0x3251,0x3252,0x3253,0x3254,0x3255,0x3256,0x3257
,0x3258,0x3259,0x325A,0x325B,0x325C,0x325D,0x325E,0x325F,0x3260,0x3261,0x3262,0x3263,0x3264
,0x3265,0x3266,0x3267,0x3268,0x3269,0x326A,0x326B,0x326C,0x326D,0x326E,0x326F,0x3270,0x3271
,0x3272,0x3273,0x3274,0x3275,0x3276,0x3277,0x3278,0x3279,0x327A,0x327B,0x327C,0x327D,0x327E
,0x327F,0x3280,0x3281,0x3282,0x3283,0x3284,0x3285,0x3286,0x3287,0x3288,0x3289,0x328A,0x328B
,0x328C,0x328D,0x328E,0x328F,0x3290,0x3291,0x3292,0x3293,0x3294,0x3295,0x3296,0x3297,0x3298
,0x3299,0x329A,0x329B,0x329C,0x329D,0x329E,0x329F,0x32A0,0x32A1,0x32A2,0x32A3,0x32A4,0x32A5
,0x32A6,0x32A7,0x32A8,0x32A9,0x32AA,0x32AB,0x32AC,0x32AD,0x32AE,0x32AF,0x32B0,0x32B1,0x32B2
,0x32B3,0x32B4,0x32B5,0x32B6,0x32B7,0x32B8,0x32B9,0x32BA,0x32BB,0x32BC,0x32BD,0x32BE,0x32BF
,0x32C0,0x32C1,0x32C2,0x32C3,0x32C4,0x32C5,0x32C6,0x32C7,0x32C8,0x32C9,0x32CA,0x32CB,0x32CC
,0x32CD,0x32CE,0x32CF,0x32D0,0x32D1,0x32D2,0x32D3,0x32D4,0x32D5,0x32D6,0x32D7,0x32D8,0x32D9
,0x32DA,0x32DB,0x32DC,0x32DD,0x32DE,0x32DF,0x32E0,0x32E1,0x32E2,0x32E3,0x32E4,0x32E5,0x32E6
,0x32E7,0x32E8,0x32E9,0x32EA,0x32EB,0x32EC,0x32ED,0x32EE,0x32EF,0x32F0,0x32F1,0x32F2,0x32F3
,0x32F4,0x32F5,0x32F6,0x32F7,0x32F8,0x32F9,0x32FA,0x32FB,0x32FC,0x32FD,0x32FE,0x3300,0x3301
,0x3302,0x3303,0x3304,0x3305,0x3306,0x3307,0x3308,0x3309,0x330A,0x330B,0x330C,0x330D,0x330E
,0x330F,0x3310,0x3311,0x3312,0x3313,0x3314,0x3315,0x3316,0x3317,0x3318,0x3319,0x331A,0x331B
,0x331C,0x331D,0x331E,0x331F,0x3320,0x3321,0x3322,0x3323,0x3324,0x3325,0x3326,0x3327,0x3328
,0x3329,0x332A,0x332B,0x332C,0x332D,0x332E,0x332F,0x3330,0x3331,0x3332,0x3333,0x3334,0x3335
,0x3336,0x3337,0x3338,0x3339,0x333A,0x333B,0x333C,0x333D,0x333E,0x333F,0x3340,0x3341,0x3342
,0x3343,0x3344,0x3345,0x3346,0x3347,0x3348,0x3349,0x334A,0x334B,0x334C,0x334D,0x334E,0x334F
,0x3350,0x3351,0x3352,0x3353,0x3354,0x3355,0x3356,0x3357,0x3358,0x3359,0x335A,0x335B,0x335C
,0x335D,0x335E,0x335F,0x3360,0x3361,0x3362,0x3363,0x3364,0x3365,0x3366,0x3367,0x3368,0x3369
,0x336A,0x336B,0x336C,0x336D,0x336E,0x336F,0x3370,0x3371,0x3372,0x3373,0x3374,0x3375,0x3376
,0x3377,0x3378,0x3379,0x337A,0x337B,0x337C,0x337D,0x337E,0x337F,0x3380,0x3381,0x3382,0x3383
,0x3384,0x3385,0x3386,0x3387,0x3388,0x3389,0x338A,0x338B,0x338C,0x338D,0x338E,0x338F,0x3390
,0x3391,0x3392,0x3393,0x3394,0x3395,0x3396,0x3397,0x3398,0x3399,0x339A,0x339B,0x339C,0x339D
,0x339E,0x339F,0x33A0,0x33A1,0x33A2,0x33A3,0x33A4,0x33A5,0x33A6,0x33A7,0x33A8,0x33A9,0x33AA
,0x33AB,0x33AC,0x33AD,0x33AE,0x33AF,0x33B0,0x33B1,0x33B2,0x33B3,0x33B4,0x33B5,0x33B6,0x33B7
,0x33B8,0x33B9,0x33BA,0x33BB,0x33BC,0x33BD,0x33BE,0x33BF,0x33C0,0x33C1,0x33C2,0x33C3,0x33C4
,0x33C5,0x33C6,0x33C7,0x33C8,0x33C9,0x33CA,0x33CB,0x33CC,0x33CD,0x33CE,0x33CF,0x33D0,0x33D1
,0x33D2,0x33D3,0x33D4,0x33D5,0x33D6,0x33D7,0x33D8,0x33D9,0x33DA,0x33DB,0x33DC,0x33DD,0x33DE
,0x33DF,0x33E0,0x33E1,0x33E2,0x33E3,0x33E4,0x33E5,0x33E6,0x33E7,0x33E8,0x33E9,0x33EA,0x33EB
,0x33EC,0x33ED,0x33EE,0x33EF,0x33F0,0x33F1,0x33F2,0x33F3,0x33F4,0x33F5,0x33F6,0x33F7,0x33F8
,0x33F9,0x33FA,0x33FB,0x33FC,0x33FD,0x33FE,0x33FF,0x4DC0,0x4DC1,0x4DC2,0x4DC3,0x4DC4,0x4DC5
,0x4DC6,0x4DC7,0x4DC8,0x4DC9,0x4DCA,0x4DCB,0x4DCC,0x4DCD,0x4DCE,0x4DCF,0x4DD0,0x4DD1,0x4DD2
,0x4DD3,0x4DD4,0x4DD5,0x4DD6,0x4DD7,0x4DD8,0x4DD9,0x4DDA,0x4DDB,0x4DDC,0x4DDD,0x4DDE,0x4DDF
,0x4DE0,0x4DE1,0x4DE2,0x4DE3,0x4DE4,0x4DE5,0x4DE6,0x4DE7,0x4DE8,0x4DE9,0x4DEA,0x4DEB,0x4DEC
,0x4DED,0x4DEE,0x4DEF,0x4DF0,0x4DF1,0x4DF2,0x4DF3,0x4DF4,0x4DF5,0x4DF6,0x4DF7,0x4DF8,0x4DF9
,0x4DFA,0x4DFB,0x4DFC,0x4DFD,0x4DFE,0x4DFF,0xA490,0xA491,0xA492,0xA493,0xA494,0xA495,0xA496
,0xA497,0xA498,0xA499,0xA49A,0xA49B,0xA49C,0xA49D,0xA49E,0xA49F,0xA4A0,0xA4A1,0xA4A2,0xA4A3
,0xA4A4,0xA4A5,0xA4A6,0xA4A7,0xA4A8,0xA4A9,0xA4AA,0xA4AB,0xA4AC,0xA4AD,0xA4AE,0xA4AF,0xA4B0
,0xA4B1,0xA4B2,0xA4B3,0xA4B4,0xA4B5,0xA4B6,0xA4B7,0xA4B8,0xA4B9,0xA4BA,0xA4BB,0xA4BC,0xA4BD
,0xA4BE,0xA4BF,0xA4C0,0xA4C1,0xA4C2,0xA4C3,0xA4C4,0xA4C5,0xA4C6,0xA4FE,0xA4FF,0xA60D,0xA60E
,0xA60F,0xA670,0xA671,0xA672,0xA673,0xA67E,0xA6F2,0xA6F3,0xA6F4,0xA6F5,0xA6F6,0xA6F7,0xA700
,0xA701,0xA702,0xA703,0xA704,0xA705,0xA706,0xA707,0xA708,0xA709,0xA70A,0xA70B,0xA70C,0xA70D
,0xA70E,0xA70F,0xA710,0xA711,0xA712,0xA713,0xA714,0xA715,0xA716,0xA720,0xA721,0xA789,0xA78A
,0xA828,0xA829,0xA82A,0xA82B,0xA830,0xA831,0xA832,0xA833,0xA834,0xA835,0xA836,0xA837,0xA838
,0xA839,0xA874,0xA875,0xA876,0xA877,0xA8CE,0xA8CF,0xA8F8,0xA8F9,0xA8FA,0xA8FC,0xA92E,0xA92F
,0xA95F,0xA9C1,0xA9C2,0xA9C3,0xA9C4,0xA9C5,0xA9C6,0xA9C7,0xA9C8,0xA9C9,0xA9CA,0xA9CB,0xA9CC
,0xA9CD,0xA9DE,0xA9DF,0xAA5C,0xAA5D,0xAA5E,0xAA5F,0xAA77,0xAA78,0xAA79,0xAADE,0xAADF,0xAAF0
,0xAAF1,0xAB5B,0xABEB,0xFB29,0xFBB2,0xFBB3,0xFBB4,0xFBB5,0xFBB6,0xFBB7,0xFBB8,0xFBB9,0xFBBA
,0xFBBB,0xFBBC,0xFBBD,0xFBBE,0xFBBF,0xFBC0,0xFBC1,0xFD3E,0xFD3F,0xFDFC,0xFDFD,0xFE10,0xFE11
,0xFE12,0xFE13,0xFE14,0xFE15,0xFE16,0xFE17,0xFE18,0xFE19,0xFE30,0xFE31,0xFE32,0xFE35,0xFE36
,0xFE37,0xFE38,0xFE39,0xFE3A,0xFE3B,0xFE3C,0xFE3D,0xFE3E,0xFE3F,0xFE40,0xFE41,0xFE42,0xFE43
,0xFE44,0xFE45,0xFE46,0xFE47,0xFE48,0xFE49,0xFE4A,0xFE4B,0xFE4C,0xFE50,0xFE51,0xFE52,0xFE54
,0xFE55,0xFE56,0xFE57,0xFE58,0xFE59,0xFE5A,0xFE5B,0xFE5C,0xFE5D,0xFE5E,0xFE5F,0xFE60,0xFE61
,0xFE62,0xFE63,0xFE64,0xFE65,0xFE66,0xFE68,0xFE69,0xFE6A,0xFE6B,0xFEFF,0xFF01,0xFF02,0xFF03
,0xFF04,0xFF05,0xFF06,0xFF07,0xFF08,0xFF09,0xFF0A,0xFF0B,0xFF0C,0xFF0D,0xFF0E,0xFF0F,0xFF1A
,0xFF1B,0xFF1C,0xFF1D,0xFF1E,0xFF1F,0xFF20,0xFF3B,0xFF3C,0xFF3D,0xFF3E,0xFF40,0xFF5B,0xFF5C
,0xFF5D,0xFF5E,0xFF5F,0xFF60,0xFF61,0xFF62,0xFF63,0xFF64,0xFF65,0xFFE0,0xFFE1,0xFFE2,0xFFE3
,0xFFE4,0xFFE5,0xFFE6,0xFFE8,0xFFE9,0xFFEA,0xFFEB,0xFFEC,0xFFED,0xFFEE,0xFFF9,0xFFFA,0xFFFB
,0xFFFC,0xFFFD,0x10100,0x10101,0x10102,0x10107,0x10108,0x10109,0x1010A,0x1010B,0x1010C,0x1010D
,0x1010E,0x1010F,0x10110,0x10111,0x10112,0x10113,0x10114,0x10115,0x10116,0x10117,0x10118,0x10119
,0x1011A,0x1011B,0x1011C,0x1011D,0x1011E,0x1011F,0x10120,0x10121,0x10122,0x10123,0x10124,0x10125
,0x10126,0x10127,0x10128,0x10129,0x1012A,0x1012B,0x1012C,0x1012D,0x1012E,0x1012F,0x10130,0x10131
,0x10132,0x10133,0x10137,0x10138,0x10139,0x1013A,0x1013B,0x1013C,0x1013D,0x1013E,0x1013F,0x10175
,0x10176,0x10177,0x10178,0x10179,0x1017A,0x1017B,0x1017C,0x1017D,0x1017E,0x1017F,0x10180,0x10181
,0x10182,0x10183,0x10184,0x10185,0x10186,0x10187,0x10188,0x10189,0x1018A,0x1018B,0x1018C,0x1018D
,0x1018E,0x10190,0x10191,0x10192,0x10193,0x10194,0x10195,0x10196,0x10197,0x10198,0x10199,0x1019A
,0x1019B,0x101A0,0x101D0,0x101D1,0x101D2,0x101D3,0x101D4,0x101D5,0x101D6,0x101D7,0x101D8,0x101D9
,0x101DA,0x101DB,0x101DC,0x101DD,0x101DE,0x101DF,0x101E0,0x101E1,0x101E2,0x101E3,0x101E4,0x101E5
,0x101E6,0x101E7,0x101E8,0x101E9,0x101EA,0x101EB,0x101EC,0x101ED,0x101EE,0x101EF,0x101F0,0x101F1
,0x101F2,0x101F3,0x101F4,0x101F5,0x101F6,0x101F7,0x101F8,0x101F9,0x101FA,0x101FB,0x101FC,0x102E1
,0x102E2,0x102E3,0x102E4,0x102E5,0x102E6,0x102E7,0x102E8,0x102E9,0x102EA,0x102EB,0x102EC,0x102ED
,0x102EE,0x102EF,0x102F0,0x102F1,0x102F2,0x102F3,0x102F4,0x102F5,0x102F6,0x102F7,0x102F8,0x102F9
,0x102FA,0x102FB,0x10320,0x10321,0x10322,0x10323,0x1039F,0x103D0,0x1056F,0x10857,0x10858,0x10859
,0x1085A,0x1085B,0x1085C,0x1085D,0x1085E,0x1085F,0x10877,0x10878,0x10879,0x1087A,0x1087B,0x1087C
,0x1087D,0x1087E,0x1087F,0x108A7,0x108A8,0x108A9,0x108AA,0x108AB,0x108AC,0x108AD,0x108AE,0x108AF
,0x108FB,0x108FC,0x108FD,0x108FE,0x108FF,0x10916,0x10917,0x10918,0x10919,0x1091A,0x1091B,0x1091F
,0x1093F,0x109BC,0x109BD,0x109C0,0x109C1,0x109C2,0x109C3,0x109C4,0x109C5,0x109C6,0x109C7,0x109C8
,0x109C9,0x109CA,0x109CB,0x109CC,0x109CD,0x109CE,0x109CF,0x109D2,0x109D3,0x109D4,0x109D5,0x109D6
,0x109D7,0x109D8,0x109D9,0x109DA,0x109DB,0x109DC,0x109DD,0x109DE,0x109DF,0x109E0,0x109E1,0x109E2
,0x109E3,0x109E4,0x109E5,0x109E6,0x109E7,0x109E8,0x109E9,0x109EA,0x109EB,0x109EC,0x109ED,0x109EE
,0x109EF,0x109F0,0x109F1,0x109F2,0x109F3,0x109F4,0x109F5,0x109F6,0x109F7,0x109F8,0x109F9,0x109FA
,0x109FB,0x109FC,0x109FD,0x109FE,0x109FF,0x10A40,0x10A41,0x10A42,0x10A43,0x10A44,0x10A45,0x10A46
,0x10A47,0x10A50,0x10A51,0x10A52,0x10A53,0x10A54,0x10A55,0x10A56,0x10A57,0x10A58,0x10A7D,0x10A7E
,0x10A7F,0x10A9D,0x10A9E,0x10A9F,0x10AC8,0x10AEB,0x10AEC,0x10AED,0x10AEE,0x10AEF,0x10AF0,0x10AF1
,0x10AF2,0x10AF3,0x10AF4,0x10AF5,0x10AF6,0x10B39,0x10B3A,0x10B3B,0x10B3C,0x10B3D,0x10B3E,0x10B3F
,0x10B58,0x10B59,0x10B5A,0x10B5B,0x10B5C,0x10B5D,0x10B5E,0x10B5F,0x10B78,0x10B79,0x10B7A,0x10B7B
,0x10B7C,0x10B7D,0x10B7E,0x10B7F,0x10B99,0x10B9A,0x10B9B,0x10B9C,0x10BA9,0x10BAA,0x10BAB,0x10BAC
,0x10BAD,0x10BAE,0x10BAF,0x10CFA,0x10CFB,0x10CFC,0x10CFD,0x10CFE,0x10CFF,0x10E60,0x10E61,0x10E62
,0x10E63,0x10E64,0x10E65,0x10E66,0x10E67,0x10E68,0x10E69,0x10E6A,0x10E6B,0x10E6C,0x10E6D,0x10E6E
,0x10E6F,0x10E70,0x10E71,0x10E72,0x10E73,0x10E74,0x10E75,0x10E76,0x10E77,0x10E78,0x10E79,0x10E7A
,0x10E7B,0x10E7C,0x10E7D,0x10E7E,0x11047,0x11048,0x11049,0x1104A,0x1104B,0x1104C,0x1104D,0x11052
,0x11053,0x11054,0x11055,0x11056,0x11057,0x11058,0x11059,0x1105A,0x1105B,0x1105C,0x1105D,0x1105E
,0x1105F,0x11060,0x11061,0x11062,0x11063,0x11064,0x11065,0x110BB,0x110BC,0x110BD,0x110BE,0x110BF
,0x110C0,0x110C1,0x11140,0x11141,0x11142,0x11143,0x11174,0x11175,0x111C5,0x111C6,0x111C7,0x111C8
,0x111C9,0x111CD,0x111DB,0x111DD,0x111DE,0x111DF,0x111E1,0x111E2,0x111E3,0x111E4,0x111E5,0x111E6
,0x111E7,0x111E8,0x111E9,0x111EA,0x111EB,0x111EC,0x111ED,0x111EE,0x111EF,0x111F0,0x111F1,0x111F2
,0x111F3,0x111F4,0x11238,0x11239,0x1123A,0x1123B,0x1123C,0x1123D,0x112A9,0x1144B,0x1144C,0x1144D
,0x1144E,0x1144F,0x1145B,0x1145D,0x114C6,0x115C1,0x115C2,0x115C3,0x115C4,0x115C5,0x115C6,0x115C7
,0x115C8,0x115C9,0x115CA,0x115CB,0x115CC,0x115CD,0x115CE,0x115CF,0x115D0,0x115D1,0x115D2,0x115D3
,0x115D4,0x115D5,0x115D6,0x115D7,0x11641,0x11642,0x11643,0x11660,0x11661,0x11662,0x11663,0x11664
,0x11665,0x11666,0x11667,0x11668,0x11669,0x1166A,0x1166B,0x1166C,0x1173A,0x1173B,0x1173C,0x1173D
,0x1173E,0x1173F,0x118EA,0x118EB,0x118EC,0x118ED,0x118EE,0x118EF,0x118F0,0x118F1,0x118F2,0x11A3F
,0x11A40,0x11A41,0x11A42,0x11A43,0x11A44,0x11A45,0x11A46,0x11A9A,0x11A9B,0x11A9C,0x11A9E,0x11A9F
,0x11AA0,0x11AA1,0x11AA2,0x11C41,0x11C42,0x11C43,0x11C44,0x11C45,0x11C5A,0x11C5B,0x11C5C,0x11C5D
,0x11C5E,0x11C5F,0x11C60,0x11C61,0x11C62,0x11C63,0x11C64,0x11C65,0x11C66,0x11C67,0x11C68,0x11C69
,0x11C6A,0x11C6B,0x11C6C,0x11C70,0x11C71,0x12470,0x12471,0x12472,0x12473,0x12474,0x16A6E,0x16A6F
,0x16AF5,0x16B37,0x16B38,0x16B39,0x16B3A,0x16B3B,0x16B3C,0x16B3D,0x16B3E,0x16B3F,0x16B44,0x16B45
,0x16B5B,0x16B5C,0x16B5D,0x16B5E,0x16B5F,0x16B60,0x16B61,0x1BC9C,0x1BC9F,0x1BCA0,0x1BCA1,0x1BCA2
,0x1BCA3,0x1D000,0x1D001,0x1D002,0x1D003,0x1D004,0x1D005,0x1D006,0x1D007,0x1D008,0x1D009,0x1D00A
,0x1D00B,0x1D00C,0x1D00D,0x1D00E,0x1D00F,0x1D010,0x1D011,0x1D012,0x1D013,0x1D014,0x1D015,0x1D016
,0x1D017,0x1D018,0x1D019,0x1D01A,0x1D01B,0x1D01C,0x1D01D,0x1D01E,0x1D01F,0x1D020,0x1D021,0x1D022
,0x1D023,0x1D024,0x1D025,0x1D026,0x1D027,0x1D028,0x1D029,0x1D02A,0x1D02B,0x1D02C,0x1D02D,0x1D02E
,0x1D02F,0x1D030,0x1D031,0x1D032,0x1D033,0x1D034,0x1D035,0x1D036,0x1D037,0x1D038,0x1D039,0x1D03A
,0x1D03B,0x1D03C,0x1D03D,0x1D03E,0x1D03F,0x1D040,0x1D041,0x1D042,0x1D043,0x1D044,0x1D045,0x1D046
,0x1D047,0x1D048,0x1D049,0x1D04A,0x1D04B,0x1D04C,0x1D04D,0x1D04E,0x1D04F,0x1D050,0x1D051,0x1D052
,0x1D053,0x1D054,0x1D055,0x1D056,0x1D057,0x1D058,0x1D059,0x1D05A,0x1D05B,0x1D05C,0x1D05D,0x1D05E
,0x1D05F,0x1D060,0x1D061,0x1D062,0x1D063,0x1D064,0x1D065,0x1D066,0x1D067,0x1D068,0x1D069,0x1D06A
,0x1D06B,0x1D06C,0x1D06D,0x1D06E,0x1D06F,0x1D070,0x1D071,0x1D072,0x1D073,0x1D074,0x1D075,0x1D076
,0x1D077,0x1D078,0x1D079,0x1D07A,0x1D07B,0x1D07C,0x1D07D,0x1D07E,0x1D07F,0x1D080,0x1D081,0x1D082
,0x1D083,0x1D084,0x1D085,0x1D086,0x1D087,0x1D088,0x1D089,0x1D08A,0x1D08B,0x1D08C,0x1D08D,0x1D08E
,0x1D08F,0x1D090,0x1D091,0x1D092,0x1D093,0x1D094,0x1D095,0x1D096,0x1D097,0x1D098,0x1D099,0x1D09A
,0x1D09B,0x1D09C,0x1D09D,0x1D09E,0x1D09F,0x1D0A0,0x1D0A1,0x1D0A2,0x1D0A3,0x1D0A4,0x1D0A5,0x1D0A6
,0x1D0A7,0x1D0A8,0x1D0A9,0x1D0AA,0x1D0AB,0x1D0AC,0x1D0AD,0x1D0AE,0x1D0AF,0x1D0B0,0x1D0B1,0x1D0B2
,0x1D0B3,0x1D0B4,0x1D0B5,0x1D0B6,0x1D0B7,0x1D0B8,0x1D0B9,0x1D0BA,0x1D0BB,0x1D0BC,0x1D0BD,0x1D0BE
,0x1D0BF,0x1D0C0,0x1D0C1,0x1D0C2,0x1D0C3,0x1D0C4,0x1D0C5,0x1D0C6,0x1D0C7,0x1D0C8,0x1D0C9,0x1D0CA
,0x1D0CB,0x1D0CC,0x1D0CD,0x1D0CE,0x1D0CF,0x1D0D0,0x1D0D1,0x1D0D2,0x1D0D3,0x1D0D4,0x1D0D5,0x1D0D6
,0x1D0D7,0x1D0D8,0x1D0D9,0x1D0DA,0x1D0DB,0x1D0DC,0x1D0DD,0x1D0DE,0x1D0DF,0x1D0E0,0x1D0E1,0x1D0E2
,0x1D0E3,0x1D0E4,0x1D0E5,0x1D0E6,0x1D0E7,0x1D0E8,0x1D0E9,0x1D0EA,0x1D0EB,0x1D0EC,0x1D0ED,0x1D0EE
,0x1D0EF,0x1D0F0,0x1D0F1,0x1D0F2,0x1D0F3,0x1D0F4,0x1D0F5,0x1D100,0x1D101,0x1D102,0x1D103,0x1D104
,0x1D105,0x1D106,0x1D107,0x1D108,0x1D109,0x1D10A,0x1D10B,0x1D10C,0x1D10D,0x1D10E,0x1D10F,0x1D110
,0x1D111,0x1D112,0x1D113,0x1D114,0x1D115,0x1D116,0x1D117,0x1D118,0x1D119,0x1D11A,0x1D11B,0x1D11C
,0x1D11D,0x1D11E,0x1D11F,0x1D120,0x1D121,0x1D122,0x1D123,0x1D124,0x1D125,0x1D126,0x1D129,0x1D12A
,0x1D12B,0x1D12C,0x1D12D,0x1D12E,0x1D12F,0x1D130,0x1D131,0x1D132,0x1D133,0x1D134,0x1D135,0x1D136
,0x1D137,0x1D138,0x1D139,0x1D13A,0x1D13B,0x1D13C,0x1D13D,0x1D13E,0x1D13F,0x1D140,0x1D141,0x1D142
,0x1D143,0x1D144,0x1D145,0x1D146,0x1D147,0x1D148,0x1D149,0x1D14A,0x1D14B,0x1D14C,0x1D14D,0x1D14E
,0x1D14F,0x1D150,0x1D151,0x1D152,0x1D153,0x1D154,0x1D155,0x1D156,0x1D157,0x1D158,0x1D159,0x1D15A
,0x1D15B,0x1D15C,0x1D15D,0x1D15E,0x1D15F,0x1D160,0x1D161,0x1D162,0x1D163,0x1D164,0x1D16A,0x1D16B
,0x1D16C,0x1D173,0x1D174,0x1D175,0x1D176,0x1D177,0x1D178,0x1D179,0x1D17A,0x1D183,0x1D184,0x1D18C
,0x1D18D,0x1D18E,0x1D18F,0x1D190,0x1D191,0x1D192,0x1D193,0x1D194,0x1D195,0x1D196,0x1D197,0x1D198
,0x1D199,0x1D19A,0x1D19B,0x1D19C,0x1D19D,0x1D19E,0x1D19F,0x1D1A0,0x1D1A1,0x1D1A2,0x1D1A3,0x1D1A4
,0x1D1A5,0x1D1A6,0x1D1A7,0x1D1A8,0x1D1A9,0x1D1AE,0x1D1AF,0x1D1B0,0x1D1B1,0x1D1B2,0x1D1B3,0x1D1B4
,0x1D1B5,0x1D1B6,0x1D1B7,0x1D1B8,0x1D1B9,0x1D1BA,0x1D1BB,0x1D1BC,0x1D1BD,0x1D1BE,0x1D1BF,0x1D1C0
,0x1D1C1,0x1D1C2,0x1D1C3,0x1D1C4,0x1D1C5,0x1D1C6,0x1D1C7,0x1D1C8,0x1D1C9,0x1D1CA,0x1D1CB,0x1D1CC
,0x1D1CD,0x1D1CE,0x1D1CF,0x1D1D0,0x1D1D1,0x1D1D2,0x1D1D3,0x1D1D4,0x1D1D5,0x1D1D6,0x1D1D7,0x1D1D8
,0x1D1D9,0x1D1DA,0x1D1DB,0x1D1DC,0x1D1DD,0x1D1DE,0x1D1DF,0x1D1E0,0x1D1E1,0x1D1E2,0x1D1E3,0x1D1E4
,0x1D1E5,0x1D1E6,0x1D1E7,0x1D1E8,0x1D200,0x1D201,0x1D202,0x1D203,0x1D204,0x1D205,0x1D206,0x1D207
,0x1D208,0x1D209,0x1D20A,0x1D20B,0x1D20C,0x1D20D,0x1D20E,0x1D20F,0x1D210,0x1D211,0x1D212,0x1D213
,0x1D214,0x1D215,0x1D216,0x1D217,0x1D218,0x1D219,0x1D21A,0x1D21B,0x1D21C,0x1D21D,0x1D21E,0x1D21F
,0x1D220,0x1D221,0x1D222,0x1D223,0x1D224,0x1D225,0x1D226,0x1D227,0x1D228,0x1D229,0x1D22A,0x1D22B
,0x1D22C,0x1D22D,0x1D22E,0x1D22F,0x1D230,0x1D231,0x1D232,0x1D233,0x1D234,0x1D235,0x1D236,0x1D237
,0x1D238,0x1D239,0x1D23A,0x1D23B,0x1D23C,0x1D23D,0x1D23E,0x1D23F,0x1D240,0x1D241,0x1D245,0x1D300
,0x1D301,0x1D302,0x1D303,0x1D304,0x1D305,0x1D306,0x1D307,0x1D308,0x1D309,0x1D30A,0x1D30B,0x1D30C
,0x1D30D,0x1D30E,0x1D30F,0x1D310,0x1D311,0x1D312,0x1D313,0x1D314,0x1D315,0x1D316,0x1D317,0x1D318
,0x1D319,0x1D31A,0x1D31B,0x1D31C,0x1D31D,0x1D31E,0x1D31F,0x1D320,0x1D321,0x1D322,0x1D323,0x1D324
,0x1D325,0x1D326,0x1D327,0x1D328,0x1D329,0x1D32A,0x1D32B,0x1D32C,0x1D32D,0x1D32E,0x1D32F,0x1D330
,0x1D331,0x1D332,0x1D333,0x1D334,0x1D335,0x1D336,0x1D337,0x1D338,0x1D339,0x1D33A,0x1D33B,0x1D33C
,0x1D33D,0x1D33E,0x1D33F,0x1D340,0x1D341,0x1D342,0x1D343,0x1D344,0x1D345,0x1D346,0x1D347,0x1D348
,0x1D349,0x1D34A,0x1D34B,0x1D34C,0x1D34D,0x1D34E,0x1D34F,0x1D350,0x1D351,0x1D352,0x1D353,0x1D354
,0x1D355,0x1D356,0x1D360,0x1D361,0x1D362,0x1D363,0x1D364,0x1D365,0x1D366,0x1D367,0x1D368,0x1D369
,0x1D36A,0x1D36B,0x1D36C,0x1D36D,0x1D36E,0x1D36F,0x1D370,0x1D371,0x1D6C1,0x1D6DB,0x1D6FB,0x1D715
,0x1D735,0x1D74F,0x1D76F,0x1D789,0x1D7A9,0x1D7C3,0x1D800,0x1D801,0x1D802,0x1D803,0x1D804,0x1D805
,0x1D806,0x1D807,0x1D808,0x1D809,0x1D80A,0x1D80B,0x1D80C,0x1D80D,0x1D80E,0x1D80F,0x1D810,0x1D811
,0x1D812,0x1D813,0x1D814,0x1D815,0x1D816,0x1D817,0x1D818,0x1D819,0x1D81A,0x1D81B,0x1D81C,0x1D81D
,0x1D81E,0x1D81F,0x1D820,0x1D821,0x1D822,0x1D823,0x1D824,0x1D825,0x1D826,0x1D827,0x1D828,0x1D829
,0x1D82A,0x1D82B,0x1D82C,0x1D82D,0x1D82E,0x1D82F,0x1D830,0x1D831,0x1D832,0x1D833,0x1D834,0x1D835
,0x1D836,0x1D837,0x1D838,0x1D839,0x1D83A,0x1D83B,0x1D83C,0x1D83D,0x1D83E,0x1D83F,0x1D840,0x1D841
,0x1D842,0x1D843,0x1D844,0x1D845,0x1D846,0x1D847,0x1D848,0x1D849,0x1D84A,0x1D84B,0x1D84C,0x1D84D
,0x1D84E,0x1D84F,0x1D850,0x1D851,0x1D852,0x1D853,0x1D854,0x1D855,0x1D856,0x1D857,0x1D858,0x1D859
,0x1D85A,0x1D85B,0x1D85C,0x1D85D,0x1D85E,0x1D85F,0x1D860,0x1D861,0x1D862,0x1D863,0x1D864,0x1D865
,0x1D866,0x1D867,0x1D868,0x1D869,0x1D86A,0x1D86B,0x1D86C,0x1D86D,0x1D86E,0x1D86F,0x1D870,0x1D871
,0x1D872,0x1D873,0x1D874,0x1D875,0x1D876,0x1D877,0x1D878,0x1D879,0x1D87A,0x1D87B,0x1D87C,0x1D87D
,0x1D87E,0x1D87F,0x1D880,0x1D881,0x1D882,0x1D883,0x1D884,0x1D885,0x1D886,0x1D887,0x1D888,0x1D889
,0x1D88A,0x1D88B,0x1D88C,0x1D88D,0x1D88E,0x1D88F,0x1D890,0x1D891,0x1D892,0x1D893,0x1D894,0x1D895
,0x1D896,0x1D897,0x1D898,0x1D899,0x1D89A,0x1D89B,0x1D89C,0x1D89D,0x1D89E,0x1D89F,0x1D8A0,0x1D8A1
,0x1D8A2,0x1D8A3,0x1D8A4,0x1D8A5,0x1D8A6,0x1D8A7,0x1D8A8,0x1D8A9,0x1D8AA,0x1D8AB,0x1D8AC,0x1D8AD
,0x1D8AE,0x1D8AF,0x1D8B0,0x1D8B1,0x1D8B2,0x1D8B3,0x1D8B4,0x1D8B5,0x1D8B6,0x1D8B7,0x1D8B8,0x1D8B9
,0x1D8BA,0x1D8BB,0x1D8BC,0x1D8BD,0x1D8BE,0x1D8BF,0x1D8C0,0x1D8C1,0x1D8C2,0x1D8C3,0x1D8C4,0x1D8C5
,0x1D8C6,0x1D8C7,0x1D8C8,0x1D8C9,0x1D8CA,0x1D8CB,0x1D8CC,0x1D8CD,0x1D8CE,0x1D8CF,0x1D8D0,0x1D8D1
,0x1D8D2,0x1D8D3,0x1D8D4,0x1D8D5,0x1D8D6,0x1D8D7,0x1D8D8,0x1D8D9,0x1D8DA,0x1D8DB,0x1D8DC,0x1D8DD
,0x1D8DE,0x1D8DF,0x1D8E0,0x1D8E1,0x1D8E2,0x1D8E3,0x1D8E4,0x1D8E5,0x1D8E6,0x1D8E7,0x1D8E8,0x1D8E9
,0x1D8EA,0x1D8EB,0x1D8EC,0x1D8ED,0x1D8EE,0x1D8EF,0x1D8F0,0x1D8F1,0x1D8F2,0x1D8F3,0x1D8F4,0x1D8F5
,0x1D8F6,0x1D8F7,0x1D8F8,0x1D8F9,0x1D8FA,0x1D8FB,0x1D8FC,0x1D8FD,0x1D8FE,0x1D8FF,0x1D900,0x1D901
,0x1D902,0x1D903,0x1D904,0x1D905,0x1D906,0x1D907,0x1D908,0x1D909,0x1D90A,0x1D90B,0x1D90C,0x1D90D
,0x1D90E,0x1D90F,0x1D910,0x1D911,0x1D912,0x1D913,0x1D914,0x1D915,0x1D916,0x1D917,0x1D918,0x1D919
,0x1D91A,0x1D91B,0x1D91C,0x1D91D,0x1D91E,0x1D91F,0x1D920,0x1D921,0x1D922,0x1D923,0x1D924,0x1D925
,0x1D926,0x1D927,0x1D928,0x1D929,0x1D92A,0x1D92B,0x1D92C,0x1D92D,0x1D92E,0x1D92F,0x1D930,0x1D931
,0x1D932,0x1D933,0x1D934,0x1D935,0x1D936,0x1D937,0x1D938,0x1D939,0x1D93A,0x1D93B,0x1D93C,0x1D93D
,0x1D93E,0x1D93F,0x1D940,0x1D941,0x1D942,0x1D943,0x1D944,0x1D945,0x1D946,0x1D947,0x1D948,0x1D949
,0x1D94A,0x1D94B,0x1D94C,0x1D94D,0x1D94E,0x1D94F,0x1D950,0x1D951,0x1D952,0x1D953,0x1D954,0x1D955
,0x1D956,0x1D957,0x1D958,0x1D959,0x1D95A,0x1D95B,0x1D95C,0x1D95D,0x1D95E,0x1D95F,0x1D960,0x1D961
,0x1D962,0x1D963,0x1D964,0x1D965,0x1D966,0x1D967,0x1D968,0x1D969,0x1D96A,0x1D96B,0x1D96C,0x1D96D
,0x1D96E,0x1D96F,0x1D970,0x1D971,0x1D972,0x1D973,0x1D974,0x1D975,0x1D976,0x1D977,0x1D978,0x1D979
,0x1D97A,0x1D97B,0x1D97C,0x1D97D,0x1D97E,0x1D97F,0x1D980,0x1D981,0x1D982,0x1D983,0x1D984,0x1D985
,0x1D986,0x1D987,0x1D988,0x1D989,0x1D98A,0x1D98B,0x1D98C,0x1D98D,0x1D98E,0x1D98F,0x1D990,0x1D991
,0x1D992,0x1D993,0x1D994,0x1D995,0x1D996,0x1D997,0x1D998,0x1D999,0x1D99A,0x1D99B,0x1D99C,0x1D99D
,0x1D99E,0x1D99F,0x1D9A0,0x1D9A1,0x1D9A2,0x1D9A3,0x1D9A4,0x1D9A5,0x1D9A6,0x1D9A7,0x1D9A8,0x1D9A9
,0x1D9AA,0x1D9AB,0x1D9AC,0x1D9AD,0x1D9AE,0x1D9AF,0x1D9B0,0x1D9B1,0x1D9B2,0x1D9B3,0x1D9B4,0x1D9B5
,0x1D9B6,0x1D9B7,0x1D9B8,0x1D9B9,0x1D9BA,0x1D9BB,0x1D9BC,0x1D9BD,0x1D9BE,0x1D9BF,0x1D9C0,0x1D9C1
,0x1D9C2,0x1D9C3,0x1D9C4,0x1D9C5,0x1D9C6,0x1D9C7,0x1D9C8,0x1D9C9,0x1D9CA,0x1D9CB,0x1D9CC,0x1D9CD
,0x1D9CE,0x1D9CF,0x1D9D0,0x1D9D1,0x1D9D2,0x1D9D3,0x1D9D4,0x1D9D5,0x1D9D6,0x1D9D7,0x1D9D8,0x1D9D9
,0x1D9DA,0x1D9DB,0x1D9DC,0x1D9DD,0x1D9DE,0x1D9DF,0x1D9E0,0x1D9E1,0x1D9E2,0x1D9E3,0x1D9E4,0x1D9E5
,0x1D9E6,0x1D9E7,0x1D9E8,0x1D9E9,0x1D9EA,0x1D9EB,0x1D9EC,0x1D9ED,0x1D9EE,0x1D9EF,0x1D9F0,0x1D9F1
,0x1D9F2,0x1D9F3,0x1D9F4,0x1D9F5,0x1D9F6,0x1D9F7,0x1D9F8,0x1D9F9,0x1D9FA,0x1D9FB,0x1D9FC,0x1D9FD
,0x1D9FE,0x1D9FF,0x1DA37,0x1DA38,0x1DA39,0x1DA3A,0x1DA6D,0x1DA6E,0x1DA6F,0x1DA70,0x1DA71,0x1DA72
,0x1DA73,0x1DA74,0x1DA76,0x1DA77,0x1DA78,0x1DA79,0x1DA7A,0x1DA7B,0x1DA7C,0x1DA7D,0x1DA7E,0x1DA7F
,0x1DA80,0x1DA81,0x1DA82,0x1DA83,0x1DA85,0x1DA86,0x1DA87,0x1DA88,0x1DA89,0x1DA8A,0x1DA8B,0x1E8C7
,0x1E8C8,0x1E8C9,0x1E8CA,0x1E8CB,0x1E8CC,0x1E8CD,0x1E8CE,0x1E8CF,0x1E95E,0x1E95F,0x1EEF0,0x1EEF1
,0x1F000,0x1F001,0x1F002,0x1F003,0x1F004,0x1F005,0x1F006,0x1F007,0x1F008,0x1F009,0x1F00A,0x1F00B
,0x1F00C,0x1F00D,0x1F00E,0x1F00F,0x1F010,0x1F011,0x1F012,0x1F013,0x1F014,0x1F015,0x1F016,0x1F017
,0x1F018,0x1F019,0x1F01A,0x1F01B,0x1F01C,0x1F01D,0x1F01E,0x1F01F,0x1F020,0x1F021,0x1F022,0x1F023
,0x1F024,0x1F025,0x1F026,0x1F027,0x1F028,0x1F029,0x1F02A,0x1F02B,0x1F030,0x1F031,0x1F032,0x1F033
,0x1F034,0x1F035,0x1F036,0x1F037,0x1F038,0x1F039,0x1F03A,0x1F03B,0x1F03C,0x1F03D,0x1F03E,0x1F03F
,0x1F040,0x1F041,0x1F042,0x1F043,0x1F044,0x1F045,0x1F046,0x1F047,0x1F048,0x1F049,0x1F04A,0x1F04B
,0x1F04C,0x1F04D,0x1F04E,0x1F04F,0x1F050,0x1F051,0x1F052,0x1F053,0x1F054,0x1F055,0x1F056,0x1F057
,0x1F058,0x1F059,0x1F05A,0x1F05B,0x1F05C,0x1F05D,0x1F05E,0x1F05F,0x1F060,0x1F061,0x1F062,0x1F063
,0x1F064,0x1F065,0x1F066,0x1F067,0x1F068,0x1F069,0x1F06A,0x1F06B,0x1F06C,0x1F06D,0x1F06E,0x1F06F
,0x1F070,0x1F071,0x1F072,0x1F073,0x1F074,0x1F075,0x1F076,0x1F077,0x1F078,0x1F079,0x1F07A,0x1F07B
,0x1F07C,0x1F07D,0x1F07E,0x1F07F,0x1F080,0x1F081,0x1F082,0x1F083,0x1F084,0x1F085,0x1F086,0x1F087
,0x1F088,0x1F089,0x1F08A,0x1F08B,0x1F08C,0x1F08D,0x1F08E,0x1F08F,0x1F090,0x1F091,0x1F092,0x1F093
,0x1F0A0,0x1F0A1,0x1F0A2,0x1F0A3,0x1F0A4,0x1F0A5,0x1F0A6,0x1F0A7,0x1F0A8,0x1F0A9,0x1F0AA,0x1F0AB
,0x1F0AC,0x1F0AD,0x1F0AE,0x1F0B1,0x1F0B2,0x1F0B3,0x1F0B4,0x1F0B5,0x1F0B6,0x1F0B7,0x1F0B8,0x1F0B9
,0x1F0BA,0x1F0BB,0x1F0BC,0x1F0BD,0x1F0BE,0x1F0BF,0x1F0C1,0x1F0C2,0x1F0C3,0x1F0C4,0x1F0C5,0x1F0C6
,0x1F0C7,0x1F0C8,0x1F0C9,0x1F0CA,0x1F0CB,0x1F0CC,0x1F0CD,0x1F0CE,0x1F0CF,0x1F0D1,0x1F0D2,0x1F0D3
,0x1F0D4,0x1F0D5,0x1F0D6,0x1F0D7,0x1F0D8,0x1F0D9,0x1F0DA,0x1F0DB,0x1F0DC,0x1F0DD,0x1F0DE,0x1F0DF
,0x1F0E0,0x1F0E1,0x1F0E2,0x1F0E3,0x1F0E4,0x1F0E5,0x1F0E6,0x1F0E7,0x1F0E8,0x1F0E9,0x1F0EA,0x1F0EB
,0x1F0EC,0x1F0ED,0x1F0EE,0x1F0EF,0x1F0F0,0x1F0F1,0x1F0F2,0x1F0F3,0x1F0F4,0x1F0F5,0x1F100,0x1F101
,0x1F102,0x1F103,0x1F104,0x1F105,0x1F106,0x1F107,0x1F108,0x1F109,0x1F10A,0x1F10B,0x1F10C,0x1F110
,0x1F111,0x1F112,0x1F113,0x1F114,0x1F115,0x1F116,0x1F117,0x1F118,0x1F119,0x1F11A,0x1F11B,0x1F11C
,0x1F11D,0x1F11E,0x1F11F,0x1F120,0x1F121,0x1F122,0x1F123,0x1F124,0x1F125,0x1F126,0x1F127,0x1F128
,0x1F129,0x1F12A,0x1F12B,0x1F12C,0x1F12D,0x1F12E,0x1F130,0x1F131,0x1F132,0x1F133,0x1F134,0x1F135
,0x1F136,0x1F137,0x1F138,0x1F139,0x1F13A,0x1F13B,0x1F13C,0x1F13D,0x1F13E,0x1F13F,0x1F140,0x1F141
,0x1F142,0x1F143,0x1F144,0x1F145,0x1F146,0x1F147,0x1F148,0x1F149,0x1F14A,0x1F14B,0x1F14C,0x1F14D
,0x1F14E,0x1F14F,0x1F150,0x1F151,0x1F152,0x1F153,0x1F154,0x1F155,0x1F156,0x1F157,0x1F158,0x1F159
,0x1F15A,0x1F15B,0x1F15C,0x1F15D,0x1F15E,0x1F15F,0x1F160,0x1F161,0x1F162,0x1F163,0x1F164,0x1F165
,0x1F166,0x1F167,0x1F168,0x1F169,0x1F16A,0x1F16B,0x1F170,0x1F171,0x1F172,0x1F173,0x1F174,0x1F175
,0x1F176,0x1F177,0x1F178,0x1F179,0x1F17A,0x1F17B,0x1F17C,0x1F17D,0x1F17E,0x1F17F,0x1F180,0x1F181
,0x1F182,0x1F183,0x1F184,0x1F185,0x1F186,0x1F187,0x1F188,0x1F189,0x1F18A,0x1F18B,0x1F18C,0x1F18D
,0x1F18E,0x1F18F,0x1F190,0x1F191,0x1F192,0x1F193,0x1F194,0x1F195,0x1F196,0x1F197,0x1F198,0x1F199
,0x1F19A,0x1F19B,0x1F19C,0x1F19D,0x1F19E,0x1F19F,0x1F1A0,0x1F1A1,0x1F1A2,0x1F1A3,0x1F1A4,0x1F1A5
,0x1F1A6,0x1F1A7,0x1F1A8,0x1F1A9,0x1F1AA,0x1F1AB,0x1F1AC,0x1F1E6,0x1F1E7,0x1F1E8,0x1F1E9,0x1F1EA
,0x1F1EB,0x1F1EC,0x1F1ED,0x1F1EE,0x1F1EF,0x1F1F0,0x1F1F1,0x1F1F2,0x1F1F3,0x1F1F4,0x1F1F5,0x1F1F6
,0x1F1F7,0x1F1F8,0x1F1F9,0x1F1FA,0x1F1FB,0x1F1FC,0x1F1FD,0x1F1FE,0x1F1FF,0x1F200,0x1F201,0x1F202
,0x1F210,0x1F211,0x1F212,0x1F213,0x1F214,0x1F215,0x1F216,0x1F217,0x1F218,0x1F219,0x1F21A,0x1F21B
,0x1F21C,0x1F21D,0x1F21E,0x1F21F,0x1F220,0x1F221,0x1F222,0x1F223,0x1F224,0x1F225,0x1F226,0x1F227
,0x1F228,0x1F229,0x1F22A,0x1F22B,0x1F22C,0x1F22D,0x1F22E,0x1F22F,0x1F230,0x1F231,0x1F232,0x1F233
,0x1F234,0x1F235,0x1F236,0x1F237,0x1F238,0x1F239,0x1F23A,0x1F23B,0x1F240,0x1F241,0x1F242,0x1F243
,0x1F244,0x1F245,0x1F246,0x1F247,0x1F248,0x1F250,0x1F251,0x1F260,0x1F261,0x1F262,0x1F263,0x1F264
,0x1F265,0x1F300,0x1F301,0x1F302,0x1F303,0x1F304,0x1F305,0x1F306,0x1F307,0x1F308,0x1F309,0x1F30A
,0x1F30B,0x1F30C,0x1F30D,0x1F30E,0x1F30F,0x1F310,0x1F311,0x1F312,0x1F313,0x1F314,0x1F315,0x1F316
,0x1F317,0x1F318,0x1F319,0x1F31A,0x1F31B,0x1F31C,0x1F31D,0x1F31E,0x1F31F,0x1F320,0x1F321,0x1F322
,0x1F323,0x1F324,0x1F325,0x1F326,0x1F327,0x1F328,0x1F329,0x1F32A,0x1F32B,0x1F32C,0x1F32D,0x1F32E
,0x1F32F,0x1F330,0x1F331,0x1F332,0x1F333,0x1F334,0x1F335,0x1F336,0x1F337,0x1F338,0x1F339,0x1F33A
,0x1F33B,0x1F33C,0x1F33D,0x1F33E,0x1F33F,0x1F340,0x1F341,0x1F342,0x1F343,0x1F344,0x1F345,0x1F346
,0x1F347,0x1F348,0x1F349,0x1F34A,0x1F34B,0x1F34C,0x1F34D,0x1F34E,0x1F34F,0x1F350,0x1F351,0x1F352
,0x1F353,0x1F354,0x1F355,0x1F356,0x1F357,0x1F358,0x1F359,0x1F35A,0x1F35B,0x1F35C,0x1F35D,0x1F35E
,0x1F35F,0x1F360,0x1F361,0x1F362,0x1F363,0x1F364,0x1F365,0x1F366,0x1F367,0x1F368,0x1F369,0x1F36A
,0x1F36B,0x1F36C,0x1F36D,0x1F36E,0x1F36F,0x1F370,0x1F371,0x1F372,0x1F373,0x1F374,0x1F375,0x1F376
,0x1F377,0x1F378,0x1F379,0x1F37A,0x1F37B,0x1F37C,0x1F37D,0x1F37E,0x1F37F,0x1F380,0x1F381,0x1F382
,0x1F383,0x1F384,0x1F385,0x1F386,0x1F387,0x1F388,0x1F389,0x1F38A,0x1F38B,0x1F38C,0x1F38D,0x1F38E
,0x1F38F,0x1F390,0x1F391,0x1F392,0x1F393,0x1F394,0x1F395,0x1F396,0x1F397,0x1F398,0x1F399,0x1F39A
,0x1F39B,0x1F39C,0x1F39D,0x1F39E,0x1F39F,0x1F3A0,0x1F3A1,0x1F3A2,0x1F3A3,0x1F3A4,0x1F3A5,0x1F3A6
,0x1F3A7,0x1F3A8,0x1F3A9,0x1F3AA,0x1F3AB,0x1F3AC,0x1F3AD,0x1F3AE,0x1F3AF,0x1F3B0,0x1F3B1,0x1F3B2
,0x1F3B3,0x1F3B4,0x1F3B5,0x1F3B6,0x1F3B7,0x1F3B8,0x1F3B9,0x1F3BA,0x1F3BB,0x1F3BC,0x1F3BD,0x1F3BE
,0x1F3BF,0x1F3C0,0x1F3C1,0x1F3C2,0x1F3C3,0x1F3C4,0x1F3C5,0x1F3C6,0x1F3C7,0x1F3C8,0x1F3C9,0x1F3CA
,0x1F3CB,0x1F3CC,0x1F3CD,0x1F3CE,0x1F3CF,0x1F3D0,0x1F3D1,0x1F3D2,0x1F3D3,0x1F3D4,0x1F3D5,0x1F3D6
,0x1F3D7,0x1F3D8,0x1F3D9,0x1F3DA,0x1F3DB,0x1F3DC,0x1F3DD,0x1F3DE,0x1F3DF,0x1F3E0,0x1F3E1,0x1F3E2
,0x1F3E3,0x1F3E4,0x1F3E5,0x1F3E6,0x1F3E7,0x1F3E8,0x1F3E9,0x1F3EA,0x1F3EB,0x1F3EC,0x1F3ED,0x1F3EE
,0x1F3EF,0x1F3F0,0x1F3F1,0x1F3F2,0x1F3F3,0x1F3F4,0x1F3F5,0x1F3F6,0x1F3F7,0x1F3F8,0x1F3F9,0x1F3FA
,0x1F3FB,0x1F3FC,0x1F3FD,0x1F3FE,0x1F3FF,0x1F400,0x1F401,0x1F402,0x1F403,0x1F404,0x1F405,0x1F406
,0x1F407,0x1F408,0x1F409,0x1F40A,0x1F40B,0x1F40C,0x1F40D,0x1F40E,0x1F40F,0x1F410,0x1F411,0x1F412
,0x1F413,0x1F414,0x1F415,0x1F416,0x1F417,0x1F418,0x1F419,0x1F41A,0x1F41B,0x1F41C,0x1F41D,0x1F41E
,0x1F41F,0x1F420,0x1F421,0x1F422,0x1F423,0x1F424,0x1F425,0x1F426,0x1F427,0x1F428,0x1F429,0x1F42A
,0x1F42B,0x1F42C,0x1F42D,0x1F42E,0x1F42F,0x1F430,0x1F431,0x1F432,0x1F433,0x1F434,0x1F435,0x1F436
,0x1F437,0x1F438,0x1F439,0x1F43A,0x1F43B,0x1F43C,0x1F43D,0x1F43E,0x1F43F,0x1F440,0x1F441,0x1F442
,0x1F443,0x1F444,0x1F445,0x1F446,0x1F447,0x1F448,0x1F449,0x1F44A,0x1F44B,0x1F44C,0x1F44D,0x1F44E
,0x1F44F,0x1F450,0x1F451,0x1F452,0x1F453,0x1F454,0x1F455,0x1F456,0x1F457,0x1F458,0x1F459,0x1F45A
,0x1F45B,0x1F45C,0x1F45D,0x1F45E,0x1F45F,0x1F460,0x1F461,0x1F462,0x1F463,0x1F464,0x1F465,0x1F466
,0x1F467,0x1F468,0x1F469,0x1F46A,0x1F46B,0x1F46C,0x1F46D,0x1F46E,0x1F46F,0x1F470,0x1F471,0x1F472
,0x1F473,0x1F474,0x1F475,0x1F476,0x1F477,0x1F478,0x1F479,0x1F47A,0x1F47B,0x1F47C,0x1F47D,0x1F47E
,0x1F47F,0x1F480,0x1F481,0x1F482,0x1F483,0x1F484,0x1F485,0x1F486,0x1F487,0x1F488,0x1F489,0x1F48A
,0x1F48B,0x1F48C,0x1F48D,0x1F48E,0x1F48F,0x1F490,0x1F491,0x1F492,0x1F493,0x1F494,0x1F495,0x1F496
,0x1F497,0x1F498,0x1F499,0x1F49A,0x1F49B,0x1F49C,0x1F49D,0x1F49E,0x1F49F,0x1F4A0,0x1F4A1,0x1F4A2
,0x1F4A3,0x1F4A4,0x1F4A5,0x1F4A6,0x1F4A7,0x1F4A8,0x1F4A9,0x1F4AA,0x1F4AB,0x1F4AC,0x1F4AD,0x1F4AE
,0x1F4AF,0x1F4B0,0x1F4B1,0x1F4B2,0x1F4B3,0x1F4B4,0x1F4B5,0x1F4B6,0x1F4B7,0x1F4B8,0x1F4B9,0x1F4BA
,0x1F4BB,0x1F4BC,0x1F4BD,0x1F4BE,0x1F4BF,0x1F4C0,0x1F4C1,0x1F4C2,0x1F4C3,0x1F4C4,0x1F4C5,0x1F4C6
,0x1F4C7,0x1F4C8,0x1F4C9,0x1F4CA,0x1F4CB,0x1F4CC,0x1F4CD,0x1F4CE,0x1F4CF,0x1F4D0,0x1F4D1,0x1F4D2
,0x1F4D3,0x1F4D4,0x1F4D5,0x1F4D6,0x1F4D7,0x1F4D8,0x1F4D9,0x1F4DA,0x1F4DB,0x1F4DC,0x1F4DD,0x1F4DE
,0x1F4DF,0x1F4E0,0x1F4E1,0x1F4E2,0x1F4E3,0x1F4E4,0x1F4E5,0x1F4E6,0x1F4E7,0x1F4E8,0x1F4E9,0x1F4EA
,0x1F4EB,0x1F4EC,0x1F4ED,0x1F4EE,0x1F4EF,0x1F4F0,0x1F4F1,0x1F4F2,0x1F4F3,0x1F4F4,0x1F4F5,0x1F4F6
,0x1F4F7,0x1F4F8,0x1F4F9,0x1F4FA,0x1F4FB,0x1F4FC,0x1F4FD,0x1F4FE,0x1F4FF,0x1F500,0x1F501,0x1F502
,0x1F503,0x1F504,0x1F505,0x1F506,0x1F507,0x1F508,0x1F509,0x1F50A,0x1F50B,0x1F50C,0x1F50D,0x1F50E
,0x1F50F,0x1F510,0x1F511,0x1F512,0x1F513,0x1F514,0x1F515,0x1F516,0x1F517,0x1F518,0x1F519,0x1F51A
,0x1F51B,0x1F51C,0x1F51D,0x1F51E,0x1F51F,0x1F520,0x1F521,0x1F522,0x1F523,0x1F524,0x1F525,0x1F526
,0x1F527,0x1F528,0x1F529,0x1F52A,0x1F52B,0x1F52C,0x1F52D,0x1F52E,0x1F52F,0x1F530,0x1F531,0x1F532
,0x1F533,0x1F534,0x1F535,0x1F536,0x1F537,0x1F538,0x1F539,0x1F53A,0x1F53B,0x1F53C,0x1F53D,0x1F53E
,0x1F53F,0x1F540,0x1F541,0x1F542,0x1F543,0x1F544,0x1F545,0x1F546,0x1F547,0x1F548,0x1F549,0x1F54A
,0x1F54B,0x1F54C,0x1F54D,0x1F54E,0x1F54F,0x1F550,0x1F551,0x1F552,0x1F553,0x1F554,0x1F555,0x1F556
,0x1F557,0x1F558,0x1F559,0x1F55A,0x1F55B,0x1F55C,0x1F55D,0x1F55E,0x1F55F,0x1F560,0x1F561,0x1F562
,0x1F563,0x1F564,0x1F565,0x1F566,0x1F567,0x1F568,0x1F569,0x1F56A,0x1F56B,0x1F56C,0x1F56D,0x1F56E
,0x1F56F,0x1F570,0x1F571,0x1F572,0x1F573,0x1F574,0x1F575,0x1F576,0x1F577,0x1F578,0x1F579,0x1F57A
,0x1F57B,0x1F57C,0x1F57D,0x1F57E,0x1F57F,0x1F580,0x1F581,0x1F582,0x1F583,0x1F584,0x1F585,0x1F586
,0x1F587,0x1F588,0x1F589,0x1F58A,0x1F58B,0x1F58C,0x1F58D,0x1F58E,0x1F58F,0x1F590,0x1F591,0x1F592
,0x1F593,0x1F594,0x1F595,0x1F596,0x1F597,0x1F598,0x1F599,0x1F59A,0x1F59B,0x1F59C,0x1F59D,0x1F59E
,0x1F59F,0x1F5A0,0x1F5A1,0x1F5A2,0x1F5A3,0x1F5A4,0x1F5A5,0x1F5A6,0x1F5A7,0x1F5A8,0x1F5A9,0x1F5AA
,0x1F5AB,0x1F5AC,0x1F5AD,0x1F5AE,0x1F5AF,0x1F5B0,0x1F5B1,0x1F5B2,0x1F5B3,0x1F5B4,0x1F5B5,0x1F5B6
,0x1F5B7,0x1F5B8,0x1F5B9,0x1F5BA,0x1F5BB,0x1F5BC,0x1F5BD,0x1F5BE,0x1F5BF,0x1F5C0,0x1F5C1,0x1F5C2
,0x1F5C3,0x1F5C4,0x1F5C5,0x1F5C6,0x1F5C7,0x1F5C8,0x1F5C9,0x1F5CA,0x1F5CB,0x1F5CC,0x1F5CD,0x1F5CE
,0x1F5CF,0x1F5D0,0x1F5D1,0x1F5D2,0x1F5D3,0x1F5D4,0x1F5D5,0x1F5D6,0x1F5D7,0x1F5D8,0x1F5D9,0x1F5DA
,0x1F5DB,0x1F5DC,0x1F5DD,0x1F5DE,0x1F5DF,0x1F5E0,0x1F5E1,0x1F5E2,0x1F5E3,0x1F5E4,0x1F5E5,0x1F5E6
,0x1F5E7,0x1F5E8,0x1F5E9,0x1F5EA,0x1F5EB,0x1F5EC,0x1F5ED,0x1F5EE,0x1F5EF,0x1F5F0,0x1F5F1,0x1F5F2
,0x1F5F3,0x1F5F4,0x1F5F5,0x1F5F6,0x1F5F7,0x1F5F8,0x1F5F9,0x1F5FA,0x1F5FB,0x1F5FC,0x1F5FD,0x1F5FE
,0x1F5FF,0x1F600,0x1F601,0x1F602,0x1F603,0x1F604,0x1F605,0x1F606,0x1F607,0x1F608,0x1F609,0x1F60A
,0x1F60B,0x1F60C,0x1F60D,0x1F60E,0x1F60F,0x1F610,0x1F611,0x1F612,0x1F613,0x1F614,0x1F615,0x1F616
,0x1F617,0x1F618,0x1F619,0x1F61A,0x1F61B,0x1F61C,0x1F61D,0x1F61E,0x1F61F,0x1F620,0x1F621,0x1F622
,0x1F623,0x1F624,0x1F625,0x1F626,0x1F627,0x1F628,0x1F629,0x1F62A,0x1F62B,0x1F62C,0x1F62D,0x1F62E
,0x1F62F,0x1F630,0x1F631,0x1F632,0x1F633,0x1F634,0x1F635,0x1F636,0x1F637,0x1F638,0x1F639,0x1F63A
,0x1F63B,0x1F63C,0x1F63D,0x1F63E,0x1F63F,0x1F640,0x1F641,0x1F642,0x1F643,0x1F644,0x1F645,0x1F646
,0x1F647,0x1F648,0x1F649,0x1F64A,0x1F64B,0x1F64C,0x1F64D,0x1F64E,0x1F64F,0x1F650,0x1F651,0x1F652
,0x1F653,0x1F654,0x1F655,0x1F656,0x1F657,0x1F658,0x1F659,0x1F65A,0x1F65B,0x1F65C,0x1F65D,0x1F65E
,0x1F65F,0x1F660,0x1F661,0x1F662,0x1F663,0x1F664,0x1F665,0x1F666,0x1F667,0x1F668,0x1F669,0x1F66A
,0x1F66B,0x1F66C,0x1F66D,0x1F66E,0x1F66F,0x1F670,0x1F671,0x1F672,0x1F673,0x1F674,0x1F675,0x1F676
,0x1F677,0x1F678,0x1F679,0x1F67A,0x1F67B,0x1F67C,0x1F67D,0x1F67E,0x1F67F,0x1F680,0x1F681,0x1F682
,0x1F683,0x1F684,0x1F685,0x1F686,0x1F687,0x1F688,0x1F689,0x1F68A,0x1F68B,0x1F68C,0x1F68D,0x1F68E
,0x1F68F,0x1F690,0x1F691,0x1F692,0x1F693,0x1F694,0x1F695,0x1F696,0x1F697,0x1F698,0x1F699,0x1F69A
,0x1F69B,0x1F69C,0x1F69D,0x1F69E,0x1F69F,0x1F6A0,0x1F6A1,0x1F6A2,0x1F6A3,0x1F6A4,0x1F6A5,0x1F6A6
,0x1F6A7,0x1F6A8,0x1F6A9,0x1F6AA,0x1F6AB,0x1F6AC,0x1F6AD,0x1F6AE,0x1F6AF,0x1F6B0,0x1F6B1,0x1F6B2
,0x1F6B3,0x1F6B4,0x1F6B5,0x1F6B6,0x1F6B7,0x1F6B8,0x1F6B9,0x1F6BA,0x1F6BB,0x1F6BC,0x1F6BD,0x1F6BE
,0x1F6BF,0x1F6C0,0x1F6C1,0x1F6C2,0x1F6C3,0x1F6C4,0x1F6C5,0x1F6C6,0x1F6C7,0x1F6C8,0x1F6C9,0x1F6CA
,0x1F6CB,0x1F6CC,0x1F6CD,0x1F6CE,0x1F6CF,0x1F6D0,0x1F6D1,0x1F6D2,0x1F6D3,0x1F6D4,0x1F6E0,0x1F6E1
,0x1F6E2,0x1F6E3,0x1F6E4,0x1F6E5,0x1F6E6,0x1F6E7,0x1F6E8,0x1F6E9,0x1F6EA,0x1F6EB,0x1F6EC,0x1F6F0
,0x1F6F1,0x1F6F2,0x1F6F3,0x1F6F4,0x1F6F5,0x1F6F6,0x1F6F7,0x1F6F8,0x1F700,0x1F701,0x1F702,0x1F703
,0x1F704,0x1F705,0x1F706,0x1F707,0x1F708,0x1F709,0x1F70A,0x1F70B,0x1F70C,0x1F70D,0x1F70E,0x1F70F
,0x1F710,0x1F711,0x1F712,0x1F713,0x1F714,0x1F715,0x1F716,0x1F717,0x1F718,0x1F719,0x1F71A,0x1F71B
,0x1F71C,0x1F71D,0x1F71E,0x1F71F,0x1F720,0x1F721,0x1F722,0x1F723,0x1F724,0x1F725,0x1F726,0x1F727
,0x1F728,0x1F729,0x1F72A,0x1F72B,0x1F72C,0x1F72D,0x1F72E,0x1F72F,0x1F730,0x1F731,0x1F732,0x1F733
,0x1F734,0x1F735,0x1F736,0x1F737,0x1F738,0x1F739,0x1F73A,0x1F73B,0x1F73C,0x1F73D,0x1F73E,0x1F73F
,0x1F740,0x1F741,0x1F742,0x1F743,0x1F744,0x1F745,0x1F746,0x1F747,0x1F748,0x1F749,0x1F74A,0x1F74B
,0x1F74C,0x1F74D,0x1F74E,0x1F74F,0x1F750,0x1F751,0x1F752,0x1F753,0x1F754,0x1F755,0x1F756,0x1F757
,0x1F758,0x1F759,0x1F75A,0x1F75B,0x1F75C,0x1F75D,0x1F75E,0x1F75F,0x1F760,0x1F761,0x1F762,0x1F763
,0x1F764,0x1F765,0x1F766,0x1F767,0x1F768,0x1F769,0x1F76A,0x1F76B,0x1F76C,0x1F76D,0x1F76E,0x1F76F
,0x1F770,0x1F771,0x1F772,0x1F773,0x1F780,0x1F781,0x1F782,0x1F783,0x1F784,0x1F785,0x1F786,0x1F787
,0x1F788,0x1F789,0x1F78A,0x1F78B,0x1F78C,0x1F78D,0x1F78E,0x1F78F,0x1F790,0x1F791,0x1F792,0x1F793
,0x1F794,0x1F795,0x1F796,0x1F797,0x1F798,0x1F799,0x1F79A,0x1F79B,0x1F79C,0x1F79D,0x1F79E,0x1F79F
,0x1F7A0,0x1F7A1,0x1F7A2,0x1F7A3,0x1F7A4,0x1F7A5,0x1F7A6,0x1F7A7,0x1F7A8,0x1F7A9,0x1F7AA,0x1F7AB
,0x1F7AC,0x1F7AD,0x1F7AE,0x1F7AF,0x1F7B0,0x1F7B1,0x1F7B2,0x1F7B3,0x1F7B4,0x1F7B5,0x1F7B6,0x1F7B7
,0x1F7B8,0x1F7B9,0x1F7BA,0x1F7BB,0x1F7BC,0x1F7BD,0x1F7BE,0x1F7BF,0x1F7C0,0x1F7C1,0x1F7C2,0x1F7C3
,0x1F7C4,0x1F7C5,0x1F7C6,0x1F7C7,0x1F7C8,0x1F7C9,0x1F7CA,0x1F7CB,0x1F7CC,0x1F7CD,0x1F7CE,0x1F7CF
,0x1F7D0,0x1F7D1,0x1F7D2,0x1F7D3,0x1F7D4,0x1F800,0x1F801,0x1F802,0x1F803,0x1F804,0x1F805,0x1F806
,0x1F807,0x1F808,0x1F809,0x1F80A,0x1F80B,0x1F810,0x1F811,0x1F812,0x1F813,0x1F814,0x1F815,0x1F816
,0x1F817,0x1F818,0x1F819,0x1F81A,0x1F81B,0x1F81C,0x1F81D,0x1F81E,0x1F81F,0x1F820,0x1F821,0x1F822
,0x1F823,0x1F824,0x1F825,0x1F826,0x1F827,0x1F828,0x1F829,0x1F82A,0x1F82B,0x1F82C,0x1F82D,0x1F82E
,0x1F82F,0x1F830,0x1F831,0x1F832,0x1F833,0x1F834,0x1F835,0x1F836,0x1F837,0x1F838,0x1F839,0x1F83A
,0x1F83B,0x1F83C,0x1F83D,0x1F83E,0x1F83F,0x1F840,0x1F841,0x1F842,0x1F843,0x1F844,0x1F845,0x1F846
,0x1F847,0x1F850,0x1F851,0x1F852,0x1F853,0x1F854,0x1F855,0x1F856,0x1F857,0x1F858,0x1F859,0x1F860
,0x1F861,0x1F862,0x1F863,0x1F864,0x1F865,0x1F866,0x1F867,0x1F868,0x1F869,0x1F86A,0x1F86B,0x1F86C
,0x1F86D,0x1F86E,0x1F86F,0x1F870,0x1F871,0x1F872,0x1F873,0x1F874,0x1F875,0x1F876,0x1F877,0x1F878
,0x1F879,0x1F87A,0x1F87B,0x1F87C,0x1F87D,0x1F87E,0x1F87F,0x1F880,0x1F881,0x1F882,0x1F883,0x1F884
,0x1F885,0x1F886,0x1F887,0x1F890,0x1F891,0x1F892,0x1F893,0x1F894,0x1F895,0x1F896,0x1F897,0x1F898
,0x1F899,0x1F89A,0x1F89B,0x1F89C,0x1F89D,0x1F89E,0x1F89F,0x1F8A0,0x1F8A1,0x1F8A2,0x1F8A3,0x1F8A4
,0x1F8A5,0x1F8A6,0x1F8A7,0x1F8A8,0x1F8A9,0x1F8AA,0x1F8AB,0x1F8AC,0x1F8AD,0x1F900,0x1F901,0x1F902
,0x1F903,0x1F904,0x1F905,0x1F906,0x1F907,0x1F908,0x1F909,0x1F90A,0x1F90B,0x1F910,0x1F911,0x1F912
,0x1F913,0x1F914,0x1F915,0x1F916,0x1F917,0x1F918,0x1F919,0x1F91A,0x1F91B,0x1F91C,0x1F91D,0x1F91E
,0x1F91F,0x1F920,0x1F921,0x1F922,0x1F923,0x1F924,0x1F925,0x1F926,0x1F927,0x1F928,0x1F929,0x1F92A
,0x1F92B,0x1F92C,0x1F92D,0x1F92E,0x1F92F,0x1F930,0x1F931,0x1F932,0x1F933,0x1F934,0x1F935,0x1F936
,0x1F937,0x1F938,0x1F939,0x1F93A,0x1F93B,0x1F93C,0x1F93D,0x1F93E,0x1F940,0x1F941,0x1F942,0x1F943
,0x1F944,0x1F945,0x1F946,0x1F947,0x1F948,0x1F949,0x1F94A,0x1F94B,0x1F94C,0x1F950,0x1F951,0x1F952
,0x1F953,0x1F954,0x1F955,0x1F956,0x1F957,0x1F958,0x1F959,0x1F95A,0x1F95B,0x1F95C,0x1F95D,0x1F95E
,0x1F95F,0x1F960,0x1F961,0x1F962,0x1F963,0x1F964,0x1F965,0x1F966,0x1F967,0x1F968,0x1F969,0x1F96A
,0x1F96B,0x1F980,0x1F981,0x1F982,0x1F983,0x1F984,0x1F985,0x1F986,0x1F987,0x1F988,0x1F989,0x1F98A
,0x1F98B,0x1F98C,0x1F98D,0x1F98E,0x1F98F,0x1F990,0x1F991,0x1F992,0x1F993,0x1F994,0x1F995,0x1F996
,0x1F997,0x1F9C0,0x1F9D0,0x1F9D1,0x1F9D2,0x1F9D3,0x1F9D4,0x1F9D5,0x1F9D6,0x1F9D7,0x1F9D8,0x1F9D9
,0x1F9DA,0x1F9DB,0x1F9DC,0x1F9DD,0x1F9DE,0x1F9DF,0x1F9E0,0x1F9E1,0x1F9E2,0x1F9E3,0x1F9E4,0x1F9E5
,0x1F9E6,0xE0001,0xE0020,0xE0021,0xE0022,0xE0023,0xE0024,0xE0025,0xE0026,0xE0027,0xE0028,0xE0029
,0xE002A,0xE002B,0xE002C,0xE002D,0xE002E,0xE002F,0xE0030,0xE0031,0xE0032,0xE0033,0xE0034,0xE0035
,0xE0036,0xE0037,0xE0038,0xE0039,0xE003A,0xE003B,0xE003C,0xE003D,0xE003E,0xE003F,0xE0040,0xE0041
,0xE0042,0xE0043,0xE0044,0xE0045,0xE0046,0xE0047,0xE0048,0xE0049,0xE004A,0xE004B,0xE004C,0xE004D
,0xE004E,0xE004F,0xE0050,0xE0051,0xE0052,0xE0053,0xE0054,0xE0055,0xE0056,0xE0057,0xE0058,0xE0059
,0xE005A,0xE005B,0xE005C,0xE005D,0xE005E,0xE005F,0xE0060,0xE0061,0xE0062,0xE0063,0xE0064,0xE0065
,0xE0066,0xE0067,0xE0068,0xE0069,0xE006A,0xE006B,0xE006C,0xE006D,0xE006E,0xE006F,0xE0070,0xE0071
,0xE0072,0xE0073,0xE0074,0xE0075,0xE0076,0xE0077,0xE0078,0xE0079,0xE007A,0xE007B,0xE007C,0xE007D
};
*/
//#define DEBUG_PARSING
/*
Code Point	Name	Abbreviation	Usage
U+200C	ZERO WIDTH NON-JOINER	<ZWNJ>	IdentifierPart
U+200D	ZERO WIDTH JOINER	<ZWJ>	IdentifierPart
U+FEFF	ZERO WIDTH NO-BREAK SPACE	<ZWNBSP>	WhiteSpace
*/
/*
ID_Start       XID_Start        Uppercase letters, lowercase letters, titlecase letters, modifier letters
                                , other letters, letter numbers, stability extensions
ID_Continue    XID_Continue     All of the above, plus nonspacing marks, spacing combining marks, decimal numbers
                                , connector punctuations, stability extensions.
                                These are also known simply as Identifier Characters, since they are a superset of
                                the ID_Start. The set of ID_Start characters minus the ID_Continue characters are
                                known as ID_Only_Continue characters.
*/
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace json {
#endif
char *json6_escape_string_length( const char *string, size_t len, size_t *outlen ) {
	size_t m = 0;
	size_t ch;
	const char *input;
	TEXTSTR output;
	TEXTSTR _output;
	if( !( input = string ) ) return NULL;
	for( ch = 0; ch < len; ch++, input++ ) {
 /*|| (input[0] == '\n') || (input[0] == '\t')*/
		if( (input[0] == '"' ) || (input[0] == '\\' ) || (input[0] == '`') || (input[0] == '\'') )
			m++;
	}
	_output = output = NewArray( TEXTCHAR, len+m+1 );
	for( (ch = 0), (input = string); ch < len; ch++, input++ ) {
		if( (input[0] == '"' ) || (input[0] == '\\' ) || (input[0] == '`' )|| (input[0] == '\'' )) {
			(*output++) = '\\';
		}
		(*output++) = input[0];
	}
	(*output) = 0;
	if( outlen ) (*outlen) = output - _output;
	return _output;
}
char *json6_escape_string( const char *string ) {
	return json6_escape_string_length( string, strlen( string ), NULL );
}
#define _2char(result,from) (((*from) += 2),( ( result & 0x1F ) << 6 ) | ( ( result & 0x3f00 )>>8))
#define _zero(result,from)  ((*from)++,0)
#define _3char(result,from) ( ((*from) += 3),( ( ( result & 0xF ) << 12 ) | ( ( result & 0x3F00 ) >> 2 ) | ( ( result & 0x3f0000 ) >> 16 )) )
#define _4char(result,from)  ( ((*from) += 4), ( ( ( result & 0x7 ) << 18 )						     | ( ( result & 0x3F00 ) << 4 )						   | ( ( result & 0x3f0000 ) >> 10 )						    | ( ( result & 0x3f000000 ) >> 24 ) ) )
#define __GetUtfChar( result, from )           ((result = ((TEXTRUNE*)*from)[0]),		     ( ( !(result & 0xFF) )              ?_zero(result,from)	                                                    :( ( result & 0x80 )		                       ?( ( result & 0xE0 ) == 0xC0 )			   ?( ( ( result & 0xC000 ) == 0x8000 ) ?_2char(result,from) : _zero(result,from)  )			    :( ( ( result & 0xF0 ) == 0xE0 )				                           ?( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) ) ? _3char(result,from) : _zero(result,from)  )				   :( ( ( result & 0xF8 ) == 0xF0 )		                       ? ( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) && ( ( result & 0xC0000000 ) == 0x80000000 ) )					  ?_4char(result,from):_zero(result,from) )				                                                                                                                  :( ( ( result & 0xC0 ) == 0x80 )					                                                                                                  ?_zero(result,from)					                                                                                                                       : ( (*from)++, (result & 0x7F) ) ) ) )		                                                                                       : ( (*from)++, (result & 0x7F) ) ) ) )
#define GetUtfChar(x) __GetUtfChar(c,x)
static int gatherString6(struct json_parse_state *state, CTEXTSTR msg, CTEXTSTR *msg_input, size_t msglen, TEXTSTR *pmOut, TEXTRUNE start_c
		//, int literalString
		) {
	char *mOut = (*pmOut);
	// collect a string
	int status = 0;
	size_t n;
	//int escape;
	//LOGICAL cr_escaped;
	TEXTRUNE c;
	//escape = 0;
	//cr_escaped = FALSE;
	while( ( ( n = (*msg_input) - msg ), ( n < msglen ) ) && ( ( c = GetUtfChar( msg_input ) ), ( status >= 0 ) ) )
	{
		(state->col)++;
		if( c == start_c ) {
			if( state->escape ) { ( *mOut++ ) = c; state->escape = FALSE; }
			else if( c == start_c ) {
				status = 1;
				break;
 // other else is not valid close quote; just store as content.
			} else ( *mOut++ ) = c;
		} else if( state->escape ) {
			if( state->stringOct ) {
/*'0'*/
/*'9'*/
				if( state->hex_char_len < 3 && c >= 48 && c <= 57 ) {
					state->hex_char *= 8;
/*.codePointAt(0)*/
					state->hex_char += c - 0x30;
					state->hex_char_len++;
					if( state->hex_char_len == 3 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringOct = FALSE;
						state->escape = FALSE;
						continue;
					}
					continue;
				} else {
					if( state->hex_char > 255 ) {
						lprintf(WIDE("(escaped character, parsing octal escape val=%d) fault while parsing; )") WIDE(" (near %*.*s[%c]%s)")
							, state->hex_char
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						break;
					}
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringOct = FALSE;
					state->escape = FALSE;
					continue;
				}
			} else if( state->unicodeWide ) {
				if( c == '}' ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->unicodeWide = FALSE;
					state->stringUnicode = FALSE;
					state->escape = FALSE;
					continue;
				}
				state->hex_char *= 16;
				if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
				else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
				else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
				else {
					lprintf(WIDE("(escaped character, parsing hex of \\u) fault while parsing; '%c' unexpected at %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
						, (int)( ( n > 3 ) ? 3 : n ), (int)( ( n > 3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n > 3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
					state->unicodeWide = FALSE;
					state->escape = FALSE;
				}
				continue;
			} else if( state->stringHex || state->stringUnicode ) {
				if( state->hex_char_len == 0 && c == '{' ) {
					state->unicodeWide = TRUE;
					continue;
				}
				if( state->hex_char_len < 2 || ( state->stringUnicode && state->hex_char_len < 4 ) ) {
					state->hex_char *= 16;
					if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
					else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
					else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
					else {
						lprintf(WIDE("(escaped character, parsing hex of \\x) fault while parsing; '%c' unexpected at %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						state->stringHex = FALSE;
						state->escape = FALSE;
						continue;
					}
				}
				state->hex_char_len++;
				if( state->stringUnicode ) {
					if( state->hex_char_len == 4 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringUnicode = FALSE;
						state->escape = FALSE;
					}
				} else if( state->hex_char_len == 2 ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringHex = FALSE;
					state->escape = FALSE;
				}
				continue;
			}
			switch( c ) {
			case '\r':
				state->cr_escaped = TRUE;
				continue;
			case '\n':
				state->line++;
				state->col = 1;
				if( state->cr_escaped ) state->cr_escaped = FALSE;
				// fall through to clear escape status <CR><LF> support.
 // LS (Line separator)
			case 2028:
 // PS (paragraph separate)
			case 2029:
				continue;
			case '/':
			case '\\':
			case '\'':
			case '"':
			case '`':
				( *mOut++ ) = c;
				break;
			case 't':
				( *mOut++ ) = '\t';
				break;
			case 'b':
				( *mOut++ ) = '\b';
				break;
			case 'n':
				( *mOut++ ) = '\n';
				break;
			case 'r':
				( *mOut++ ) = '\r';
				break;
			case 'f':
				( *mOut++ ) = '\f';
				break;
			case '0': case '1': case '2': case '3':
				state->stringOct = TRUE;
				state->hex_char = c - 48;
				state->hex_char_len = 1;
				continue;
			case 'x':
				state->stringHex = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			case 'u':
				state->stringUnicode = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			default:
				if( state->cr_escaped ) {
					state->cr_escaped = FALSE;
					state->escape = FALSE;
					mOut += ConvertToUTF8(mOut, c);
				} else {
					lprintf(WIDE("(escaped character) fault while parsing; '%c' unexpected %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
						, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
				}
				break;
			}
			state->escape = 0;
		} else if( c == '\\' ) {
			if( state->escape ) {
				(*mOut++) = '\\';
				state->escape = 0;
			}
			else state->escape = 1;
		}
		else
		{
			if( state->cr_escaped ) {
				state->cr_escaped = FALSE;
				if( c == '\n' ) {
					state->line++;
					state->col = 1;
					state->escape = FALSE;
					continue;
				}
			}
			mOut += ConvertToUTF8( mOut, c );
		}
	}
	if( status )
  // terminate the string.
		(*mOut++) = 0;
	(*pmOut) = mOut;
	return status;
}
int json6_parse_add_data( struct json_parse_state *state
                            , const char * msg
                            , size_t msglen )
{
	/* I guess this is a good parser */
	TEXTRUNE c;
	PPARSE_BUFFER input;
	struct json_output_buffer* output;
	int string_status;
	int retval = 0;
	if( !state->status )
		return -1;
	if( msg && msglen ) {
		input = GetFromSet( PARSE_BUFFER, &jpsd.parseBuffers );
		input->pos = input->buf = msg;
		input->size = msglen;
		EnqueLinkNL( state->inBuffers, input );
		if( state->gatheringString || state->gatheringNumber || state->parse_context == CONTEXT_OBJECT_FIELD ) {
			// have to extend the previous output buffer to include this one instead of allocating a split string.
			size_t offset;
			size_t offset2;
			output = (struct json_output_buffer*)DequeLinkNL( state->outQueue );
			//lprintf( "output from before is %p", output );
			offset = (output->pos - output->buf);
			offset2 = state->val.string ? (state->val.string - output->buf) : 0;
			AddLink( state->outValBuffers, output->buf );
			output->buf = NewArray( char, output->size + msglen + 1 );
			if( state->val.string ) {
				MemCpy( output->buf + offset2, state->val.string, offset - offset2 );
				state->val.string = output->buf + offset2;
			}
			output->size += msglen;
			//lprintf( "previous val:%s", state->val.string, state->val.string );
			output->pos = output->buf + offset;
			PrequeLink( state->outQueue, output );
		}
		else {
			output = (struct json_output_buffer*)GetFromSet( PARSE_BUFFER, &jpsd.parseBuffers );
			output->pos = output->buf = NewArray( char, msglen + 1 );
			output->size = msglen;
			EnqueLinkNL( state->outQueue, output );
		}
	}
	else {
		// zero length input buffer... terminate a number.
		if( state->gatheringNumber ) {
			//console.log( "Force completed.")
			output = (struct json_output_buffer*)DequeLinkNL( state->outQueue );
			output->pos[0] = 0;
			PushLink( state->outBuffers, output );
			state->gatheringNumber = FALSE;
			//lprintf( "result with number:%s", state->val.string );
			if( state->val.float_result )
			{
				CTEXTSTR endpos;
				state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
				if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
			}
			else
			{
				state->val.result_n = IntCreateFromText( state->val.string );
				if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
			}
			state->val.value_type = VALUE_NUMBER;
			if( state->parse_context == CONTEXT_UNKNOWN ) {
				state->completed = TRUE;
			}
			retval = 1;
		}
	}
	while( state->status && ( input = (PPARSE_BUFFER)DequeLinkNL( state->inBuffers ) ) ) {
		output = (struct json_output_buffer*)DequeLinkNL( state->outQueue );
		//lprintf( "output is %p", output );
		state->n = input->pos - input->buf;
		if( state->n > input->size ) DebugBreak();
		if( state->gatheringString ) {
			string_status = gatherString6( state, input->buf, &input->pos, input->size, &output->pos, state->gatheringStringFirstChar );
			if( string_status < 0 )
				state->status = FALSE;
			else if( string_status > 0 )
			{
				state->gatheringString = FALSE;
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
				state->val.stringLen = (output->pos - state->val.string)-1;
				if( state->status ) state->val.value_type = VALUE_STRING;
			}
			else {
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
			}
		}
		if( state->gatheringNumber ) {
			//lprintf( "continue gathering a string" );
			goto continueNumber;
		}
		//lprintf( "Completed at start?%d", state->completed );
		while( state->status && (state->n < input->size) && (c = GetUtfChar( &input->pos )) )
		{
			state->col++;
			state->n = input->pos - input->buf;
			if( state->n > input->size ) DebugBreak();
			if( state->comment ) {
				if( state->comment == 1 ) {
					if( c == '*' ) { state->comment = 3; continue; }
					if( c != '/' ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "Fault while parsing; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
					else state->comment = 2;
					continue;
				}
				if( state->comment == 2 ) {
					if( c == '\n' ) { state->comment = 0; continue; }
					else continue;
				}
				if( state->comment == 3 ) {
					if( c == '*' ) { state->comment = 4; continue; }
					else continue;
				}
				if( state->comment == 4 ) {
					if( c == '/' ) { state->comment = 0; continue; }
					else { if( c != '*' ) state->comment = 3; continue; }
				}
			}
			switch( c )
			{
			case '/':
				if( !state->comment ) state->comment = 1;
				break;
			case '{':
				if( state->word == WORD_POS_FIELD || state->word == WORD_POS_AFTER_FIELD || (state->parse_context == CONTEXT_OBJECT_FIELD && state->word == WORD_POS_RESET) ) {
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					vtprintf( state->pvtError, "Fault while parsing; getting field name unexpected '%c' at %" _size_f " %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
					break;
				}
				{
					struct json_parse_context *old_context = GetFromSet( PARSE_CONTEXT, &jpsd.parseContexts );
#ifdef _DEBUG_PARSING
					lprintf( "Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d", val.value_type );
#endif
					old_context->context = state->parse_context;
					old_context->elements = state->elements;
					old_context->name = state->val.name;
					old_context->nameLen = state->val.nameLen;
// CreateDataList( sizeof( state->val ) );
					state->elements = GetFromSet( PDATALIST, &jpsd.dataLists );
					if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
					else state->elements[0]->Cnt = 0;
					PushLink( state->context_stack, old_context );
					RESET_STATE_VAL();
					state->parse_context = CONTEXT_OBJECT_FIELD;
				}
				break;
			case '[':
				if( state->parse_context == CONTEXT_OBJECT_FIELD ) {
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					vtprintf( state->pvtError, WIDE( "Fault while parsing; while getting field name unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
					break;
				}
				{
					struct json_parse_context *old_context = GetFromSet( PARSE_CONTEXT, &jpsd.parseContexts );
#ifdef _DEBUG_PARSING
					lprintf( "Begin a new array; previously pushed into elements; but wait until trailing comma or close previously:%d", val.value_type );
#endif
					old_context->context = state->parse_context;
					old_context->elements = state->elements;
					old_context->name = state->val.name;
					old_context->nameLen = state->val.nameLen;
// CreateDataList( sizeof( state->val ) );
					state->elements = GetFromSet( PDATALIST, &jpsd.dataLists );
					if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
					else state->elements[0]->Cnt = 0;
					PushLink( state->context_stack, old_context );
					RESET_STATE_VAL();
					state->parse_context = CONTEXT_IN_ARRAY;
				}
				break;
			case ':':
				if( state->parse_context == CONTEXT_OBJECT_FIELD )
				{
					if( state->word != WORD_POS_RESET
						&& state->word != WORD_POS_FIELD
						&& state->word != WORD_POS_AFTER_FIELD ) {
						// allow starting a new word
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "unquoted keyword used as object field name:parsing fault; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
						break;
					}
					else if( state->word == WORD_POS_FIELD ) {
						//state->val.stringLen = output->pos - state->val.string;
						//lprintf( "Set string length:%d", state->val.stringLen );
					}
					if( !( state->val.value_type == VALUE_STRING ) )
						(*output->pos++) = 0;
					state->word = WORD_POS_RESET;
					if( state->val.name ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "two names single value?" );
					}
					state->val.name = state->val.string;
					state->val.nameLen = ( output->pos - state->val.string ) - 1;
					state->val.string = NULL;
					state->val.stringLen = 0;
					state->parse_context = CONTEXT_OBJECT_FIELD_VALUE;
					state->val.value_type = VALUE_UNSET;
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					if( state->parse_context == CONTEXT_IN_ARRAY )
						vtprintf( state->pvtError, WIDE( "(in array, got colon out of string):parsing fault; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					else
						vtprintf( state->pvtError, WIDE( "(outside any object, got colon out of string):parsing fault; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case '}':
				if( state->word == WORD_POS_END ) {
					// allow starting a new word
					state->word = WORD_POS_RESET;
				}
				// coming back after pushing an array or sub-object will reset the contxt to FIELD, so an end with a field should still push value.
				if( (state->parse_context == CONTEXT_OBJECT_FIELD) || (state->parse_context == CONTEXT_OBJECT_FIELD_VALUE) ) {
#ifdef _DEBUG_PARSING
					lprintf( "close object; empty object %d", state->val.value_type );
#endif
					//if( (state->parse_context == CONTEXT_OBJECT_FIELD_VALUE) )
					if( state->val.value_type != VALUE_UNSET ) {
						AddDataItem( state->elements, &state->val );
					}
					//RESET_STATE_VAL();
					state->val.value_type = VALUE_OBJECT;
					state->val.string = NULL;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					{
						struct json_parse_context *old_context = (struct json_parse_context *)PopLink( state->context_stack );
						//struct json_value_container *oldVal = (struct json_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						DeleteFromSet( PARSE_CONTEXT, jpsd.parseContexts, old_context );
					}
					if( state->parse_context == CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					vtprintf( state->pvtError, WIDE( "Fault while parsing; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case ']':
				if( state->word == WORD_POS_END ) {
					// allow starting a new word
					state->word = WORD_POS_RESET;
				}
				if( state->parse_context == CONTEXT_IN_ARRAY )
				{
#ifdef _DEBUG_PARSING
					lprintf( "close array, push last element: %d", state->val.value_type );
#endif
					if( state->val.value_type != VALUE_UNSET ) {
						AddDataItem( state->elements, &state->val );
					}
					state->val.value_type = VALUE_ARRAY;
					state->val.string = NULL;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					{
						struct json_parse_context *old_context = (struct json_parse_context *)PopLink( state->context_stack );
						//struct json_value_container *oldVal = (struct json_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						DeleteFromSet( PARSE_CONTEXT, jpsd.parseContexts, old_context );
					}
					if( state->parse_context == CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "bad context %d; fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->parse_context, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case ',':
				if( state->word == WORD_POS_END ) {
					// allow starting a new word
					state->word = WORD_POS_RESET;
				}
				if( state->parse_context == CONTEXT_IN_ARRAY )
				{
					if( state->val.value_type == VALUE_UNSET )
 // in an array, elements after a comma should init as undefined...
						state->val.value_type = VALUE_EMPTY;
																 // undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.
					if( state->val.value_type != VALUE_UNSET ) {
#ifdef _DEBUG_PARSING
						lprintf( "back in array; push item %d", state->val.value_type );
#endif
						AddDataItem( state->elements, &state->val );
						RESET_STATE_VAL();
					}
				}
				else if( state->parse_context == CONTEXT_OBJECT_FIELD_VALUE )
				{
					// after an array value, it will have returned to OBJECT_FIELD anyway
#ifdef _DEBUG_PARSING
					lprintf( "comma after field value, push field to object: %s", state->val.name );
#endif
					state->parse_context = CONTEXT_OBJECT_FIELD;
					if( state->val.value_type != VALUE_UNSET )
						AddDataItem( state->elements, &state->val );
					RESET_STATE_VAL();
				}
				else
				{
					state->status = FALSE;
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "bad context; fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
				}
				break;
			default:
				if( state->parse_context == CONTEXT_OBJECT_FIELD ) {
					//lprintf( "gathering object field:%c  %*.*s", c, output->pos-output->buf, output->pos - output->buf, output->buf );
					if( c < 0xFF ) {
						if( nonIdentifiers8[c] ) {
							// invalid start/continue
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, WIDE( "fault while parsing object field name; \\u00%02X unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
							break;
						}
					}
					else {
						int n;
						for( n = 0; n < (sizeof( nonIdentifierBits ) / sizeof( nonIdentifierBits[0] )); n++ ) {
							if( c >= (TEXTRUNE)nonIdentifierBits[n].firstChar && c < (TEXTRUNE)nonIdentifierBits[n].lastChar &&
								(nonIdentifierBits[n].bits[(c - nonIdentifierBits[n].firstChar) / 24]
									& (1 << ((c - nonIdentifierBits[n].firstChar) % 24))) ) {
								state->status = FALSE;
								if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
								vtprintf( state->pvtError, WIDE( "fault while parsing object field name; \\u00%02X unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
								break;
							}
						}
						if( c < (sizeof( nonIdentifierBits ) / sizeof( nonIdentifierBits[0] )) )
							break;
					}
					switch( c )
					{
					case '`':
						// this should be a special case that passes continuation to gatherString
						// but gatherString now just gathers all strings
					case '"':
					case '\'':
						state->val.string = output->pos;
						state->gatheringString = TRUE;
						state->gatheringStringFirstChar = c;
						string_status = gatherString6( state, input->buf, &input->pos, input->size, &output->pos, c );
						//lprintf( "string gather status:%d", string_status );
						if( string_status < 0 )
							state->status = FALSE;
						else if( string_status > 0 ) {
							state->gatheringString = FALSE;
							state->val.stringLen = (output->pos - state->val.string) - 1;
						}
						state->n = input->pos - input->buf;
						if( state->n > input->size ) DebugBreak();
						if( state->status ) {
							state->val.value_type = VALUE_STRING;
							//state->val.stringLen = (output->pos - state->val.string - 1);
							//lprintf( "Set string length:%d", state->val.stringLen );
						}
						break;
					case '\n':
						state->line++;
						state->col = 1;
						// fall through to normal space handling - just updated line/col position
					case ' ':
					case '\t':
					case '\r':
 // ZWNBS is WS though
					case 0xFEFF:
						if( state->word == WORD_POS_RESET || state->word == WORD_POS_AFTER_FIELD )
							break;
						else if( state->word == WORD_POS_FIELD ) {
							state->word = WORD_POS_AFTER_FIELD;
							//state->val.stringLen = output->pos - state->val.string;
							//lprintf( "Set string length:%d", state->val.stringLen );
							break;
						}
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
						vtprintf( state->pvtError, WIDE( "fault while parsing; whitespace unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n, state->line, state->col );
						// skip whitespace
						//n++;
						//lprintf( "whitespace skip..." );
						break;
					default:
						if( state->word == WORD_POS_AFTER_FIELD ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, WIDE( "fault while parsing; unquoted space in field name at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n, state->line, state->col );
							break;
						} else if( state->word == WORD_POS_RESET ) {
							state->word = WORD_POS_FIELD;
							state->val.string = output->pos;
						}
						if( c < 128 ) (*output->pos++) = c;
						else output->pos += ConvertToUTF8( output->pos, c );
 // default
						break;
					}
				}
				else switch( c )
				{
				case '`':
					// this should be a special case that passes continuation to gatherString
					// but gatherString now just gathers all strings
				case '"':
				case '\'':
					state->val.string = output->pos;
					state->gatheringString = TRUE;
					state->gatheringStringFirstChar = c;
					string_status = gatherString6( state, input->buf, &input->pos, input->size, &output->pos, c );
					//lprintf( "string gather status:%d", string_status );
					if( string_status < 0 )
						state->status = FALSE;
					else if( string_status > 0 ) {
						state->gatheringString = FALSE;
						state->val.stringLen = (output->pos - state->val.string) - 1;
					} else if( state->complete_at_end ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "End of string fail." );
						state->status = FALSE;
					}
					state->n = input->pos - input->buf;
					if( state->n > input->size ) DebugBreak();
					if( state->status ) {
						state->val.value_type = VALUE_STRING;
						state->word = WORD_POS_END;
						if( state->complete_at_end ) {
							if( state->parse_context == CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					break;
				case '\n':
					state->line++;
					state->col = 1;
					// FALLTHROUGH
				case ' ':
				case '\t':
				case '\r':
				case 0xFEFF:
					if( state->word == WORD_POS_END ) {
						state->word = WORD_POS_RESET;
						if( state->parse_context == CONTEXT_UNKNOWN ) {
							state->completed = TRUE;
						}
						break;
					}
					if( state->word == WORD_POS_RESET ) {
						break;
					}
					else if( state->word == WORD_POS_FIELD ) {
						state->word = WORD_POS_AFTER_FIELD;
					}
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
						vtprintf( state->pvtError, WIDE( "fault while parsing; whitespace unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n );
					}
					// skip whitespace
					//n++;
					//lprintf( "whitespace skip..." );
					break;
					//----------------------------------------------------------
					//  catch characters for true/false/null/undefined which are values outside of quotes
				case 't':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_TRUE_1;
					else if( state->word == WORD_POS_INFINITY_6 ) state->word = WORD_POS_INFINITY_7;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
								, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'r':
					if( state->word == WORD_POS_TRUE_1 ) state->word = WORD_POS_TRUE_2;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'u':
					if( state->word == WORD_POS_TRUE_2 ) state->word = WORD_POS_TRUE_3;
					else if( state->word == WORD_POS_NULL_1 ) state->word = WORD_POS_NULL_2;
					else if( state->word == WORD_POS_RESET ) state->word = WORD_POS_UNDEFINED_1;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'e':
					if( state->word == WORD_POS_TRUE_3 ) {
						state->val.value_type = VALUE_TRUE;
						state->word = WORD_POS_END;
					}
					else if( state->word == WORD_POS_FALSE_4 ) {
						state->val.value_type = VALUE_FALSE;
						state->word = WORD_POS_END;
					}
					else if( state->word == WORD_POS_UNDEFINED_3 ) state->word = WORD_POS_UNDEFINED_4;
					else if( state->word == WORD_POS_UNDEFINED_7 ) state->word = WORD_POS_UNDEFINED_8;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'n':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_NULL_1;
					else if( state->word == WORD_POS_UNDEFINED_1 ) state->word = WORD_POS_UNDEFINED_2;
					else if( state->word == WORD_POS_UNDEFINED_6 ) state->word = WORD_POS_UNDEFINED_7;
					else if( state->word == WORD_POS_INFINITY_1 ) state->word = WORD_POS_INFINITY_2;
					else if( state->word == WORD_POS_INFINITY_4 ) state->word = WORD_POS_INFINITY_5;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'd':
					if( state->word == WORD_POS_UNDEFINED_2 ) state->word = WORD_POS_UNDEFINED_3;
					else if( state->word == WORD_POS_UNDEFINED_8 ) { state->val.value_type = VALUE_UNDEFINED; state->word = WORD_POS_END; }
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'i':
					if( state->word == WORD_POS_UNDEFINED_5 ) state->word = WORD_POS_UNDEFINED_6;
					else if( state->word == WORD_POS_INFINITY_3 ) state->word = WORD_POS_INFINITY_4;
					else if( state->word == WORD_POS_INFINITY_5 ) state->word = WORD_POS_INFINITY_6;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'l':
					if( state->word == WORD_POS_NULL_2 ) state->word = WORD_POS_NULL_3;
					else if( state->word == WORD_POS_NULL_3 ) {
						state->val.value_type = VALUE_NULL;
						state->word = WORD_POS_END;
					}
					else if( state->word == WORD_POS_FALSE_2 ) state->word = WORD_POS_FALSE_3;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'f':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_FALSE_1;
					else if( state->word == WORD_POS_UNDEFINED_4 ) state->word = WORD_POS_UNDEFINED_5;
					else if( state->word == WORD_POS_INFINITY_2 ) state->word = WORD_POS_INFINITY_3;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'a':
					if( state->word == WORD_POS_FALSE_1 ) state->word = WORD_POS_FALSE_2;
					else if( state->word == WORD_POS_NAN_1 ) state->word = WORD_POS_NAN_2;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 's':
					if( state->word == WORD_POS_FALSE_3 ) state->word = WORD_POS_FALSE_4;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'I':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_INFINITY_1;
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'N':
					if( state->word == WORD_POS_RESET ) state->word = WORD_POS_NAN_1;
					else if( state->word == WORD_POS_NAN_2 ) { state->val.value_type = state->negative ? VALUE_NEG_NAN : VALUE_NAN; state->word = WORD_POS_END; }
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
				case 'y':
					if( state->word == WORD_POS_INFINITY_7 ) { state->val.value_type = state->negative ? VALUE_NEG_INFINITY : VALUE_INFINITY; state->word = WORD_POS_END; }
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
// fault
					}
					break;
					//
					//----------------------------------------------------------
				case '-':
					state->negative = !state->negative;
					break;
				default:
					if( (c >= '0' && c <= '9') || (c == '+') || (c == '.') )
					{
						LOGICAL fromDate;
 // to unwind last character past number.
						const char *_msg_input;
						// always reset this here....
						// keep it set to determine what sort of value is ready.
						if( !state->gatheringNumber ) {
							state->exponent = FALSE;
							state->exponent_sign = FALSE;
							state->exponent_digit = FALSE;
							fromDate = FALSE;
							state->fromHex = FALSE;
							state->val.float_result = (c == '.');
							state->val.string = output->pos;
  // terminate the string.
							(*output->pos++) = c;
						}
						else
						{
						continueNumber:
							fromDate = state->numberFromDate;
						}
						while( (_msg_input = input->pos), ((state->n < input->size) && (c = GetUtfChar( &input->pos ))) )
						{
							//lprintf( "Number input:%c", c );
							state->col++;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
							// leading zeros should be forbidden.
							if( c == '_' )
								continue;
							if( c >= '0' && c <= '9' )
							{
								(*output->pos++) = c;
								if( state->exponent )
									state->exponent_digit = TRUE;
							}
#if 0
							// to be implemented
							else if( c == ':' || c == '-' || c == 'Z' || c == '+' ) {
								/* toISOString()
								var today = new Date('05 October 2011 14:48 UTC');
								console.log(today.toISOString());
								// Returns 2011-10-05T14:48:00.000Z
								*/
								(*output->pos++) = c;
							}
#endif
							else if( ( c == 'x' || c == 'b' || c =='o' || c == 'X' || c == 'B' || c == 'O')
							       && ( output->pos - output->buf ) == 1
							       && output->buf[0] == '0' ) {
								// hex conversion.
								if( !state->fromHex ) {
									state->fromHex = TRUE;
 // force lower case.
									(*output->pos++) = c | 0x20;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( (c == 'e') || (c == 'E') )
							{
								if( !state->exponent ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
									state->exponent = TRUE;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( c == '-' || c == '+' ) {
								if( !state->exponent ) {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
								else {
									if( !state->exponent_sign && !state->exponent_digit ) {
										(*output->pos++) = c;
										state->exponent_sign = 1;
									}
									else {
										state->status = FALSE;
										if( !state->pvtError ) state->pvtError = VarTextCreate();
										vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
										break;
									}
								}
							}
							else if( c == '.' )
							{
								if( !state->val.float_result && !state->fromHex ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else
							{
								// in non streaming mode; these would be required to follow
								if( c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == 0xFEFF
									|| c == ',' || c == ']' || c == '}'  || c == ':' ) {
									//lprintf( "Non numeric character received; push the value we have" );
									(*output->pos) = 0;
									break;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
						}
						if( input ) {
							input->pos = _msg_input;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
						}
						//LogBinary( (uint8_t*)output->buf, output->size );
						if( input && (!state->complete_at_end) && state->n == input->size )
						{
							//lprintf( "completion mode is not end of string; and at end of string" );
							state->gatheringNumber = TRUE;
							state->numberFromDate = fromDate;
						}
						else
						{
							(*output->pos++) = 0;
							state->val.stringLen = (output->pos - state->val.string) - 1;
							state->gatheringNumber = FALSE;
							//lprintf( "result with number:%s", state->val.string );
							if( state->val.float_result )
							{
								CTEXTSTR endpos;
								state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
								if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
							}
							else
							{
								state->val.result_n = IntCreateFromText( state->val.string );
								if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
							}
							state->val.value_type = VALUE_NUMBER;
							if( state->parse_context == CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					else
					{
						// fault, illegal characer
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "fault parsing '%c' unexpected %" )_size_f WIDE( " (near %*.*s[%c]%s)" ), c, state->n
							, (int)((state->n > 4) ? 3 : (state->n-1)), (int)((state->n > 4) ? 3 : (state->n-1))
							, input->buf + state->n - ((state->n > 3) ? 3 : state->n)
							, c
							, input->buf + state->n
// fault
						);
					}
 // default
					break;
				}
 // default of high level switch
				break;
			}
			// got a completed value; skip out
			if( state->completed ) {
				if( state->word == WORD_POS_END ) {
					state->word = WORD_POS_RESET;
				}
				break;
			}
		}
		//lprintf( "at end... %d %d comp:%d", state->n, input->size, state->completed );
		if( input ) {
			if( state->n >= input->size ) {
				DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, input );
				if( state->gatheringString || state->gatheringNumber || state->parse_context == CONTEXT_OBJECT_FIELD ) {
					//lprintf( "output is still incomplete? " );
					PrequeLink( state->outQueue, output );
					retval = 0;
				}
				else {
					PushLink( state->outBuffers, output );
					if( state->parse_context == CONTEXT_UNKNOWN
					  && ( state->val.value_type != VALUE_UNSET
					     || state->elements[0]->Cnt ) ) {
						state->completed = TRUE;
						retval = 1;
					}
				}
				//lprintf( "Is complete already?%d", state->completed );
			}
			else {
				// put these back into the stack.
				//lprintf( "put buffers back into queues..." );
				PrequeLink( state->inBuffers, input );
				PrequeLink( state->outQueue, output );
  // if returning buffers, then obviously there's more in this one.
				retval = 2;
			}
		}
		if( state->completed )
			break;
 // while DequeInput
	}
	if( !state->status ) {
		// some error condition; cannot resume parsing.
		return -1;
	}
	if( state->completed ) {
		if( state->val.value_type != VALUE_UNSET ) {
			AddDataItem( state->elements, &state->val );
			RESET_STATE_VAL();
		}
		state->completed = FALSE;
	}
	return retval;
}
PDATALIST json_parse_get_data( struct json_parse_state *state ) {
	PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
	state->elements = GetFromSet( PDATALIST, &jpsd.dataLists );
	if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
	else state->elements[0]->Cnt = 0;
	return result[0];
}
void json_parse_clear_state( struct json_parse_state *state ) {
	if( state ) {
		PPARSE_BUFFER buffer;
		while( buffer = (PPARSE_BUFFER)PopLink( state->outBuffers ) ) {
			Deallocate( const char *, buffer->buf );
			DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, buffer );
		}
		while( buffer = (PPARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
			DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, buffer );
		while( buffer = (PPARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
			Deallocate( const char*, buffer->buf );
			DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, buffer );
		}
		DeleteFromSet( PLINKQUEUE, jpsd.linkQueues, state->inBuffers );
		//DeleteLinkQueue( &state->inBuffers );
		DeleteFromSet( PLINKQUEUE, jpsd.linkQueues, state->outQueue );
		//DeleteLinkQueue( &state->outQueue );
		DeleteFromSet( PLINKSTACK, jpsd.linkStacks, state->outBuffers );
		//DeleteLinkStack( &state->outBuffers );
		{
			char *buf;
			INDEX idx;
			LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
				Deallocate( char*, buf );
			}
			DeleteFromSet( PLIST, jpsd.listSet, state->outValBuffers );
			//DeleteList( &state->outValBuffers );
		}
		state->status = TRUE;
		state->parse_context = CONTEXT_UNKNOWN;
		state->word = WORD_POS_RESET;
		state->n = 0;
		state->col = 1;
		state->line = 1;
		state->gatheringString = FALSE;
		state->gatheringNumber = FALSE;
		{
			PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
			state->elements = GetFromSet( PDATALIST, &jpsd.dataLists );
			if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
			else state->elements[0]->Cnt = 0;
			//state->elements = CreateDataList( sizeof( state->val ) );
			json6_dispose_message( result );
		}
	}
}
PTEXT json_parse_get_error( struct json_parse_state *state ) {
	if( !state )
		state = jpsd.last_parse_state;
	if( !state )
		return NULL;
	if( state->pvtError ) {
		PTEXT error = VarTextGet( state->pvtError );
		return error;
	}
	return NULL;
}
void json_parse_dispose_state( struct json_parse_state **ppState ) {
	struct json_parse_state *state = (*ppState);
	struct json_parse_context *old_context;
	PPARSE_BUFFER buffer;
	_json_dispose_message( state->elements );
	//DeleteDataList( &state->elements );
	while( buffer = (PPARSE_BUFFER)PopLink( state->outBuffers ) ) {
		Deallocate( const char *, buffer->buf );
		DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, buffer );
	}
	{
		char *buf;
		INDEX idx;
		LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
			Deallocate( char*, buf );
		}
		DeleteFromSet( PLIST, jpsd.listSet, state->outValBuffers );
		//DeleteList( &state->outValBuffers );
	}
	while( buffer = (PPARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
		DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, buffer );
	while( buffer = (PPARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
		Deallocate( const char*, buffer->buf );
		DeleteFromSet( PARSE_BUFFER, jpsd.parseBuffers, buffer );
	}
	DeleteFromSet( PLINKQUEUE, jpsd.linkQueues, state->inBuffers );
	//DeleteLinkQueue( &state->inBuffers );
	DeleteFromSet( PLINKQUEUE, jpsd.linkQueues, state->outQueue );
	//DeleteLinkQueue( &state->outQueue );
	DeleteFromSet( PLINKSTACK, jpsd.linkStacks, state->outBuffers );
	//DeleteLinkStack( &state->outBuffers );
	DeleteFromSet( PARSE_CONTEXT, jpsd.parseContexts, state->context );
	while( (old_context = (struct json_parse_context *)PopLink( state->context_stack )) ) {
		//lprintf( "warning unclosed contexts...." );
		DeleteFromSet( PARSE_CONTEXT, jpsd.parseContexts, old_context );
	}
	if( state->context_stack )
		DeleteFromSet( PLINKSTACK, jpsd.linkStacks, state->context_stack );
		//DeleteLinkStack( &state->context_stack );
	DeleteFromSet( PARSE_STATE, jpsd.parseStates, state );
	//Deallocate( struct json_parse_state *, state );
	(*ppState) = NULL;
}
LOGICAL json6_parse_message( const char * msg
	, size_t msglen
	, PDATALIST *_msg_output ) {
	struct json_parse_state *state = json_begin_parse();
	static struct json_parse_state *_state;
	state->complete_at_end = TRUE;
	int result = json6_parse_add_data( state, msg, msglen );
	if( _state ) json_parse_dispose_state( &_state );
	if( result > 0 ) {
		(*_msg_output) = json_parse_get_data( state );
		_state = state;
		//json6_parse_dispose_state( &state );
		return TRUE;
	}
	(*_msg_output) = NULL;
	jpsd.last_parse_state = state;
	_state = state;
	return FALSE;
}
void json6_dispose_decoded_message( struct json6_context_object *format
                                 , POINTER msg_data )
{
	// a complex format might have sub-parts .... but for now we'll assume simple flat structures
	//Release( msg_data );
}
void json6_dispose_message( PDATALIST *msg_data )
{
	json_dispose_message( msg_data );
	return;
}
// puts the current collected value into the element; assumes conversion was correct
static void FillDataToElement6( struct json_context_object_element *element
							    , size_t object_offset
								, struct json_value_container *val
								, POINTER msg_output )
{
	if( !val->name )
		return;
	// remove name; indicate that the value has been used.
	Release( val->name );
	val->name = NULL;
	switch( element->type )
	{
	case JSON_Element_String:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_NULL:
				((CTEXTSTR*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = NULL;
				break;
			case VALUE_STRING:
				((CTEXTSTR*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = StrDup( val->string );
				break;
			default:
				lprintf( WIDE("Expected a string, but parsed result was a %d"), val->value_type );
				break;
			}
		}
		break;
	case JSON_Element_Integer_64:
	case JSON_Element_Integer_32:
	case JSON_Element_Integer_16:
	case JSON_Element_Integer_8:
	case JSON_Element_Unsigned_Integer_64:
	case JSON_Element_Unsigned_Integer_32:
	case JSON_Element_Unsigned_Integer_16:
	case JSON_Element_Unsigned_Integer_8:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_TRUE:
				switch( element->type )
				{
				case JSON_Element_String:
				case JSON_Element_CharArray:
				case JSON_Element_Float:
				case JSON_Element_Double:
				case JSON_Element_Array:
				case JSON_Element_Object:
				case JSON_Element_ObjectPointer:
				case JSON_Element_List:
				case JSON_Element_Text:
				case JSON_Element_PTRSZVAL:
				case JSON_Element_PTRSZVAL_BLANK_0:
				case JSON_Element_UserRoutine:
				case JSON_Element_Raw_Object:
					lprintf( "Uhandled element conversion." );
					break;
				case JSON_Element_Integer_64:
				case JSON_Element_Unsigned_Integer_64:
					((int8_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				case JSON_Element_Integer_32:
				case JSON_Element_Unsigned_Integer_32:
					((int16_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				case JSON_Element_Integer_16:
				case JSON_Element_Unsigned_Integer_16:
					((int32_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				case JSON_Element_Integer_8:
				case JSON_Element_Unsigned_Integer_8:
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 1;
					break;
				}
				break;
			case VALUE_FALSE:
				switch( element->type )
				{
				case JSON_Element_String:
				case JSON_Element_CharArray:
				case JSON_Element_Float:
				case JSON_Element_Double:
				case JSON_Element_Array:
				case JSON_Element_Object:
				case JSON_Element_ObjectPointer:
				case JSON_Element_List:
				case JSON_Element_Text:
				case JSON_Element_PTRSZVAL:
				case JSON_Element_PTRSZVAL_BLANK_0:
				case JSON_Element_UserRoutine:
				case JSON_Element_Raw_Object:
					lprintf( "Uhandled element conversion." );
					break;
				case JSON_Element_Integer_64:
				case JSON_Element_Unsigned_Integer_64:
					((int8_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				case JSON_Element_Integer_32:
				case JSON_Element_Unsigned_Integer_32:
					((int16_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				case JSON_Element_Integer_16:
				case JSON_Element_Unsigned_Integer_16:
					((int32_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				case JSON_Element_Integer_8:
				case JSON_Element_Unsigned_Integer_8:
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = 0;
					break;
				}
				break;
			case VALUE_NUMBER:
				if( val->float_result )
				{
					lprintf( WIDE("warning received float, converting to int") );
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (int64_t)val->result_d;
				}
				else
				{
					((int64_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = val->result_n;
				}
				break;
			default:
				lprintf( WIDE("Expected a string, but parsed result was a %d"), val->value_type );
				break;
			}
		}
		break;
	case JSON_Element_Float:
	case JSON_Element_Double:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_NUMBER:
				if( val->float_result )
				{
					if( element->type == JSON_Element_Float )
						((float*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (float)val->result_d;
					else
						((double*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = val->result_d;
				}
				else
				{
					// this is probably common (0 for instance)
					lprintf( WIDE("warning received int, converting to float") );
					if( element->type == JSON_Element_Float )
						((float*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (float)val->result_n;
					else
						((double*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (double)val->result_n;
				}
				break;
			default:
				lprintf( WIDE("Expected a float, but parsed result was a %d"), val->value_type );
				break;
			}
		}
		break;
	case JSON_Element_PTRSZVAL_BLANK_0:
	case JSON_Element_PTRSZVAL:
		if( element->count )
		{
		}
		else if( element->count_offset != JSON_NO_OFFSET )
		{
		}
		else
		{
			switch( val->value_type )
			{
			case VALUE_NUMBER:
				if( val->float_result )
				{
					lprintf( WIDE("warning received float, converting to int (uintptr_t)") );
					((uintptr_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (uintptr_t)val->result_d;
				}
				else
				{
					// this is probably common (0 for instance)
					((uintptr_t*)( ((uintptr_t)msg_output) + element->offset + object_offset ))[0] = (uintptr_t)val->result_n;
				}
				break;
			}
		}
		break;
	}
}
#undef GetUtfChar
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
#define JSOX_PARSER_SOURCE
#define JSOX_PARSER_MAIN_SOURCE
#define DEADSTART_ROOT_OPTION_THING
/***************************************************************
 * JSOX Parser
 *
 * Parses JSOX (github.com/d3x0r/jsox)
 *
 * This function is meant for a simple utility to just take a known completed packet,
 * and get the values from it.  There may be mulitple top level values, although
 * the JSON standard will only supply a single object or array as the first value.
 * jsox_parse_message( "utf8 data", sizeof( "utf8 data" )-1, &pdlMessage );
 *
 *
 * Example :
 // call to parse a message... and iterate through each value.
 {
parse_message
    PDATALIST pdlMessage;
    LOGICAL gotMessage;
	 if( jsox_parse_message( "utf8 data", sizeof( "utf8 data" )-1, &pdlMessage ) ) {
		  int index;
        struct jsox_value_container *value;
		  DATALIST_FORALL( pdlMessage, index, struct jsox_value_container *. value ) {
           /* for each value in the result.... the first layer will
           always be just one element, either a simple type, or a VALUE_ARRAY or VALUE_OBJECT, which
           then for each value->contains (as a datalist like above), process each of those values.
		  }
        jsox_dispose_mesage( &pdlMessage );
    }
 }
 *
 *  This is a streaming setup, where a data block can be added,
 *  and the stream of objects can be returned from it....
 *
 *  Example 2:
 // allocate a parser to keep track of the parsing state...
 struct jsox_parse_state *parser = jsox_begin_parse();
 // at some point later, add some data to it...
 jsox_parse_add_data( parser, "utf8-data", sizeof( "utf8-data" ) - 1 );
 // and then get any objects that have been parsed from the stream so far...
 {
    PDATALIST pdlMessage;
	 pdlMessage = jsox_parse_get_data( parser );
    if( pdlMessage )
	 {
        int index;
        struct jsox_value_container *value;
        DATALIST_FORALL( pdlMessage, index, struct jsox_value_container *. value ) {
           /* for each value in the result.... the first layer will
           always be just one element, either a simple type, or a VALUE_ARRAY or VALUE_OBJECT, which
           then for each value->contains (as a datalist like above), process each of those values.
        }
        jsox_dispose_mesage( &pdlMessage );
		  jsox_parse_add_data( parser, NULL, 0 ); // trigger parsing next message.
	 }
 }
 *
 ***************************************************************/
#ifndef JSOX_PARSER_HEADER_INCLUDED
#define JSOX_PARSER_HEADER_INCLUDED
#define JSON_EMITTER_HEADER_INCLUDED
// include types to get namespace, and, well PDATALIST types
#ifdef __cplusplus
SACK_NAMESPACE namespace network {
	namespace jsox {
#endif
#ifdef JSOX_PARSER_SOURCE
#  define JSOX_PARSER_PROC(type,name) EXPORT_METHOD type name
#else
#  define JSOX_PARSER_PROC(type,name) IMPORT_METHOD type name
#endif
enum jsox_value_types {
	JSOX_VALUE_UNDEFINED = -1
	, JSOX_VALUE_UNSET = 0
 //= 1 no data
	, JSOX_VALUE_NULL
 //= 2 no data
	, JSOX_VALUE_TRUE
 //= 3 no data
	, JSOX_VALUE_FALSE
 //= 4 string
	, JSOX_VALUE_STRING
 //= 5 string + result_d | result_n
	, JSOX_VALUE_NUMBER
 //= 6 contains
	, JSOX_VALUE_OBJECT
 //= 7 contains
	, JSOX_VALUE_ARRAY
	// up to here is supported in JSON
 //= 8 no data
	, JSOX_VALUE_NEG_NAN
 //= 9 no data
	, JSOX_VALUE_NAN
 //= 10 no data
	, JSOX_VALUE_NEG_INFINITY
 //= 11 no data
	, JSOX_VALUE_INFINITY
  // = 12 comes in as a number, string is data.
	, JSOX_VALUE_DATE
 // = 13 string data, needs bigint library to process...
	, JSOX_VALUE_BIGINT
 // = 14 no data; used in [,,,] as place holder of empty
	, JSOX_VALUE_EMPTY
  // = 15 string is base64 encoding of bytes.
	, JSOX_VALUE_TYPED_ARRAY
  // = 14 string is base64 encoding of bytes.
	, JSOX_VALUE_TYPED_ARRAY_MAX = JSOX_VALUE_TYPED_ARRAY +12
};
struct jsox_value_container {
  // name of this value (if it's contained in an object)
	char * name;
	size_t nameLen;
 // value from above indiciating the type of this value
	enum jsox_value_types value_type;
   // the string value of this value (strings and number types only)
	char *string;
	size_t stringLen;
  // boolean whether to use result_n or result_d
	int float_result;
	union {
		double result_d;
		int64_t result_n;
		//struct json_value_container *nextToken;
	};
  // list of struct json_value_container that this contains.
	PDATALIST contains;
  // acutal source datalist(?)
	PDATALIST *_contains;
  // if VALUE_OBJECT or VALUE_TYPED_ARRAY; this may be non NULL indicating what the class name is.
	char *className;
};
// allocates a JSOX parsing context and is prepared to begin parsing data.
JSOX_PARSER_PROC( struct jsox_parse_state *, jsox_begin_parse )(void);
// clear state; after an error state, this can allow reusing a state.
JSOX_PARSER_PROC( void, jsox_parse_clear_state )( struct jsox_parse_state *state );
// destroy current parse state.
JSOX_PARSER_PROC( void, jsox_parse_dispose_state )(struct jsox_parse_state **ppState);
// return >0 when a completed value/object is available.
// after returning >0, call json_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns 0, then ther is no further object
// to retrieve.  If this return -1 there was an error, and use jsox_parse_get_error() to
// retrieve the error text.
JSOX_PARSER_PROC( int, jsox_parse_add_data )(struct jsox_parse_state *context
	, const char * msg
	, size_t msglen
	);
JSOX_PARSER_PROC( PTEXT, jsox_parse_get_error )(struct jsox_parse_state *state);
JSOX_PARSER_PROC( PDATALIST, jsox_parse_get_data )(struct jsox_parse_state *context);
// single all-in-one parsing of an input buffer.
JSOX_PARSER_PROC( LOGICAL, jsox_parse_message )(const char * msg
	, size_t msglen
	, PDATALIST *msg_data_out
	);
// release all resources of a message from jsox_parse_message or jsox_parse_get_data
JSOX_PARSER_PROC( void, jsox_dispose_message )(PDATALIST *msg_data);
JSOX_PARSER_PROC( char *, jsox_escape_string_length )(const char *string, size_t len, size_t *outlen);
JSOX_PARSER_PROC( char *, jsox_escape_string )(const char *string);
#ifdef __cplusplus
} } SACK_NAMESPACE_END
using namespace sack::network::jsox;
#endif
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace jsox {
#endif
#if JSOX_EMITTER_WORKS
struct json_context_object_element
{
     // type of the element at this offset
	enum JSON_ObjectElementTypes type;
     // type of the element at this offset
	enum JSON_ObjectElementTypes content_type;
  // how big this element is.
	size_t object_size;
   // offset into the structure
	size_t offset;
 // name of this element in the object
	CTEXTSTR name;
 // at offset, this number of these is there; (array)
	size_t count;
 // at count_offset, is the number of elements that the pointer at this offset
	size_t count_offset;
	void (*user_formatter)(PVARTEXT pvt_output,CPOINTER msg_data);
	struct json_context_object *object;
};
struct json_context_object
{
	struct json_context *context;
   // list of members of this object struct json_context_object_element *
	PLIST members;
 // if set is an array format, otherwise is an object format.
	int is_array;
	size_t object_size;
	size_t offset;
	struct json_context_object_flags
	{
  // this is not a root object
		BIT_FIELD keep_phrase : 1;
		BIT_FIELD dynamic_size : 1;
	} flags;
	struct json_context_object *parent;
};
struct json_context
{
	int levels;
	PVARTEXT pvt;
	PLIST object_types;
	int human_readable;
};
#endif
enum jsox_word_char_states {
 // not in a keyword
	JSOX_WORD_POS_RESET = 0,
  // at end of a word, waiting for separator
	JSOX_WORD_POS_END,
	JSOX_WORD_POS_TRUE_1,
	JSOX_WORD_POS_TRUE_2,
	JSOX_WORD_POS_TRUE_3,
	//JSOX_WORD_POS_TRUE_4,
 // 11
	JSOX_WORD_POS_FALSE_1,
	JSOX_WORD_POS_FALSE_2,
	JSOX_WORD_POS_FALSE_3,
	JSOX_WORD_POS_FALSE_4,
 // 21  get u
	JSOX_WORD_POS_NULL_1,
 //  get l
	JSOX_WORD_POS_NULL_2,
 // 10 get l
	JSOX_WORD_POS_NULL_3,
  // 31
	JSOX_WORD_POS_UNDEFINED_1,
	JSOX_WORD_POS_UNDEFINED_2,
	JSOX_WORD_POS_UNDEFINED_3,
	JSOX_WORD_POS_UNDEFINED_4,
	JSOX_WORD_POS_UNDEFINED_5,
	JSOX_WORD_POS_UNDEFINED_6,
	JSOX_WORD_POS_UNDEFINED_7,
	JSOX_WORD_POS_UNDEFINED_8,
	//JSOX_WORD_POS_UNDEFINED_9, // instead of stepping to this value here, go to RESET
	JSOX_WORD_POS_NAN_1,
  // 20
	JSOX_WORD_POS_NAN_2,
	//JSOX_WORD_POS_NAN_3,// instead of stepping to this value here, go to RESET
	JSOX_WORD_POS_INFINITY_1,
	JSOX_WORD_POS_INFINITY_2,
	JSOX_WORD_POS_INFINITY_3,
	JSOX_WORD_POS_INFINITY_4,
	JSOX_WORD_POS_INFINITY_5,
	JSOX_WORD_POS_INFINITY_6,
	JSOX_WORD_POS_INFINITY_7,
	//JSOX_WORD_POS_INFINITY_8,// instead of stepping to this value here, go to RESET
	JSOX_WORD_POS_FIELD,
	JSOX_WORD_POS_AFTER_FIELD,
 // 30
	JSOX_WORD_POS_DOT_OPERATOR,
	JSOX_WORD_POS_PROPER_NAME,
	JSOX_WORD_POS_AFTER_PROPER_NAME,
	JSOX_WORD_POS_AFTER_GET,
	JSOX_WORD_POS_AFTER_SET,
  //36
	JSOX_WORD_POS_CLASS_NAME,
 // 37
	JSOX_WORD_POS_CLASS_VALUES,
};
enum jsox_parse_context_modes {
	JSOX_CONTEXT_UNKNOWN = 0,
	JSOX_CONTEXT_IN_ARRAY = 1,
	//JSOX_CONTEXT_IN_OBJECT = 2,
	JSOX_CONTEXT_OBJECT_FIELD = 3,
	JSOX_CONTEXT_OBJECT_FIELD_VALUE = 4,
	JSOX_CONTEXT_CLASS_FIELD = 5,
	JSOX_CONTEXT_CLASS_VALUE = 6,
};
#define JSOX_RESET_VAL()  {	  val.value_type = JSOX_VALUE_UNSET;	 val.contains = NULL;	              val._contains = NULL;	             val.name = NULL;	                  val.string = NULL;	                val.className = NULL;	             negative = FALSE; }
#define JSOX_RESET_STATE_VAL()  {	  state->val.value_type = JSOX_VALUE_UNSET;	 state->val.contains = NULL;	              state->val._contains = NULL;	             state->val.name = NULL;	                  state->val.string = NULL;	                state->val.className = NULL;	             state->negative = FALSE; }
struct jsox_input_buffer {
      // prior input buffer
	char const * buf;
 // size of prior input buffer
	size_t       size;
  // last position in _input if context closed before end of buffer
	char const * pos;
};
struct jsox_output_buffer {
      // prior input buffer
	char * buf;
 // size of prior input buffer
	size_t  size;
  // last position in _input if context closed before end of buffer
	char * pos;
};
typedef struct jsox_input_buffer JSOX_PARSE_BUFFER, *PJSOX_PARSE_BUFFER;
#define MAXJSOX_PARSE_BUFFERSPERSET 128
DeclareSet( JSOX_PARSE_BUFFER );
struct jsox_class_field {
	char *name;
	size_t nameLen;
};
typedef struct jsox_class_field JSOX_CLASS_FIELD, *PJSOX_CLASS_FIELD;
#define MAXJSOX_CLASS_FIELDSPERSET 128
DeclareSet( JSOX_CLASS_FIELD );
struct jsox_class_type {
	char *name;
	size_t nameLen;
	PLIST fields;
};
typedef struct jsox_class_type JSOX_CLASS, *PJSOX_CLASS;
#define MAXJSOX_CLASSSPERSET 128
DeclareSet( JSOX_CLASS );
struct jsox_parse_context {
	enum jsox_parse_context_modes context;
	PDATALIST *elements;
	char *name;
	size_t nameLen;
	struct jsox_value_container valState;
	//struct jsox_context_object *object;
	PJSOX_CLASS current_class;
	int current_class_item;
	int arrayType;
};
typedef struct jsox_parse_context JSOX_PARSE_CONTEXT, *PJSOX_PARSE_CONTEXT;
#define MAXJSOX_PARSE_CONTEXTSPERSET 128
DeclareSet( JSOX_PARSE_CONTEXT );
// this is the stack state that can be saved between parsing for streaming.
struct jsox_parse_state {
	//TEXTRUNE c;
	PDATALIST *elements;
 //
	PLINKSTACK *outBuffers;
 // matches input queue
	PLINKQUEUE *outQueue;
	PLIST *outValBuffers;
	//TEXTSTR mOut;// = NewArray( char, msglen );
	size_t line;
	size_t col;
 // character index;
	size_t n;
	//size_t _n = 0; // character index; (restore1)
	enum jsox_word_char_states word;
	LOGICAL status;
	LOGICAL negative;
	LOGICAL literalString;
	PLINKSTACK *context_stack;
	PLIST classes;
	PJSOX_CLASS current_class;
	int current_class_item;
	int arrayType;
	LOGICAL first_token;
	PJSOX_PARSE_CONTEXT context;
	enum jsox_parse_context_modes parse_context;
	struct jsox_value_container val;
	int comment;
	TEXTRUNE operatorAccum;
	PLINKQUEUE *inBuffers;
	//char const * input;     // current input buffer start
	//char const * msg_input; // current input buffer position (incremented while reading)
	LOGICAL completed;
	LOGICAL complete_at_end;
	LOGICAL gatheringString;
	TEXTRUNE gatheringStringFirstChar;
	TEXTRUNE gatheringCodeLastChar;
	int codeDepth;
	LOGICAL gatheringNumber;
	LOGICAL numberExponent;
	LOGICAL numberFromHex;
	LOGICAL numberFromDate;
	LOGICAL numberFromBigInt;
	PVARTEXT pvtError;
	LOGICAL fromHex;
	LOGICAL exponent;
	LOGICAL exponent_sign;
	LOGICAL exponent_digit;
	LOGICAL escape;
	LOGICAL cr_escaped;
	LOGICAL unicodeWide;
	LOGICAL stringUnicode;
	LOGICAL stringHex;
	TEXTRUNE hex_char;
	int hex_char_len;
	LOGICAL stringOct;
	LOGICAL weakSpace;
	PDATALIST root;
	//char *token_begin;
};
typedef struct jsox_parse_state JSOX_PARSE_STATE, *PJSOX_PARSE_STATE;
#define MAXJSOX_PARSE_STATESPERSET 32
DeclareSet( JSOX_PARSE_STATE );
#ifndef JSON_PARSER_INCLUDED
typedef PLIST *PPLIST;
#define MAXPLISTSPERSET 256
DeclareSet( PLIST );
typedef PLINKSTACK *PPLINKSTACK;
#define MAXPLINKSTACKSPERSET 256
DeclareSet( PLINKSTACK );
typedef PLINKQUEUE *PPLINKQUEUE;
#define MAXPLINKQUEUESPERSET 256
DeclareSet( PLINKQUEUE );
typedef PDATALIST *PPDATALIST;
#define MAXPDATALISTSPERSET 256
DeclareSet( PDATALIST );
#endif
struct jsox_parser_shared_data {
	PJSOX_PARSE_CONTEXTSET parseContexts;
	PJSOX_PARSE_BUFFERSET parseBuffers;
	struct jsox_parse_state *last_parse_state;
	PJSOX_PARSE_STATESET parseStates;
	PPLISTSET listSet;
	PPLINKSTACKSET linkStacks;
	PPLINKQUEUESET linkQueues;
	PPDATALISTSET dataLists;
	PJSOX_CLASSSET  classes;
	PJSOX_CLASS_FIELDSET  class_fields;
};
#ifndef JSOX_PARSER_MAIN_SOURCE
extern
#endif
struct jsox_parser_shared_data jxpsd;
void _jsox_dispose_message( PDATALIST *msg_data );
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
//#define DEBUG_PARSING
/*
Code Point	Name	Abbreviation	Usage
U+200C	ZERO WIDTH NON-JOINER	<ZWNJ>	IdentifierPart
U+200D	ZERO WIDTH JOINER	<ZWJ>	IdentifierPart
U+FEFF	ZERO WIDTH NO-BREAK SPACE	<ZWNBSP>	WhiteSpace
*/
/*
ID_Start       XID_Start        Uppercase letters, lowercase letters, titlecase letters, modifier letters
                                , other letters, letter numbers, stability extensions
ID_Continue    XID_Continue     All of the above, plus nonspacing marks, spacing combining marks, decimal numbers
                                , connector punctuations, stability extensions.
                                These are also known simply as Identifier Characters, since they are a superset of
                                the ID_Start. The set of ID_Start characters minus the ID_Continue characters are
                                known as ID_Only_Continue characters.
*/
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace jsox {
#endif
PLIST knownArrayTypeNames;
static void registerKnownArrayTypeNames(void) {
	AddLink( &knownArrayTypeNames, "ab" );
	AddLink( &knownArrayTypeNames, "u8" );
	AddLink( &knownArrayTypeNames, "cu8" );
	AddLink( &knownArrayTypeNames, "s8" );
	AddLink( &knownArrayTypeNames, "u16" );
	AddLink( &knownArrayTypeNames, "s16" );
	AddLink( &knownArrayTypeNames, "u32" );
	AddLink( &knownArrayTypeNames, "s32" );
	AddLink( &knownArrayTypeNames, "u64" );
	AddLink( &knownArrayTypeNames, "s64" );
	AddLink( &knownArrayTypeNames, "f32" );
	AddLink( &knownArrayTypeNames, "f64" );
	AddLink( &knownArrayTypeNames, "ref" );
}
static void jsox_state_init( struct jsox_parse_state *state )
{
	PPDATALIST ppElements;
	PPLIST ppList;
	PPLINKQUEUE ppQueue;
	PPLINKSTACK ppStack;
	ppElements = GetFromSet( PDATALIST, &jxpsd.dataLists );
	if( !ppElements[0] ) ppElements[0] = CreateDataList( sizeof( state->val ) );
	state->elements = ppElements;
	state->elements[0]->Cnt = 0;
	ppStack = GetFromSet( PLINKSTACK, &jxpsd.linkStacks );
	if( !ppStack[0] ) ppStack[0] = CreateLinkStack();
	state->outBuffers = ppStack;
	state->outBuffers[0]->Top = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &jxpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->inBuffers = ppQueue;
	state->inBuffers[0]->Top = state->inBuffers[0]->Bottom = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &jxpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->outQueue = ppQueue;
	state->outQueue[0]->Top = state->outQueue[0]->Bottom = 0;
	ppList = GetFromSet( PLIST, &jxpsd.listSet );
	if( ppList[0] ) ppList[0]->Cnt = 0;
	state->outValBuffers = ppList;
	state->line = 1;
	state->col = 1;
 // character index;
	state->n = 0;
	state->word = JSOX_WORD_POS_RESET;
	state->status = TRUE;
	state->negative = FALSE;
	state->current_class = NULL;
	state->current_class_item = 0;
	state->arrayType = -1;
// NULL;
	state->context_stack = GetFromSet( PLINKSTACK, &jxpsd.linkStacks );
	if( state->context_stack[0] ) state->context_stack[0]->Top = 0;
	//state->first_token = TRUE;
	state->context = GetFromSet( JSOX_PARSE_CONTEXT, &jxpsd.parseContexts );
	state->parse_context = JSOX_CONTEXT_UNKNOWN;
	state->comment = 0;
	state->completed = FALSE;
	//state->mOut = msg;// = NewArray( char, msglen );
	//state->msg_input = (char const *)msg;
	state->val.value_type = JSOX_VALUE_UNSET;
	state->val.contains = NULL;
	state->val._contains = NULL;
	state->val.name = NULL;
	state->val.string = NULL;
	state->complete_at_end = FALSE;
	state->gatheringString = FALSE;
	state->gatheringNumber = FALSE;
	state->pvtError = NULL;
}
/* I guess this is a good parser */
struct jsox_parse_state * jsox_begin_parse( void )
{
//New( struct json_parse_state );
	struct jsox_parse_state *state = GetFromSet( JSOX_PARSE_STATE, &jxpsd.parseStates );
	jsox_state_init( state );
	return state;
}
char *jsox_escape_string_length( const char *string, size_t len, size_t *outlen ) {
	size_t m = 0;
	size_t ch;
	const char *input;
	TEXTSTR output;
	TEXTSTR _output;
	if( !( input = string ) ) return NULL;
	for( ch = 0; ch < len; ch++, input++ ) {
 /*|| (input[0] == '\n') || (input[0] == '\t')*/
		if( (input[0] == '"' ) || (input[0] == '\\' ) || (input[0] == '`') || (input[0] == '\'') )
			m++;
	}
	_output = output = NewArray( TEXTCHAR, len+m+1 );
	for( (ch = 0), (input = string); ch < len; ch++, input++ ) {
		if( (input[0] == '"' ) || (input[0] == '\\' ) || (input[0] == '`' )|| (input[0] == '\'' )) {
			(*output++) = '\\';
		}
		(*output++) = input[0];
	}
	(*output) = 0;
	if( outlen ) (*outlen) = output - _output;
	return _output;
}
char *jsox_escape_string( const char *string ) {
	return jsox_escape_string_length( string, strlen( string ), NULL );
}
#define _2char(result,from) (((*from) += 2),( ( result & 0x1F ) << 6 ) | ( ( result & 0x3f00 )>>8))
#define _zero(result,from)  ((*from)++,0)
#define _3char(result,from) ( ((*from) += 3),( ( ( result & 0xF ) << 12 ) | ( ( result & 0x3F00 ) >> 2 ) | ( ( result & 0x3f0000 ) >> 16 )) )
#define _4char(result,from)  ( ((*from) += 4), ( ( ( result & 0x7 ) << 18 )						     | ( ( result & 0x3F00 ) << 4 )						   | ( ( result & 0x3f0000 ) >> 10 )						    | ( ( result & 0x3f000000 ) >> 24 ) ) )
#define __GetUtfChar( result, from )           ((result = ((TEXTRUNE*)*from)[0]),		     ( ( !(result & 0xFF) )              ?_zero(result,from)	                                                    :( ( result & 0x80 )		                       ?( ( result & 0xE0 ) == 0xC0 )			   ?( ( ( result & 0xC000 ) == 0x8000 ) ?_2char(result,from) : _zero(result,from)  )			    :( ( ( result & 0xF0 ) == 0xE0 )				                           ?( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) ) ? _3char(result,from) : _zero(result,from)  )				   :( ( ( result & 0xF8 ) == 0xF0 )		                       ? ( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) && ( ( result & 0xC0000000 ) == 0x80000000 ) )					  ?_4char(result,from):_zero(result,from) )				                                                                                                                  :( ( ( result & 0xC0 ) == 0x80 )					                                                                                                  ?_zero(result,from)					                                                                                                                       : ( (*from)++, (result & 0x7F) ) ) ) )		                                                                                       : ( (*from)++, (result & 0x7F) ) ) ) )
#define GetUtfChar(x) __GetUtfChar(c,x)
static int gatherString6(struct jsox_parse_state *state, CTEXTSTR msg, CTEXTSTR *msg_input, size_t msglen, TEXTSTR *pmOut, TEXTRUNE start_c
		//, int literalString
		) {
	char *mOut = (*pmOut);
	// collect a string
	int status = 0;
	size_t n;
	//int escape;
	//LOGICAL cr_escaped;
	TEXTRUNE c;
	//escape = 0;
	//cr_escaped = FALSE;
	while( ( ( n = (*msg_input) - msg ), ( n < msglen ) ) && ( ( c = GetUtfChar( msg_input ) ), ( status >= 0 ) ) )
	{
		(state->col)++;
		if( c == start_c ) {
			if( state->escape ) { ( *mOut++ ) = c; state->escape = FALSE; }
			else if( c == start_c ) {
				status = 1;
				break;
 // other else is not valid close quote; just store as content.
			} else ( *mOut++ ) = c;
		} else if( state->escape ) {
			if( state->stringOct ) {
/*'0'*/
/*'9'*/
				if( state->hex_char_len < 3 && c >= 48 && c <= 57 ) {
					state->hex_char *= 8;
/*.codePointAt(0)*/
					state->hex_char += c - 0x30;
					state->hex_char_len++;
					if( state->hex_char_len == 3 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringOct = FALSE;
						state->escape = FALSE;
						continue;
					}
					continue;
				} else {
					if( state->hex_char > 255 ) {
						lprintf(WIDE("(escaped character, parsing octal escape val=%d) fault while parsing; )") WIDE(" (near %*.*s[%c]%s)")
							, state->hex_char
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						break;
					}
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringOct = FALSE;
					state->escape = FALSE;
					continue;
				}
			} else if( state->unicodeWide ) {
				if( c == '}' ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->unicodeWide = FALSE;
					state->stringUnicode = FALSE;
					state->escape = FALSE;
					continue;
				}
				state->hex_char *= 16;
				if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
				else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
				else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
				else {
					lprintf(WIDE("(escaped character, parsing hex of \\u) fault while parsing; '%c' unexpected at %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
						, (int)( ( n > 3 ) ? 3 : n ), (int)( ( n > 3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n > 3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
					state->unicodeWide = FALSE;
					state->escape = FALSE;
				}
				continue;
			} else if( state->stringHex || state->stringUnicode ) {
				if( state->hex_char_len == 0 && c == '{' ) {
					state->unicodeWide = TRUE;
					continue;
				}
				if( state->hex_char_len < 2 || ( state->stringUnicode && state->hex_char_len < 4 ) ) {
					state->hex_char *= 16;
					if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
					else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
					else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
					else {
						lprintf(WIDE("(escaped character, parsing hex of \\x) fault while parsing; '%c' unexpected at %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						state->stringHex = FALSE;
						state->escape = FALSE;
						continue;
					}
				}
				state->hex_char_len++;
				if( state->stringUnicode ) {
					if( state->hex_char_len == 4 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringUnicode = FALSE;
						state->escape = FALSE;
					}
				} else if( state->hex_char_len == 2 ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringHex = FALSE;
					state->escape = FALSE;
				}
				continue;
			}
			switch( c ) {
			case '\r':
				state->cr_escaped = TRUE;
				continue;
			case '\n':
				state->line++;
				state->col = 1;
				if( state->cr_escaped ) state->cr_escaped = FALSE;
				// fall through to clear escape status <CR><LF> support.
 // LS (Line separator)
			case 2028:
 // PS (paragraph separate)
			case 2029:
				continue;
			case '/':
			case '\\':
			case '\'':
			case '"':
			case '`':
				( *mOut++ ) = c;
				break;
			case 't':
				( *mOut++ ) = '\t';
				break;
			case 'b':
				( *mOut++ ) = '\b';
				break;
			case 'n':
				( *mOut++ ) = '\n';
				break;
			case 'r':
				( *mOut++ ) = '\r';
				break;
			case 'f':
				( *mOut++ ) = '\f';
				break;
			case '0': case '1': case '2': case '3':
				state->stringOct = TRUE;
				state->hex_char = c - 48;
				state->hex_char_len = 1;
				continue;
			case 'x':
				state->stringHex = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			case 'u':
				state->stringUnicode = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			default:
				if( state->cr_escaped ) {
					state->cr_escaped = FALSE;
					state->escape = FALSE;
					mOut += ConvertToUTF8(mOut, c);
				} else {
					lprintf(WIDE("(escaped character) fault while parsing; '%c' unexpected %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
						, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
				}
				break;
			}
			state->escape = 0;
		} else if( c == '\\' ) {
			if( state->escape ) {
				(*mOut++) = '\\';
				state->escape = 0;
			}
			else state->escape = 1;
		}
		else
		{
			if( state->cr_escaped ) {
				state->cr_escaped = FALSE;
				if( c == '\n' ) {
					state->line++;
					state->col = 1;
					state->escape = FALSE;
					continue;
				}
			}
			mOut += ConvertToUTF8( mOut, c );
		}
	}
	if( status )
  // terminate the string.
		(*mOut++) = 0;
	(*pmOut) = mOut;
	return status;
}
static int recoverIdent( struct jsox_parse_state *state, struct jsox_output_buffer* output, int cInt );
static int openObject( struct jsox_parse_state *state, struct jsox_output_buffer* output, int c ) {
	enum jsox_parse_context_modes nextMode;
	PJSOX_CLASS cls = NULL;
	//let tmpobj = {};
	if( state->word > JSOX_WORD_POS_RESET && state->word < JSOX_WORD_POS_FIELD )
		recoverIdent( state, output, -1 );
	if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
 /*|| state->word == JSOX_WORD_POS_AFTER_FIELD*/
		if( state->word == JSOX_WORD_POS_FIELD ) {
			INDEX idx;
			(*output->pos++) = 0;
#ifdef DEBUG_PARSING
			lprintf( "define class: %*.*s", output->pos - state->val.string, output->pos - state->val.string, state->val.string );
#endif
			LIST_FORALL( state->classes, idx, PJSOX_CLASS, cls )
				if( strcmp( cls->name, state->val.string ) == 0 )
					break;
			if( !cls ) {
				cls = GetFromSet( JSOX_CLASS, &jxpsd.classes );
				cls->name = state->val.string;
				cls->nameLen = output->pos - state->val.string;
				cls->fields = NULL;
				AddLink( &state->classes, cls );
				nextMode = JSOX_CONTEXT_CLASS_FIELD;
			} else {
				//tmpobj = Object.assign( tmpobj, cls.protoObject );
				//Object.setPrototypeOf( tmpobj, Object.getPrototypeOf( cls.protoObject ) );
				nextMode = JSOX_CONTEXT_CLASS_VALUE;
			}
			state->word = JSOX_WORD_POS_RESET;
		}
		else {
			nextMode = JSOX_CONTEXT_OBJECT_FIELD;
			state->word = JSOX_WORD_POS_FIELD;
		}
 /*|| state->word == JSOX_WORD_POS_AFTER_FIELD*/
	} else if( state->word == JSOX_WORD_POS_FIELD || state->parse_context == JSOX_CONTEXT_IN_ARRAY || state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE ) {
		if( state->word != JSOX_WORD_POS_RESET ) {
			INDEX idx;
			(*output->pos++) = 0;
			LIST_FORALL( state->classes, idx, PJSOX_CLASS, cls )
				if( strcmp( cls->name, state->val.string ) == 0 )
					break;
			if( !cls ) lprintf( "Referenced class %s has not been defined", state->val.string );
			nextMode = JSOX_CONTEXT_CLASS_VALUE;
			state->word = JSOX_WORD_POS_RESET;
		}
		else {
			nextMode = JSOX_CONTEXT_OBJECT_FIELD;
			state->word = JSOX_WORD_POS_RESET;
		}
	} else if( (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD && state->word == JSOX_WORD_POS_RESET) ) {
		if( !state->pvtError ) state->pvtError = VarTextCreate();
		vtprintf( state->pvtError, "Fault while parsing; getting field name unexpected '%c' at %" _size_f " %" _size_f ":%" _size_f, c, state->n, state->line, state->col );
		state->status = FALSE;
		return FALSE;
	}
	else
		nextMode = JSOX_CONTEXT_OBJECT_FIELD;
	// common code; create new object container layer...
	{
		struct jsox_parse_context *old_context = GetFromSet( JSOX_PARSE_CONTEXT, &jxpsd.parseContexts );
#ifdef DEBUG_PARSING
		lprintf( "Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d", state->val.value_type );
#endif
		old_context->context = state->parse_context;
		old_context->elements = state->elements;
		old_context->name = state->val.name;
		old_context->nameLen = state->val.nameLen;
		old_context->current_class = state->current_class;
		old_context->current_class_item = state->current_class_item;
		old_context->arrayType = state->arrayType;
		state->current_class = cls;
		state->current_class_item = 0;
// CreateDataList( sizeof( state->val ) );
		state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
		if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
		else state->elements[0]->Cnt = 0;
		PushLink( state->context_stack, old_context );
		JSOX_RESET_STATE_VAL();
		state->parse_context = nextMode;
	}
	return TRUE;
}
static LOGICAL openArray( struct jsox_parse_state *state, struct jsox_output_buffer* output, int c ) {
	if( state->word > JSOX_WORD_POS_RESET && state->word < JSOX_WORD_POS_FIELD )
		recoverIdent(state,output,c);
	if( state->word == JSOX_WORD_POS_FIELD ) {
		char *name;
// = knownArrayTypeNames.findIndex( type = > (type == = val.string) );
		INDEX typeIndex;
		(*output->pos++) = 0;
#ifdef DEBUG_PARSING
		lprintf( "define typed array:%s", state->val.string );
#endif
		if( !knownArrayTypeNames ) registerKnownArrayTypeNames();
		LIST_FORALL( knownArrayTypeNames, typeIndex, char *, name ) {
			if( strcmp( state->val.string, name ) == 0 )
				break;
		}
		if( typeIndex < 13 ) {
			state->word = JSOX_WORD_POS_FIELD;
			state->arrayType = typeIndex;
#ifdef DEBUG_PARSING
			lprintf( "setup array type... %d", typeIndex );
#endif
			state->val.string = output->pos;
		}
		else {
			if( !state->pvtError ) state->pvtError = VarTextCreate();
			vtprintf( state->pvtError, WIDE( "Unknown type specified for array:; %s at '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
				, state->val.string, c, state->n, state->line, state->col );
			state->status = FALSE;
			return FALSE;
		}
	} else if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) {
		if( !state->pvtError ) state->pvtError = VarTextCreate();
		vtprintf( state->pvtError, WIDE( "Fault while parsing; while getting field name unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
		state->status = FALSE;
		return FALSE;
	}
	{
		struct jsox_parse_context *old_context = GetFromSet( JSOX_PARSE_CONTEXT, &jxpsd.parseContexts );
#ifdef DEBUG_PARSING
		lprintf( "Begin a new array; previously pushed into elements; but wait until trailing comma or close previously:%d", state->val.value_type );
#endif
		old_context->context = state->parse_context;
		old_context->elements = state->elements;
		old_context->name = state->val.name;
		old_context->nameLen = state->val.nameLen;
		old_context->current_class = state->current_class;
		old_context->current_class_item = state->current_class_item;
		old_context->arrayType = state->arrayType;
		state->current_class = NULL;
		state->current_class_item = 0;
		state->arrayType = -1;
// CreateDataList( sizeof( state->val ) );
		state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
		if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
		else state->elements[0]->Cnt = 0;
		PushLink( state->context_stack, old_context );
		JSOX_RESET_STATE_VAL();
		state->parse_context = JSOX_CONTEXT_IN_ARRAY;
	}
	return TRUE;
}
int recoverIdent( struct jsox_parse_state *state, struct jsox_output_buffer* output, int cInt ) {
	if( state->word != JSOX_WORD_POS_RESET ) {
		if( !state->val.string ) {
#ifdef DEBUG_PARSINGs
			lprintf( "Updating string postion?" );
#endif
			state->val.string = output->pos;
		}
		if( state->word == JSOX_WORD_POS_END ) {
			switch( state->val.value_type ) {
			case JSOX_VALUE_TRUE:
				(*output->pos++) = 't';
				(*output->pos++) = 'r';
				(*output->pos++) = 'u';
				(*output->pos++) = 'e';
				break;
			case JSOX_VALUE_FALSE:
				(*output->pos++) = 'f';
				(*output->pos++) = 'a';
				(*output->pos++) = 'l';
				(*output->pos++) = 's';
				(*output->pos++) = 'e';
				break;
			case JSOX_VALUE_NULL:
				(*output->pos++) = 'n';
				(*output->pos++) = 'u';
				(*output->pos++) = 'l';
				(*output->pos++) = 'l';
				break;
			case JSOX_VALUE_UNDEFINED:
				(*output->pos++) = 'u';
				(*output->pos++) = 'n';
				(*output->pos++) = 'd';
				(*output->pos++) = 'e';
				(*output->pos++) = 'f';
				(*output->pos++) = 'i';
				(*output->pos++) = 'n';
				(*output->pos++) = 'e';
				(*output->pos++) = 'd';
				break;
			case JSOX_VALUE_NEG_NAN:
				(*output->pos++) = '-';
			case JSOX_VALUE_NAN:
				(*output->pos++) = 'N';
				(*output->pos++) = 'a';
				(*output->pos++) = 'N';
				break;
			case JSOX_VALUE_NEG_INFINITY:
				(*output->pos++) = '-';
			case JSOX_VALUE_INFINITY:
				(*output->pos++) = 'I';
				(*output->pos++) = 'n';
				(*output->pos++) = 'f';
				(*output->pos++) = 'i';
				(*output->pos++) = 'n';
				(*output->pos++) = 'i';
				(*output->pos++) = 't';
				(*output->pos++) = 'y';
				break;
			}
		}
		switch( state->word ) {
		case JSOX_WORD_POS_TRUE_1:
			(*output->pos++) = 't';
			break;
		case JSOX_WORD_POS_TRUE_2:
			(*output->pos++) = 't';
			(*output->pos++) = 'r';
			break;
		case JSOX_WORD_POS_TRUE_3:
			(*output->pos++) = 't';
			(*output->pos++) = 'r';
			(*output->pos++) = 'u';
			break;
 // 11
		case JSOX_WORD_POS_FALSE_1:
			(*output->pos++) = 'f';
			break;
		case JSOX_WORD_POS_FALSE_2:
			(*output->pos++) = 'f';
			(*output->pos++) = 'a';
			break;
		case JSOX_WORD_POS_FALSE_3:
			(*output->pos++) = 'f';
			(*output->pos++) = 'a';
			(*output->pos++) = 'l';
			break;
		case JSOX_WORD_POS_FALSE_4:
			(*output->pos++) = 'f';
			(*output->pos++) = 'a';
			(*output->pos++) = 'l';
			(*output->pos++) = 's';
			break;
 // 21  get u
		case JSOX_WORD_POS_NULL_1:
			(*output->pos++) = 'n';
			break;
 //  get l
		case JSOX_WORD_POS_NULL_2:
			(*output->pos++) = 'n';
			(*output->pos++) = 'u';
			break;
 //  get l
		case JSOX_WORD_POS_NULL_3:
			(*output->pos++) = 'n';
			(*output->pos++) = 'u';
			(*output->pos++) = 'l';
			break;
  // 31
		case JSOX_WORD_POS_UNDEFINED_1:
			(*output->pos++) = 'u';
			break;
		case JSOX_WORD_POS_UNDEFINED_2:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_UNDEFINED_3:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			break;
		case JSOX_WORD_POS_UNDEFINED_4:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			break;
		case JSOX_WORD_POS_UNDEFINED_5:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			break;
		case JSOX_WORD_POS_UNDEFINED_6:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			break;
		case JSOX_WORD_POS_UNDEFINED_7:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_UNDEFINED_8:
			(*output->pos++) = 'u';
			(*output->pos++) = 'n';
			(*output->pos++) = 'd';
			(*output->pos++) = 'e';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			(*output->pos++) = 'e';
			break;
		case JSOX_WORD_POS_NAN_1:
			(*output->pos++) = 'N';
			break;
		case JSOX_WORD_POS_NAN_2:
			(*output->pos++) = 'N';
			(*output->pos++) = 'a';
			break;
		case JSOX_WORD_POS_INFINITY_1:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			break;
		case JSOX_WORD_POS_INFINITY_2:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_INFINITY_3:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			break;
		case JSOX_WORD_POS_INFINITY_4:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			break;
		case JSOX_WORD_POS_INFINITY_5:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			break;
		case JSOX_WORD_POS_INFINITY_6:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			(*output->pos++) = 'i';
			break;
		case JSOX_WORD_POS_INFINITY_7:
			if( state->negative )
				(*output->pos++) = '-';
			(*output->pos++) = 'I';
			(*output->pos++) = 'n';
			(*output->pos++) = 'f';
			(*output->pos++) = 'i';
			(*output->pos++) = 'n';
			(*output->pos++) = 'i';
			(*output->pos++) = 't';
			break;
		}
	}
#ifdef DEBUG_PARSING
	lprintf( "RECOVER IDENT: TURN INTO FIELD NAME" );
#endif
	state->word = JSOX_WORD_POS_FIELD;
	state->negative = FALSE;
	state->val.value_type = JSOX_VALUE_STRING;
/*'{'*/
	if( cInt == 123 )
		openObject( state, output, cInt );
/*'['*/
	else if( cInt == 91 )
		openArray( state, output, cInt );
	else if( cInt >= 0 ) {
		// ignore white space.
/*' '*/
		if( cInt == 32 || cInt == 13 || cInt == 10 || cInt == 9 || cInt == 0xFEFF || cInt == 2028 || cInt == 2029 )
			return 0;
/*','*/
/*'}'*/
/*']'*/
/*':'*/
		if( cInt == 44 || cInt == 125 || cInt == 93 || cInt == 58 )
			vtprintf( state->pvtError, WIDE( "invalid character; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, cInt, state->n, state->line, state->col );
		else {
			if( !state->val.string )  state->val.string = output->pos;
			if( cInt < 128 ) (*output->pos++) = cInt;
			else output->pos += ConvertToUTF8( output->pos, cInt );
#ifdef DEBUG_PARSING
			lprintf( "Collected .. %d %c  %*.*s", cInt, cInt, output->pos - state->val.string, output->pos - state->val.string, state->val.string );
#endif
		}
	}
	return 0;
}
static void pushValue( struct jsox_parse_state *state, PDATALIST *pdl, struct jsox_value_container *val, int line ) {
#define pushValue(a,b,c) pushValue(a,b,c,__LINE__)
#ifdef DEBUG_PARSING
	lprintf( "pushValue:%d %d", val->value_type, state->arrayType );
	if( val->name )
		lprintf( "push named:%*.*s %d", val->nameLen, val->nameLen, val->name, line );
#endif
	if( val->value_type == JSOX_VALUE_ARRAY ) {
		if( state->arrayType >= 0 ) {
			//size_t size;
			val->className = (char*)GetLink( &knownArrayTypeNames, state->arrayType );
			val->value_type = (enum jsox_value_types)(JSOX_VALUE_TYPED_ARRAY + state->arrayType);
			//lprintf( "INPUT:%d %s", val->stringLen, val->string );
			val->string = (char*)DecodeBase64Ex( val->string, val->stringLen, &val->stringLen, NULL );
			//lprintf( "base:%s", EncodeBase64Ex( "HELLO, World!", 13, NULL, NULL ) );
			//lprintf( "Resolve base64 string:%s", val->string );
		}
	}
	AddDataItem( pdl, val );
}
static LOGICAL isNonIdentifier( TEXTRUNE c ) {
	if( c < 0xFF ) {
		if( nonIdentifiers8[c] ) {
			return TRUE;
		}
	}
	else {
		int n;
		for( n = 0; n < (sizeof( nonIdentifierBits ) / sizeof( nonIdentifierBits[0] )); n++ ) {
			if( c >= (TEXTRUNE)nonIdentifierBits[n].firstChar && c < (TEXTRUNE)nonIdentifierBits[n].lastChar &&
				(nonIdentifierBits[n].bits[(c - nonIdentifierBits[n].firstChar) / 24]
					& (1 << ((c - nonIdentifierBits[n].firstChar) % 24))) )
				return TRUE;
		}
	}
	return FALSE;
}
int jsox_parse_add_data( struct jsox_parse_state *state
                            , const char * msg
                            , size_t msglen )
{
	/* I guess this is a good parser */
	TEXTRUNE c;
	PJSOX_PARSE_BUFFER input;
	struct jsox_output_buffer* output;
	int string_status;
	int retval = 0;
	if( !state->status )
		return -1;
	if( msg && msglen ) {
		input = GetFromSet( JSOX_PARSE_BUFFER, &jxpsd.parseBuffers );
		input->pos = input->buf = msg;
		input->size = msglen;
		EnqueLinkNL( state->inBuffers, input );
		if( state->gatheringString || state->gatheringNumber || state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) {
			// have to extend the previous output buffer to include this one instead of allocating a split string.
			size_t offset;
			size_t offset2;
			output = (struct jsox_output_buffer*)DequeLinkNL( state->outQueue );
			//lprintf( "output from before is %p", output );
			offset = (output->pos - output->buf);
			offset2 = state->val.string ? (state->val.string - output->buf) : 0;
			AddLink( state->outValBuffers, output->buf );
			output->buf = NewArray( char, output->size + msglen + 1 );
			if( state->val.string ) {
				MemCpy( output->buf + offset2, state->val.string, offset - offset2 );
				state->val.string = output->buf + offset2;
			}
			output->size += msglen;
			//lprintf( "previous val:%s", state->val.string, state->val.string );
			output->pos = output->buf + offset;
			PrequeLink( state->outQueue, output );
		}
		else {
			output = (struct jsox_output_buffer*)GetFromSet( JSOX_PARSE_BUFFER, &jxpsd.parseBuffers );
			output->pos = output->buf = NewArray( char, msglen + 1 );
			output->size = msglen;
			EnqueLinkNL( state->outQueue, output );
		}
	}
	else {
		// zero length input buffer... terminate a number.
		if( state->gatheringNumber ) {
			//console.log( "Force completed.")
			output = (struct jsox_output_buffer*)DequeLinkNL( state->outQueue );
			output->pos[0] = 0;
			PushLink( state->outBuffers, output );
			state->gatheringNumber = FALSE;
			//lprintf( "result with number:%s", state->val.string );
			if( state->val.float_result )
			{
				CTEXTSTR endpos;
				state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
				if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
			}
			else
			{
				state->val.result_n = IntCreateFromText( state->val.string );
				if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
			}
			state->val.value_type = JSOX_VALUE_NUMBER;
			if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
				state->completed = TRUE;
			}
			retval = 1;
		}
	}
	while( state->status && ( input = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->inBuffers ) ) ) {
		output = (struct jsox_output_buffer*)DequeLinkNL( state->outQueue );
		//lprintf( "output is %p", output );
		state->n = input->pos - input->buf;
		if( state->n > input->size ) DebugBreak();
		if( state->gatheringString ) {
			string_status = gatherString6( state, input->buf, &input->pos, input->size, &output->pos, state->gatheringStringFirstChar );
			if( string_status < 0 )
				state->status = FALSE;
			else if( string_status > 0 )
			{
				state->gatheringString = FALSE;
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
				state->val.stringLen = (output->pos - state->val.string)-1;
#ifdef DEBUG_PARSING
				lprintf( "STRING1: %s %d", state->val.string, state->val.stringLen );
#endif
				if( state->status ) state->val.value_type = JSOX_VALUE_STRING;
			}
			else {
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
			}
		}
		if( state->gatheringNumber ) {
			//lprintf( "continue gathering a string" );
			goto continueNumber;
		}
		//lprintf( "Completed at start?%d", state->completed );
		while( state->status && (state->n < input->size) && (c = GetUtfChar( &input->pos )) )
		{
#ifdef DEBUG_PARSING
			lprintf( "parse character %c %d %d %d %d", c<32?".":c, state->word, state->parse_context, state->parse_context, state->word );
#endif
			state->col++;
			state->n = input->pos - input->buf;
			if( state->n > input->size ) DebugBreak();
			if( state->comment ) {
				if( state->comment == 1 ) {
					if( c == '*' ) { state->comment = 3; continue; }
					if( c != '/' ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "Fault while parsing; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
					else state->comment = 2;
					continue;
				}
				if( state->comment == 2 ) {
					if( c == '\n' ) { state->comment = 0; continue; }
					else continue;
				}
				if( state->comment == 3 ) {
					if( c == '*' ) { state->comment = 4; continue; }
					else continue;
				}
				if( state->comment == 4 ) {
					if( c == '/' ) { state->comment = 0; continue; }
					else { if( c != '*' ) state->comment = 3; continue; }
				}
			}
			switch( c )
			{
			case '/':
				if( !state->comment ) state->comment = 1;
				break;
			case '{':
				openObject( state, output, c );
				break;
			case '[':
				openArray( state, output, c );
				break;
			case ':':
				if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD )
				{
					if( state->word != JSOX_WORD_POS_RESET
						&& state->word != JSOX_WORD_POS_FIELD
						&& state->word != JSOX_WORD_POS_AFTER_FIELD ) {
						// allow starting a new word
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "unquoted keyword used as object field name:parsing fault; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
						break;
					}
					else if( state->word == JSOX_WORD_POS_FIELD ) {
						//state->val.stringLen = output->pos - state->val.string;
						//lprintf( "Set string length:%d", state->val.stringLen );
					}
					if( !(state->val.value_type == JSOX_VALUE_STRING) || state->word == JSOX_WORD_POS_FIELD )
						(*output->pos++) = 0;
					state->word = JSOX_WORD_POS_RESET;
					if( state->val.name ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "two names single value?" );
					}
					state->val.name = state->val.string;
					state->val.nameLen = ( output->pos - state->val.string ) - 1;
					state->val.string = NULL;
					state->val.stringLen = 0;
					state->parse_context = JSOX_CONTEXT_OBJECT_FIELD_VALUE;
					state->val.value_type = JSOX_VALUE_UNSET;
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					if( state->parse_context == JSOX_CONTEXT_IN_ARRAY )
						vtprintf( state->pvtError, WIDE( "(in array, got colon out of string):parsing fault; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					else
						vtprintf( state->pvtError, WIDE( "(outside any object, got colon out of string):parsing fault; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case '}':
				if( state->word == JSOX_WORD_POS_END ) {
					// allow starting a new word
					state->word = JSOX_WORD_POS_RESET;
				}
				if( state->parse_context == JSOX_CONTEXT_CLASS_FIELD ) {
					if( state->current_class ) {
						// allow blank comma at end to not be a field
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						if(state->val.string) {
							struct jsox_class_field *field = GetFromSet( JSOX_CLASS_FIELD, &jxpsd.class_fields );
							field->name = state->val.string;
							field->nameLen = output->pos - state->val.string;
							(*output->pos++) = 0;
							state->val.string = NULL;
							AddLink( &state->current_class->fields, field );
							//AddLink( &state->current_class->fields, state->val.string );
						}
						JSOX_RESET_STATE_VAL();
						state->word = JSOX_WORD_POS_RESET;
#ifdef DEBUG_PARSING_STCK
						lprintf( "object pop stack (close obj) %d %p", context_stack.length, old_context );
#endif
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					} else {
						vtprintf( state->pvtError, WIDE( "State error; gathering class fields, and lost the class; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f
							, c, state->n, state->line, state->col );
					}
				} else if( ( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) || state->parse_context == JSOX_CONTEXT_CLASS_VALUE ) {
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						struct jsox_class_field *field = (struct jsox_class_field *)GetLink( &state->current_class->fields, state->current_class_item++ );
						state->val.name = field->name;
						state->val.nameLen = field->nameLen;
#ifdef DEBUG_PARSING
						lprintf( "Push value closing class value %d %p", state->current_class_item, state->current_class );
#endif
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
					//if( _DEBUG_PARSING ) lprintf( "close object; empty object", val, elements );
					state->val.value_type = JSOX_VALUE_OBJECT;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					state->val.className = state->current_class->name;
					state->val.string = NULL;
					{
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						//if( _DEBUG_PARSING_STACK ) console.log( "object pop stack (close obj)", context_stack.length, old_context );
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					}
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				} else if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE ) {
					//enum json_value_types
#ifdef DEBUG_PARSING
					lprintf( "close object; empty object %d", state->val.value_type );
#endif
					//if( (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE) )
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						if( state->val.string ) {
							if( state->val.value_type != JSOX_VALUE_STRING ) {
								state->val.stringLen = output->pos - state->val.string;
#ifdef DEBUG_PARSING
								lprintf( "STRING2: %s %d", state->val.string, state->val.stringLen );
#endif
								(*output->pos++) = 0;
							}
						}
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
					//JSOX_RESET_STATE_VAL();
					state->val.value_type = JSOX_VALUE_OBJECT;
					state->val.string = NULL;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					{
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						//struct jsox_value_container *oldVal = (struct jsox_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
 // this will restore as IN_ARRAY or OBJECT_FIELD
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					}
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
					vtprintf( state->pvtError, WIDE( "Fault while parsing; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case ']':
				if( state->word == JSOX_WORD_POS_END ) {
					// allow starting a new word
					state->word = JSOX_WORD_POS_RESET;
				}
				if( state->parse_context == JSOX_CONTEXT_IN_ARRAY )
				{
#ifdef DEBUG_PARSING
					lprintf( "close array, push last element: %d", state->val.value_type );
#endif
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						if( state->val.string ) {
							if( state->val.value_type != JSOX_VALUE_STRING ) {
								state->val.stringLen = output->pos - state->val.string;
#ifdef DEBUG_PARSING
								lprintf( "STRING3: %s %d", state->val.string, state->val.stringLen );
#endif
								(*output->pos++) = 0;
							}
						}
						pushValue( state, state->elements, &state->val );
					}
					state->val.value_type = JSOX_VALUE_ARRAY;
					//state->val.string = NULL;
					state->val.contains = state->elements[0];
					state->val._contains = state->elements;
					{
						struct jsox_parse_context *old_context = (struct jsox_parse_context *)PopLink( state->context_stack );
						//struct jsox_value_container *oldVal = (struct jsox_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
						//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
						state->parse_context = old_context->context;
						state->elements = old_context->elements;
						state->val.name = old_context->name;
						state->val.nameLen = old_context->nameLen;
						state->current_class = old_context->current_class;
						state->current_class_item = old_context->current_class_item;
						state->arrayType = old_context->arrayType;
						DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
					}
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
						state->completed = TRUE;
					}
				}
				else
				{
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "bad context %d; fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->parse_context, c, state->n, state->line, state->col );
					state->status = FALSE;
				}
				break;
			case ',':
				if( state->word == JSOX_WORD_POS_END || state->word == JSOX_WORD_POS_FIELD ) {
					// allow starting a new word
					state->word = JSOX_WORD_POS_RESET;
				}
				if( state->parse_context == JSOX_CONTEXT_CLASS_FIELD ) {
					if( state->current_class ) {
						struct jsox_class_field *field = GetFromSet( JSOX_CLASS_FIELD, &jxpsd.class_fields );
						field->name = state->val.string;
						field->nameLen = output->pos - state->val.string;
						(*output->pos++) = 0;
						state->val.string = NULL;
						AddLink( &state->current_class->fields, field );
						state->word = JSOX_WORD_POS_FIELD;
					}
					else {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
						vtprintf( state->pvtError, WIDE( "lost class definition; fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->parse_context, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
				}
				else if( state->parse_context == JSOX_CONTEXT_CLASS_VALUE ) {
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
						struct jsox_class_field *field = (struct jsox_class_field *)GetLink( &state->current_class->fields, state->current_class_item++ );
						state->val.name = field->name;
						state->val.nameLen = field->nameLen;
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
						state->word = JSOX_WORD_POS_RESET;
					}
				}
				else if( state->parse_context == JSOX_CONTEXT_IN_ARRAY )
				{
					if( state->val.value_type == JSOX_VALUE_UNSET )
 // in an array, elements after a comma should init as undefined...
						state->val.value_type = JSOX_VALUE_EMPTY;
																 // undefined allows [,,,] to be 4 values and [1,2,3,] to be 4 values with an undefined at end.
					if( state->val.value_type != JSOX_VALUE_UNSET ) {
#ifdef DEBUG_PARSING
						lprintf( "back in array; push item %d", state->val.value_type );
#endif
						pushValue( state, state->elements, &state->val );
						JSOX_RESET_STATE_VAL();
					}
				}
				else if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE )
				{
					// after an array value, it will have returned to OBJECT_FIELD anyway
#ifdef DEBUG_PARSING
					lprintf( "comma after field value, push field to object: %s", state->val.name );
#endif
					state->parse_context = JSOX_CONTEXT_OBJECT_FIELD;
					if( state->val.value_type != JSOX_VALUE_UNSET )
						pushValue( state, state->elements, &state->val );
					JSOX_RESET_STATE_VAL();
				}
				else
				{
					state->status = FALSE;
					if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
					vtprintf( state->pvtError, WIDE( "bad context; fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
				}
				break;
			default:
				if( state->parse_context == JSOX_CONTEXT_OBJECT_FIELD
				   || state->parse_context == JSOX_CONTEXT_UNKNOWN
				   || (state->parse_context == JSOX_CONTEXT_OBJECT_FIELD_VALUE && state->word == JSOX_WORD_POS_FIELD )
				   || state->parse_context == JSOX_CONTEXT_CLASS_FIELD
				) {
					//lprintf( "gathering object field:%c  %*.*s", c, output->pos- state->val.string, output->pos - state->val.string, state->val.string );
					switch( c )
					{
					case '`':
						// this should be a special case that passes continuation to gatherString
						// but gatherString now just gathers all strings
					case '"':
					case '\'':
						if( state->val.value_type == JSOX_VALUE_STRING
							&& state->val.className ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
// fault
							vtprintf( state->pvtError, WIDE( "too many strings in a row; fault while parsing; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
							break;
						}
						if( state->word == JSOX_WORD_POS_FIELD
							|| ( state->val.value_type == JSOX_VALUE_STRING
								&& !state->val.className ) ) {
							(*output->pos++) = 0;
							state->val.className = state->val.string;
						}
						state->val.string = output->pos;
						state->gatheringString = TRUE;
						state->gatheringStringFirstChar = c;
						string_status = gatherString6( state, input->buf, &input->pos, input->size, &output->pos, c );
						//lprintf( "string gather status:%d", string_status );
						if( string_status < 0 )
							state->status = FALSE;
						else if( string_status > 0 ) {
							state->gatheringString = FALSE;
							state->val.stringLen = (output->pos - state->val.string) - 1;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) state->completed = TRUE;
#ifdef DEBUG_PARSING
							lprintf( "STRING4: %s %d", state->val.string, state->val.stringLen );
#endif
						}
						state->n = input->pos - input->buf;
						if( state->n > input->size ) DebugBreak();
						if( state->status ) {
							state->val.value_type = JSOX_VALUE_STRING;
							//state->val.stringLen = (output->pos - state->val.string - 1);
							//lprintf( "Set string length:%d", state->val.stringLen );
						}
						break;
					case '\n':
						state->line++;
						state->col = 1;
						// fall through to normal space handling - just updated line/col position
					case ' ':
					case '\t':
					case '\r':
 // LS (Line separator)
					case 2028:
 // PS (paragraph separate)
					case 2029:
 // ZWNBS is WS though
					case 0xFEFF:
						if( state->word == JSOX_WORD_POS_END ) {
							state->word = JSOX_WORD_POS_RESET;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
							break;
						}
						if( (state->word == JSOX_WORD_POS_RESET) || ( state->word == JSOX_WORD_POS_AFTER_FIELD ) )
							break;
						else if( state->word == JSOX_WORD_POS_FIELD ) {
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
								break;
							}
							if( state->val.string )
								state->word = JSOX_WORD_POS_AFTER_FIELD;
						}
						else {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, WIDE( "fault while parsing; whitespace unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n, state->line, state->col );
						}
						// skip whitespace
						//n++;
						//lprintf( "whitespace skip..." );
						break;
					default:
						if( state->word == JSOX_WORD_POS_RESET && ( (c >= '0' && c <= '9') || (c == '+') || (c == '.') ) ) {
							goto beginNumber;
						}
						if( state->word == JSOX_WORD_POS_AFTER_FIELD ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, WIDE( "fault while parsing; second string in field name at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n, state->line, state->col );
							break;
						} else if( state->word == JSOX_WORD_POS_RESET ) {
							state->word = JSOX_WORD_POS_FIELD;
							state->val.string = output->pos;
							state->val.value_type = JSOX_VALUE_STRING;
						}
						if( isNonIdentifier( c ) ) {
							state->status = FALSE;
							if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
							vtprintf( state->pvtError, WIDE( "fault while parsing object field name; \\u00%02X unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
							break;
						}
						if( !state->val.string ) state->val.string = output->pos;
						if( c < 128 ) (*output->pos++) = c;
						else output->pos += ConvertToUTF8( output->pos, c );
 // default
						break;
					}
				}
				else switch( c )
				{
				case '`':
					// this should be a special case that passes continuation to gatherString
					// but gatherString now just gathers all strings
				case '"':
				case '\'':
					state->val.string = output->pos;
					state->gatheringString = TRUE;
					state->gatheringStringFirstChar = c;
					string_status = gatherString6( state, input->buf, &input->pos, input->size, &output->pos, c );
					//lprintf( "string gather status:%d", string_status );
					if( string_status < 0 )
						state->status = FALSE;
					else if( string_status > 0 ) {
						state->gatheringString = FALSE;
						state->val.stringLen = (output->pos - state->val.string) - 1;
#ifdef DEBUG_PARSING
						lprintf( "STRING5: %s %d", state->val.string, state->val.stringLen );
#endif
					} else if( state->complete_at_end ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, "End of string fail." );
						state->status = FALSE;
					}
					state->n = input->pos - input->buf;
					if( state->n > input->size ) DebugBreak();
					if( state->status ) {
						state->val.value_type = JSOX_VALUE_STRING;
						state->word = JSOX_WORD_POS_END;
						if( state->complete_at_end ) {
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					break;
				case '\n':
					state->line++;
					state->col = 1;
					// FALLTHROUGH
				case ' ':
 // LS (Line separator)
				case 2028:
 // PS (paragraph separate)
				case 2029:
				case '\t':
				case '\r':
				case 0xFEFF:
					if( state->word == JSOX_WORD_POS_END ) {
						state->word = JSOX_WORD_POS_RESET;
						if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
							state->completed = TRUE;
						}
						break;
					}
					if( state->word == JSOX_WORD_POS_RESET || (state->word == JSOX_WORD_POS_AFTER_FIELD) ) {
						break;
					}
					else if( state->word == JSOX_WORD_POS_FIELD ) {
						if( state->val.string )
							state->word = JSOX_WORD_POS_AFTER_FIELD;
					}
					else {
						state->status = FALSE;
						if( !state->pvtError ) state->pvtError = VarTextCreate();
	// fault
						vtprintf( state->pvtError, WIDE( "fault while parsing; whitespace unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, state->n );
					}
					// skip whitespace
					//n++;
					//lprintf( "whitespace skip..." );
					break;
					//----------------------------------------------------------
					//  catch characters for true/false/null/undefined which are values outside of quotes
				case 't':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_TRUE_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_6 ) state->word = JSOX_WORD_POS_INFINITY_7;
					else recoverIdent( state, output, c );
					break;
				case 'r':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_TRUE_1 ) state->word = JSOX_WORD_POS_TRUE_2;
					else {
						recoverIdent( state, output, c );
// fault
					}
					break;
				case 'u':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_TRUE_2 ) state->word = JSOX_WORD_POS_TRUE_3;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NULL_1 ) state->word = JSOX_WORD_POS_NULL_2;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_UNDEFINED_1;
					else recoverIdent( state, output, c );
					break;
				case 'e':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_TRUE_3 ) {
						state->val.value_type = JSOX_VALUE_TRUE;
						state->word = JSOX_WORD_POS_END;
					}
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_4 ) {
						state->val.value_type = JSOX_VALUE_FALSE;
						state->word = JSOX_WORD_POS_END;
					}
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_3 ) state->word = JSOX_WORD_POS_UNDEFINED_4;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_7 ) state->word = JSOX_WORD_POS_UNDEFINED_8;
					else recoverIdent( state, output, c );
					break;
				case 'n':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_NULL_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_1 ) state->word = JSOX_WORD_POS_UNDEFINED_2;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_6 ) state->word = JSOX_WORD_POS_UNDEFINED_7;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_1 ) state->word = JSOX_WORD_POS_INFINITY_2;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_4 ) state->word = JSOX_WORD_POS_INFINITY_5;
					else recoverIdent( state, output, c );
					break;
				case 'd':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_2 ) state->word = JSOX_WORD_POS_UNDEFINED_3;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_8 ) { state->val.value_type = JSOX_VALUE_UNDEFINED; state->word = JSOX_WORD_POS_END; }
					else recoverIdent( state, output, c );
					break;
				case 'i':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_5 ) state->word = JSOX_WORD_POS_UNDEFINED_6;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_3 ) state->word = JSOX_WORD_POS_INFINITY_4;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_5 ) state->word = JSOX_WORD_POS_INFINITY_6;
					else recoverIdent( state, output, c );
					break;
				case 'l':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NULL_2 ) state->word = JSOX_WORD_POS_NULL_3;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NULL_3 ) {
						state->val.value_type = JSOX_VALUE_NULL;
						state->word = JSOX_WORD_POS_END;
					}
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_2 ) state->word = JSOX_WORD_POS_FALSE_3;
					else recoverIdent( state, output, c );
					break;
				case 'f':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_FALSE_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_UNDEFINED_4 ) state->word = JSOX_WORD_POS_UNDEFINED_5;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_2 ) state->word = JSOX_WORD_POS_INFINITY_3;
					else recoverIdent( state, output, c );
					break;
				case 'a':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_1 ) state->word = JSOX_WORD_POS_FALSE_2;
					else if(state->val.value_type == JSOX_VALUE_UNSET &&  state->word == JSOX_WORD_POS_NAN_1 ) state->word = JSOX_WORD_POS_NAN_2;
					else recoverIdent( state, output, c );
					break;
				case 's':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_FALSE_3 ) state->word = JSOX_WORD_POS_FALSE_4;
					else recoverIdent( state, output, c );
					break;
				case 'I':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_INFINITY_1;
					else recoverIdent( state, output, c );
					break;
				case 'N':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_RESET ) state->word = JSOX_WORD_POS_NAN_1;
					else if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_NAN_2 ) { state->val.value_type = state->negative ? JSOX_VALUE_NEG_NAN : JSOX_VALUE_NAN; state->word = JSOX_WORD_POS_END; }
					else recoverIdent( state, output, c );
					break;
				case 'y':
					if( state->val.value_type == JSOX_VALUE_UNSET && state->word == JSOX_WORD_POS_INFINITY_7 ) { state->val.value_type = state->negative ? JSOX_VALUE_NEG_INFINITY : JSOX_VALUE_INFINITY; state->word = JSOX_WORD_POS_END; }
					else recoverIdent( state, output, c );
					break;
					//
					//----------------------------------------------------------
				case '-':
					state->negative = !state->negative;
					break;
				default:
					if( state->word == JSOX_WORD_POS_RESET && ( (c >= '0' && c <= '9') || (c == '+') || (c == '.') ) )
					{
						LOGICAL fromDate;
 // to unwind last character past number.
						const char *_msg_input;
						// always reset this here....
						// keep it set to determine what sort of value is ready.
					beginNumber:
						if( !state->gatheringNumber ) {
							state->numberFromBigInt = FALSE;
							state->numberFromDate = FALSE;
							state->exponent = FALSE;
							state->exponent_sign = FALSE;
							state->exponent_digit = FALSE;
							fromDate = FALSE;
							state->fromHex = FALSE;
							state->val.float_result = (c == '.');
							state->val.string = output->pos;
  // terminate the string.
							(*output->pos++) = c;
						}
						else
						{
						continueNumber:
							fromDate = state->numberFromDate;
						}
						while( (_msg_input = input->pos), ((state->n < input->size) && (c = GetUtfChar( &input->pos ))) )
						{
							//lprintf( "Number input:%c", c );
							state->col++;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
							// leading zeros should be forbidden.
							if( c == '_' )
								continue;
							if( c >= '0' && c <= '9' )
							{
								(*output->pos++) = c;
								if( state->exponent )
									state->exponent_digit = TRUE;
							}
							// to be implemented
							else if( c == ':' || c == '-' || c == 'T' || c == 'Z' || c == '+' ) {
								/* toISOString()
								var today = new Date('05 October 2011 14:48 UTC');
								console.log(today.toISOString());
								// Returns 2011-10-05T14:48:00.000Z
								*/
								(*output->pos++) = c;
								state->numberFromDate = TRUE;
							}
							else if( ( c == 'x' || c == 'b' || c =='o' || c == 'X' || c == 'B' || c == 'O')
							       && ( output->pos - output->buf ) == 1
							       && output->buf[0] == '0' ) {
								// hex conversion.
								if( !state->fromHex ) {
									state->fromHex = TRUE;
 // force lower case.
									(*output->pos++) = c | 0x20;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault while parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( (c == 'e') || (c == 'E') )
							{
								if( !state->exponent ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
									state->exponent = TRUE;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( c == '-' || c == '+' ) {
								if( !state->exponent ) {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
								else {
									if( !state->exponent_sign && !state->exponent_digit ) {
										(*output->pos++) = c;
										state->exponent_sign = 1;
									}
									else {
										state->status = FALSE;
										if( !state->pvtError ) state->pvtError = VarTextCreate();
										vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
										break;
									}
								}
							} else if( c == 'n' ) {
								(*output->pos++) = c;
								state->numberFromBigInt = TRUE;
 // consume character.
								_msg_input = input->pos;
								break;
							} else if( c == '.' ) {
								if( !state->val.float_result && !state->fromHex ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							} else {
								// in non streaming mode; these would be required to follow
								if( c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == 0xFEFF
									|| c == ',' || c == ']' || c == '}'  || c == ':' ) {
									//lprintf( "Non numeric character received; push the value we have" );
									(*output->pos) = 0;
									break;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
						}
						if( input ) {
							input->pos = _msg_input;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
						}
						//LogBinary( (uint8_t*)output->buf, output->size );
						if( input && (!state->complete_at_end) && state->n == input->size )
						{
							//lprintf( "completion mode is not end of string; and at end of string" );
							state->gatheringNumber = TRUE;
							state->numberFromDate = fromDate;
						}
						else
						{
							(*output->pos++) = 0;
							state->val.stringLen = (output->pos - state->val.string) - 1;
#ifdef DEBUG_PARSING
							lprintf( "STRING6: %s %d", state->val.string, state->val.stringLen );
#endif
							state->gatheringNumber = FALSE;
							//lprintf( "result with number:%s", state->val.string );
							if( state->val.float_result )
							{
								CTEXTSTR endpos;
								state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
								if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
							}
							else
							{
								state->val.result_n = IntCreateFromText( state->val.string );
								if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
							}
							if( state->numberFromDate )
								state->val.value_type = JSOX_VALUE_DATE;
							else if( state->numberFromBigInt )
								state->val.value_type = JSOX_VALUE_BIGINT;
							else
								state->val.value_type = JSOX_VALUE_NUMBER;
							if( state->parse_context == JSOX_CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
					}
					else
					{
						recoverIdent( state, output, c );
					}
 // default
					break;
				}
 // default of high level switch
				break;
			}
			// got a completed value; skip out
			if( state->completed ) {
				if( state->word == JSOX_WORD_POS_END ) {
					state->word = JSOX_WORD_POS_RESET;
				}
				break;
			}
		}
		//lprintf( "at end... %d %d comp:%d", state->n, input->size, state->completed );
		if( input ) {
			if( state->n >= input->size ) {
				DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, input );
				if( state->gatheringString || state->gatheringNumber || state->parse_context == JSOX_CONTEXT_OBJECT_FIELD ) {
					//lprintf( "output is still incomplete? " );
					PrequeLink( state->outQueue, output );
					retval = 0;
				}
				else {
					PushLink( state->outBuffers, output );
					if( state->parse_context == JSOX_CONTEXT_UNKNOWN
					  && ( state->val.value_type != JSOX_VALUE_UNSET
					     || state->elements[0]->Cnt ) ) {
						state->completed = TRUE;
						retval = 1;
					}
				}
				//lprintf( "Is complete already?%d", state->completed );
			}
			else {
				// put these back into the stack.
				//lprintf( "put buffers back into queues..." );
				PrequeLink( state->inBuffers, input );
				PrequeLink( state->outQueue, output );
  // if returning buffers, then obviously there's more in this one.
				retval = 2;
			}
		}
		if( state->completed )
			break;
 // while DequeInput
	}
	if( !state->status ) {
		// some error condition; cannot resume parsing.
		return -1;
	}
	if( state->completed ) {
		if( state->val.value_type != JSOX_VALUE_UNSET ) {
			pushValue( state, state->elements, &state->val );
			JSOX_RESET_STATE_VAL();
		}
		state->completed = FALSE;
	}
	return retval;
}
PDATALIST jsox_parse_get_data( struct jsox_parse_state *state ) {
	PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
	state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
	if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
	else state->elements[0]->Cnt = 0;
	return result[0];
}
void _jsox_dispose_message( PDATALIST *msg_data )
{
	struct jsox_value_container *val;
	INDEX idx;
	if( !msg_data ) return;
	DATA_FORALL( (*msg_data), idx, struct jsox_value_container*, val )
	{
		// names and string buffers for JSON parsed values in a single buffer
		// associated with the root message.
		//if( val->name ) Release( val->name );
		//if( val->string ) Release( val->string );
		if( val->contains )
			_jsox_dispose_message( val->_contains );
	}
	// quick method
	DeleteDataList( msg_data );
	DeleteFromSet( PDATALIST, jxpsd.dataLists, msg_data );
}
static uintptr_t FindDataList( void*p, uintptr_t psv ) {
	if( ((PPDATALIST)p)[0] == (PDATALIST)psv )
		return (uintptr_t)p;
	return 0;
}
void jsox_dispose_message( PDATALIST *msg_data ) {
	uintptr_t actual = ForAllInSet( PDATALIST, jxpsd.dataLists, FindDataList, (uintptr_t)msg_data[0] );
	_jsox_dispose_message( (PDATALIST*)actual );
	msg_data[0] = NULL;
}
void jsox_parse_clear_state( struct jsox_parse_state *state ) {
	if( state ) {
		PJSOX_PARSE_BUFFER buffer;
		while( buffer = (PJSOX_PARSE_BUFFER)PopLink( state->outBuffers ) ) {
			Deallocate( const char *, buffer->buf );
			DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
		}
		while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
			DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
		while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
			Deallocate( const char*, buffer->buf );
			DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
		}
		DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->inBuffers );
		//DeleteLinkQueue( &state->inBuffers );
		DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->outQueue );
		//DeleteLinkQueue( &state->outQueue );
		DeleteFromSet( PLINKSTACK, jxpsd.linkStacks, state->outBuffers );
		//DeleteLinkStack( &state->outBuffers );
		{
			char *buf;
			INDEX idx;
			LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
				Deallocate( char*, buf );
			}
			DeleteFromSet( PLIST, jxpsd.listSet, state->outValBuffers );
			//DeleteList( &state->outValBuffers );
		}
		state->status = TRUE;
		state->parse_context = JSOX_CONTEXT_UNKNOWN;
		state->word = JSOX_WORD_POS_RESET;
		state->n = 0;
		state->col = 1;
		state->line = 1;
		state->gatheringString = FALSE;
		state->gatheringNumber = FALSE;
		{
			PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
			state->elements = GetFromSet( PDATALIST, &jxpsd.dataLists );
			if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
			else state->elements[0]->Cnt = 0;
			//state->elements = CreateDataList( sizeof( state->val ) );
			jsox_dispose_message( result );
		}
	}
}
PTEXT jsox_parse_get_error( struct jsox_parse_state *state ) {
	if( !state )
		state = jxpsd.last_parse_state;
	if( !state )
		return NULL;
	if( state->pvtError ) {
		PTEXT error = VarTextGet( state->pvtError );
		return error;
	}
	return NULL;
}
void jsox_parse_dispose_state( struct jsox_parse_state **ppState ) {
	struct jsox_parse_state *state = (*ppState);
	struct jsox_parse_context *old_context;
	PJSOX_PARSE_BUFFER buffer;
	_jsox_dispose_message( state->elements );
	//DeleteDataList( &state->elements );
	while( buffer = (PJSOX_PARSE_BUFFER)PopLink( state->outBuffers ) ) {
		Deallocate( const char *, buffer->buf );
		DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
	}
	{
		char *buf;
		INDEX idx;
		LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
			Deallocate( char*, buf );
		}
		DeleteFromSet( PLIST, jxpsd.listSet, state->outValBuffers );
		//DeleteList( &state->outValBuffers );
	}
	while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
		DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
	while( buffer = (PJSOX_PARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
		Deallocate( const char*, buffer->buf );
		DeleteFromSet( JSOX_PARSE_BUFFER, jxpsd.parseBuffers, buffer );
	}
	DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->inBuffers );
	//DeleteLinkQueue( &state->inBuffers );
	DeleteFromSet( PLINKQUEUE, jxpsd.linkQueues, state->outQueue );
	//DeleteLinkQueue( &state->outQueue );
	DeleteFromSet( PLINKSTACK, jxpsd.linkStacks, state->outBuffers );
	//DeleteLinkStack( &state->outBuffers );
	DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, state->context );
	while( (old_context = (struct jsox_parse_context *)PopLink( state->context_stack )) ) {
		//lprintf( "warning unclosed contexts...." );
		DeleteFromSet( JSOX_PARSE_CONTEXT, jxpsd.parseContexts, old_context );
	}
	if( state->context_stack )
		DeleteFromSet( PLINKSTACK, jxpsd.linkStacks, state->context_stack );
		//DeleteLinkStack( &state->context_stack );
	DeleteFromSet( JSOX_PARSE_STATE, jxpsd.parseStates, state );
	//Deallocate( struct jsox_parse_state *, state );
	(*ppState) = NULL;
}
LOGICAL jsox_parse_message( const char * msg
	, size_t msglen
	, PDATALIST *_msg_output ) {
	struct jsox_parse_state *state = jsox_begin_parse();
	static struct jsox_parse_state *_state;
	state->complete_at_end = TRUE;
	int result = jsox_parse_add_data( state, msg, msglen );
	if( _state ) jsox_parse_dispose_state( &_state );
	if( result > 0 ) {
		(*_msg_output) = jsox_parse_get_data( state );
		_state = state;
		//jsox_parse_dispose_state( &state );
		return TRUE;
	}
	(*_msg_output) = NULL;
	jxpsd.last_parse_state = state;
	_state = state;
	return FALSE;
}
#undef GetUtfChar
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
#ifndef JSON_EMITTER_SOURCE
#  define JSON_EMITTER_SOURCE
#endif
/***********
 <Alternative, instead of object format thing, provide a registration mechanism to specify
  bindings similar to ODBC>
 Structure member notation...
 ###<T>
 [padding]name:[offset][type][(p/a)count][{subformat}],name:[offset][type][(p/a)count][{subformat}],...
 padding is an optional number that is minimum offset in the object (structure)
 offset is an optional number before the type; otherwise the offset is relative from prior members
 count is an optional number after the type for array types (is the size of the array)
	 if count is (*) then the next member describes the array length
	 if count is (-*) then the prior member describes the array length
 type can be one of
		i  (integer)
		ip (integer array (int*) )
		ia (integer array (int[]) )
		s  (string (char*))
		sa (string array (char**))
		c  (char; unused?)
		ca (char aray (string, but not from a pointer)(char[]))
		f  (float)
		fa (float array float[])
		fp (float array float* )
		d  (float)
		da (float array float[])
		dp (float array float* )
		o  (object) (begin another level of breakdown (void*) )
		op  (object) (begin another level of breakdown (void*) )
		struct outer {
			 int a;
			 struct inner {
				  char *name;
			 } *substruct;
			 }
		4a:i,substruct:op{name:s}
 *************/
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace json {
#endif
uintptr_t json_add_object( struct json_context *context, CTEXTSTR name, struct json_context_object *format, POINTER object );
static CTEXTSTR tab_filler = WIDE("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
//----------------------------------------------------------------------------------------------
struct json_context *json_create_context( void )
{
	struct json_context *context = New( struct json_context );
	MemSet( context, 0, sizeof( struct json_context ) );
	context->pvt = VarTextCreateExx( 1024, 16384 );
	return context;
}
//----------------------------------------------------------------------------------------------
void json_begin_object( struct json_context *context, CTEXTSTR name )
{
	if( context->human_readable )
		if( context->levels && name )
			vtprintf( context->pvt, WIDE("%*.*s\"%s\":{\n")
					  , context->levels, context->levels, tab_filler
					  , name );
		else
			vtprintf( context->pvt, WIDE("%*.*s{\n")
					  , context->levels, context->levels, tab_filler );
	else
		if( context->levels && name )
			vtprintf( context->pvt, WIDE("\"%s\":{")
					  , name );
		else
			VarTextAddCharacter( context->pvt, '{' );
	context->levels++;
}
//----------------------------------------------------------------------------------------------
void json_end_object( struct json_context *context )
{
	context->levels--;
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s}\n")
				  , context->levels, context->levels, tab_filler );
	else
		VarTextAddCharacter( context->pvt, '}');
}
//----------------------------------------------------------------------------------------------
void json_begin_array( struct json_context *context, CTEXTSTR name )
{
	if( context->human_readable )
		if( context->levels && name )
			vtprintf( context->pvt, WIDE("%*.*s\"%s\":[\n")
					  , context->levels, context->levels, tab_filler
					  , name );
		else
			vtprintf( context->pvt, WIDE("%*.*s[\n")
					  , context->levels, context->levels, tab_filler );
	else
		if( context->levels && name )
			vtprintf( context->pvt, WIDE("\"%s\":[")
					  , name );
		else
			VarTextAddCharacter( context->pvt, '[');
	context->levels++;
}
//----------------------------------------------------------------------------------------------
void json_end_array( struct json_context *context )
{
	context->levels--;
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s]\n")
				  , context->levels, context->levels, tab_filler );
	else
		VarTextAddCharacter( context->pvt, ']');
}
//----------------------------------------------------------------------------------------------
void json_add_value( struct json_context *context, CTEXTSTR name, CTEXTSTR value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":\"%s\"\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":\"%s\"")
				  , name, value );
}
//----------------------------------------------------------------------------------------------
void json_add_list_value( struct json_context_object *object, struct json_context *context, CTEXTSTR name, PLIST values )
{
	INDEX idx;
	POINTER p;
	int first = 1;
	vtprintf( context->pvt, WIDE( "\"%s\":[" ), name );
	LIST_FORALL( values, idx, POINTER, p )
	{
		if( !first )
			vtprintf( context->pvt, WIDE( "," ) );
		else
			first = 0;
		json_build_message( object, p );
	}
	vtprintf( context->pvt, WIDE( "]" ) );
}
void json_add_int_64_value( struct json_context *context, CTEXTSTR name, int64_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _64fs WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _64fs
				  , name, value );
}
void json_add_int_32_value( struct json_context *context, CTEXTSTR name, int32_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _32fs WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _32fs
				  , name, value );
}
void json_add_int_16_value( struct json_context *context, CTEXTSTR name, int16_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _16fs WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _16fs
				  , name, value );
}
void json_add_int_8_value( struct json_context *context, CTEXTSTR name, int8_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _8fs WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _8fs
				  , name, value );
}
//----------------------------------------------------------------------------------------------
void json_add_uint_64_value( struct json_context *context, CTEXTSTR name, uint64_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _64f WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _64f
				  , name, value );
}
void json_add_uint_32_value( struct json_context *context, CTEXTSTR name, uint32_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _32f WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _32f
				  , name, value );
}
void json_add_uint_16_value( struct json_context *context, CTEXTSTR name, uint16_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _16f WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _16f
				  , name, value );
}
void json_add_uint_8_value( struct json_context *context, CTEXTSTR name, uint8_t value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%") _8f WIDE("\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%") _8f
				  , name, value );
}
//----------------------------------------------------------------------------------------------
void json_add_float_value( struct json_context *context, CTEXTSTR name, double value )
{
	if( context->human_readable )
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":%g\n")
				  , context->levels, context->levels, tab_filler
				  , name, value );
	else
		vtprintf( context->pvt, WIDE("\"%s\":%g")
				  , name, value );
}
//----------------------------------------------------------------------------------------------
void json_add_value_array( struct json_context *context, CTEXTSTR name, CTEXTSTR* pValue, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%s"), (n==0)?WIDE(""):WIDE(","), pValue[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%s"), (n==0)?WIDE(""):WIDE(","), pValue[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_int_64_value_array( struct json_context *context, CTEXTSTR name, int64_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _64fs, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _64fs, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_int_32_value_array( struct json_context *context, CTEXTSTR name, int32_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _32fs, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _32fs, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_int_16_value_array( struct json_context *context, CTEXTSTR name, int16_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_int_8_value_array( struct json_context *context, CTEXTSTR name, int8_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_uint_64_value_array( struct json_context *context, CTEXTSTR name, uint64_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _64f, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _64f, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_uint_32_value_array( struct json_context *context, CTEXTSTR name, uint32_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _32f, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%") _32f, (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_uint_16_value_array( struct json_context *context, CTEXTSTR name, uint16_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_uint_8_value_array( struct json_context *context, CTEXTSTR name, uint8_t* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_int_array( struct json_context *context, CTEXTSTR name, int* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("\"%s\":[")
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%d"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_float_value_array( struct json_context *context, CTEXTSTR name, float* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%g"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%g"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
void json_add_double_value_array( struct json_context *context, CTEXTSTR name, double* pValues, size_t nValues )
{
	size_t n;
	if( context->human_readable )
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%g"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		vtprintf( context->pvt, WIDE("]\n") );
	}
	else
	{
		vtprintf( context->pvt, WIDE("%*.*s\"%s\":[")
				  , context->levels, context->levels, tab_filler
				  , name );
		for( n = 0; n < nValues; n++ )
			vtprintf( context->pvt, WIDE("%s%g"), (n==0)?WIDE(""):WIDE(","), pValues[nValues] );
		VarTextAddCharacter( context->pvt, ']' );
	}
}
//----------------------------------------------------------------------------------------------
static int GetNumber( CTEXTSTR *start )
{
	int result = 0;
	while( (*start)[0] <= '9' && (*start)[0] >= '0' )
	{
		result *= 10;
		result += (*start)[0] - '0';
		(*start)++;
	}
	return result;
}
//----------------------------------------------------------------------------------------------
uintptr_t ParseFormat( struct json_context *context, CTEXTSTR format, uintptr_t object )
{
	size_t padding = 0;
	int member_offset;
	uintptr_t current_obj_ofs = object;
	CTEXTSTR start = format;
	CTEXTSTR _start;
	TEXTCHAR namebuf[256];
#define namebuf_size (sizeof(namebuf)/sizeof(namebuf[0]))
	size_t name_end;
	padding = GetNumber( &start );
	name_end = 0;
	_start = start;
	while( name_end < namebuf_size && start[0] && start[0] != ':' )
	{
		namebuf[name_end++] = start[0];
		start++;
	}
	namebuf[name_end] = 0;
	if( !start[0] )
	{
		lprintf( WIDE("Object description format error: no colon after (%s)"), _start );
		return 0;
	}
 // skip the ':'
	start++;
	member_offset = GetNumber( &start );
	if( member_offset )
		current_obj_ofs = ((uintptr_t)object)+member_offset;
#define padded_add(n)	((n)<padding?padding:(n))
	switch( start[0] )
	{
	case 'i':
		{
			int int_size;
			start++;
			int_size = GetNumber( &start );
			switch( start[0] )
			{
			case 'p':
				break;
			case 'a':
				break;
			default:
				switch( int_size )
				{
				case 1:
					current_obj_ofs += padded_add( 1 );
					break;
				case 2:
					current_obj_ofs += padded_add( 2 );
					break;
				case 4:
					current_obj_ofs += padded_add( 4 );
					break;
				case 8:
					current_obj_ofs += padded_add( 8 );
					break;
				default:
					current_obj_ofs += padded_add( sizeof(int) );
				}
			}
		}
		break;
	case 's':
		current_obj_ofs += padded_add( sizeof(char*) );
		break;
	case 'c':
		current_obj_ofs += padded_add( sizeof(char) );
		break;
	case 'f':
		current_obj_ofs += padded_add( sizeof(float) );
		break;
	case 'd':
		current_obj_ofs += padded_add( sizeof(double) );
		break;
	case 'o':
		switch( start[1] )
		{
		case 'p':
			if( start[2] == '{' )
			{
				// add_object doesn't work like this now
				//json_add_object( context, namebuf, start + 3, *(POINTER*)current_obj_ofs );
			}
			current_obj_ofs += padded_add( sizeof( POINTER ) );
			break;
		case '{':
			// add_object doesn't work like this now
			//current_obj_ofs = json_add_object( context, namebuf, start + 2, (POINTER)current_obj_ofs );
			break;
		default:
			lprintf( WIDE("Didn't find object description for object (%s) near (%s)"), namebuf, start );
			break;
		}
		break;
	default:
		lprintf( WIDE("Unrecognize type format character at (%s) for value (%s)"), start, namebuf );
	}
	return current_obj_ofs;
}
static size_t GetDefaultObjectSize( enum JSON_ObjectElementTypes type )
{
	switch( type )
	{
	case JSON_Element_Array:
	case JSON_Element_UserRoutine:
	case JSON_Element_Raw_Object:
		lprintf( "Returning invalid object size for this type." );
		return 0;
	case JSON_Element_Integer_8:
		return sizeof( int8_t );
	case JSON_Element_Integer_16:
		return sizeof( int16_t );
	case JSON_Element_Integer_32:
		 return sizeof( int32_t );
	case JSON_Element_Integer_64:
		 return sizeof( int64_t );
	case JSON_Element_Unsigned_Integer_8:
		 return sizeof( uint8_t );
	case JSON_Element_Unsigned_Integer_16:
		return sizeof( uint16_t );
	case JSON_Element_Unsigned_Integer_32:
		return sizeof( uint32_t );
	case JSON_Element_Unsigned_Integer_64:
		return sizeof( uint64_t );
	case JSON_Element_String:
		return sizeof( POINTER );
	case JSON_Element_CharArray:
		return 0;
	case JSON_Element_Float:
		return sizeof( float );
	case JSON_Element_Double:
		return sizeof( double );
	case JSON_Element_Object:
		return 0;
	case JSON_Element_ObjectPointer:
	case JSON_Element_List:
  // ptext type
	case JSON_Element_Text:
		return sizeof( POINTER );
	case JSON_Element_PTRSZVAL:
	case JSON_Element_PTRSZVAL_BLANK_0:
		return sizeof( uintptr_t );
		break;
	}
	return 0;
}
//----------------------------------------------------------------------------------------------
uintptr_t json_add_object( struct json_context *context, CTEXTSTR name, struct json_context_object *format, POINTER object )
{
	return 0;
}
//----------------------------------------------------------------------------------------------
void json_add_object_array( struct json_context *context, CTEXTSTR name, struct json_context_object *format, POINTER pValues, size_t nValues  )
{
}
//----------------------------------------------------------------------------------------------
struct json_context_object *json_create_object( struct json_context *context, size_t object_size )
{
	struct json_context_object *format = New( struct json_context_object );
	MemSet( format, 0, sizeof( struct json_context_object ) );
	format->context = context;
	if( object_size )
		format->object_size = object_size;
	else
		format->flags.dynamic_size = 1;
	// keep a reference for cleanup
	AddLink( &context->object_types, format );
	return format;
}
//----------------------------------------------------------------------------------------------
struct json_context_object *json_create_array( struct json_context *context
															, size_t offset
															, enum JSON_ObjectElementTypes type
															, size_t count
															, size_t count_offset
											 )
{
	struct json_context_object *format = New( struct json_context_object );
	format->context = context;
	format->members = NULL;
	format->is_array = TRUE;
	{
		struct json_context_object_element *element;
		element = New( struct json_context_object_element );
		MemSet( element, 0, sizeof( struct json_context_object_element ) );
		element->name = NULL;
		element->object = format;
		element->offset = offset;
		element->type = type;
		element->count = count;
		element->count_offset = count_offset;
		AddLink( &format->members, element );
	}
	// keep a reference for cleanup
	AddLink( &context->object_types, format );
	return format;
}
//----------------------------------------------------------------------------------------------
struct json_context_object *json_add_object_member_array( struct json_context_object *format
																		  , CTEXTSTR name
																		  , size_t offset
																		  , enum JSON_ObjectElementTypes type
																		  , size_t object_size
																		  , size_t count
																		  , size_t count_offset
																		  )
{
	struct json_context *context = format->context;
	struct json_context_object_element *member = New( struct json_context_object_element );
	MemSet( member, 0, sizeof( struct json_context_object_element ) );
	if( !object_size )
		object_size = GetDefaultObjectSize(type);
	if( format->flags.dynamic_size )
	{
		struct json_context_object *parent;
		for( parent = format; parent; parent = parent->parent )
		{
			parent->object_size += object_size;
		}
	}
	member->name = StrDup( name );
	member->offset = offset;
	member->type = type;
	member->count = count;
	member->count_offset = count_offset;
	switch( type )
	{
	case JSON_Element_Object:
	case JSON_Element_ObjectPointer:
		member->object = json_create_object( context, object_size );
		member->object->parent = format;
		member->object->offset = offset;
		member->object->flags.keep_phrase = TRUE;
		break;
	}
	AddLink( &format->members, member );
	if( member->object )
		return member->object;
	return format;
}
struct json_context_object *json_add_object_member_user_routine( struct json_context_object *object
																, CTEXTSTR name
																  , size_t offset, enum JSON_ObjectElementTypes type
																  , size_t object_size
																  , void (*user_formatter)(PVARTEXT,CPOINTER) )
{
	struct json_context_object *new_object = json_add_object_member_array( object
	                                                                     , name
	                                                                     , offset
	                                                                     , JSON_Element_UserRoutine
	                                                                     , object_size?object_size:GetDefaultObjectSize( type )
	                                                                     , 0
	                                                                     , JSON_NO_OFFSET );
	struct json_context_object_element *last_element = NULL;
	struct json_context_object_element *element;
	INDEX idx;
	LIST_FORALL( object->members, idx, struct json_context_object_element *, element )
	{
		last_element = element;
	}
	if( last_element )
	{
		last_element->content_type = type;
		last_element->user_formatter = user_formatter;
	}
	return new_object;
}
//----------------------------------------------------------------------------------------------
struct json_context_object *json_add_object_member( struct json_context_object *format
																  , CTEXTSTR name
																  , size_t offset, enum JSON_ObjectElementTypes type
																  , size_t object_size )
{
	return json_add_object_member_array( format, name, offset, type, object_size, 0, JSON_NO_OFFSET );
}
// adds a reference to a PLIST as an array with the content of the array specified as the type
struct json_context_object *json_add_object_member_list( struct json_context_object *object
																		 , CTEXTSTR name
																		 , size_t offset
																		 , enum JSON_ObjectElementTypes content_type
																		 , size_t object_size
																		 )
{
	// this is a double pointer... implement as a specific type?
	//return json_add_object_member_array( format, name, offset, content_type, object_size, 0, offsetof(
	struct json_context *context = object->context;
	struct json_context_object_element *member = New( struct json_context_object_element );
	MemSet( member, 0, sizeof( struct json_context_object_element ) );
	member->name = StrDup( name );
	if( object->flags.dynamic_size )
	{
		struct json_context_object *parent;
		for( parent = object; parent; parent = parent->parent )
			parent->object_size += object_size;
	}
	member->object_size = object_size;
	member->offset = offset;
	member->type = JSON_Element_List;
	member->content_type = content_type;
	member->count = 0;
	member->count_offset = offsetof( LIST, Cnt );
	member->object = json_create_object( context, 0 );
	member->object->flags.keep_phrase = TRUE;
	AddLink( &object->members, member );
	if( member->object )
		return member->object;
	return object;
}
// this allows recursive structures, so the structure may contain a reference to itself.
// this allows buildling other objects and referencing them instead of building them in-place
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_object_array )( struct json_context_object *object
																												  , CTEXTSTR name
																												  , size_t offset
																												  , enum JSON_ObjectElementTypes type
																												  , struct json_context_object *child_object
																												  , int count
																												  , size_t count_offset
																												  )
{
	//struct json_context *context = object->context;
	struct json_context_object_element *member = New( struct json_context_object_element );
	MemSet( member, 0, sizeof( struct json_context_object_element ) );
	member->name = StrDup( name );
	member->offset = offset;
	member->type = type;
	member->count = count;
	member->count_offset = count_offset;
	switch( type )
	{
	case JSON_Element_Object:
	case JSON_Element_ObjectPointer:
		member->object = child_object;
		break;
	case JSON_Element_Integer_8:
	case JSON_Element_Integer_16:
	case JSON_Element_Integer_32:
	case JSON_Element_Integer_64:
	case JSON_Element_Unsigned_Integer_8:
	case JSON_Element_Unsigned_Integer_16:
	case JSON_Element_Unsigned_Integer_32:
	case JSON_Element_Unsigned_Integer_64:
	case JSON_Element_Float:
	case JSON_Element_Double:
	case JSON_Element_Array:
	case JSON_Element_List:
	case JSON_Element_Text:
	case JSON_Element_CharArray:
	case JSON_Element_String:
	case JSON_Element_PTRSZVAL:
	case JSON_Element_PTRSZVAL_BLANK_0:
	case JSON_Element_UserRoutine:
	case JSON_Element_Raw_Object:
	default:
		lprintf( WIDE("incompatible type") );
		break;
	}
	AddLink( &object->members, member );
	if( member->object )
		return member->object;
	return object;
}
JSON_EMITTER_PROC( struct json_context_object *, json_add_object_member_object )( struct json_context_object *object
																								 , CTEXTSTR name
																								 , size_t offset
																								 , enum JSON_ObjectElementTypes type
																								 , struct json_context_object *child_object
																								 )
{
	return json_add_object_member_object_array( object, name, offset, type, child_object, 0, JSON_NO_OFFSET );
}
//----------------------------------------------------------------------------------------------
struct json_context_object * json_add_object_member_array_pointer( struct json_context_object *object
													  , CTEXTSTR name
													  , size_t offset, enum JSON_ObjectElementTypes type
													  , size_t count_offset )
{
	struct json_context *context = object->context;
	struct json_context_object_element *member = New( struct json_context_object_element );
	MemSet( member, 0, sizeof( struct json_context_object_element ) );
	member->name = StrDup( name );
	member->offset = offset;
	member->type = type;
	member->count_offset = count_offset;
   return object;
}
//----------------------------------------------------------------------------------------------
TEXTSTR json_build_message( struct json_context_object *object
									, POINTER msg )
{
	struct json_context *context = object->context;
	TEXTSTR result;
	int n = 0;
	INDEX idx;
	struct json_context_object_element *member;
	if( !object->flags.keep_phrase )
		VarTextEmpty( context->pvt );
	if( object->is_array )
		json_begin_array( context, NULL );
	else
		json_begin_object( context, NULL );
	LIST_FORALL( object->members, idx, struct json_context_object_element *, member )
	{
		if( n && ( member->type != JSON_Element_PTRSZVAL_BLANK_0 ) )
			vtprintf( context->pvt, WIDE(",") );
		n++;
		switch( member->type )
		{
		default:
			lprintf( WIDE("Unhandled json_emitter type: %d"), member->type );
			break;
		case JSON_Element_List:
			//if( member->count )
			//	;
			//else if( member->count_offset != JSON_NO_OFFSET )
			//	;
			//else
				json_add_list_value( member->object, context, member->name, *(PLIST*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Integer_64:
			if( member->count )
				json_add_int_64_value_array( context, member->name, (int64_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_int_64_value_array( context, member->name
										, *(int64_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_int_64_value( context, member->name, *(int64_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Integer_32:
			if( member->count )
				json_add_int_32_value_array( context, member->name, (int32_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_int_32_value_array( context, member->name
										, *(int32_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_int_32_value( context, member->name, *(int32_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Integer_16:
			if( member->count )
				json_add_int_16_value_array( context, member->name, (int16_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_int_16_value_array( context, member->name
										, *(int16_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_int_16_value( context, member->name, *(int16_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Integer_8:
			if( member->count )
				json_add_int_8_value_array( context, member->name, (int8_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_int_8_value_array( context, member->name
										, *(int8_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_int_8_value( context, member->name, *(int8_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Unsigned_Integer_64:
			if( member->count )
				json_add_uint_64_value_array( context, member->name, (uint64_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_uint_64_value_array( context, member->name
										, *(uint64_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_uint_64_value( context, member->name, *(uint64_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Unsigned_Integer_32:
			if( member->count )
				json_add_uint_32_value_array( context, member->name, (uint32_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_uint_32_value_array( context, member->name
										, *(uint32_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_uint_32_value( context, member->name, *(uint32_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Unsigned_Integer_16:
			if( member->count )
				json_add_uint_16_value_array( context, member->name, (uint16_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_uint_16_value_array( context, member->name
										, *(uint16_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_uint_16_value( context, member->name, *(uint16_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Unsigned_Integer_8:
			if( member->count )
				json_add_uint_8_value_array( context, member->name, (uint8_t*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_uint_8_value_array( context, member->name
										, *(uint8_t**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_uint_8_value( context, member->name, *(uint8_t*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Float:
			if( member->count )
				json_add_float_value_array( context, member->name, (float*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_float_value_array( context, member->name
										, *(float**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_float_value( context, member->name, *(float*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_Double:
			if( member->count )
				json_add_double_value_array( context, member->name, (double*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_double_value_array( context, member->name
										, *(double**)(((uintptr_t)msg)+member->offset)
										, *(size_t*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_float_value( context, member->name, *(double*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_String:
			if( member->count )
				json_add_value_array( context, member->name, *(CTEXTSTR**)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_value_array( context, member->name
										, (CTEXTSTR*)(((uintptr_t)msg)+member->offset)
										, *(int*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_value( context, member->name, *(CTEXTSTR*)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_CharArray:
			if( member->count )
				json_add_value_array( context, member->name, (CTEXTSTR*)(((uintptr_t)msg)+member->offset), member->count );
			else if( member->count_offset != JSON_NO_OFFSET )
				json_add_value_array( context, member->name
										, (CTEXTSTR*)(((uintptr_t)msg)+member->offset)
										, *(int*)(((uintptr_t)msg)+member->count_offset)
										);
			else
				json_add_value( context, member->name, (CTEXTSTR)(((uintptr_t)msg)+member->offset) );
			break;
		case JSON_Element_ObjectPointer:
			{
				vtprintf( context->pvt, WIDE("\"%s\":")
						  , member->name );
				json_build_message( member->object, *((POINTER*)(((uintptr_t)msg)+member->offset)) );
			}
			break;
		case JSON_Element_Object:
			{
				vtprintf( context->pvt, WIDE("\"%s\":")
						  , member->name );
				json_build_message( member->object, (POINTER)(((uintptr_t)msg)+member->offset) );
			}
			break;
		case JSON_Element_PTRSZVAL:
			{
				uintptr_t psv;
#ifdef __64__
				if( ( psv = *(int64_t*)(((uintptr_t)msg)+member->offset) ) == INVALID_INDEX )
					json_add_int_64_value( context, member->name, *(int64_t*)(((uintptr_t)msg)+member->offset) );
				else
					json_add_uint_64_value( context, member->name, *(int64_t*)(((uintptr_t)msg)+member->offset) );
#else
				if( ( psv = *(int32_t*)(((uintptr_t)msg)+member->offset) ) == INVALID_INDEX )
					json_add_int_32_value( context, member->name, *(int32_t*)(((uintptr_t)msg)+member->offset) );
				else
					json_add_uint_32_value( context, member->name, *(int32_t*)(((uintptr_t)msg)+member->offset) );
#endif
			}
			break;
		case JSON_Element_PTRSZVAL_BLANK_0:
			{
				uintptr_t psv;
#ifdef __64__
				if( psv = *(int64_t*)(((uintptr_t)msg)+member->offset) )
				{
					if( n )
						vtprintf( context->pvt, WIDE(",") );
					if( psv == INVALID_INDEX )
						json_add_int_64_value( context, member->name, psv );
					else
						json_add_uint_64_value( context, member->name, psv );
				}
#else
				if( psv = *(int32_t*)(((uintptr_t)msg)+member->offset) )
				{
					if( n )
						vtprintf( context->pvt, WIDE(",") );
					if( psv == INVALID_INDEX )
						json_add_int_32_value( context, member->name, psv );
					else
						json_add_uint_32_value( context, member->name, psv );
				}
#endif
			}
			break;
		case JSON_Element_UserRoutine:
			vtprintf( context->pvt, WIDE("\"%s\":"), member->name );
			member->user_formatter( context->pvt, (CPOINTER)(((uintptr_t)msg)+member->offset) );
			break;
		}
	}
	if( object->is_array )
		json_end_array( context );
	else
		json_end_object( context );
	if( !object->flags.keep_phrase )
	{
		PTEXT tmp = VarTextGet( context->pvt );
		result = StrDup( GetText( tmp ) );
		LineRelease( tmp );
		return result;
	}
	// will be incomplete...
	return NULL;
}
//----------------------------------------------------------------------------------------------
#ifdef __cplusplus
} } }
#endif
#define VESL_EMITTER_SOURCE
#define VESL_PARSER_MAIN_SOURCE
#ifndef VESL_EMITTER_HEADER_INCLUDED
#define VESL_EMITTER_HEADER_INCLUDED
#ifdef VESL_EMITTER_SOURCE
#define VESL_EMITTER_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define VESL_EMITTER_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace vesl {
#endif
struct vesl_context_object_element;
struct vesl_context_object;
struct vesl_context;
// take a vesl string and a format and fill in a structure from the text.
// tests all formats, to first-match;
// take a vesl string and a format and fill in a structure from the text.
// if object does not fit all members (may have extra, but must have at least all members in message in format to return TRUE)
// then it returns false; that is if a member is in the 'msg' parameter that is not in
// the format, then the result is FALSE.
//  PDATALIST is full of struct vesl_value_container
// turns out numbers can be  hex, octal and binary numbers  (0x[A-F,a-f,0-9]*, 0b[0-1]*, 0[0-9]*)
// slightly faster (17%) than vesl6_parse_message because of fewer possible checks.
VESL_EMITTER_PROC( LOGICAL, vesl_parse_message )(const char * msg
                                                , size_t msglen
                                                , PDATALIST *msg_data_out
																);
// allocates a parsing context and begins parsing data.
VESL_EMITTER_PROC( struct vesl_parse_state *, vesl_begin_parse )( void );
// return TRUE when a completed value/object is available.
// after returning TRUE, call vesl_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns FALSE, then ther is no further object
// to retrieve.
VESL_EMITTER_PROC( int, vesl_parse_add_data )( struct vesl_parse_state *context
                                                 , const char * msg
                                                 , size_t msglen
                                                 );
// these are common functions that work for VESL stream parsers
VESL_EMITTER_PROC( PDATALIST, vesl_parse_get_data )( struct vesl_parse_state *context );
VESL_EMITTER_PROC( void, vesl_parse_dispose_state )( struct vesl_parse_state **context );
VESL_EMITTER_PROC( void, vesl_parse_clear_state )(struct vesl_parse_state *context);
VESL_EMITTER_PROC( PTEXT, vesl_parse_get_error )(struct vesl_parse_state *context);
// Add some data to parse for vesl stream (which may consist of multiple values)
// return 1 when a completed value/object is available.
// after returning 1, call vesl_parse_get_data.  It is possible that there is
// still unconsumed data that can begin a new object.  Call this with NULL, 0 for data
// to consume this internal data.  if this returns 0, then there is no further object
// to retrieve.
// if this returns -1, an error in parsing has occured, and no further parsing can happen.
VESL_EMITTER_PROC( int, vesl_parse_add_data )( struct vesl_parse_state *context
	, const char * msg
	, size_t msglen
	);
// one shot, just process this one message.
VESL_EMITTER_PROC( LOGICAL, vesl_parse_message )(const char * msg
	, size_t msglen
	, PDATALIST *msg_data_out
	);
// any allocate mesage parts are released.
VESL_EMITTER_PROC( void, vesl_dispose_expressions )(PDATALIST *msg_data);
enum vesl_value_types {
	VESL_VALUE_UNDEFINED = -1
	, VESL_VALUE_UNSET = 0
 //= 1 no data
	, VESL_VALUE_NULL
 //= 2 no data
	, VESL_VALUE_TRUE
 //= 3 no data
	, VESL_VALUE_FALSE
 //= 4 string
	, VESL_VALUE_STRING
 //= 5 string + result_d | result_n
	, VESL_VALUE_NUMBER
 //= 6 contains
	, VESL_VALUE_OBJECT
 //= 7 contains
	, VESL_VALUE_ARRAY
	// up to here is supported in VESL
 //= 8 no data
	, VESL_VALUE_NEG_NAN
 //= 9 no data
	, VESL_VALUE_NAN
 //= 10 no data
	, VESL_VALUE_NEG_INFINITY
 //= 11 no data
	, VESL_VALUE_INFINITY
  // = 12 UNIMPLEMENTED
	, VESL_VALUE_DATE
 // = 13 no data; used in [,,,] as place holder of empty
	, VESL_VALUE_EMPTY
	// --- up to here is supports in VESL(6)
 // = 14 string needs to be parsed for expressions.
	, VESL_VALUE_NEED_EVAL
 // contains
	, VESL_VALUE_VARIABLE
 // code (string), contains
	, VESL_VALUE_FUNCTION
 // code (string), contains[n] = parameters
	, VESL_VALUE_FUNCTION_CALL
 //  ( ... ) or { ... } , string, contains[n] = value(s) last is THE value
	, VESL_VALUE_EXPRESSION
 // Symbolic operator, with combination rules so the operator text is complete.
	, VESL_VALUE_OPERATOR
 // 'if'  contains[1], contains[1], contains[2]
	, VESL_VALUE_OP_IF
 // '?'  contains[N] expressions to evaluate
	, VESL_VALUE_OP_TRINARY_THEN
 // ':'  contains[N] expressions to evaluate
	, VESL_VALUE_OP_TRINARY_ELSE
 // 'switch'
	, VESL_VALUE_OP_SWITCH
 // 'case'
	, VESL_VALUE_OP_CASE
 // 'for'   no data, contains[0], contains[1], contains[2],
	, VESL_VALUE_OP_FOR
 // 'break'  // strip optional label break
	, VESL_VALUE_OP_BREAK
 // 'while'
	, VESL_VALUE_OP_WHILE
 // 'do'
	, VESL_VALUE_OP_DO
 // 'continue'
	, VESL_VALUE_OP_CONTINUE
 // 'goto'
	, VESL_VALUE_OP_GOTO
 // 'stop'
	, VESL_VALUE_OP_STOP
 // 'this'
	, VESL_VALUE_OP_THIS
 // 'holder'
	, VESL_VALUE_OP_HOLDER
 // 'base'
	, VESL_VALUE_OP_BASE
};
struct vesl_value_container {
 // value from above indiciating the type of this value
	enum vesl_value_types value_type;
   // the string value of this value (strings and number types only)
	char *string;
	size_t stringLen;
  // boolean whether to use result_n or result_d
	int float_result;
	union {
		double result_d;
		int64_t result_n;
		//struct vesl_value_container *nextToken;
	};
	//PDATALIST contains;  // list of struct vesl_value_container that this contains.
  // acutal source datalist(?)
	PDATALIST *_contains;
};
#ifdef __cplusplus
} } SACK_NAMESPACE_END
using namespace sack::network::vesl;
#endif
#endif
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace vesl {
#endif
enum word_char_states {
 // not in a keyword
	WORD_POS_RESET = 0,
  // at end of a word, waiting for separator
	WORD_POS_END,
	WORD_POS_TRUE_1,
	WORD_POS_TRUE_2,
	WORD_POS_TRUE_3,
	WORD_POS_TRUE_4,
 // 11
	WORD_POS_FALSE_1,
	WORD_POS_FALSE_2,
	WORD_POS_FALSE_3,
	WORD_POS_FALSE_4,
 // 21  get u
	WORD_POS_NULL_1,
 //  get l
	WORD_POS_NULL_2,
 //  get l
	WORD_POS_NULL_3,
  // 31
	WORD_POS_UNDEFINED_1,
	WORD_POS_UNDEFINED_2,
	WORD_POS_UNDEFINED_3,
	WORD_POS_UNDEFINED_4,
	WORD_POS_UNDEFINED_5,
	WORD_POS_UNDEFINED_6,
	WORD_POS_UNDEFINED_7,
	WORD_POS_UNDEFINED_8,
	//WORD_POS_UNDEFINED_9, // instead of stepping to this value here, go to RESET
	WORD_POS_NAN_1,
	WORD_POS_NAN_2,
	//WORD_POS_NAN_3,// instead of stepping to this value here, go to RESET
	WORD_POS_INFINITY_1,
	WORD_POS_INFINITY_2,
	WORD_POS_INFINITY_3,
	WORD_POS_INFINITY_4,
	WORD_POS_INFINITY_5,
	WORD_POS_INFINITY_6,
	WORD_POS_INFINITY_7,
	//WORD_POS_INFINITY_8,// instead of stepping to this value here, go to RESET
	WORD_POS_FIELD,
	WORD_POS_AFTER_FIELD,
	WORD_POS_DOT_OPERATOR,
	WORD_POS_PROPER_NAME,
	WORD_POS_AFTER_PROPER_NAME,
	WORD_POS_AFTER_GET,
	WORD_POS_AFTER_SET,
};
enum parse_context_modes {
 CONTEXT_UNKNOWN = 0,
 CONTEXT_IN_ARRAY = 1,
 CONTEXT_IN_OBJECT = 2,
 CONTEXT_OBJECT_FIELD = 3,
 CONTEXT_OBJECT_FIELD_VALUE = 4,
 };
struct vesl_parse_context {
	enum parse_context_modes context;
	PDATALIST *elements;
	char *name;
	size_t nameLen;
	struct vesl_value_container valState;
	struct vesl_context_object *object;
};
#ifdef RESET_VAL
#  undef RESET_VAL
#endif
	 /*val.contains = NULL;     */
#define RESET_VAL()  {	            val.value_type = VESL_VALUE_UNSET;	   val._contains = NULL;	         val.string = NULL;	            negative = FALSE; }
#ifdef RESET_STATE_VAL
#  undef RESET_STATE_VAL
#endif
	 /*state->val.contains = NULL; */
#define RESET_STATE_VAL()  {	             state->val.value_type = VESL_VALUE_UNSET;	     state->val._contains = NULL;	         state->val.string = NULL;	            state->negative = FALSE; }
typedef struct vesl_parse_context PARSE_CONTEXT, *PPARSE_CONTEXT;
#define MAXPARSE_CONTEXTSPERSET 128
DeclareSet( PARSE_CONTEXT );
struct vesl_input_buffer {
      // prior input buffer
	char const * buf;
 // size of prior input buffer
	size_t       size;
  // last position in _input if context closed before end of buffer
	char const * pos;
};
struct vesl_output_buffer {
      // prior input buffer
	char * buf;
 // size of prior input buffer
	size_t  size;
  // last position in _input if context closed before end of buffer
	char * pos;
};
typedef struct vesl_input_buffer PARSE_BUFFER, *PPARSE_BUFFER;
#define MAXPARSE_BUFFERSPERSET 128
DeclareSet( PARSE_BUFFER );
// this is the stack state that can be saved between parsing for streaming.
struct vesl_parse_state {
	//TEXTRUNE c;
	PDATALIST *elements;
 //
	PLINKSTACK *outBuffers;
 // matches input queue
	PLINKQUEUE *outQueue;
	PLIST *outValBuffers;
	//TEXTSTR mOut;// = NewArray( char, msglen );
	size_t line;
	size_t col;
 // character index;
	size_t n;
	//size_t _n = 0; // character index; (restore1)
	enum word_char_states word;
	LOGICAL status;
	LOGICAL negative;
	LOGICAL literalString;
	PLINKSTACK *context_stack;
	LOGICAL first_token;
	//PPARSE_CONTEXT context;
	enum parse_context_modes parse_context;
	struct vesl_value_container val;
	int comment;
	TEXTRUNE operatorAccum;
	PLINKQUEUE *inBuffers;
	//char const * input;     // current input buffer start
	//char const * msg_input; // current input buffer position (incremented while reading)
	LOGICAL completed;
	LOGICAL complete_at_end;
	LOGICAL gatheringString;
	TEXTRUNE gatheringStringFirstChar;
	TEXTRUNE gatheringCodeLastChar;
	int codeDepth;
	LOGICAL gatheringNumber;
	LOGICAL numberExponent;
	LOGICAL numberFromHex;
	LOGICAL numberFromDate;
	PVARTEXT pvtError;
	LOGICAL fromHex;
	LOGICAL exponent;
	LOGICAL exponent_sign;
	LOGICAL exponent_digit;
	LOGICAL escape;
	LOGICAL cr_escaped;
	LOGICAL unicodeWide;
	LOGICAL stringUnicode;
	LOGICAL stringHex;
	TEXTRUNE hex_char;
	int hex_char_len;
	LOGICAL stringOct;
	LOGICAL weakSpace;
	struct vesl_output_buffer *output;
	PDATALIST root;
	//char *token_begin;
};
typedef struct vesl_parse_state PARSE_STATE, *PPARSE_STATE;
#define MAXPARSE_STATESPERSET 32
DeclareSet( PARSE_STATE );
typedef PLIST *PPLIST;
#define MAXPLISTSPERSET 256
DeclareSet( PLIST );
typedef PLINKSTACK *PPLINKSTACK;
#define MAXPLINKSTACKSPERSET 256
DeclareSet( PLINKSTACK );
typedef PLINKQUEUE *PPLINKQUEUE;
#define MAXPLINKQUEUESPERSET 256
DeclareSet( PLINKQUEUE );
typedef PDATALIST *PPDATALIST;
#define MAXPDATALISTSPERSET 256
DeclareSet( PDATALIST );
struct vesl_parser_shared_data {
	PPARSE_CONTEXTSET parseContexts;
	PPARSE_BUFFERSET parseBuffers;
	struct vesl_parse_state *last_parse_state;
	PPARSE_STATESET parseStates;
	PPLISTSET listSet;
	PPLINKSTACKSET linkStacks;
	PPLINKQUEUESET linkQueues;
	PPDATALISTSET dataLists;
};
#ifndef VESL_PARSER_MAIN_SOURCE
extern
#endif
struct vesl_parser_shared_data vpsd;
// shared to code parser...
void _vesl_dispose_message( PDATALIST *msg_data );
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
#define NUM_VALUE_NAMES  ((sizeof(value_type_names)/sizeof(value_type_names[0])))
const char *value_type_names[] = {
	"-unset-", "null", "true", "false"
	, "string", "number", "object"
	, "array", "NegNan", "Nan", "NegInf"
	, "Inf", "data", "EMPTY", "NeedsEval"
	, "variable", "function", "function Call"
	, "expression", "operator"
};
#define NUM_POS_NAMES  ((sizeof(word_pos_names)/sizeof(word_pos_names[0])))
const char *word_pos_names[] = {
 // not in a keyword
	"WORD_POS_RESET"
  // at end of a word, waiting for separator
	,"WORD_POS_END"
	,"WORD_POS_TRUE_1"
	,"WORD_POS_TRUE_2"
	,"WORD_POS_TRUE_3"
	,"WORD_POS_TRUE_4"
 // 11
	,"WORD_POS_FALSE_1"
	,"WORD_POS_FALSE_2"
	,"WORD_POS_FALSE_3"
	,"WORD_POS_FALSE_4"
 // 21  get u
	,"WORD_POS_NULL_1"
 //  get l
	,"WORD_POS_NULL_2"
 //  get l
	,"WORD_POS_NULL_3"
  // 31
	,"WORD_POS_UNDEFINED_1"
	,"WORD_POS_UNDEFINED_2"
	,"WORD_POS_UNDEFINED_3"
	,"WORD_POS_UNDEFINED_4"
	,"WORD_POS_UNDEFINED_5"
	,"WORD_POS_UNDEFINED_6"
	,"WORD_POS_UNDEFINED_7"
	,"WORD_POS_UNDEFINED_8"
	//WORD_POS_UNDEFINED_9, // instead of stepping to this value here, go to RESET
	,"WORD_POS_NAN_1"
	,"WORD_POS_NAN_2"
	//WORD_POS_NAN_3,// instead of stepping to this value here, go to RESET
	,"WORD_POS_INFINITY_1"
	,"WORD_POS_INFINITY_2"
	,"WORD_POS_INFINITY_3"
	,"WORD_POS_INFINITY_4"
	,"WORD_POS_INFINITY_5"
	,"WORD_POS_INFINITY_6"
	,"WORD_POS_INFINITY_7"
	//WORD_POS_INFINITY_8,// instead of stepping to this value here, go to RESET
	,"WORD_POS_FIELD"
	,"WORD_POS_AFTER_FIELD"
	,"WORD_POS_DOT_OPERATOR"
	,"WORD_POS_PROPER_NAME"
	,"WORD_POS_AFTER_PROPER_NAME"
	,"WORD_POS_AFTER_GET"
	,"WORD_POS_AFTER_SET"
};
//#define DEBUG_PARSING
/*
Code Point	Name	Abbreviation	Usage
U+200C	ZERO WIDTH NON-JOINER	<ZWNJ>	IdentifierPart
U+200D	ZERO WIDTH JOINER	<ZWJ>	IdentifierPart
U+FEFF	ZERO WIDTH NO-BREAK SPACE	<ZWNBSP>	WhiteSpace
*/
/*
ID_Start       XID_Start        Uppercase letters, lowercase letters, titlecase letters, modifier letters
                                , other letters, letter numbers, stability extensions
ID_Continue    XID_Continue     All of the above, plus nonspacing marks, spacing combining marks, decimal numbers
                                , connector punctuations, stability extensions.
                                These are also known simply as Identifier Characters, since they are a superset of
                                the ID_Start. The set of ID_Start characters minus the ID_Continue characters are
                                known as ID_Only_Continue characters.
*/
#ifdef __cplusplus
SACK_NAMESPACE namespace network { namespace vesl {
#endif
#define _2char(result,from) (((*from) += 2),( ( result & 0x1F ) << 6 ) | ( ( result & 0x3f00 )>>8))
#define _zero(result,from)  ((*from)++,0)
#define _3char(result,from) ( ((*from) += 3),( ( ( result & 0xF ) << 12 ) | ( ( result & 0x3F00 ) >> 2 ) | ( ( result & 0x3f0000 ) >> 16 )) )
#define _4char(result,from)  ( ((*from) += 4), ( ( ( result & 0x7 ) << 18 )                                    | ( ( result & 0x3F00 ) << 4 )                                         | ( ( result & 0x3f0000 ) >> 10 )                                      | ( ( result & 0x3f000000 ) >> 24 ) ) )
#define __GetUtfChar( result, from )           ((result = ((TEXTRUNE*)*from)[0]),             ( ( !(result & 0xFF) )                     ?_zero(result,from)                                                           :( ( result & 0x80 )                       ?( ( result & 0xE0 ) == 0xC0 )               ?( ( ( result & 0xC000 ) == 0x8000 ) ?_2char(result,from) : _zero(result,from)  )                :( ( ( result & 0xF0 ) == 0xE0 )                                           ?( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) ) ? _3char(result,from) : _zero(result,from)  )                   :( ( ( result & 0xF8 ) == 0xF0 )                      ? ( ( ( ( result & 0xC000 ) == 0x8000 ) && ( ( result & 0xC00000 ) == 0x800000 ) && ( ( result & 0xC0000000 ) == 0x80000000 ) )                         ?_4char(result,from):_zero(result,from) )                                                                                                        :( ( ( result & 0xC0 ) == 0x80 )                                                                                                                    ?_zero(result,from)                                                                                                                                 : ( (*from)++, (result & 0x7F) ) ) ) )                                                                                               : ( (*from)++, (result & 0x7F) ) ) ) )
#define GetUtfChar(x) __GetUtfChar(c,x)
static void vesl_state_init( struct vesl_parse_state *state )
{
	PPDATALIST ppElements;
	PPLIST ppList;
	PPLINKQUEUE ppQueue;
	PPLINKSTACK ppStack;
	ppElements = GetFromSet( PDATALIST, &vpsd.dataLists );
	if( !ppElements[0] ) ppElements[0] = CreateDataList( sizeof( state->val ) );
	state->elements = ppElements;
	state->elements[0]->Cnt = 0;
	ppStack = GetFromSet( PLINKSTACK, &vpsd.linkStacks );
	if( !ppStack[0] ) ppStack[0] = CreateLinkStack();
	state->outBuffers = ppStack;
	state->outBuffers[0]->Top = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &vpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->inBuffers = ppQueue;
	state->inBuffers[0]->Top = state->inBuffers[0]->Bottom = 0;
	ppQueue = GetFromSet( PLINKQUEUE, &vpsd.linkQueues );
	if( !ppQueue[0] ) ppQueue[0] = CreateLinkQueue();
// CreateLinkQueue();
	state->outQueue = ppQueue;
	state->outQueue[0]->Top = state->outQueue[0]->Bottom = 0;
	ppList = GetFromSet( PLIST, &vpsd.listSet );
	if( ppList[0] ) ppList[0]->Cnt = 0;
	state->outValBuffers = ppList;
	state->line = 1;
	state->col = 1;
 // character index;
	state->n = 0;
	state->word = WORD_POS_RESET;
	state->status = TRUE;
	state->negative = FALSE;
// NULL;
	state->context_stack = GetFromSet( PLINKSTACK, &vpsd.linkStacks );
	if( state->context_stack[0] ) state->context_stack[0]->Top = 0;
	//state->first_token = TRUE;
	//state->context = GetFromSet( PARSE_CONTEXT, &vpsd.parseContexts );
	state->parse_context = CONTEXT_UNKNOWN;
	state->comment = 0;
	state->completed = FALSE;
	//state->mOut = msg;// = NewArray( char, msglen );
	//state->msg_input = (char const *)msg;
	state->val.value_type = VESL_VALUE_UNSET;
	//state->val.contains = NULL;
	state->val._contains = NULL;
	state->val.string = NULL;
	state->complete_at_end = FALSE;
	state->gatheringString = FALSE;
	state->gatheringNumber = FALSE;
	state->pvtError = NULL;
}
static void vesl_start_container( struct vesl_parse_state *state ) {
	{
		struct vesl_parse_context *old_context = GetFromSet( PARSE_CONTEXT, &vpsd.parseContexts );
#ifdef _DEBUG_PARSING
		lprintf( "Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d", val.value_type );
#endif
		old_context->context = state->parse_context;
		old_context->elements = state->elements;
		old_context->valState = state->val;
		state->elements = state->val._contains;
// CreateDataList( sizeof( state->val ) );
		if( !state->elements ) old_context->valState._contains = state->elements = GetFromSet( PDATALIST, &vpsd.dataLists );
		if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
		if( !state->root ) state->root = state->elements[0];
		//else state->elements[0]->Cnt = 0;
		lprintf( "Pushing pending thing, so this object is assicated under it as a list: %s", state->val.string );
		PushLink( state->context_stack, old_context );
		state->word = WORD_POS_RESET;
		RESET_STATE_VAL();
	}
}
static void commitPending( struct vesl_parse_state *state ) {
	if( state->val.value_type ) {
		if( state->val.string )
			state->val.stringLen = state->output->pos - state->val.string;
		AddDataItem( state->elements, &state->val );
		RESET_STATE_VAL();
		state->word = WORD_POS_RESET;
		state->operatorAccum = 0;
	}
}
static void vesl_start_expression( struct vesl_parse_state *state ) {
	commitPending( state );
	state->val.value_type = VESL_VALUE_EXPRESSION;
	//AddDataItem( state->elements, &state->val );
	//RESET_STATE_VAL();
	vesl_start_container( state );
	state->parse_context = CONTEXT_OBJECT_FIELD;
}
static void vesl_start_array( struct vesl_parse_state *state ) {
	commitPending( state );
	state->val.value_type = VESL_VALUE_ARRAY;
	//AddDataItem( state->elements, &state->val );
	//RESET_STATE_VAL();
	vesl_start_container( state );
	state->parse_context = CONTEXT_IN_ARRAY;
}
static void vesl_close_expression_array( struct vesl_parse_state *state ) {
	commitPending( state );
	{
		struct vesl_parse_context *old_context = (struct vesl_parse_context *)PopLink( state->context_stack );
		//struct vesl_value_container *oldVal = (struct vesl_value_container *)GetDataItem( &old_context->elements, old_context->elements->Cnt - 1 );
		//oldVal->contains = state->elements;  // save updated elements list in the old value in the last pushed list.
 // this will restore as IN_ARRAY or OBJECT_FIELD
		state->parse_context = old_context->context;
		state->elements = old_context->elements;
		state->val = old_context->valState;
		DeleteFromSet( PARSE_CONTEXT, vpsd.parseContexts, old_context );
	}
}
static void vesl_dump_parse_level( PDATALIST *pdl, int level ) {
	struct vesl_value_container *val;
	INDEX idx;
	int n;
	DATA_FORALL( pdl[0], idx, struct vesl_value_container *, val ) {
		for( n = 0; n < level; n++ )
			printf( "\t" );
		if( val->value_type < 0 )
			printf( "undefined" );
		else if( val->value_type < NUM_VALUE_NAMES )
			printf( "%s:", value_type_names[val->value_type] );
		else
			printf( "%d:", val->value_type );
		if( val->string )
			printf( "STRING(%*.*s)", (int)val->stringLen, (int)val->stringLen, val->string );
		printf( "\n" );
		if( val->_contains )
			vesl_dump_parse_level( val->_contains, level + 1 );
	}
}
static void vesl_dump_parse( PDATALIST pdl ) {
	vesl_dump_parse_level( &pdl, 0 );
}
static int gatherString6v(struct vesl_parse_state *state, CTEXTSTR msg, CTEXTSTR *msg_input, size_t msglen, TEXTSTR *pmOut
		//, int literalString
		) {
	char *mOut = (*pmOut);
	// collect a string
	int status = 0;
	size_t n;
	//int escape;
	//LOGICAL cr_escaped;
	TEXTRUNE c;
	//escape = 0;
	//cr_escaped = FALSE;
	while( ( ( n = (*msg_input) - msg ), ( n < msglen ) ) && ( ( c = GetUtfChar( msg_input ) ), ( status >= 0 ) ) )
	{
		(state->col)++;
		if( c == state->gatheringStringFirstChar ) {
			if( state->escape ) { ( *mOut++ ) = c; state->escape = FALSE; }
			else if( c == state->gatheringStringFirstChar ) {
				status = 1;
				break;
 // other else is not valid close quote; just store as content.
			} else ( *mOut++ ) = c;
		} else if( state->escape ) {
			if( state->stringOct ) {
/*'0'*/
/*'9'*/
				if( state->hex_char_len < 3 && c >= 48 && c <= 57 ) {
					state->hex_char *= 8;
/*.codePointAt(0)*/
					state->hex_char += c - 0x30;
					state->hex_char_len++;
					if( state->hex_char_len == 3 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringOct = FALSE;
						state->escape = FALSE;
						continue;
					}
					continue;
				} else {
					if( state->hex_char > 255 ) {
						lprintf(WIDE("(escaped character, parsing octal escape val=%d) fault while parsing; )") WIDE(" (near %*.*s[%c]%s)")
							, state->hex_char
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						break;
					}
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringOct = FALSE;
					state->escape = FALSE;
					continue;
				}
			} else if( state->unicodeWide ) {
				if( c == '}' ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->unicodeWide = FALSE;
					state->stringUnicode = FALSE;
					state->escape = FALSE;
					continue;
				}
				state->hex_char *= 16;
				if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
				else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
				else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
				else {
					lprintf(WIDE("(escaped character, parsing hex of \\u) fault while parsing; '%c' unexpected at %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
						, (int)( ( n > 3 ) ? 3 : n ), (int)( ( n > 3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n > 3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
					state->unicodeWide = FALSE;
					state->escape = FALSE;
				}
				continue;
			} else if( state->stringHex || state->stringUnicode ) {
				if( state->hex_char_len == 0 && c == '{' ) {
					state->unicodeWide = TRUE;
					continue;
				}
				if( state->hex_char_len < 2 || ( state->stringUnicode && state->hex_char_len < 4 ) ) {
					state->hex_char *= 16;
					if( c >= '0' && c <= '9' )      state->hex_char += c - '0';
					else if( c >= 'A' && c <= 'F' ) state->hex_char += ( c - 'A' ) + 10;
					else if( c >= 'a' && c <= 'f' ) state->hex_char += ( c - 'a' ) + 10;
					else {
						lprintf(WIDE("(escaped character, parsing hex of \\x) fault while parsing; '%c' unexpected at %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
							, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
							, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
							, c
							, ( *msg_input ) + 1
// fault
						);
						status = -1;
						state->stringHex = FALSE;
						state->escape = FALSE;
						continue;
					}
				}
				state->hex_char_len++;
				if( state->stringUnicode ) {
					if( state->hex_char_len == 4 ) {
						mOut += ConvertToUTF8(mOut, state->hex_char);
						state->stringUnicode = FALSE;
						state->escape = FALSE;
					}
				} else if( state->hex_char_len == 2 ) {
					mOut += ConvertToUTF8(mOut, state->hex_char);
					state->stringHex = FALSE;
					state->escape = FALSE;
				}
				continue;
			}
			switch( c ) {
			case '\r':
				state->cr_escaped = TRUE;
				continue;
			case '\n':
				state->line++;
				state->col = 1;
				if( state->cr_escaped ) state->cr_escaped = FALSE;
				// fall through to clear escape status <CR><LF> support.
 // LS (Line separator)
			case 2028:
 // PS (paragraph separate)
			case 2029:
				continue;
			case '/':
			case '\\':
			case '\'':
			case '"':
			case '`':
				( *mOut++ ) = c;
				break;
			case 't':
				( *mOut++ ) = '\t';
				break;
			case 'b':
				( *mOut++ ) = '\b';
				break;
			case 'n':
				( *mOut++ ) = '\n';
				break;
			case 'r':
				( *mOut++ ) = '\r';
				break;
			case 'f':
				( *mOut++ ) = '\f';
				break;
			case '0': case '1': case '2': case '3':
				state->stringOct = TRUE;
				state->hex_char = c - 48;
				state->hex_char_len = 1;
				continue;
			case 'x':
				state->stringHex = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			case 'u':
				state->stringUnicode = TRUE;
				state->hex_char_len = 0;
				state->hex_char = 0;
				continue;
			default:
				if( state->cr_escaped ) {
					state->cr_escaped = FALSE;
					state->escape = FALSE;
					mOut += ConvertToUTF8(mOut, c);
				} else {
					lprintf(WIDE("(escaped character) fault while parsing; '%c' unexpected %")_size_f WIDE(" (near %*.*s[%c]%s)"), c, n
						, (int)( ( n>3 ) ? 3 : n ), (int)( ( n>3 ) ? 3 : n )
						, ( *msg_input ) - ( ( n>3 ) ? 3 : n )
						, c
						, ( *msg_input ) + 1
// fault
					);
					status = -1;
				}
				break;
			}
			state->escape = 0;
		} else if( c == '\\' ) {
			if( state->escape ) {
				(*mOut++) = '\\';
				state->escape = 0;
			}
			else state->escape = 1;
		}
		else
		{
			if( state->cr_escaped ) {
				state->cr_escaped = FALSE;
				if( c == '\n' ) {
					state->line++;
					state->col = 1;
					state->escape = FALSE;
					continue;
				}
			}
			if( c < 127 )
				(*mOut++) = (char)c;
			else
				mOut += ConvertToUTF8( mOut, c );
		}
	}
	// this CAN nul terminate; since the end is a quote, which is lost; but let's be conservative.
	//if( status )
	//	(*mOut++) = 0;  // terminate the string.
	(*pmOut) = mOut;
	return status;
}
static int gatherIdentifier( struct vesl_parse_state *state, CTEXTSTR msg
	, CTEXTSTR *msg_input, size_t msglen, TEXTRUNE *unused
	, TEXTSTR *pmOut
) {
	char *mOut = (*pmOut);
	// collect an identifier
	int status = 0;
	size_t n;
	TEXTRUNE c = (*unused);
	do
	{
		(state->col)++;
		if( c < 0xFF ) {
			if( nonIdentifiers8[c] ) {
				status = 1;
				(*unused) = c;
				break;
			}
		} else {
			int n;
			for( n = 0; n < (sizeof( nonIdentifierBits ) / sizeof( nonIdentifierBits[0] )); n++ ) {
				if( c >= (TEXTRUNE)nonIdentifierBits[n].firstChar && c < (TEXTRUNE)nonIdentifierBits[n].lastChar &&
					(nonIdentifierBits[n].bits[(c - nonIdentifierBits[n].firstChar) / 24]
						& (1 << ((c - nonIdentifierBits[n].firstChar) % 24))) )
					break;
			}
			if( c < (sizeof( nonIdentifierBits ) / sizeof( nonIdentifierBits[0] )) ) {
				status = 1;
				(*unused) = c;
				break;
			}
		}
		if( state->val.value_type == VESL_VALUE_UNSET ) {
			state->val.value_type = VESL_VALUE_VARIABLE;
			state->val.string = mOut;
		}
		if( c < 127 )
			(*mOut++) = (char)c;
		else
			mOut += ConvertToUTF8( mOut, c );
	}
	while( ((n = (*msg_input) - msg), (n < msglen)) && ((c = GetUtfChar( msg_input )), (status >= 0)) );
	if( (*pmOut) != mOut ) {
		status |= 2;
		(*pmOut) = mOut;
	}
	return status;
}
static FLAGSET( isOp, 128 );
static FLAGSET( isOp2[128], 128 );
static void InitOperatorSyms( void ) {
	static const char *ops = "=<>+-*/%^~!&|?:.";
	//@#\$_
 /*=*/
 /*<*/
 /*>*/
 /*+*/
 /*-*/
 /***/
 /*/*/
 /*%*/
	static const char *op2[] = {"=","<=",">=","+=","-=","=","=/*","="
 /*^*/
 /*~*/
 /*!*/
 /*&*/
 /*|*/
 /*?*/
 /*:*/
 /*.*/
							   ,"=","=","=><&|","=&","=|",NULL,NULL,NULL };
	int n;
	int m;
	for( n = 0; ops[n]; n++ ) {
		SETFLAG( isOp, ops[n] );
		if( op2[n] ) for( m = 0; op2[n][m]; m++ ) SETFLAG( isOp2[ops[n]], op2[n][m] );
	}
}
static void setOperator( struct vesl_parse_state *state, TEXTRUNE c ) {
}
PRELOAD( InitVESLOpSyms ) {
	InitOperatorSyms();
}
int vesl_parse_add_data( struct vesl_parse_state *state
                            , const char * msg
                            , size_t msglen )
{
	/* I guess this is a good parser */
	TEXTRUNE c;
	PPARSE_BUFFER input;
	struct vesl_output_buffer* output;
	int string_status;
	int retval = 0;
	if( !state->status )
		return -1;
	if( msg && msglen ) {
		input = GetFromSet( PARSE_BUFFER, &vpsd.parseBuffers );
		input->pos = input->buf = msg;
		input->size = msglen;
		EnqueLinkNL( state->inBuffers, input );
		output = (struct vesl_output_buffer*)DequeLinkNL( state->outQueue );
		if( output && (state->gatheringString || state->gatheringNumber || state->parse_context == CONTEXT_OBJECT_FIELD) ) {
			// have to extend the previous output buffer to include this one instead of allocating a split string.
			size_t offset;
			size_t offset2;
			output = (struct vesl_output_buffer*)DequeLinkNL( state->outQueue );
			//lprintf( "output from before is %p", output );
			offset = (output->pos - output->buf);
			offset2 = state->val.string ? (state->val.string - output->buf) : 0;
			AddLink( state->outValBuffers, output->buf );
			output->buf = NewArray( char, output->size + msglen + 1 );
			if( state->val.string ) {
				MemCpy( output->buf + offset2, state->val.string, offset - offset2 );
				state->val.string = output->buf + offset2;
			}
			output->size += msglen;
			//lprintf( "previous val:%s", state->val.string, state->val.string );
			output->pos = output->buf + offset;
			PrequeLink( state->outQueue, output );
		}
		else {
			if( output )
				PrequeLink( state->outQueue, output );
			output = (struct vesl_output_buffer*)GetFromSet( PARSE_BUFFER, &vpsd.parseBuffers );
			output->pos = output->buf = NewArray( char, msglen + 1 );
			output->size = msglen;
			EnqueLinkNL( state->outQueue, output );
		}
	}
	else {
		// zero length input buffer... terminate a number.
		if( state->gatheringNumber ) {
			//console.log( "Force completed.")
			output = (struct vesl_output_buffer*)DequeLinkNL( state->outQueue );
			output->pos[0] = 0;
			PushLink( state->outBuffers, output );
			state->gatheringNumber = FALSE;
			//lprintf( "result with number:%s", state->val.string );
			if( state->val.float_result )
			{
				CTEXTSTR endpos;
				state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
				if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
			}
			else
			{
				state->val.result_n = IntCreateFromText( state->val.string );
				if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
			}
			state->val.value_type = VESL_VALUE_NUMBER;
			if( state->parse_context == CONTEXT_UNKNOWN ) {
				state->completed = TRUE;
			}
			retval = 1;
		}
	}
	while( state->status && ( input = (PPARSE_BUFFER)DequeLinkNL( state->inBuffers ) ) ) {
		state->output = output = (struct vesl_output_buffer*)DequeLinkNL( state->outQueue );
		//lprintf( "output is %p", output );
		state->n = input->pos - input->buf;
		if( state->n > input->size ) DebugBreak();
		if( state->gatheringString ) {
			string_status = gatherString6v( state, input->buf, &input->pos, input->size, &output->pos );
			if( string_status < 0 )
				state->status = FALSE;
			else if( string_status > 0 )
			{
				state->gatheringString = FALSE;
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
				state->val.stringLen = (output->pos - state->val.string)-1;
				if( state->status ) state->val.value_type = VESL_VALUE_STRING;
			}
			else {
				state->n = input->pos - input->buf;
				if( state->n > input->size ) DebugBreak();
			}
		}
		if( state->gatheringNumber ) {
			//lprintf( "continue gathering a string" );
			goto continueNumber;
		}
		//lprintf( "Completed at start?%d", state->completed );
		while( state->status && (state->n < input->size) && (c = GetUtfChar( &input->pos )) )
		{
		retry:
			state->col++;
			state->n = input->pos - input->buf;
			if( state->n > input->size ) DebugBreak();
			lprintf( "  --- Character %c(%d) val:%d(%s) context:%d word:%d(%s)  isOp:%d"
				, c<32?'.':c, c, state->val.value_type, (state->val.value_type >= 0 && state->val.value_type < NUM_VALUE_NAMES)?value_type_names[state->val.value_type]:"????"
				, state->parse_context, state->word, word_pos_names[state->word]
				, (c<127)?TESTFLAG(isOp,c):0);
			vesl_dump_parse( state->root );
			if( state->comment ) {
				if( state->comment == 1 ) {
					if( c == '*' ) { state->comment = 3; continue; }
					if( c != '/' ) {
						if( !state->pvtError ) state->pvtError = VarTextCreate();
						vtprintf( state->pvtError, WIDE( "Fault while parsing; unexpected %c at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
						state->status = FALSE;
					}
					else state->comment = 2;
					continue;
				}
				if( state->comment == 2 ) {
					if( c == '\n' ) { state->comment = 0; continue; }
					else continue;
				}
				if( state->comment == 3 ) {
					if( c == '*' ) { state->comment = 4; continue; }
					else continue;
				}
				if( state->comment == 4 ) {
					if( c == '/' ) { state->comment = 0; continue; }
					else { if( c != '*' ) state->comment = 3; continue; }
				}
			}
			switch( c )
			{
			case '(':
			case '{':
				vesl_start_expression( state );
				break;
			case '[':
				vesl_start_array( state );
				break;
			case '}':
			case ')':
				vesl_close_expression_array( state );
				break;
			case ']':
				vesl_close_expression_array( state );
				break;
			default:
				if( c == ' ' || c == 0xFEFF ) {
					state->weakSpace = TRUE;
					continue;
				}
				if( c == '\n' ) {
					state->line++;
					state->col = 1;
					state->weakSpace = FALSE;
					continue;
				}
				if( c == ',' || c == ';' || c == '\t' || c == '\r' ) {
					state->weakSpace = FALSE;
					continue;
				}
				if( c < 0xff ) {
					if( (c >= '0' && c <= '9') )
					{
						LOGICAL fromDate;
 // to unwind last character past number.
						const char *_msg_input;
												// always reset this here....
												// keep it set to determine what sort of value is ready.
						if( !state->gatheringNumber ) {
							state->exponent = FALSE;
							state->exponent_sign = FALSE;
							state->exponent_digit = FALSE;
							fromDate = FALSE;
							state->fromHex = FALSE;
							state->val.float_result = (c == '.');
							state->val.string = output->pos;
  // terminate the string.
							(*output->pos++) = c;
						}
						else
						{
						continueNumber:
							fromDate = state->numberFromDate;
						}
						while( (_msg_input = input->pos), ((state->n < input->size) && (c = GetUtfChar( &input->pos ))) )
						{
							//lprintf( "Number input:%c", c );
							state->col++;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
							// leading zeros should be forbidden.
							if( c == '_' )
								continue;
							if( c >= '0' && c <= '9' )
							{
								(*output->pos++) = c;
								if( state->exponent )
									state->exponent_digit = TRUE;
							}
#if 0
							// to be implemented (date parsing?)
							else if( c == ':' || c == '-' || c == 'Z' || c == '+' ) {
								/* toISOString()
								var today = new Date('05 October 2011 14:48 UTC');
								console.log(today.toISOString());
								// Returns 2011-10-05T14:48:00.000Z
								*/
								(*output->pos++) = c;
							}
#endif
							else if( (c == 'x' || c == 'b' || c == 'o' || c == 'X' || c == 'B' || c == 'O')
								&& (output->pos - output->buf) == 1
								&& output->buf[0] == '0' ) {
								// hex conversion.
								if( !state->fromHex ) {
									state->fromHex = TRUE;
 // force lower case.
									(*output->pos++) = c | 0x20;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( (c == 'e') || (c == 'E') )
							{
								if( !state->exponent ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
									state->exponent = TRUE;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else if( c == '-' || c == '+' ) {
								if( !state->exponent ) {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
								else {
									if( !state->exponent_sign && !state->exponent_digit ) {
										(*output->pos++) = c;
										state->exponent_sign = 1;
									}
									else {
										state->status = FALSE;
										if( !state->pvtError ) state->pvtError = VarTextCreate();
										vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
										break;
									}
								}
							}
							else if( c == '.' )
							{
								if( !state->val.float_result && !state->fromHex ) {
									state->val.float_result = 1;
									(*output->pos++) = c;
								}
								else {
									state->status = FALSE;
									if( !state->pvtError ) state->pvtError = VarTextCreate();
									vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
									break;
								}
							}
							else
							{
								// in non streaming mode; these would be required to follow
								//if( c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == 0xFEFF
								//	|| c == ',' || c == ';' || c == ']' || c == '}' || c == ':' ) {
								//lprintf( "Non numeric character received; push the value we have" );
								// operator may be following, which is not lost.
								//(*output->pos) = 0;
								break;
								//}
								//else {
								//	state->status = FALSE;
								//	if( !state->pvtError ) state->pvtError = VarTextCreate();
								//	vtprintf( state->pvtError, WIDE( "fault white parsing number; '%c' unexpected at %" ) _size_f WIDE( "  %" ) _size_f WIDE( ":%" ) _size_f, c, state->n, state->line, state->col );
								//	break;
								//}
							}
						}
						if( input ) {
							input->pos = _msg_input;
							state->n = (input->pos - input->buf);
							if( state->n > input->size ) DebugBreak();
						}
						//LogBinary( (uint8_t*)output->buf, output->size );
						if( input && (!state->complete_at_end) && state->n == input->size )
						{
							//lprintf( "completion mode is not end of string; and at end of string" );
							state->gatheringNumber = TRUE;
							state->numberFromDate = fromDate;
						}
						else
						{
							(*output->pos++) = 0;
							state->val.stringLen = (output->pos - state->val.string);
							state->gatheringNumber = FALSE;
							//lprintf( "result with number:%s", state->val.string );
							if( state->val.float_result )
							{
								CTEXTSTR endpos;
								state->val.result_d = FloatCreateFromText( state->val.string, &endpos );
								if( state->negative ) { state->val.result_d = -state->val.result_d; state->negative = FALSE; }
							}
							else
							{
								state->val.result_n = IntCreateFromText( state->val.string );
								if( state->negative ) { state->val.result_n = -state->val.result_n; state->negative = FALSE; }
							}
							state->val.value_type = VESL_VALUE_NUMBER;
							if( state->parse_context == CONTEXT_UNKNOWN ) {
								state->completed = TRUE;
							}
						}
						continue;
					}
					if( !state->operatorAccum ) {
						if( TESTFLAG( isOp, c ) ) {
							commitPending( state );
							state->operatorAccum = c;
 // is an operator... next!
							continue;
						}
					}
					else {
						state->val.value_type = VESL_VALUE_OPERATOR;
						state->val.string = output->pos;
						state->val.stringLen = 1;
						(*output->pos++) = state->operatorAccum;
						if( TESTFLAG( isOp2[state->operatorAccum], c ) ) {
							if( state->operatorAccum == '/' && c == '/' ) {
								state->comment = 2;
								continue;
							}
							if( state->operatorAccum == '/' && c == '*' ) {
								state->comment = 3;
								continue;
							}
							state->val.stringLen = 2;
							(*output->pos++) = c;
							commitPending( state );
							break;
						}
						lprintf( "flush operator; push value:%s %p", value_type_names[state->val.value_type], state->elements );
						commitPending( state );
						//goto retry;
					}
				}
				if( c == '`' || c == '"' || c == '\'' ) {
					if( !state->val.string )
						state->val.string = output->pos;
					state->gatheringString = TRUE;
					state->gatheringStringFirstChar = c;
					string_status = gatherString6v( state, input->buf, &input->pos, input->size, &output->pos );
					//lprintf( "string gather status:%d", string_status );
					if( string_status < 0 )
						state->status = FALSE;
					else if( string_status > 0 ) {
						state->gatheringString = FALSE;
						state->val.stringLen = (output->pos - state->val.string);
					}
					state->n = input->pos - input->buf;
					if( state->n > input->size ) DebugBreak();
					if( state->status ) {
						state->val.value_type = VESL_VALUE_STRING;
						commitPending( state );
					}
					continue;
				}
				switch( gatherIdentifier( state, input->buf, &input->pos, input->size, &c, &output->pos ) ) {
 // no data.  C will not have data.
				case 0:
					break;
 // c has a character
				case 1:
					goto retry;
 // length, but ran out of data, no next character.
				case 2:
					commitPending( state );
					break;
 // length, but ran out of data, no next character.
				case 3:
					commitPending( state );
					goto retry;
				}
			}
		}
		//lprintf( "at end... %d %d comp:%d", state->n, input->size, state->completed );
		if( input ) {
			if( state->n >= input->size ) {
				DeleteFromSet( PARSE_BUFFER, vpsd.parseBuffers, input );
				if( state->gatheringString || state->gatheringNumber || state->word != WORD_POS_RESET ) {
					//lprintf( "output is still incomplete? " );
					PrequeLink( state->outQueue, output );
					retval = 0;
				}
				else {
					PushLink( state->outBuffers, output );
					if( state->parse_context == CONTEXT_OBJECT_FIELD
					  && ( state->val.value_type != VESL_VALUE_UNSET
					     || state->elements[0]->Cnt ) ) {
						state->completed = TRUE;
						retval = 1;
					}
				}
				//lprintf( "Is complete already?%d", state->completed );
			}
			else {
				// put these back into the stack.
				//lprintf( "put buffers back into queues..." );
				PrequeLink( state->inBuffers, input );
				PrequeLink( state->outQueue, output );
  // if returning buffers, then obviously there's more in this one.
				retval = 2;
			}
		}
		if( state->completed )
			break;
 // while DequeInput
	}
	if( !state->status ) {
		// some error condition; cannot resume parsing.
		return -1;
	}
	state->root = NULL;
	if( state->completed ) {
		if( state->val.value_type != VESL_VALUE_UNSET ) {
			lprintf( "Final completed, push expression; push value:%s", value_type_names[state->val.value_type] );
			AddDataItem( state->elements, &state->val );
			RESET_STATE_VAL();
		}
		state->completed = FALSE;
	}
	return retval;
}
void vesl_preinit_state( struct vesl_parse_state *state ) {
	struct vesl_parse_context *old_context = GetFromSet( PARSE_CONTEXT, &vpsd.parseContexts );
#ifdef _DEBUG_PARSING
	lprintf( "Begin a new object; previously pushed into elements; but wait until trailing comma or close previously:%d", val.value_type );
#endif
	// it's going to be an expression list.
	state->val.value_type = VESL_VALUE_EXPRESSION;
	old_context->context = state->parse_context;
	old_context->elements = state->elements;
	old_context->valState = state->val;
	state->elements = state->val._contains;
	if( !state->elements ) state->elements = GetFromSet( PDATALIST, &vpsd.dataLists );
	if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
	//if( !state->root ) state->root = state->elements[0];
	//else state->elements[0]->Cnt = 0;
	PushLink( state->context_stack, old_context );
	RESET_STATE_VAL();
	state->parse_context = CONTEXT_OBJECT_FIELD;
}
/* I guess this is a good parser */
struct vesl_parse_state * vesl_begin_parse( void )
{
//New( struct vesl_parse_state );
	struct vesl_parse_state *state = GetFromSet( PARSE_STATE, &vpsd.parseStates );
	vesl_state_init( state );
	return state;
}
PDATALIST vesl_parse_get_data( struct vesl_parse_state *state ) {
	PDATALIST *result = state->elements;
// CreateDataList( sizeof( state->val ) );
	state->elements = GetFromSet( PDATALIST, &vpsd.dataLists );
	if( !state->elements[0] ) state->elements[0] = CreateDataList( sizeof( state->val ) );
	else state->elements[0]->Cnt = 0;
	return result[0];
}
void _vesl_dispose_message( PDATALIST *msg_data )
{
	struct vesl_value_container *val;
	INDEX idx;
	if( !msg_data ) return;
	DATA_FORALL( (*msg_data), idx, struct vesl_value_container*, val )
	{
		// names and string buffers for JSON parsed values in a single buffer
		// associated with the root message.
		//if( val->name ) Release( val->name );
		//if( val->string ) Release( val->string );
		if( val->_contains )
			_vesl_dispose_message( val->_contains );
	}
	// quick method
	DeleteFromSet( PDATALIST, vpsd.dataLists, msg_data );
	(*msg_data) = NULL;
	//DeleteDataList( msg_data );
}
void vesl_parse_dispose_state( struct vesl_parse_state **ppState ) {
	struct vesl_parse_state *state = (*ppState);
	struct vesl_parse_context *old_context;
	PPARSE_BUFFER buffer;
	_vesl_dispose_message( state->elements );
	//DeleteDataList( &state->elements );
	while( buffer = (PPARSE_BUFFER)PopLink( state->outBuffers ) ) {
		Deallocate( const char *, buffer->buf );
		DeleteFromSet( PARSE_BUFFER, vpsd.parseBuffers, buffer );
	}
	{
		char *buf;
		INDEX idx;
		LIST_FORALL( state->outValBuffers[0], idx, char*, buf ) {
			Deallocate( char*, buf );
		}
		DeleteFromSet( PLIST, vpsd.listSet, state->outValBuffers );
		//DeleteList( &state->outValBuffers );
	}
	while( buffer = (PPARSE_BUFFER)DequeLinkNL( state->inBuffers ) )
		DeleteFromSet( PARSE_BUFFER, vpsd.parseBuffers, buffer );
	while( buffer = (PPARSE_BUFFER)DequeLinkNL( state->outQueue ) ) {
		Deallocate( const char*, buffer->buf );
		DeleteFromSet( PARSE_BUFFER, vpsd.parseBuffers, buffer );
	}
	DeleteFromSet( PLINKQUEUE, vpsd.linkQueues, state->inBuffers );
	//DeleteLinkQueue( &state->inBuffers );
	DeleteFromSet( PLINKQUEUE, vpsd.linkQueues, state->outQueue );
	//DeleteLinkQueue( &state->outQueue );
	DeleteFromSet( PLINKSTACK, vpsd.linkStacks, state->outBuffers );
	//DeleteLinkStack( &state->outBuffers );
	//DeleteFromSet( PARSE_CONTEXT, vpsd.parseContexts, state->context );
	while( (old_context = (struct vesl_parse_context *)PopLink( state->context_stack )) ) {
		//lprintf( "warning unclosed contexts...." );
		DeleteFromSet( PARSE_CONTEXT, vpsd.parseContexts, old_context );
	}
	if( state->context_stack )
		DeleteFromSet( PLINKSTACK, vpsd.linkStacks, state->context_stack );
	//DeleteLinkStack( &state->context_stack );
	DeleteFromSet( PARSE_STATE, vpsd.parseStates, state );
	//Deallocate( struct vesl_parse_state *, state );
	(*ppState) = NULL;
}
LOGICAL vesl_parse_message( const char * msg
	, size_t msglen
	, PDATALIST *_msg_output ) {
	struct vesl_parse_state *state = vesl_begin_parse();
	static struct vesl_parse_state *_state;
	int result;
	vesl_preinit_state( state );
	state->complete_at_end = TRUE;
	result = vesl_parse_add_data( state, msg, msglen );
	if( _state ) vesl_parse_dispose_state( &_state );
	if( result > 0 ) {
		(*_msg_output) = vesl_parse_get_data( state );
		vesl_dump_parse( (*_msg_output) );
		_state = state;
		//vesl_parse_dispose_state( &state );
		return TRUE;
	}
	(*_msg_output) = NULL;
	vpsd.last_parse_state = state;
	_state = state;
	return FALSE;
}
void vesl_dispose_decoded_message( struct vesl_context_object *format
                                 , POINTER msg_data )
{
	// a complex format might have sub-parts .... but for now we'll assume simple flat structures
	//Release( msg_data );
}
void vesl_dispose_message( PDATALIST *msg_data )
{
	//vesl_dispose_message( msg_data );
	return;
}
#undef GetUtfChar
#ifdef __cplusplus
} } SACK_NAMESPACE_END
#endif
///////////////////////////////////////////////////////////////////////////
//
// Filename    -  Network.C
//
// Description -  Network services for Communications Client
//
// Author      -  James Buckeyne
//
// Create Date -  Before now.
// Conversion update for Linux GLIBC 2.1 9/26/2000
//
///////////////////////////////////////////////////////////////////////////
//
//  DEBUG FLAGS IN netstruc.h
//
#define FIX_RELEASE_COM_COLLISION
#define NO_UNICODE_C
#define MAIN_PROGRAM
 // critical section
//#include "../contrib/MatrixSSL/3.7.1/matrixssl/matrixsslApi.h"
// debugging flag for socket creation/closing
//#define LOG_SOCKET_CREATION
// there were some messages regarding the close sequence of sockets
// they were left open... so developers might track why sockets were closing...
// these should be probably be re-enabled and be controlled with a runtime option flag.
//#define LOG_DEBUG_CLOSING
// started using this symbol more in the later days of disabling logging...
//#define VERBOSE_DEBUG
//#define LOG_STARTUP_SHUTDOWN
// Define this symbol to use Log( ghLog, WIDE("") ) to log pending
// write status...
//#define LOG_PENDING
// for windows - this will log all FD_XXXX notifications processed...
//#define LOG_NOTICES
//#define LOG_CLIENT_LISTS
//#define LOG_NETWORK_LOCKING
/// for windows - this logs detailed info about the new threaded events
//#define LOG_NETWORK_EVENT_THREAD
//TODO: modify the client struct to contain the MAC addr
#ifndef __LINUX__
#define USE_WSA_EVENTS
#endif
#ifndef CLIENT_DEFINED
#define CLIENT_DEFINED
SACK_NETWORK_NAMESPACE
#define MAGIC_SOCKADDR_LENGTH ( sizeof(SOCKADDR_IN)< 256?256:sizeof( SOCKADDR_IN) )
#define IN_SOCKADDR_LENGTH sizeof(struct sockaddr_in)
#define IN6_SOCKADDR_LENGTH sizeof(struct sockaddr_in6)
// this might have to be like sock_addr_len_t
#define SOCKADDR_LENGTH(sa) ( (int)*(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) )
#ifdef __MAC__
#  define SET_SOCKADDR_LENGTH(sa,size) ( ( ( *(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) ) = size ), ( sa->sa_len = size ) )
#else
#  define SET_SOCKADDR_LENGTH(sa,size) ( ( *(uintptr_t*)( ( (uintptr_t)(sa) ) - 2*sizeof(uintptr_t) ) ) = size )
#endif
// used by the network thread dispatched network layer messages...
  // messages for UDP use this window Message
#define SOCKMSG_UDP (WM_USER+1)
  // Messages for TCP use this Window Message
#define SOCKMSG_TCP (WM_USER+2)
 // Message for Network layer shutdown.
#define SOCKMSG_CLOSE (WM_USER+3)
// not sure if this is used anywhere....
      // maximum length of a host's text name...
#define HOSTNAME_LEN 50
typedef struct PendingBuffer
{
                // number of bytes to be read yet
   size_t dwAvail;
                 // Number of bytes already read.
   size_t dwUsed;
             // number of bytes received on last read.
   size_t dwLastRead;
   struct {
    // is a stream request...
      int  bStream:1;
 // lpBuffer was malloced...
      int  bDynBuffer:1;
	}s;
	union {
              // Buffer Pointer.
		CPOINTER c;
		POINTER p;
	} buffer;
 // Next Pending Message to be handled
   struct PendingBuffer *lpNext;
}PendingBuffer;
enum NetworkConnectionFlags {
	CF_UDP               = 0x00000001
	// no flag... is NOT UDP....
	, CF_TCP             = 0x00000000
	, CF_LISTEN          = 0x00000002
	// some write is left hanging to output
	, CF_WRITEPENDING    = 0x00000004
	// set if buffers have been set by a read
	, CF_READPENDING     = 0x00000008
	// set if next read to pend should recv also
	, CF_READREADY       = 0x00000010
	// set if reading application is waiting in-line for result.
	, CF_READWAITING     = 0x00008000
	// set when FD_CONNECT is issued...
	, CF_CONNECTED       = 0x00000020
	, CF_CONNECTERROR    = 0x00000040
	, CF_CONNECTING      = 0x00000080
	, CF_CONNECT_WAITING = 0x00008000
	, CF_CONNECT_CLOSED  = 0x00100000
	, CF_TOCLOSE         = 0x00000100
	, CF_WRITEISPENDED   = 0x00000200
	, CF_CLOSING         = 0x00000400
	, CF_DRAINING        = 0x00000800
	// closed, handled everything except releasing the socket.
	, CF_CLOSED          = 0x00001000
	, CF_ACTIVE          = 0x00002000
	, CF_AVAILABLE       = 0x00004000
	, CF_CPPCONNECT      = 0x00010000
	// server/client is implied in usage....
	// much like Read, ReadEX are implied in TCP/UDP usage...
	//#define CF_CPPSERVERCONNECT 0x010000
	//#define CF_CPPCLIENTCONNECT 0x020000
	, CF_CPPREAD         = 0x00020000
	, CF_CPPCLOSE        = 0x00040000
	, CF_CPPWRITE        = 0x00080000
	, CF_CALLBACKTYPES   = 0x00010000
                        | 0x00020000
                        | 0x00040000
//(CF_CPPCONNECT | CF_CPPREAD | CF_CPPCLOSE | CF_CPPWRITE)
                        | 0x00080000
  //( CF_ACTIVE | CF_AVAILABLE | CF_CLOSED)
	, CF_STATEFLAGS      = 0x1000 | 0x2000 | 0x4000
	//, CF_WANTS_GLOBAL_LOCK = 0x10000000
	, CF_PROCESSING      = 0x20000000
};
#ifdef __cplusplus
#  ifndef DEFINE_ENUM_FLAG_OPERATORS
#    ifdef __GNUC__
// used as an approximation of std::underlying_type<T>
template <size_t S>
struct _ENUM_FLAG_INTEGER_FOR_SIZE;
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
{
	typedef int8_t type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
{
	typedef int16_t type;
};
template <>
struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
{
	typedef int32_t type;
};
template <class T>
struct _ENUM_FLAG_SIZED_INTEGER
{
	typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof( T )>::type type;
};
#    endif
#    define DEFINE_ENUM_FLAG_OPERATORS(ENUMTYPE)         extern "C++" {         inline ENUMTYPE operator | ( ENUMTYPE a, ENUMTYPE b ) { return ENUMTYPE( ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b) ); }         inline ENUMTYPE &operator |= ( ENUMTYPE &a, ENUMTYPE b ) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }         inline ENUMTYPE operator & ( ENUMTYPE a, ENUMTYPE b ) { return ENUMTYPE( ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b) ); }         inline ENUMTYPE &operator &= ( ENUMTYPE &a, ENUMTYPE b ) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }         inline ENUMTYPE operator ~ ( ENUMTYPE a ) { return ENUMTYPE( ~((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ); }         inline ENUMTYPE operator ^ ( ENUMTYPE a, ENUMTYPE b ) { return ENUMTYPE( ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b) ); }         inline ENUMTYPE &operator ^= ( ENUMTYPE &a, ENUMTYPE b ) { return (ENUMTYPE &)(((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ENUMTYPE>::type)b)); }         }
#  endif
DEFINE_ENUM_FLAG_OPERATORS( NetworkConnectionFlags )
#endif
struct peer_thread_info
{
	struct peer_thread_info *parent_peer;
	struct peer_thread_info *child_peer;
   // list of PCLIENT which are waiting on
	PLIST monitor_list;
 // list of HANDLE which is waited on
	PDATALIST event_list;
	PTHREAD thread;
#ifdef _WIN32
	WSAEVENT hThread;
	int nEvents;
	LOGICAL counting;
 // updated with count thread is waiting on
	int nWaitEvents;
#endif
#ifdef __LINUX__
#  ifdef __MAC__
	int kqueue;
   PDATALIST kevents;
#  else
	int epoll_fd;
#  endif
	uint32_t nEvents;
#endif
	struct {
		BIT_FIELD bProcessing : 1;
		BIT_FIELD bBuildingList : 1;
	} flags;
};
struct NetworkClient
{
  //Dest Address
	SOCKADDR *saClient;
  //Local Address of this port ...
	SOCKADDR *saSource;
 // use this for UDP recvfrom
	SOCKADDR *saLastClient;
	uint8_t     hwClient[6];
	uint8_t     hwSource[6];
	//  ServeUDP( WIDE("SourceIP"), SourcePort );
	//		 saSource w/ no Dest - read is a connect...
	//  ConnectUDP( WIDE("DestIP"), DestPort );
	//     saClient is DestIP
	//		saSource and implied source...
	//     USE TCP to locate MY Address?
	//     bind(UDP) results in?
	//     connect(UDP) results in?
	SOCKET      Socket;
 // okay keep both...
	SOCKET      SocketBroadcast;
	struct interfaceAddress* interfaceAddress;
 // CF_
	enum NetworkConnectionFlags  dwFlags;
	uintptr_t        *lpUserData;
	union {
 // new incoming client.
		void (CPROC*ClientConnected)( struct NetworkClient *old, struct NetworkClient *newclient );
		void (CPROC*ThisConnected)(struct NetworkClient *me, int nStatus );
 // new incoming client.
		void (CPROC*CPPClientConnected)( uintptr_t psv, struct NetworkClient *newclient );
		void (CPROC*CPPThisConnected)( uintptr_t psv, int nStatus );
	}connect;
	uintptr_t psvConnect;
	union {
		void (CPROC*CloseCallback)(struct NetworkClient *);
		void (CPROC*CPPCloseCallback)(uintptr_t psv);
	} close;
	uintptr_t psvClose;
	union {
		cReadComplete ReadComplete;
		cppReadComplete CPPReadComplete;
		cReadCompleteEx ReadCompleteEx;
		cppReadCompleteEx CPPReadCompleteEx;
	}read;
	uintptr_t psvRead;
	union {
		void (CPROC*WriteComplete)( struct NetworkClient * );
		void (CPROC*CPPWriteComplete)( uintptr_t psv );
	}write;
	uintptr_t psvWrite;
 // set during bWriteComplete Notify...
	LOGICAL        bWriteComplete;
    // byte sink functions.... JAB:980202
	LOGICAL        bDraining;
  // length does not matter - read until one empty read.
	LOGICAL        bDrainExact;
	size_t         nDrainLength;
#if defined( USE_WSA_EVENTS )
	WSAEVENT event;
#endif
    // per client lock.
	CRITICALSECTION csLockRead;
   // per client lock.
	CRITICALSECTION csLockWrite;
 // Thread which is waiting for a result...
	PTHREAD pWaiting;
 // current incoming buffer
	PendingBuffer RecvPending, FirstWritePending;
 // outgoing buffers
	PendingBuffer *lpFirstPending,*lpLastPending;
 // GetTickCount() of last event...
	uint32_t    LastEvent;
	DeclareLink( struct NetworkClient );
 // listeners opened with port only have two connections, one IPV4 one IPV6
	PCLIENT pcOther;
	struct network_client_flags {
		BIT_FIELD bAddedToEvents : 1;
		BIT_FIELD bRemoveFromEvents : 1;
		BIT_FIELD bSecure : 1;
		BIT_FIELD bAllowDowngrade : 1;
	} flags;
	// this is set to what the thread that's waiting for this event is.
	struct peer_thread_info *this_thread;
	int tcp_delay_count;
	struct ssl_session *ssl_session;
};
typedef struct NetworkClient CLIENT;
#ifdef MAIN_PROGRAM
#define LOCATION
#else
#define LOCATION extern
#endif
//LOCATION CRITICALSECTION csNetwork;
#define MAX_NETCLIENTS  globalNetworkData.nMaxClients
typedef struct client_slab_tag {
	uint32_t count;
	uintptr_t* pUserData;
	CLIENT client[1];
} CLIENT_SLAB, *PCLIENT_SLAB;
// global network data goes here...
LOCATION struct network_global_data{
	uint32_t     nMaxClients;
     // number of longs.
	int     nUserData;
	//uint8_t*     pUserData;
	PLIST   ClientSlabs;
	LOGICAL bLog;
	LOGICAL bQuit;
 // list of all threads - needed because of limit of 64 sockets per multiplewait
	PLIST   pThreads;
	PCLIENT AvailableClients;
	PCLIENT ActiveClients;
	PCLIENT ClosedClients;
	CRITICALSECTION csNetwork;
	uint32_t uNetworkPauseTimer;
	uint32_t uPendingTimer;
#ifndef __LINUX__
	HWND ghWndNetwork;
#endif
	CTEXTSTR system_name;
#ifdef WIN32
	int nProtos;
	WSAPROTOCOL_INFOW *pProtos;
	INDEX tcp_protocol;
	INDEX udp_protocol;
	INDEX tcp_protocolv6;
	INDEX udp_protocolv6;
#endif
#if defined( USE_WSA_EVENTS )
   HANDLE hMonitorThreadControlEvent;
  // shorter list of new sockets to monitor than the full list
   PLINKQUEUE client_schedule;
#endif
	uint32_t dwReadTimeout;
	uint32_t dwConnectTimeout;
	PLIST addresses;
	struct {
		BIT_FIELD bLogNotices : 1;
		BIT_FIELD bShortLogReceivedData : 1;
		BIT_FIELD bLogReceivedData : 1;
		BIT_FIELD bLogSentData : 1;
		BIT_FIELD bThreadInitComplete : 1;
		BIT_FIELD bThreadExit : 1;
		BIT_FIELD bNetworkReady : 1;
		BIT_FIELD bThreadInitOkay : 1;
		BIT_FIELD bLogProtocols : 1;
	} flags;
 // how many peer threads do we have
	int nPeers;
	struct peer_thread_info *root_thread;
#if !defined( USE_WSA_EVENTS ) && defined( WIN32 )
	WNDCLASS wc;
#endif
}
 // aka 'globalNetworkData'
*global_network_data;
#define globalNetworkData (*global_network_data)
#ifdef _WIN32
#ifndef errno
#define errno WSAGetLastError()
#endif
#else
#endif
//---------------------------------------------------------------------
// routines exported from the core for use in external modules
PCLIENT GetFreeNetworkClientEx( DBG_VOIDPASS );
#define GetFreeNetworkClient() GetFreeNetworkClientEx( DBG_VOIDSRC )
_UDP_NAMESPACE
int FinishUDPRead( PCLIENT pc, int broadcastEvent );
_UDP_NAMESPACE_END
#ifdef WIN32
	// errors started arrising because of faulty driver stacks.
	// spontaneous 10106 errors in socket require migration to winsock2.
   // socket is opened specifically by protocol descriptor...
SOCKET OpenSocket( LOGICAL v4, LOGICAL bStream, LOGICAL bRaw, int another_offset );
int SystemCheck( void );
#endif
// internal functions
const char * GetAddrName( SOCKADDR *addr );
void TerminateClosedClientEx( PCLIENT pc DBG_PASS );
#define TerminateClosedClient(pc) TerminateClosedClientEx(pc DBG_SRC)
void InternalRemoveClientExx(PCLIENT lpClient, LOGICAL bBlockNofity, LOGICAL bLinger DBG_PASS );
#define InternalRemoveClientEx(c,b,l) InternalRemoveClientExx(c,b,l DBG_SRC)
#define InternalRemoveClient(c) InternalRemoveClientEx(c, FALSE, FALSE )
struct peer_thread_info *IsNetworkThread( void );
SOCKADDR *AllocAddrEx( DBG_VOIDPASS );
#define AllocAddr() AllocAddrEx( DBG_VOIDSRC )
PCLIENT AddActive( PCLIENT pClient );
void RemoveThreadEvent( PCLIENT pc );
void AddThreadEvent( PCLIENT pc, int broadcast );
#define IsValid(S)   ((S)!=INVALID_SOCKET)
#define IsInvalid(S) ((S)==INVALID_SOCKET)
#define CLIENT_DEFINED
SACK_NETWORK_NAMESPACE_END
#endif
//#define DO_LOGGING // override no _DEBUG def to do loggings...
//#define NO_LOGGING // force neverlog....
#ifdef __LINUX__
#endif
//for GetMacAddress
#ifdef __LINUX__
//#include <sys/timeb.h>
//*******************8
#include <net/if_arp.h>
#ifndef __ANDROID__
#include <ifaddrs.h>
#else
/* from https://github.com/morristech/android-ifaddrs/blob/master/ifaddrs.h  2017/25/12 */
/*
 * Copyright (c) 1995, 1999
 *	Berkeley Software Design, Inc.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	BSDI ifaddrs.h,v 2.5 2000/02/23 14:51:59 dab Exp
 */
#ifndef	_IFADDRS_H_
#define	_IFADDRS_H_
struct ifaddrs {
	struct ifaddrs  *ifa_next;
	char		*ifa_name;
	unsigned int	 ifa_flags;
	struct sockaddr	*ifa_addr;
	struct sockaddr	*ifa_netmask;
	struct sockaddr	*ifa_dstaddr;
	void		*ifa_data;
};
/*
 * This may have been defined in <net/if.h>.  Note that if <net/if.h> is
 * to be included it must be included before this header file.
 */
#ifndef	ifa_broadaddr
#define	ifa_broadaddr	ifa_dstaddr
#endif
#include <sys/cdefs.h>
__BEGIN_DECLS
extern int getifaddrs(struct ifaddrs **ifap);
extern void freeifaddrs(struct ifaddrs *ifa);
__END_DECLS
#endif
#define EPOLLRDHUP EPOLLHUP
#define EPOLL_CLOEXEC 0
#endif
#ifdef __MAC__
#include <sys/event.h>
#else
#include <sys/epoll.h>
#endif
//*******************8
#endif
#ifdef WIN32
#ifdef __CYGWIN__
#include <mingw/tchar.h>
#else
#endif
#include <wincrypt.h>
#include <iphlpapi.h>
#endif
SACK_NETWORK_NAMESPACE
PRELOAD( InitNetworkGlobalOptions )
{
#ifdef __LINUX__
	signal(SIGPIPE, SIG_IGN);
#endif
#ifndef __NO_OPTIONS__
	globalNetworkData.flags.bLogProtocols = SACK_GetProfileIntEx( WIDE("SACK"), WIDE( "Network/Log Protocols" ), 0, TRUE );
	globalNetworkData.flags.bShortLogReceivedData = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Received Data(64 byte max)" ), 0, TRUE );
	globalNetworkData.flags.bLogReceivedData = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Received Data" ), 0, TRUE );
	globalNetworkData.flags.bLogSentData = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Sent Data" ), globalNetworkData.flags.bLogReceivedData, TRUE );
#  ifdef LOG_NOTICES
	globalNetworkData.flags.bLogNotices = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Log Network Notifications" ), 0, TRUE );
#  endif
	globalNetworkData.dwReadTimeout = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Read wait timeout" ), 5000, TRUE );
	globalNetworkData.dwConnectTimeout = SACK_GetProfileIntEx( WIDE( "SACK" ), WIDE( "Network/Connect timeout" ), 10000, TRUE );
#else
	globalNetworkData.flags.bLogNotices = 0;
	globalNetworkData.dwReadTimeout = 5000;
	globalNetworkData.dwConnectTimeout = 10000;
#endif
}
static void LowLevelNetworkInit( void )
{
	if( !global_network_data ) {
		SimpleRegisterAndCreateGlobal( global_network_data );
		InitializeCriticalSec( &globalNetworkData.csNetwork );
	}
}
PRIORITY_PRELOAD( InitNetworkGlobal, CONFIG_SCRIPT_PRELOAD_PRIORITY - 1 )
{
	LowLevelNetworkInit();
	if( !globalNetworkData.system_name )
	{
		globalNetworkData.system_name = WIDE("no.network");
	}
}
//----------------------------------------------------------------------------
// forward declaration for the window proc...
_TCP_NAMESPACE
void AcceptClient(PCLIENT pc);
int TCPWriteEx(PCLIENT pc DBG_PASS);
#define TCPWrite(pc) TCPWriteEx(pc DBG_SRC)
int FinishPendingRead(PCLIENT lpClient DBG_PASS );
LOGICAL TCPDrainRead( PCLIENT pClient );
_TCP_NAMESPACE_END
//----------------------------------------------------------------------------
#ifndef __MAC__
#  define INCLUDE_MAC_SUPPORT
#endif
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( int, GetMacAddress)(PCLIENT pc, uint8_t* buf, size_t *buflen )
{
#ifdef INCLUDE_MAC_SUPPORT
#  ifdef __LINUX__
#    ifdef __THIS_CODE_GETS_MY_MAC_ADDRESS___
	int fd;
	struct ifreq ifr;
	fd = socket(PF_UNIX, SOCK_DGRAM, 0);
	if (fd == -1)
	{
		lprintf(WIDE ("Unable to create socket for pclient: %p"), pc);
		return -1;
	}
	strcpy (ifr.ifr_name, GetNetworkLong(pc,GNL_IP));
	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	if (ioctl (fd, SIOCGIFHWADDR, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	close (fd);
	memcpy (pc->hwClient, ifr.ifr_hwaddr.sa_data, 6);
	return 0;
#    endif
	   /* this code queries the arp table to figure out who the other side is */
	//int fd;
	struct arpreq arpr;
	struct ifconf ifc;
	MemSet( &arpr, 0, sizeof( arpr ) );
	lprintf( WIDE( "this is broken." ) );
	MemCpy( &arpr.arp_pa, pc->saClient, sizeof( SOCKADDR ) );
	arpr.arp_ha.sa_family = AF_INET;
	{
		char buf[256];
		ifc.ifc_len = sizeof( buf );
		ifc.ifc_buf = buf;
		ioctl( pc->Socket, SIOCGIFCONF, &ifc );
		{
			int i;
			struct ifreq *IFR;
			IFR = ifc.ifc_req;
			for( i = ifc.ifc_len / sizeof( struct ifreq); --i >=0; IFR++ )
			{
				printf( WIDE( "IF: %s\n" ), IFR->ifr_name );
				strcpy( arpr.arp_dev, WIDE( "eth0" ) );
			}
		}
	}
	DebugBreak();
	if( ioctl( pc->Socket, SIOCGARP, &arpr ) < 0 )
	{
		lprintf( WIDE( "Error of some sort ... %s" ), strerror( errno ) );
		DebugBreak();
	}
	return 0;
#  endif
#  ifdef WIN32
	HRESULT hr;
	ULONG   ulLen;
	// I don't understand this useless cast - from size_t to ULONG?
	// isn't that the same thing?
	ulLen = (ULONG)(*buflen);
	//needs ws2_32.lib and iphlpapi.lib in the linker.
	hr = SendARP ( (IPAddr)GetNetworkLong(pc,GNL_MYIP), (IPAddr)GetNetworkLong(pc,GNL_MYIP), (PULONG)buf, &ulLen);
	(*buflen) = ulLen;
//  The second parameter of SendARP is a PULONG, which is typedef'ed to a pointer to
//  an unsigned long.  The pc->hwClient is a pointer to an array of uint8_t (unsigned chars),
//  actually defined in netstruc.h as uint8_t hwClient[6]; Well, in the end, they are all
//  just addresses, whether they be address to information of eight bits in length, or
//  of (sizeof(unsigned)) in length.  Although this may, in the future, throw a warning.
	//hr = SendARP (GetNetworkLong(pc,GNL_IP), 0, (PULONG)pc->hwClient, &ulLen);
	//lprintf (WIDE("Return %08x, length %8d\n"), hr, ulLen);
	return hr == S_OK;
#  endif
#else
	return 0;
#endif
}
//int get_mac_addr (char *device, unsigned char *buffer)
NETWORK_PROC( PLIST, GetMacAddresses)( void )
{
#ifdef INCLUDE_MAC_SUPPORT
#ifdef __LINUX__
#ifdef __THIS_CODE_GETS_MY_MAC_ADDRESS___
	int fd;
	struct ifreq ifr;
	fd = socket(PF_UNIX, SOCK_DGRAM, 0);
	if (fd == -1)
	{
		lprintf(WIDE ("Unable to create socket for pclient: %p"), pc);
		return -1;
	}
	strcpy (ifr.ifr_name, GetNetworkLong(pc,GNL_IP));
	if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	if (ioctl (fd, SIOCGIFHWADDR, &ifr) < 0)
	{
		close (fd);
		return -1;
	}
	close (fd);
	memcpy (pc->hwClient, ifr.ifr_hwaddr.sa_data, 6);
	return 0;
#endif
	/* this code queries the arp table to figure out who the other side is */
	//int fd;
	struct arpreq arpr;
	MemSet( &arpr, 0, sizeof( arpr ) );
#if 0
	lprintf( WIDE( "this is broken." ) );
	MemCpy( &arpr.arp_pa, pc->saClient, sizeof( SOCKADDR ) );
	arpr.arp_ha.sa_family = AF_INET;
	{
		char buf[256];
		ifc.ifc_len = sizeof( buf );
		ifc.ifc_buf = buf;
		ioctl( pc->Socket, SIOCGIFCONF, &ifc );
		{
			int i;
			struct ifreq *IFR;
			IFR = ifc.ifc_req;
			for( i = ifc.ifc_len / sizeof( struct ifreq); --i >=0; IFR++ )
			{
				printf( WIDE( "IF: %s\n" ), IFR->ifr_name );
				strcpy( arpr.arp_dev, WIDE( "eth0" ) );
			}
		}
	}
	DebugBreak();
	if( ioctl( pc->Socket, SIOCGARP, &arpr ) < 0 )
	{
		lprintf( WIDE( "Error of some sort ... %s" ), strerror( errno ) );
		DebugBreak();
	}
#endif
	return 0;
#endif
#ifdef WIN32
	HRESULT hr;
	ULONG   ulLen;
	uint8_t hwClient[6];
	ulLen = 6;
	//needs ws2_32.lib and iphlpapi.lib in the linker.
	hr = SendARP ((IPAddr)GetNetworkLong(NULL,GNL_IP), 0x100007f, (PULONG)&hwClient, &ulLen);
//  The second parameter of SendARP is a PULONG, which is typedef'ed to a pointer to
//  an unsigned long.  The pc->hwClient is a pointer to an array of uint8_t (unsigned chars),
//  actually defined in netstruc.h as uint8_t hwClient[6]; Well, in the end, they are all
//  just addresses, whether they be address to information of eight bits in length, or
//  of (sizeof(unsigned)) in length.  Although this may, in the future, throw a warning.
	//hr = SendARP (GetNetworkLong(pc,GNL_IP), 0, (PULONG)pc->hwClient, &ulLen);
	lprintf (WIDE("Return %08x, length %8d\n"), hr, ulLen);
	return 0;
#endif
#else
	return 0;
#endif
}
//----------------------------------------------------------------------------
void DumpLists( void )
{
	int c = 0;
	PCLIENT pc;
	for( pc = globalNetworkData.AvailableClients; c < 50 && pc; pc = pc->next )
	{
		//lprintf( WIDE("Available %p"), pc );
		if( (*pc->me) != pc )
			DebugBreak();
		c++;
	}
	if( c > 50 )
	{
		lprintf( WIDE( "Overflow available clients." ) );
		//DebugBreak();
	}
	c = 0;
	for( pc = globalNetworkData.ActiveClients; c < 50 && pc; pc = pc->next )
	{
		//lprintf( WIDE( WIDE( "Active %p(%d)" ) ), pc, pc->Socket );
		if( (*pc->me) != pc )
			DebugBreak();
		c++;
	}
	if( c > 50 )
	{
		lprintf( WIDE( "Overflow active clients." ) );
		DebugBreak();
	}
	c = 0;
	for( pc = globalNetworkData.ClosedClients; c < 50 && pc; pc = pc->next )
	{
		//lprintf( WIDE( "Closed %p(%d)" ), pc, pc->Socket );
		if( (*pc->me) != pc )
			DebugBreak();
		c++;
	}
	if( c > 50 )
	{
		lprintf( WIDE( "Overflow closed clients." ) );
		DebugBreak();
	}
}
//----------------------------------------------------------------------------
LOGICAL IsAddressV6( SOCKADDR *addr )
{
	if( addr->sa_family == AF_INET6 && SOCKADDR_LENGTH( addr ) == 28 )
		return TRUE;
	return FALSE;
}
const char * GetAddrString( SOCKADDR *addr )
{
	static char buf[256];
	//lprintf( "addr family is: %d", addr->sa_family );
	if( addr->sa_family == AF_INET )
		snprintf( buf, 256, "%d.%d.%d.%d"
			, *(((unsigned char *)addr) + 4),
			*(((unsigned char *)addr) + 5),
			*(((unsigned char *)addr) + 6),
			*(((unsigned char *)addr) + 7) );
	else if( addr->sa_family == AF_INET6 )
	{
		int first0 = 8;
		int last0 = 0;
		int after0 = 0;
		int n;
		int ofs = 0;
		uint32_t peice;
		for( n = 0; n < 8; n++ ) {
			peice = (*(((unsigned short *)((unsigned char*)addr + 8 + (n * 2)))));
			if( peice ) {
				if( first0 < 8 )
					after0 = 1;
				if( !ofs ) {
					ofs += snprintf( buf + ofs, 256 - ofs, "%x", ntohs( peice ) );
				}
				else {
					//console.log( last0, n );
					if( last0 == 4 && first0 == 0 )
						if( peice == 0xFFFF ) {
							snprintf( buf, 256, "::ffff:%d.%d.%d.%d",
								(*((unsigned char*)addr + 20)),
								(*((unsigned char*)addr + 21)),
								(*((unsigned char*)addr + 22)),
								(*((unsigned char*)addr + 23)) );
							break;
						}
					ofs += snprintf( buf + ofs, 256 - ofs, ":%x", ntohs( peice ) );
				}
			}
			else {
				if( !after0 ) {
					if( first0 > n ) {
						first0 = n;
						ofs += snprintf( buf + ofs, 256 - ofs, ":" );
					}
					if( last0 < n )
						last0 = n;
				}
				if( last0 < n )
					ofs += snprintf( buf + ofs, 256 - ofs, ":%x", ntohs( peice ) );
			}
		}
		if( !after0 )
			ofs += snprintf( buf + ofs, 256 - ofs, ":" );
	}
	else
		snprintf( buf, 256, "unknown protocol" );
	return buf;
}
const char * GetAddrName( SOCKADDR *addr )
{
	char * tmp = ((char**)addr)[-1];
	if( !tmp )
	{
		const char *buf = GetAddrString( addr );
		((char**)addr)[-1] = strdup( buf );
	}
	return ((char**)addr)[-1];
}
void SetAddrName( SOCKADDR *addr, const char *name )
{
	((uintptr_t*)addr)[-1] = (uintptr_t)strdup( name );
}
//---------------------------------------------------------------------------
SOCKADDR *AllocAddrEx( DBG_VOIDPASS )
{
	SOCKADDR *lpsaAddr=(SOCKADDR*)AllocateEx( MAGIC_SOCKADDR_LENGTH + 2 * sizeof( uintptr_t ) DBG_RELAY );
	memset( lpsaAddr, 0, MAGIC_SOCKADDR_LENGTH );
	//initialize socket length to something identifiable?
	((uintptr_t*)lpsaAddr)[0] = 3;
 // string representation of address
	((uintptr_t*)lpsaAddr)[1] = 0;
	lpsaAddr = (SOCKADDR*)( ( (uintptr_t)lpsaAddr ) + sizeof(uintptr_t) * 2 );
	return lpsaAddr;
}
//----------------------------------------------------------------------------
PCLIENT GrabClientEx( PCLIENT pClient DBG_PASS )
#define GrabClient(pc) GrabClientEx( pc DBG_SRC )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		_lprintf(DBG_RELAY)( WIDE( "grabbed client %p(%d)" ), pClient, pClient->Socket );
		lprintf( WIDE( "grabbed client %p Ac:%p(%p(%d)) Av:%p(%p(%d)) Cl:%p(%p(%d))" )
				 , pClient->me
					 , &globalNetworkData.ActiveClients, globalNetworkData.ActiveClients, globalNetworkData.ActiveClients?globalNetworkData.ActiveClients->Socket:0
					 , &globalNetworkData.AvailableClients, globalNetworkData.AvailableClients, globalNetworkData.AvailableClients?globalNetworkData.AvailableClients->Socket:0
					 , &globalNetworkData.ClosedClients, globalNetworkData.ClosedClients, globalNetworkData.ClosedClients?globalNetworkData.ClosedClients->Socket:0
				 );
		DumpLists();
#endif
		pClient->dwFlags &= ~CF_STATEFLAGS;
		if( pClient->dwFlags & CF_AVAILABLE )
			lprintf( "Grabbed. %p  %08x", pClient, pClient->dwFlags );
		pClient->LastEvent = GetTickCount();
		if( ( (*pClient->me) = pClient->next ) )
			pClient->next->me = pClient->me;
	}
	return pClient;
}
//----------------------------------------------------------------------------
static PCLIENT AddAvailable( PCLIENT pClient )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		lprintf( WIDE( "Add Avail client %p(%d)" ), pClient, pClient->Socket );
		DumpLists();
#endif
		pClient->dwFlags |= CF_AVAILABLE;
		pClient->LastEvent = GetTickCount();
		pClient->me = &globalNetworkData.AvailableClients;
		if( ( pClient->next = globalNetworkData.AvailableClients ) )
			globalNetworkData.AvailableClients->me = &pClient->next;
		globalNetworkData.AvailableClients = pClient;
	}
	return pClient;
}
//----------------------------------------------------------------------------
// used externally by udp/tcp
PCLIENT AddActive( PCLIENT pClient )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		lprintf( WIDE( "Add Active client %p(%d)" ), pClient, pClient->Socket );
		DumpLists();
#endif
		pClient->dwFlags |= CF_ACTIVE;
		pClient->LastEvent = GetTickCount();
		pClient->me = &globalNetworkData.ActiveClients;
		if( ( pClient->next = globalNetworkData.ActiveClients ) )
			globalNetworkData.ActiveClients->me = &pClient->next;
		globalNetworkData.ActiveClients = pClient;
	}
	return pClient;
}
//----------------------------------------------------------------------------
static PCLIENT AddClosed( PCLIENT pClient )
{
	if( pClient )
	{
#ifdef LOG_CLIENT_LISTS
		lprintf( WIDE( "Add Closed client %p(%d)" ), pClient, pClient->Socket );
		DumpLists();
#endif
		pClient->dwFlags |= CF_CLOSED;
		pClient->LastEvent = GetTickCount();
		pClient->me = &globalNetworkData.ClosedClients;
		if( ( pClient->next = globalNetworkData.ClosedClients ) )
			globalNetworkData.ClosedClients->me = &pClient->next;
		globalNetworkData.ClosedClients = pClient;
	}
	return pClient;
}
//----------------------------------------------------------------------------
static void ClearClient( PCLIENT pc DBG_PASS )
{
	uintptr_t* pbtemp;
	PCLIENT next;
	PCLIENT *me;
	CRITICALSECTION csr;
	CRITICALSECTION csw;
	// keep the closing flag until it's really been closed. (getfreeclient will try to nab it)
	enum NetworkConnectionFlags  dwFlags = pc->dwFlags & (CF_STATEFLAGS | CF_CLOSING | CF_CONNECT_WAITING | CF_CONNECT_CLOSED);
#ifdef VERBOSE_DEBUG
	lprintf( WIDE("CLEAR CLIENT!") );
#endif
	me = pc->me;
	next = pc->next;
	pbtemp = pc->lpUserData;
	csr = pc->csLockRead;
	csw = pc->csLockWrite;
	ReleaseAddress( pc->saClient );
	ReleaseAddress( pc->saSource );
#if _WIN32
	if( pc->event ) {
		if( globalNetworkData.flags.bLogNotices )
			_lprintf(DBG_RELAY)( "Closing network event:%p  %p", pc, pc->event );
		WSACloseEvent( pc->event );
	}
#endif
	// sets socket to 0 - so it's not quite == INVALID_SOCKET
#ifdef LOG_NETWORK_EVENT_THREAD
	if( globalNetworkData.flags.bLogNotices )
		_lprintf(DBG_RELAY)( WIDE( "Clear Client %p  %08x   %08x" ), pc, pc->dwFlags, dwFlags );
#endif
 // clear all information...
	MemSet( pc, 0, sizeof( CLIENT ) );
	// Socket is now 0; which for linux is a valid handle... which is what I get for events...
	pc->csLockRead = csr;
	pc->csLockWrite = csw;
	pc->lpUserData = pbtemp;
	if( pc->lpUserData )
		MemSet( pc->lpUserData, 0, globalNetworkData.nUserData * sizeof( uintptr_t ) );
	pc->next = next;
	pc->me = me;
	pc->dwFlags = dwFlags;
}
//----------------------------------------------------------------------------
static void NetworkGlobalLock( DBG_VOIDPASS ) {
	LOGICAL locked = FALSE;
	do {
#ifdef USE_NATIVE_CRITICAL_SECTION
		if( TryEnterCriticalSection( &globalNetworkData.csNetwork ) < 1 )
#else
		if( EnterCriticalSecNoWaitEx( &globalNetworkData.csNetwork, NULL DBG_RELAY ) < 1 )
#endif
		{
#ifdef LOG_NETWORK_LOCKING
			_lprintf( DBG_RELAY )(WIDE( "Failed enter global? %lld" ), globalNetworkData.csNetwork.dwThreadID );
#endif
			Relinquish();
		}
		else
			locked = TRUE;
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )(WIDE( "Got global lock" ));
#endif
	} while( !locked );
}
void NetworkGloalUnlock( DBG_VOIDPASS ) {
#ifdef USE_NATIVE_CRITICAL_SECTION
	LeaveCriticalSection( &globalNetworkData.csNetwork );
#else
	LeaveCriticalSecEx( &globalNetworkData.csNetwork DBG_RELAY );
#endif
}
//----------------------------------------------------------------------------
void TerminateClosedClientEx( PCLIENT pc DBG_PASS )
{
#ifdef VERBOSE_DEBUG
	_lprintf(DBG_RELAY)( WIDE( "terminate client %p " ), pc );
#endif
	if( !pc )
		return;
	if( pc->dwFlags & CF_TOCLOSE ) {
#ifdef VERBOSE_DEBUG
		lprintf( "WAIT FOR CLOSE LATER... %x", pc->dwFlags );
#endif
		//return;
	}
	if( pc->dwFlags & CF_CLOSED )
	{
		PendingBuffer * lpNext;
		EnterCriticalSec( &globalNetworkData.csNetwork );
#ifdef VERBOSE_DEBUG
		lprintf( "REMOVED EVENT...." );
#endif
		RemoveThreadEvent( pc );
		//lprintf( WIDE( "Terminating closed client..." ) );
		if( IsValid( pc->Socket ) )
		{
#ifdef VERBOSE_DEBUG
			lprintf( "close soekcet." );
#endif
#if !defined( SHUT_WR ) && defined( _WIN32 )
#  define SHUT_WR SD_SEND
#endif
			shutdown( pc->Socket, SHUT_WR );
#if defined( _WIN32 )
#undef SHUT_WR
#endif
			closesocket( pc->Socket );
			while( pc->lpFirstPending )
			{
				lpNext = pc->lpFirstPending -> lpNext;
				if( pc->lpFirstPending->s.bDynBuffer )
					Deallocate( POINTER, pc->lpFirstPending->buffer.p );
				if( pc->lpFirstPending != &pc->FirstWritePending )
				{
#ifdef LOG_PENDING
					lprintf( WIDE(WIDE( "Data queued...Deleting in remove." )) );
#endif
					Deallocate( PendingBuffer*, pc->lpFirstPending);
				}
				else
				{
#ifdef LOG_PENDING
					lprintf( WIDE("Normal send queued...Deleting in remove.") );
#endif
				}
				if (!lpNext)
					pc->lpLastPending = NULL;
				pc->lpFirstPending = lpNext;
			}
		}
		ClearClient( pc DBG_RELAY );
		// this should move from globalNetworkData.close to globalNetworkData.available.
		AddAvailable( GrabClient( pc ) );
 // it's no longer closing.  (was set during the course of closure)
		pc->dwFlags &= ~CF_CLOSING;
		LeaveCriticalSec( &globalNetworkData.csNetwork );
		//NetworkUnlock( pc );
	}
#ifdef LOG_PENDING
	else
		lprintf( WIDE("Client's state was not CLOSED...") );
#endif
}
//----------------------------------------------------------------------------
#ifdef _WIN32
//----------------------------------------------------------------------------
static int NetworkStartup( void )
{
	static int attempt = 0;
	static int nStep = 0,
	          nError;
	static SOCKET sockMaster;
	static SOCKADDR remSin;
	switch( nStep )
	{
	case 0 :
		SystemCheck();
		nStep++;
		attempt = 0;
	case 1 :
		// Sit around, waiting for the network to start...
		//--------------------
		// sorry this is really really ugly to read!
		sockMaster = OpenSocket( TRUE, FALSE, FALSE, 0 );
		if( sockMaster == INVALID_SOCKET )
		{
			lprintf( WIDE( "Clever OpenSocket failed... fallback... and survey sez..." ) );
			//--------------------
			sockMaster = socket( AF_INET, SOCK_DGRAM, 0);
			//--------------------
		}
		//--------------------
		if( sockMaster == INVALID_SOCKET )
		{
			nError = WSAGetLastError();
			lprintf( WIDE( "Failed to create a socket - error is %ld" ), WSAGetLastError() );
 // provvider init fail )
			if( nError == 10106 )
			{
				if( ++attempt >= 30 ) return NetworkQuit();
				return -2;
			}
			if( nError == WSAENETDOWN )
			{
				if( ++attempt >= 30 ) return NetworkQuit();
				//else return NetworkPause(WIDE( "Socket is delaying..." ));
			}
 // reset...
			 nStep = 0;
			if( ++attempt >= 30 ) return NetworkQuit();
//NetworkQuit();
			return 1;
		}
		// Retrieve my IP address and UDP Port number
		remSin.sa_family=AF_INET;
		remSin.sa_data[0]=0;
		remSin.sa_data[1]=0;
		((SOCKADDR_IN*)&remSin)->sin_addr.s_addr=INADDR_ANY;
		nStep++;
		attempt = 0;
		// Fall into next state..............
	case 2 :
		// Associate an address with a socket. (bind)
		if( bind( sockMaster, (PSOCKADDR)&remSin, sizeof(remSin))
			 == SOCKET_ERROR )
		{
			if( WSAGetLastError() == WSAENETDOWN )
			{
				if( ++attempt >= 30 ) return NetworkQuit();
				//else return NetworkPause(WIDE( "Bind is Delaying" ));
			}
 // reset...
			nStep = 0;
			return NetworkQuit();
		}
		nStep++;
		attempt = 0;
		// Fall into next state..............
	case 3 :
		closesocket(sockMaster);
		sockMaster = INVALID_SOCKET;
 // reset...
		nStep = 0;
		break;
	}
	return 0;
}
//----------------------------------------------------------------------------
static void CPROC NetworkPauseTimer( uintptr_t psv )
{
	int nResult;
	nResult = NetworkStartup();
	if( nResult == 0 )
	{
		while( !globalNetworkData.uNetworkPauseTimer )
			Relinquish();
		RemoveTimer( globalNetworkData.uNetworkPauseTimer );
		globalNetworkData.flags.bNetworkReady = TRUE;
		globalNetworkData.flags.bThreadInitOkay = TRUE;
	}
	else if( nResult == -1 )
	{
		globalNetworkData.flags.bNetworkReady = TRUE;
		globalNetworkData.flags.bThreadInitOkay = FALSE;
		// exiting ... bad stuff happens
	}
	else if( nResult == -2 )
	{
		// delaying... okay....
	}
}
//----------------------------------------------------------------------------
static void HandleEvent( PCLIENT pClient )
{
	WSANETWORKEVENTS networkEvents;
	if( globalNetworkData.bQuit )
	{
		lprintf( WIDE( "Task is shutting down network... don't handle event." ) );
		return;
	}
	if( !pClient )
	{
		lprintf( WIDE( "How did a NULL client get here?!" ) );
		return;
	}
	pClient->dwFlags |= CF_PROCESSING;
#ifdef LOG_NETWORK_EVENT_THREAD
	//if( globalNetworkData.flags.bLogNotices )
	//	lprintf( WIDE( "Client event on %p" ), pClient );
#endif
	if( WSAEnumNetworkEvents( pClient->Socket, pClient->event, &networkEvents ) == ERROR_SUCCESS )
	{
		if( networkEvents.lNetworkEvents == 0 ) {
#ifdef LOG_NETWORK_EVENT_THREAD
			if( globalNetworkData.flags.bLogNotices )
				lprintf( WIDE( "zero events...%p %p %p" ), pClient, pClient->Socket, pClient->event );
#endif
			return;
		}
		{
			if( pClient->dwFlags & CF_UDP )
			{
				if( networkEvents.lNetworkEvents & FD_READ )
				{
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf( WIDE( "Got UDP FD_READ" ) );
#endif
					FinishUDPRead( pClient, 0 );
				}
			}
			else
			{
				THREAD_ID prior = 0;
#ifdef LOG_CLIENT_LISTS
				lprintf( WIDE( "client lists Ac:%p(%p(%d)) Av:%p(%p(%d)) Cl:%p(%p(%d))" )
						 , &globalNetworkData.ActiveClients, globalNetworkData.ActiveClients, globalNetworkData.ActiveClients?globalNetworkData.ActiveClients->Socket:0
						 , &globalNetworkData.AvailableClients, globalNetworkData.AvailableClients, globalNetworkData.AvailableClients?globalNetworkData.AvailableClients->Socket:0
						 , &globalNetworkData.ClosedClients, globalNetworkData.ClosedClients, globalNetworkData.ClosedClients?globalNetworkData.ClosedClients->Socket:0
						 );
#endif
#ifdef LOG_NETWORK_LOCKING
				lprintf( WIDE( "Handle Event left global" ) );
#endif
				// if an unknown socket issued a
				// notification - close it - unknown handling of unknown socket.
#ifdef LOG_NETWORK_EVENT_THREAD
				if( globalNetworkData.flags.bLogNotices )
					lprintf( WIDE( "events : %08x on %p" ), networkEvents.lNetworkEvents, pClient );
#endif
				if( networkEvents.lNetworkEvents & FD_CONNECT )
				{
					{
						uint16_t wError = networkEvents.iErrorCode[FD_CONNECT_BIT];
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE("FD_CONNECT on %p"), pClient );
#endif
						if( !wError )
							pClient->dwFlags |= CF_CONNECTED;
						else
						{
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE("Connect error: %d"), wError );
#endif
							pClient->dwFlags |= CF_CONNECTERROR;
						}
						if( !( pClient->dwFlags & CF_CONNECTERROR ) )
						{
							// since this is done before connecting is clear, tcpwrite
							// may make notice of previously queued data to
							// connection opening...
							//lprintf( WIDE("Sending any previously queued data.") );
							// with events, we get a FD_WRITE also... which calls tcpwrite.
							//TCPWrite( pClient );
						}
						pClient->dwFlags &= ~CF_CONNECTING;
						if( pClient->connect.ThisConnected )
						{
							if( !wError && !pClient->saSource ) {
#ifdef __LINUX__
								socklen_t
#else
								int
#endif
									nLen = MAGIC_SOCKADDR_LENGTH;
								if( !pClient->saSource )
									pClient->saSource = AllocAddr();
								if( getsockname( pClient->Socket, pClient->saSource, &nLen ) )
								{
									lprintf( WIDE( "getsockname errno = %d" ), errno );
								}
							}
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "Post connect to application %p  error:%d" ), pClient, wError );
#endif
							if( pClient->dwFlags & CF_CPPCONNECT )
								pClient->connect.CPPThisConnected( pClient->psvConnect, wError );
							else
								pClient->connect.ThisConnected( pClient, wError );
						}
						//lprintf( WIDE("Returned from application connected callback") );
						// check to see if the read was queued before the connect
						// actually completed...
						if( (pClient->dwFlags & ( CF_ACTIVE | CF_CONNECTED )) ==
							( CF_ACTIVE | CF_CONNECTED ) )
						{
							if( pClient->read.ReadComplete )
								if( pClient->dwFlags & CF_CPPREAD )
									pClient->read.CPPReadComplete( pClient->psvRead, NULL, 0 );
								else
									pClient->read.ReadComplete( pClient, NULL, 0 );
						}
						if( pClient->pWaiting )
							WakeThread( pClient->pWaiting );
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "FD_CONNECT Completed" ) );
#endif
						//lprintf( WIDE("Returned from application inital read complete.") );
					}
				}
				if( networkEvents.lNetworkEvents & FD_READ )
				{
					PCLIENT pcLock;
					while( !( pcLock = NetworkLockEx( pClient, 1 DBG_SRC ) ) ) {
						// done with events; inactive sockets can't have events
						if( !( pClient->dwFlags & CF_ACTIVE ) ) {
							pcLock = NULL;
							break;
						}
						Relinquish();
					}
#ifdef LOG_NOTICES
					//if( globalNetworkData.flags.bLogNotices )
					//	lprintf( WIDE( "FD_READ" ) );
#endif
					  if( ( pClient->dwFlags & CF_ACTIVE ) ) {
						if( pClient->bDraining )
						{
							TCPDrainRead( pClient );
						}
						else
						{
							// got a network event, and won't get another until recv is called.
							// mark that the socket has data, then the pend_read code will trigger the finishpendingread.
							if( FinishPendingRead( pClient DBG_SRC ) == 0 )
							{
								pClient->dwFlags |= CF_READREADY;
							}
							if( pClient->dwFlags & CF_TOCLOSE )
							{
								lprintf( WIDE( "Pending read failed - and wants to close." ) );
								//InternalRemoveClientEx( pc, TRUE, FALSE );
							}
						}
						NetworkUnlock( pClient, 1 );
					}
				}
				if( networkEvents.lNetworkEvents & FD_WRITE )
				{
					PCLIENT pcLock;
					while( !( pcLock = NetworkLockEx( pClient, 0 DBG_SRC ) ) ) {
						// done with events; inactive sockets can't have events
						if( !( pClient->dwFlags & CF_ACTIVE ) ) {
							pcLock = NULL;
							break;
						}
						Relinquish();
					}
					if( pClient->dwFlags & CF_ACTIVE ) {
#ifdef LOG_NOTICES
						//if( globalNetworkData.flags.bLogNotices )
						//	lprintf( WIDE("FD_Write") );
#endif
						// returns true while it wrote or there is data to write
						if( pClient->lpFirstPending )
							TCPWrite(pClient);
						if( !pClient->lpFirstPending ) {
							if( pClient->dwFlags & CF_TOCLOSE )
							{
								pClient->dwFlags &= ~CF_TOCLOSE;
								lprintf( WIDE( "Pending read failed - and wants to close." ) );
								InternalRemoveClientEx( pClient, FALSE, TRUE );
								TerminateClosedClient( pClient );
							}
						}
						NetworkUnlock( pClient, 0 );
					}
				}
				if( networkEvents.lNetworkEvents & FD_CLOSE )
				{
					if( !pClient->bDraining )
					{
						size_t bytes_read;
						// act of reading can result in a close...
						// there are things like IE which close and send
						// adn we might get the close notice at application level indicating there might still be data...
						while( ( bytes_read = FinishPendingRead( pClient DBG_SRC) ) > 0
 // try and read...
							&& bytes_read != (size_t)-1 );
						//if( pClient->dwFlags & CF_TOCLOSE )
						{
							//lprintf( "Pending read failed - reset connection. (well this is FD_CLOSE so yeah...??]" );
							//InternalRemoveClientEx( pc, TRUE, FALSE );
						}
					}
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf(WIDE( "FD_CLOSE... %p  %08x" ), pClient, pClient->dwFlags );
#endif
					if( pClient->dwFlags & CF_ACTIVE )
					{
						// might already be cleared and gone..
						InternalRemoveClientEx( pClient, FALSE, TRUE );
						TerminateClosedClient( pClient );
					}
					// section will be blank after termination...(correction, we keep the section state now)
 // it's no longer closing.  (was set during the course of closure)
					pClient->dwFlags &= ~CF_CLOSING;
				}
				if( networkEvents.lNetworkEvents & FD_ACCEPT )
				{
#ifdef LOG_NOTICES
					//if( globalNetworkData.flags.bLogNotices )
					//	lprintf( WIDE("FD_ACCEPT on %p"), pClient );
#endif
					AcceptClient(pClient);
					//NetworkUnlock( pClient, 1 );
				}
				//lprintf( WIDE("leaveing event handler...") );
				//lprintf( WIDE("Left event handler CS.") );
			}
		}
	}
	else
	{
		DWORD dwError = WSAGetLastError();
		if( dwError == 10038 )
		{
			// no longer a socket, probably in a closed or closing state.
		}
		else
			lprintf( WIDE( "Event enum failed... do what? close socket? %p %" _32f ), pClient, dwError );
	}
	pClient->dwFlags &= ~CF_PROCESSING;
}
 // if defined _WIN32
#endif
//----------------------------------------------------------------------------
void SetNetworkWriteComplete( PCLIENT pClient
                            , cWriteComplete WriteComplete )
{
	if( pClient && IsValid( pClient->Socket ) )
	{
		pClient->write.WriteComplete = WriteComplete;
	}
}
//----------------------------------------------------------------------------
void SetCPPNetworkWriteComplete( PCLIENT pClient
                               , cppWriteComplete WriteComplete
                               , uintptr_t psv)
{
	if( pClient && IsValid( pClient->Socket ) )
	{
		pClient->write.CPPWriteComplete = WriteComplete;
		pClient->psvWrite = psv;
		pClient->dwFlags |= CF_CPPWRITE;
	}
}
//----------------------------------------------------------------------------
void SetNetworkCloseCallback( PCLIENT pClient
                            , cCloseCallback CloseCallback )
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->close.CloseCallback = CloseCallback;
	}
}
//----------------------------------------------------------------------------
void SetCPPNetworkCloseCallback( PCLIENT pClient
                               , cppCloseCallback CloseCallback
                               , uintptr_t psv)
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->close.CPPCloseCallback = CloseCallback;
		pClient->psvClose = psv;
		pClient->dwFlags |= CF_CPPCLOSE;
	}
}
//----------------------------------------------------------------------------
void SetNetworkReadComplete( PCLIENT pClient
                           , cReadComplete pReadComplete )
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->read.ReadComplete = pReadComplete;
	}
}
//----------------------------------------------------------------------------
void SetCPPNetworkReadComplete( PCLIENT pClient
                              , cppReadComplete pReadComplete
                              , uintptr_t psv)
{
	if( pClient && IsValid(pClient->Socket) )
	{
		pClient->read.CPPReadComplete = pReadComplete;
		pClient->psvRead = psv;
		pClient->dwFlags |= CF_CPPREAD;
	}
}
//----------------------------------------------------------------------------
#if defined( _WIN32 )
//----------------------------------------------------------------------------
static uintptr_t CPROC NetworkThreadProc( PTHREAD thread );
void RemoveThreadEvent( PCLIENT pc ) {
	struct peer_thread_info *thread = pc->this_thread;
 // could be closed (accept, initial read, protocol causes close before ever completing getting scheduled)
	if( !thread ) return;
	// reduce peer wait count to 1.
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "Remove client %p from %p thread events...  proc:%d  ev:%d  wait:%d", pc, thread, thread->flags.bProcessing, thread->nEvents, thread->nWaitEvents );
#endif
	thread->counting = TRUE;
	thread->nEvents = 1;
	if( thread->thread != MakeThread() && !thread->flags.bProcessing )
		while( thread->nEvents != thread->nWaitEvents ) {
			if( !thread->flags.bProcessing )
			{
				// have to make sure threads reset to the new list.
				//lprintf( "have to wait for thread to be in wait state..." );
				WSASetEvent( thread->hThread );
				LeaveCriticalSec( &globalNetworkData.csNetwork );
				while( (thread->nWaitEvents > 1) || thread->flags.bProcessing )
					Relinquish();
				EnterCriticalSec( &globalNetworkData.csNetwork );
			}
			else
  // if it's processing, race it; build new list, count it.
				break;
			Relinquish();
		}
	{
		INDEX idx;
		INDEX c = 0;
		PCLIENT previous;
		PLIST newList = CreateList();
		SetLink( &newList, 65, 0 );
		//EmptyDataList( &thread->event_list );
		LIST_FORALL( thread->monitor_list, idx, PCLIENT, previous ) {
			if( previous != pc )
			{
				AddLink( &newList, previous );
				SetDataItem( &thread->event_list, c++, GetDataItem( &thread->event_list, idx ) );
			}
		}
		thread->event_list->Cnt = c;
		thread->nEvents = (int)c;
		thread->counting = FALSE;
		DeleteListEx( &thread->monitor_list DBG_SRC );
		thread->monitor_list = newList;
		pc->this_thread = NULL;
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "peer %p now has %d events", thread, thread->nEvents );
#endif
	}
  // don't bubble sort root thread
	if( thread->parent_peer )
		while( ( thread->nEvents < thread->parent_peer->nEvents ) && thread->parent_peer->parent_peer ) {
#ifdef LOG_NETWORK_EVENT_THREAD
			//lprintf( "swapping this with parent peer ... this events %d  parent %d", thread->nEvents, thread->parent_peer->nEvents );
#endif
			if( thread->child_peer )
				thread->child_peer->parent_peer = thread->parent_peer;
			thread->parent_peer->child_peer = thread->child_peer;
			struct peer_thread_info *tmp = thread->parent_peer;
			tmp->parent_peer->child_peer = thread;
			thread->parent_peer = tmp->parent_peer;
			tmp->parent_peer = thread;
			thread->child_peer = tmp;
		}
}
// unused parameter broadcsat on windows; not needed.
void AddThreadEvent( PCLIENT pc, int broadcsat )
{
	struct peer_thread_info *peer = globalNetworkData.root_thread;
	LOGICAL addPeer = FALSE;
#ifdef LOG_NOTICES
	if( globalNetworkData.flags.bLogNotices )
		lprintf( "Add thread event %p %p %08x", pc, pc->event, pc->dwFlags );
#endif
	for( ; peer; peer = peer->child_peer ) {
		if( !peer->child_peer ) {
#ifdef LOG_NOTICES
			if( globalNetworkData.flags.bLogNotices )
				lprintf( "On last peer..." );
#endif
			if( peer->nEvents > globalNetworkData.nPeers ) {
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "global peers is %d, this has %d", globalNetworkData.nPeers, peer->nEvents );
#endif
				addPeer = TRUE;
				break;
			}
			if( peer->nEvents >= 60 ) {
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "this has max events already....", globalNetworkData.nPeers, peer->nEvents );
#endif
				addPeer = TRUE;
				break;
			}
		}
		if( peer->nEvents < 60 ) {
// last thread.
			if( !peer->child_peer )
				break;
			if( peer->nEvents < peer->child_peer->nEvents ) {
#ifdef LOG_NOTICES
				//if( globalNetworkData.flags.bLogNotices )
				//	lprintf( "this event has fewer than the next thread's events %d  %d", peer->nEvents, peer->child_peer->nEvents );
#endif
				break;
			}
		}
	}
	if( addPeer ) {
#ifdef LOG_NOTICES
		if( globalNetworkData.flags.bLogNotices )
			lprintf( "Creating a new thread...." );
#endif
		AddLink( &globalNetworkData.pThreads, ThreadTo( NetworkThreadProc, (uintptr_t)peer ) );
		globalNetworkData.nPeers++;
		while( !peer->child_peer )
			Relinquish();
		if( globalNetworkData.root_thread != peer ) {
			// relink to be higher in list of peers so it's found earlier.
#ifdef LOG_NOTICES
			if( globalNetworkData.flags.bLogNotices )
				lprintf( "Relinking thread to be after root peer (no events, so it must be first)" );
#endif
			peer->child_peer->child_peer = globalNetworkData.root_thread->child_peer;
			globalNetworkData.root_thread->child_peer->parent_peer = peer->child_peer;
			globalNetworkData.root_thread->child_peer = peer->child_peer;
			peer->child_peer->parent_peer = globalNetworkData.root_thread;
			peer->child_peer = NULL;
			peer = globalNetworkData.root_thread->child_peer;
		}
		else
			peer = peer->child_peer;
	}
	// make sure to only add this handle when the first peer will also be added.
	// this means the list can be 61 and at this time no more.
	AddLink( &peer->monitor_list, pc );
	AddDataItem( &peer->event_list, &pc->event );
	pc->this_thread = peer;
	pc->flags.bAddedToEvents = 1;
	peer->nEvents++;
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "peer %p now has %d events", peer, peer->nEvents );
#endif
 // scheduler thread already awake do not wake him.
	if( !peer->flags.bProcessing && peer->parent_peer )
		WSASetEvent( peer->hThread );
}
// this is passed '0' when it is called internally
// this is passed '1' when it is called by idleproc
int CPROC ProcessNetworkMessages( struct peer_thread_info *thread, uintptr_t quick_check )
{
	//lprintf( WIDE("Check messages.") );
	if( globalNetworkData.bQuit )
		return -1;
	if( thread->flags.bProcessing )
		return 0;
	// disallow changing of the lists.
	if( !thread->parent_peer )
	{
		EnterCriticalSec( &globalNetworkData.csNetwork );
		{
			PCLIENT pc;
			PCLIENT next;
			for( pc = globalNetworkData.ClosedClients; pc; pc = next )
			{
#    ifdef LOG_NOTICES
				lprintf( "Have a closed client to check..." );
#    endif
				next = pc->next;
				if( +GetTickCount() > (pc->LastEvent + 1000) )
				{
					lprintf( "Remove thread event on closed thread (should be terminate here..)" );
  // also does the remove.
					TerminateClosedClient( pc );
					//RemoveThreadEvent( pc ); // also does the close.
				}
			}
		}
		{
			PCLIENT pc;
			while( pc = (PCLIENT)DequeLink( &globalNetworkData.client_schedule ) )
			{
				// use this for "added to schedule".  Closing removes from schedule.
				if( !pc->flags.bAddedToEvents )
				{
					if( pc->dwFlags & CF_CLOSED || (!(pc->dwFlags & CF_ACTIVE)) )
					{
						lprintf( WIDE( " Found closed? %p" ), pc );
						continue;
					}
#ifdef LOG_NETWORK_EVENT_THREAD
					if( globalNetworkData.flags.bLogNotices )
						lprintf( WIDE( "Added to schedule : %p %08x" ), pc, pc->dwFlags );
#endif
					AddThreadEvent( pc, 0 );
				}
				else
					lprintf( "Client in schedule queue, but it is already schedule?! %p", pc );
			}
		}
		LeaveCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
		lprintf( WIDE( "Process Network left global" ) );
#endif
	}
	else
	{
		// wait for master thread to set up the proper wait
		while( thread->nEvents == 0 )
			Relinquish();
	}
	while( 1 )
	{
		int32_t result;
		// want to wait here anyhow...
#ifdef LOG_NETWORK_EVENT_THREAD
		//if( globalNetworkData.flags.bLogNotices )
		//	lprintf( WIDE( "%p Waiting on %d events" ), thread, thread->nEvents );
#endif
		thread->nWaitEvents = thread->nEvents;
		thread->flags.bProcessing = 0;
		while( thread->counting ) { thread->nWaitEvents = thread->nEvents; Relinquish(); }
		result = WSAWaitForMultipleEvents( thread->nEvents
													, (const HANDLE *)thread->event_list->data
													, FALSE
													, (quick_check)?0:WSA_INFINITE
													, FALSE
													);
		if( globalNetworkData.bQuit )
			return -1;
#ifdef LOG_NETWORK_EVENT_THREAD
		//if( globalNetworkData.flags.bLogNotices )
		//	lprintf( WIDE( "Event Wait Result was %d" ), result );
#endif
		// this should never be 0, but we're awake, not sleeping, and should say we're in a place
		// where we probably do want to be woken on a 0 event.
		if( result != WSA_WAIT_EVENT_0 )
		{
#ifdef LOG_NETWORK_EVENT_THREAD
			//if( globalNetworkData.flags.bLogNotices )
			//	lprintf( WIDE("Begin - thread processing %d"), result );
#endif
			thread->flags.bProcessing = 1;
		}
		thread->nWaitEvents = 0;
		if( result == WSA_WAIT_FAILED )
		{
			DWORD dwError = WSAGetLastError();
			if( dwError == WSA_INVALID_HANDLE )
			{
				lprintf( WIDE( "Rebuild list, have a bad event handle somehow." ) );
				break;
			}
			lprintf( WIDE( "error of wait is %d   %p" ), dwError, thread );
			LogBinary( thread->event_list->data, 64 );
			break;
		}
#ifndef UNDER_CE
		else if( result == WSA_WAIT_IO_COMPLETION )
		{
			// reselect... not sure where io completion fits for network...
			continue;
		}
#endif
		else if( result == WSA_WAIT_TIMEOUT )
		{
			if( quick_check )
				return 1;
		}
		else if( result >= WSA_WAIT_EVENT_0 )
		{
			// if result is _0, then it's the global event, and we just return.
			if( result > WSA_WAIT_EVENT_0 )
			{
				PCLIENT pc = (PCLIENT)GetLink( &thread->monitor_list, result - (WSA_WAIT_EVENT_0) );
				//if( pcLock ) {
					if( !pc || ( pc->dwFlags & CF_AVAILABLE ) ) {
						//lprintf( "thread event happened on a now available client." );
					}
					else
						HandleEvent( pc );
				//}
				/*
				if( thread->parent_peer )
				{
					// if this is a child worker, wait for main to rebuild events.
					// if this was the main thread, it would wake us anyway...
					WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
					while( thread->nEvents != 1 )
						Relinquish();
				}
				*/
				if( !quick_check )
					continue;
			}
			//else
			{
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( thread->parent_peer?WIDE("RESET THREAD EVENT"):WIDE( "RESET GLOBAL EVENT" ) );
#endif
				WSAResetEvent( thread->hThread );
			}
			return 1;
		}
	}
	// result 0... we had nothing to do
	// but we are this thread.
	return 0;
}
//----------------------------------------------------------------------------
static int CPROC IdleProcessNetworkMessages( uintptr_t quick_check )
{
	struct peer_thread_info *this_thread = IsNetworkThread();
	if( this_thread )
		return ProcessNetworkMessages( this_thread, quick_check );
	return -1;
}
 // if !__LINUX__
#else
static uintptr_t CPROC NetworkThreadProc( PTHREAD thread );
void RemoveThreadEvent( PCLIENT pc ) {
	struct peer_thread_info *thread = pc->this_thread;
	// could be closed (accept, initial read, protocol causes close before ever completing getting scheduled)
	if( !thread ) {
		 lprintf( "didn't have one? %p", pc );
		return;
	}
	{
#  ifdef __MAC__
#    ifdef __64__
		struct kevent64_s ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET64( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
		} else {
			EV_SET64( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uintptr_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
			EV_SET64( &ev, pc->Socket, EVFILT_WRITE, EV_DELETE, 0, 0, (uintptr_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
		if( pc->SocketBroadcast ) {
			EV_SET64( &ev, pc->SocketBroadcast, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc, NULL, NULL );
			kevent64( thread->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
#    else
		struct kevent ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
		} else {
			EV_SET( &ev, pc->Socket, EVFILT_READ, EV_DELETE, 0, 0, (uintptr_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
			EV_SET( &ev, pc->Socket, EVFILT_WRITE, EV_DELETE, 0, 0, (uintptr_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
		}
		if( pc->SocketBroadcast ) {
			EV_SET( &ev, pc->SocketBroadcsat, EVFILT_READ, EV_DELETE, 0, 0, (uint64_t)pc );
			kevent( thread->kqueue, &ev, 1, 0, 0, 0 );
		}
#    endif
#  else
		int r;
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "Removing event %p   %d from poll %d", pc, pc->Socket, thread->epoll_fd );
#endif
		//r = epoll_ctl( thread->epoll_fd, EPOLL_CTL_DISABLE, pc->Socket, NULL );
		//if( r < 0 ) lprintf( "Error removing:%d", errno );
		r = epoll_ctl( thread->epoll_fd, EPOLL_CTL_DEL, pc->Socket, NULL );
		if( r < 0 ) lprintf( "Error removing:%d", errno );
		if( pc->SocketBroadcast ) {
			r = epoll_ctl( thread->epoll_fd, EPOLL_CTL_DEL, pc->SocketBroadcast, NULL );
			if( r < 0 ) lprintf( "Error removing:%d", errno );
		}
		pc->flags.bAddedToEvents = 0;
		pc->this_thread = NULL;
#  endif
	}
	LockedDecrement( &thread->nEvents );
	// don't bubble sort root thread
	if( thread->parent_peer )
		while( (thread->nEvents < thread->parent_peer->nEvents) && thread->parent_peer->parent_peer ) {
#ifdef LOG_NETWORK_EVENT_THREAD
			//lprintf( "swapping this with parent peer ... this events %d  parent %d", thread->nEvents, thread->parent_peer->nEvents );
#endif
			if( thread->child_peer )
				thread->child_peer->parent_peer = thread->parent_peer;
			thread->parent_peer->child_peer = thread->child_peer;
			struct peer_thread_info *tmp = thread->parent_peer;
			tmp->parent_peer->child_peer = thread;
			thread->parent_peer = tmp->parent_peer;
			tmp->parent_peer = thread;
			thread->child_peer = tmp;
		}
}
struct event_data {
	PCLIENT pc;
	int broadcast;
};
void AddThreadEvent( PCLIENT pc, int broadcast )
{
	struct peer_thread_info *peer = globalNetworkData.root_thread;
	LOGICAL addPeer = FALSE;
	if( pc->Socket <= 0 ) {
		lprintf( "SAVED FROM A FATAL INFINITE EVENT LOOP");
		return;
	}
#ifdef LOG_NOTICES
	//if( globalNetworkData.flags.bLogNotices )
		lprintf( "Add thread event %p %d %08x  %s", pc, broadcast?pc->SocketBroadcast:pc->Socket, pc->dwFlags, broadcast?"broadcast":"direct" );
#endif
	if( !broadcast ) {
		for( ; peer; peer = peer->child_peer ) {
			if( !peer->child_peer ) {
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "On last peer..." );
#endif
				if( peer->nEvents > globalNetworkData.nPeers ) {
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf( "global peers is %d, this has %d", globalNetworkData.nPeers, peer->nEvents );
#endif
					addPeer = TRUE;
					break;
				}
				if( peer->nEvents >= 2560 ) {
#ifdef LOG_NOTICES
					if( globalNetworkData.flags.bLogNotices )
						lprintf( "this has max events already.... %d %d", globalNetworkData.nPeers, peer->nEvents );
#endif
					addPeer = TRUE;
					break;
				}
			}
			if( peer->nEvents < 2560 ) {
												// last thread.
				if( !peer->child_peer )
					break;
				if( peer->nEvents < peer->child_peer->nEvents ) {
#ifdef LOG_NOTICES
					//if( globalNetworkData.flags.bLogNotices )
					//	lprintf( "this event has fewer than the next thread's events %d  %d", peer->nEvents, peer->child_peer->nEvents );
#endif
					break;
				}
			}
		}
		if( addPeer ) {
#ifdef LOG_NOTICES
			if( globalNetworkData.flags.bLogNotices )
				lprintf( "Creating a new thread...." );
#endif
			AddLink( &globalNetworkData.pThreads, ThreadTo( NetworkThreadProc, (uintptr_t)peer ) );
			globalNetworkData.nPeers++;
			while( !peer->child_peer )
				Relinquish();
			if( globalNetworkData.root_thread != peer ) {
				// relink to be higher in list of peers so it's found earlier.
#ifdef LOG_NOTICES
				if( globalNetworkData.flags.bLogNotices )
					lprintf( "Relinking thread to be after root peer (no events, so it must be first)" );
#endif
				peer->child_peer->child_peer = globalNetworkData.root_thread->child_peer;
				globalNetworkData.root_thread->child_peer->parent_peer = peer->child_peer;
				globalNetworkData.root_thread->child_peer = peer->child_peer;
				peer->child_peer->parent_peer = globalNetworkData.root_thread;
				peer->child_peer = NULL;
				peer = globalNetworkData.root_thread->child_peer;
			}
			else
				peer = peer->child_peer;
		}
	} else {
 // add broadcast to the same event as the original.
		peer = pc->this_thread;
	}
	// make sure to only add this handle when the first peer will also be added.
	// this means the list can be 61 and at this time no more.
	{
#  ifdef __MAC__
		struct event_data *data = New( struct event_data );
		data->pc = pc;
		data->broadcast = broadcast;
#    ifdef __64__
		struct kevent64_s ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET64( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)data, NULL, NULL );
			kevent64( peer->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
		else {
			EV_SET64( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)data, NULL, NULL );
			kevent64( peer->kqueue, &ev, 1, 0, 0, 0, 0 );
			EV_SET64( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_WRITE, EV_ADD | EV_CLEAR, 0, 0, (uintptr_t)data, NULL, NULL );
			kevent64( peer->kqueue, &ev, 1, 0, 0, 0, 0 );
		}
#    else
		struct kevent ev;
		if( pc->dwFlags & CF_LISTEN ) {
			EV_SET( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)data );
			kevent( peer->kqueue, &ev, 1, 0, 0, 0 );
		}
		else {
			EV_SET( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_READ, EV_ADD|EV_ENABLE, 0, 0, (uintptr_t)data );
			kevent( peer->kqueue, &ev, 1, 0, 0, 0 );
			EV_SET( &ev, broadcast?pc->SocketBroadcast:pc->Socket, EVFILT_WRITE, EV_ADD|EV_ENABLE|EV_CLEAR, 0, 0, (uintptr_t)data );
			kevent( peer->kqueue, &ev, 1, 0, 0, 0 );
		}
#    endif
#  else
		int r;
		struct epoll_event ev;
		ev.data.ptr = New( struct event_data );
		((struct event_data*)ev.data.ptr)->pc = pc;
		((struct event_data*)ev.data.ptr)->broadcast = broadcast;
		if( pc->dwFlags & CF_LISTEN )
			ev.events = EPOLLIN;
		else {
			ev.events = EPOLLIN | EPOLLOUT | EPOLLRDHUP | EPOLLET;
		}
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "peer add socket %d to %d now has 0x%x events", pc->Socket, peer->epoll_fd, ev.events );
#endif
		r = epoll_ctl( peer->epoll_fd, EPOLL_CTL_ADD, broadcast?pc->SocketBroadcast:pc->Socket, &ev );
		if( r < 0 ) lprintf( "Error adding:%d %d", errno, broadcast?pc->SocketBroadcast:pc->Socket );
#  endif
	}
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "added thread: %p  %p  %p  ", pc, pc->this_thread, peer );
#endif
	if( !pc->this_thread ) {
		LockedIncrement( &peer->nEvents );
		pc->this_thread = peer;
		pc->flags.bAddedToEvents = 1;
	}
#ifdef LOG_NETWORK_EVENT_THREAD
	lprintf( "peer %p now has %d events", peer, peer->nEvents );
#endif
	// scheduler thread already awake do not wake him.
}
int CPROC ProcessNetworkMessages( struct peer_thread_info *thread, uintptr_t unused )
{
	int cnt;
	struct timeval time;
	if( globalNetworkData.bQuit )
		return -1;
	{
#  ifdef __MAC__
#    ifdef __64__
		struct kevent64_s events[10];
		cnt = kevent64( thread->kqueue, NULL, 0, events, 10, 0, NULL );
#    else
		kevent events[10];
		cnt = kevent( thread->kqueue, NULL, 0, events, 10, NULL );
#    endif
#  else
		struct epoll_event events[10];
#    ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "Wait on %d", thread->epoll_fd );
#    endif
		cnt = epoll_wait( thread->epoll_fd, events, 10, -1 );
#  endif
		if( cnt < 0 )
		{
			int err = errno;
			if( err == EINTR )
				return 1;
			Log1( WIDE( "Sorry epoll_pwait/kevent call failed... %d" ), err );
			return 1;
		}
		if( cnt > 0 )
		{
			int closed;
			int n;
			struct event_data *event_data;
			THREAD_ID prior = 0;
			PCLIENT next;
#  ifdef LOG_NETWORK_EVENT_THREAD
			lprintf( "process %d events", cnt );
#  endif
			for( n = 0; n < cnt; n++ ) {
				closed = 0;
#  ifdef __MAC__
				event_data = (struct event_data*)events[n].udata;
#  ifdef LOG_NOTICES
				lprintf( "Process %d %x %x"
				       , ((uintptr_t)event_data == 1) ?0:event_data->broadcast?event_data->pc->SocketBroadcast:event_data->pc->Socket
				       , ((uintptr_t)event_data == 1) ?0:event_data->pc->dwFlags
				       , events[n].filter );
#  endif
#  else
				event_data = (struct event_data*)events[n].data.ptr;
#  ifdef LOG_NOTICES
				lprintf( "Process %d %x", event_data->broadcast?event_data->pc->SocketBroadcast:event_data->pc->Socket
				       , events[n].events );
#  endif
#  endif
				if( event_data == (struct event_data*)1 ) {
					//char buf;
					//stat = read( GetThreadSleeper( thread->pThread ), &buf, 1 );
					//call wakeable sleep to just clear the sleep; because this is an event on the sleep pipe.
					WakeableSleep( SLEEP_FOREVER );
					return 1;
				}
#  ifdef __MAC__
				if( events[n].filter == EVFILT_READ )
#  else
				if( events[n].events & EPOLLIN )
#  endif
				{
					int locked;
					locked = 1;
					while( !NetworkLock( event_data->pc, 1 ) ) {
						if( !( event_data->pc->dwFlags & CF_ACTIVE ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
							lprintf( "failed lock dwFlags : %8x", event_data->pc->dwFlags );
#  endif
							locked = 0;
							break;
						}
						if( event_data->pc->dwFlags & CF_AVAILABLE ) {
							locked = 0;
							break;
						}
						Relinquish();
					}
					if( !( event_data->pc->dwFlags & ( CF_ACTIVE | CF_CLOSED ) ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
						lprintf( "not active but locked? dwFlags : %8x", event_data->pc->dwFlags );
#  endif
						continue;
					}
					if( event_data->pc->dwFlags & CF_AVAILABLE )
						continue;
					if( !IsValid( event_data->pc->Socket ) ) {
						NetworkUnlock( event_data->pc, 1 );
						continue;
					}
#  ifdef LOG_NETWORK_EVENT_THREAD
					lprintf( "EPOLLIN/EVFILT_READ %x", event_data->pc->dwFlags );
#  endif
					if( event_data->pc->dwFlags & CF_CLOSED ) {
						PCLIENT pClient = event_data->pc;
						// close notice went to application; all resources for application are gone.
						// any pending reads are no longre valid.
						//lprintf( "socket is already closed... what do we need to do?");
						//WakeableSleep( 100 );
						if( 0 && !pClient->bDraining )
						{
							size_t bytes_read;
							// act of reading can result in a close...
							// there are things like IE which close and send
							// adn we might get the close notice at application level indicating there might still be data...
							while( ( bytes_read = FinishPendingRead( pClient DBG_SRC) ) > 0
 // try and read...
								&& bytes_read != (size_t)-1 );
							//if( pClient->dwFlags & CF_TOCLOSE )
							{
								//lprintf( "Pending read failed - reset connection. (well this is FD_CLOSE so yeah...??]" );
								//InternalRemoveClientEx( pc, TRUE, FALSE );
							}
						}
#  ifdef LOG_NOTICES
						//if( globalNetworkData.flags.bLogNotices )
							lprintf(WIDE( "FD_CLOSE... %p  %08x" ), pClient, pClient->dwFlags );
#  endif
						//if( pClient->dwFlags & CF_ACTIVE )
						{
							// might already be cleared and gone..
							//InternalRemoveClientEx( pClient, FALSE, TRUE );
							TerminateClosedClient( pClient );
							closed = 1;
						}
						// section will be blank after termination...(correction, we keep the section state now)
 // it's no longer closing.  (was set during the course of closure)
						pClient->dwFlags &= ~CF_CLOSING;
					} else if( !(event_data->pc->dwFlags & (CF_ACTIVE) ) ) {
						lprintf( "Event on socket no longer active..." );
						// change to inactive status by the time we got here...
					} else if( event_data->pc->dwFlags & CF_LISTEN )
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "accepting..." ) );
#endif
						AcceptClient( event_data->pc );
					}
					else if( event_data->pc->dwFlags & CF_UDP )
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "UDP Read Event..." ) );
#endif
						//lprintf( "UDP READ" );
						FinishUDPRead( event_data->pc, event_data->broadcast );
					}
					else if( event_data->pc->bDraining )
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "TCP Drain Event..." ) );
#endif
						TCPDrainRead( event_data->pc );
					}
					else if( event_data->pc->dwFlags & CF_READPENDING )
					{
						size_t read;
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "TCP Read Event..." ) );
#endif
						// packet oriented things may probably be reading only
						// partial messages at a time...
						read = FinishPendingRead( event_data->pc DBG_SRC );
						//lprintf( "Read %d", read );
						if( ( read == -1 ) && ( event_data->pc->dwFlags & CF_TOCLOSE ) )
						{
#ifdef LOG_NOTICES
							//if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "Pending read failed - reset connection." ) );
#endif
							InternalRemoveClientEx( event_data->pc, FALSE, FALSE );
							TerminateClosedClient( event_data->pc );
							closed = 1;
						}
						else if( !event_data->pc->RecvPending.s.bStream )
							event_data->pc->dwFlags |= CF_READREADY;
					}
					else
					{
#ifdef LOG_NOTICES
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "TCP Set read ready..." ) );
#endif
						event_data->pc->dwFlags |= CF_READREADY;
					}
					if( locked )
						LeaveCriticalSec( &event_data->pc->csLockRead );
				}
				if( !closed && ( event_data->pc->dwFlags & CF_ACTIVE ) ) {
					int locked;
					locked = 1;
#  ifdef __MAC__
					if( events[n].filter == EVFILT_WRITE )
#  else
					if( events[n].events & EPOLLOUT )
#  endif
					{
#  ifdef LOG_NETWORK_EVENT_THREAD
						lprintf( "EPOLLOUT %s", ( event_data->pc->dwFlags & CF_CONNECTING ) ? "connecting"
							: ( !( event_data->pc->dwFlags & CF_ACTIVE ) ) ? "closed" : "writing" );
#  endif
						while( !NetworkLock( event_data->pc, 0 ) ) {
							if( !( event_data->pc->dwFlags & CF_WRITEISPENDED ) ) {
								locked = 0;
								break;
							}
							if( !( event_data->pc->dwFlags & CF_ACTIVE ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
								lprintf( "failed lock dwFlags : %8x", event_data->pc->dwFlags );
#  endif
								locked = 0;
								break;
							}
							if( event_data->pc->dwFlags & CF_AVAILABLE ) {
								locked = 0;
								break;
							}
							Relinquish();
						}
						if( !( event_data->pc->dwFlags & ( CF_ACTIVE | CF_CLOSED ) ) ) {
#  ifdef LOG_NETWORK_EVENT_THREAD
							lprintf( "not active but locked? dwFlags : %8x", event_data->pc->dwFlags );
#  endif
							continue;
						}
						if( event_data->pc->dwFlags & CF_AVAILABLE )
							continue;
						if( !IsValid( event_data->pc->Socket ) ) {
							NetworkUnlock( event_data->pc, 0 );
							continue;
						}
						if( !( event_data->pc->dwFlags & CF_ACTIVE ) ) {
							//lprintf( "FLAGS IS NOT ACTIVE BUT: %x", event_data->pc->dwFlags );
							// change to inactive status by the time we got here...
						} else if( event_data->pc->dwFlags & CF_CONNECTING ) {
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "Connected!" ) );
#endif
							event_data->pc->dwFlags |= CF_CONNECTED;
							event_data->pc->dwFlags &= ~CF_CONNECTING;
							{
								PCLIENT pc = event_data->pc;
#ifdef __LINUX__
								socklen_t
#else
								int
#endif
									nLen = MAGIC_SOCKADDR_LENGTH;
								if( !pc->saSource )
									pc->saSource = AllocAddr();
								if( getsockname( pc->Socket, pc->saSource, &nLen ) ) {
									lprintf( WIDE( "getsockname errno = %d" ), errno );
								}
								if( pc->saSource->sa_family == AF_INET )
									SET_SOCKADDR_LENGTH( pc->saSource, IN_SOCKADDR_LENGTH );
								else if( pc->saSource->sa_family == AF_INET6 )
									SET_SOCKADDR_LENGTH( pc->saSource, IN6_SOCKADDR_LENGTH );
								else
									SET_SOCKADDR_LENGTH( pc->saSource, nLen );
							}
							{
								int error;
								socklen_t errlen = sizeof( error );
								getsockopt( event_data->pc->Socket, SOL_SOCKET
									, SO_ERROR
									, &error, &errlen );
								//lprintf( WIDE( "Error checking for connect is: %s on %d" ), strerror( error ), event_data->pc->Socket );
								if( event_data->pc->pWaiting ) {
#ifdef LOG_NOTICES
									if( globalNetworkData.flags.bLogNotices )
										lprintf( WIDE( "Got connect event, waking waiter.." ) );
#endif
									WakeThread( event_data->pc->pWaiting );
								}
								if( event_data->pc->connect.ThisConnected )
									event_data->pc->connect.ThisConnected( event_data->pc, error );
#ifdef LOG_NOTICES
								if( globalNetworkData.flags.bLogNotices )
									lprintf( "Connect error was: %d", error );
#endif
								// if connected okay - issue first read...
								if( !error ) {
#ifdef LOG_NOTICES
									lprintf( "Read Complete" );
#endif
									if( event_data->pc->read.ReadComplete ) {
#ifdef LOG_NOTICES
										lprintf( "Initial Read Complete" );
#endif
										event_data->pc->read.ReadComplete( event_data->pc, NULL, 0 );
									}
									if( event_data->pc->lpFirstPending ) {
										lprintf( WIDE( "Data was pending on a connecting socket, try sending it now" ) );
										TCPWrite( event_data->pc );
									}
								} else {
									event_data->pc->dwFlags |= CF_CONNECTERROR;
								}
							}
						} else if( event_data->pc->dwFlags & CF_UDP ) {
							//lprintf( "UDP WRITE IS NEVER QUEUED." );
							// udp write event complete....
							// do we ever care? probably sometime...
						} else {
#ifdef LOG_NOTICES
							if( globalNetworkData.flags.bLogNotices )
								lprintf( WIDE( "TCP Write Event..." ) );
#endif
							event_data->pc->dwFlags &= ~CF_WRITEISPENDED;
							TCPWrite( event_data->pc );
						}
						if( locked )
							NetworkUnlock( event_data->pc, 0 );
					}
				} else {
					//lprintf( "Already closed? Stop looping on this event? %p %d %x", event_data->pc, event_data->pc->Socket, event_data->pc->dwFlags );
				}
			}
			// had some event  - return 1 to continue working...
		}
		return 1;
	}
	//lprintf( WIDE("Attempting to wake thread (send sighup!)") );
	//WakeThread( globalNetworkData.pThread );
	//lprintf( WIDE("Only reason should get here is if it's not this thread...") );
	return -1;
}
//----------------------------------------------------------------------------
static int CPROC IdleProcessNetworkMessages( uintptr_t quick_check )
{
	struct peer_thread_info *this_thread = IsNetworkThread();
	if( this_thread )
		return ProcessNetworkMessages( this_thread, quick_check );
	return -1;
}
#endif
uintptr_t CPROC NetworkThreadProc( PTHREAD thread )
{
	struct peer_thread_info *peer_thread = (struct peer_thread_info*)GetThreadParam( thread );
	struct peer_thread_info this_thread;
	// and when unloading should remove these timers.
	if( !peer_thread )
	{
#ifdef _WIN32
		globalNetworkData.uNetworkPauseTimer = AddTimerEx( 1, 1000, NetworkPauseTimer, 0 );
		if( !globalNetworkData.client_schedule )
			globalNetworkData.client_schedule = CreateLinkQueue();
#endif
#ifdef __LINUX__
		globalNetworkData.flags.bNetworkReady = TRUE;
		globalNetworkData.flags.bThreadInitOkay = TRUE;
#endif
	}
	memset( &this_thread, 0, sizeof( this_thread ) );
	this_thread.monitor_list = NULL;
#ifdef _WIN32
	this_thread.event_list = CreateDataList( sizeof( WSAEVENT ) );
	this_thread.hThread = WSACreateEvent();
	// setup this as if it was cleared already.
	this_thread.nEvents = 1;
 // has to be a non zero value.  monitor is not referenced for wait event 0
	SetLink( &this_thread.monitor_list, 0, (POINTER)1 );
	SetDataItem( &this_thread.event_list, 0, &this_thread.hThread );
#else
	// have to fall back to poll() for __MAC__ builds. (probably client only)
	//this_thread.event_list = CreateDataList( sizeof( struct pollfd ) );
#ifdef __LINUX__
#ifdef __MAC__
	this_thread.kqueue = kqueue();
#else
#ifdef __ANDROID__
 // close on exec (no inherit)
	this_thread.epoll_fd = epoll_create( 128 );
#else
 // close on exec (no inherit)
	this_thread.epoll_fd = epoll_create1( EPOLL_CLOEXEC );
#endif
#endif
	{
#  ifdef __MAC__
#    ifdef __64__
		struct kevent64_s ev;
		this_thread.kevents = CreateDataList( sizeof( ev ) );
		EV_SET64( &ev, GetThreadSleeper( thread ), EVFILT_READ, EV_ADD, 0, 0, (uint64_t)1, NULL, NULL );
		kevent64( this_thread.kqueue, &ev, 1, 0, 0, 0, 0 );
#    else
		struct kevent ev;
		this_thread.kevents = CreateDataList( sizeof( ev ) );
		EV_SET( &ev, GetThreadSleeper( thread ), EVFILT_READ, EV_ADD, 0, 0, (uintptr_t)1 );
		kevent( this_thread.kqueue, &ev, 1, 0, 0, 0 );
#    endif
#  else
		struct epoll_event ev;
		ev.data.ptr = (void*)1;
		ev.events = EPOLLIN;
		epoll_ctl( this_thread.epoll_fd, EPOLL_CTL_ADD, GetThreadSleeper( thread ), &ev );
#  endif
	}
#endif
#endif
	this_thread.parent_peer = peer_thread;
	this_thread.child_peer = NULL;
	this_thread.thread = thread;
	if( peer_thread )
		peer_thread->child_peer = &this_thread;
	else {
		globalNetworkData.root_thread = &this_thread;
#ifdef _WIN32
		globalNetworkData.hMonitorThreadControlEvent = this_thread.hThread;
#endif
	}
 // creator won't pass until bThreadInitComplete is set.
	while( !globalNetworkData.pThreads )
		Relinquish();
	globalNetworkData.flags.bThreadInitOkay = TRUE;
	globalNetworkData.flags.bThreadInitComplete = TRUE;
	while( !globalNetworkData.bQuit )
	{
		ProcessNetworkMessages( &this_thread, 0 );
	}
	xlprintf( 2100 )(WIDE( "Enter global network on shutdown... (thread exiting)" ));
	EnterCriticalSec( &globalNetworkData.csNetwork );
#  ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE( "NetworkThread(exit) in global" ) );
#  endif
	if( !this_thread.parent_peer )
	{
		if( globalNetworkData.root_thread = this_thread.child_peer )
			this_thread.child_peer->parent_peer = NULL;
	}
	else
	{
		if( this_thread.parent_peer->child_peer = this_thread.child_peer )
			this_thread.child_peer->parent_peer = this_thread.parent_peer;
	}
	// this used to be done in the WM_DESTROY
	DeleteLink( &globalNetworkData.pThreads, thread );
	globalNetworkData.flags.bThreadExit = TRUE;
	xlprintf( 2100 )(WIDE( "Shut down network thread." ));
	globalNetworkData.flags.bThreadInitComplete = FALSE;
	globalNetworkData.flags.bNetworkReady = FALSE;
	LeaveCriticalSec( &globalNetworkData.csNetwork );
#  ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE( "NetworkThread(exit) left global" ) );
#  endif
	//DeleteCriticalSec( &globalNetworkData.csNetwork );	 //spv:980303
	return 0;
}
//----------------------------------------------------------------------------
struct peer_thread_info *IsNetworkThread( void )
{
	struct peer_thread_info *thread;
	PTHREAD this_thread = MakeThread();
	for( thread = globalNetworkData.root_thread; thread; thread = thread->child_peer )
	{
		if( thread->thread == this_thread )
			return thread;
	}
	return NULL;
}
//----------------------------------------------------------------------------
int NetworkQuit(void)
{
	if( !global_network_data )
		return 0;
#if 0
	if( globalNetworkData.uPendingTimer )
	{
		RemoveTimer( globalNetworkData.uPendingTimer );
		globalNetworkData.uPendingTimer = 0;
	}
#endif
	//while( globalNetworkData.ActiveClients )
	{
#ifdef LOG_NOTICES
		if( globalNetworkData.flags.bLogNotices )
			lprintf( WIDE("NetworkQuit - Remove active client %p"), globalNetworkData.ActiveClients );
#endif
		//InternalRemoveClientEx( globalNetworkData.ActiveClients, TRUE, FALSE );
	}
	globalNetworkData.bQuit = TRUE;
	{
		PTHREAD thread;
		INDEX idx;
#ifdef USE_WSA_EVENTS
		PLIST wakeEvents = NULL;
		struct peer_thread_info *peer_thread;
		WSAEVENT hThread;
		peer_thread = globalNetworkData.root_thread;
		globalNetworkData.root_thread = NULL;
		for( ; peer_thread; peer_thread = peer_thread->child_peer ) {
			AddLink( &wakeEvents, peer_thread->hThread );
		}
		LIST_FORALL( wakeEvents, idx, WSAEVENT, hThread )
			WSASetEvent( hThread );
#endif
		LIST_FORALL( globalNetworkData.pThreads, idx, PTHREAD, thread ) {
			WakeThread( thread );
		}
	}
#ifdef _WIN32
#  ifdef LOG_NOTICES
	if( globalNetworkData.flags.bLogNotices )
		lprintf( WIDE( "SET GLOBAL EVENT (trigger quit)" ) );
#  endif
	WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#else
#  ifndef __LINUX__
	if( IsWindow( globalNetworkData.ghWndNetwork ) )
	{
		// okay forget this... at exit, cannot guarantee that
		// any other thread other than myself has any rights to do anything.
#    ifdef LOG_NOTICES
		if( globalNetworkData.flags.bLogNotices )
			lprintf( WIDE( "Post SOCKMSG_CLOSE" ) );
#    endif
		PostMessage( globalNetworkData.ghWndNetwork, SOCKMSG_CLOSE, 0, 0 );
		// also remove PCLIENT clients, and all client->pUserData allocated...
	}
#  else
	//while( globalNetworkData.pThread )
	//	Sleep(0);
	// should kill Our thread.... and close any active ockets...
#  endif
#endif
	globalNetworkData.flags.bThreadInitComplete = FALSE;
	//RemoveIdleProc( ProcessNetworkMessages );
	if( globalNetworkData.pThreads )
	{
		uint32_t started = timeGetTime() + 500;
 // allow network thread to gracefully exit
		Relinquish();
		while( globalNetworkData.flags.bNetworkReady && timeGetTime() < started )
			IdleFor( 20 );
		if( globalNetworkData.flags.bNetworkReady )
		{
#ifdef LOG_STARTUP_SHUTDOWN
			lprintf( WIDE( "Network was locked up?  Failed to allow network to exit in half a second (500ms)" ) );
#endif
		}
	}
	globalNetworkData.root_thread = NULL;
	return -1;
}
ATEXIT( NetworkShutdown )
{
	NetworkQuit();
}
//----------------------------------------------------------------------------
LOGICAL NetworkAlive( void )
{
	return !globalNetworkData.flags.bThreadExit;
}
//----------------------------------------------------------------------------
static void AddClients( void ) {
	PCLIENT_SLAB pClientSlab;
	// protect all structures.
	EnterCriticalSec( &globalNetworkData.csNetwork );
	{
		size_t n;
		//Log1( WIDE("Creating %d Client Resources"), MAX_NETCLIENTS );
		pClientSlab = NewPlus( CLIENT_SLAB, (MAX_NETCLIENTS - 1 )* sizeof( CLIENT ) );
		pClientSlab->pUserData = NewArray( uintptr_t, MAX_NETCLIENTS * globalNetworkData.nUserData );
 // can't clear the lpUserData Address!!!
		MemSet( pClientSlab->client, 0, (MAX_NETCLIENTS) * sizeof( CLIENT ) );
		MemSet( pClientSlab->pUserData, 0, (MAX_NETCLIENTS) * globalNetworkData.nUserData * sizeof( uintptr_t ) );
		pClientSlab->count = MAX_NETCLIENTS;
		for( n = 0; n < pClientSlab->count; n++ )
		{
 // unused sockets on all clients.
			pClientSlab->client[n].Socket = INVALID_SOCKET;
			pClientSlab->client[n].lpUserData = pClientSlab->pUserData + (n * globalNetworkData.nUserData);
			InitializeCriticalSec( &pClientSlab->client[n].csLockRead );
			InitializeCriticalSec( &pClientSlab->client[n].csLockWrite );
			AddAvailable( pClientSlab->client + n );
		}
		AddLink( &globalNetworkData.ClientSlabs, pClientSlab );
	}
	LeaveCriticalSec( &globalNetworkData.csNetwork );
}
//----------------------------------------------------------------------------
static void ReallocClients( uint32_t wClients, int nUserData )
{
	// protect all structures.
	EnterCriticalSec( &globalNetworkData.csNetwork );
	if( !wClients )
  // default 32 clients per slab...
		wClients = 32;
	if( !nUserData )
  // defualt to 4 pointer words per socket; most applications only use 1.
		nUserData = 4;
	// keep the max of specified data..
	if( nUserData < globalNetworkData.nUserData )
		nUserData = globalNetworkData.nUserData;
	// keep the max of specified connections..
	if( wClients < MAX_NETCLIENTS )
		wClients = MAX_NETCLIENTS;
	// if the client slab size increases, new slabs will be the new size; old slabs will still be the old size.
 // have to reallocate the user data for all sockets
	if( nUserData > globalNetworkData.nUserData )
	{
		INDEX idx;
		PCLIENT_SLAB slab;
		uint32_t n;
		// for all existing client slabs...
		LIST_FORALL( globalNetworkData.ClientSlabs, idx, PCLIENT_SLAB, slab )
		{
			uintptr_t* pUserData;
// slab->pUserData;
			pUserData = NewArray( uintptr_t, nUserData * sizeof( uintptr_t ) * slab->count );
			for( n = 0; n < slab->count; n++ )
			{
				if( slab->client[n].lpUserData )
					MemCpy( (char*)pUserData + (n * (nUserData * sizeof( uintptr_t )))
					      , slab->client[n].lpUserData
					      , globalNetworkData.nUserData * sizeof( uintptr_t ) );
				slab->client[n].lpUserData = pUserData + (n * nUserData);
			}
			Deallocate( uintptr_t*, slab->pUserData );
			slab->pUserData = pUserData;
		}
	}
	MAX_NETCLIENTS = wClients;
	globalNetworkData.nUserData = nUserData;
	LeaveCriticalSec( &globalNetworkData.csNetwork );
}
#ifdef __LINUX__
NETWORK_PROC( LOGICAL, NetworkWait )(POINTER unused,uint32_t wClients,int wUserData)
#else
NETWORK_PROC( LOGICAL, NetworkWait )(HWND hWndNotify,uint32_t wClients,int wUserData)
#endif
{
	// want to start the thead; clear quit.
	if( !global_network_data )
		LowLevelNetworkInit();
	// allow network to restart with new NetworkWait after NetworkQuit
	globalNetworkData.bQuit = FALSE;
	ReallocClients( wClients, wUserData );
	//-------------------------
	// please be mindful of the following data declared immediate...
	if( GetLinkCount( globalNetworkData.pThreads ) )
	{
		//xlprintf(200)( WIDE("Threads already active...") );
		// might do something... might not...
 // network thread active, do not realloc
		return TRUE;
	}
/*peer_thread==*/
	AddLink( &globalNetworkData.pThreads, ThreadTo( NetworkThreadProc, (uintptr_t)NULL ) );
	globalNetworkData.nPeers++;
	AddIdleProc( IdleProcessNetworkMessages, 1 );
	//lprintf( WIDE("Network Initialize..."));
	//lprintf( WIDE("Create network thread.") );
	while( !globalNetworkData.flags.bThreadInitComplete )
	{
		Relinquish();
	}
	if( !globalNetworkData.flags.bThreadInitOkay )
	{
		lprintf( WIDE("Abort network, init is NOT ok.") );
		return FALSE;
	}
	while( !globalNetworkData.flags.bNetworkReady )
 // wait for actual network...
		Relinquish();
	{
		char buffer[256];
		if( gethostname( buffer, sizeof( buffer ) ) == 0)
			globalNetworkData.system_name = DupCStr( buffer );
	}
	LoadNetworkAddresses();
  // return status of thread initialization
	return globalNetworkData.flags.bThreadInitOkay;
}
//----------------------------------------------------------------------------
PCLIENT GetFreeNetworkClientEx( DBG_VOIDPASS )
{
	PCLIENT pClient = NULL;
get_client:
	EnterCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE("GetFreeNetworkClient in global") );
#endif
 // if there's none available, add some with current config
	if( !globalNetworkData.AvailableClients )
		AddClients();
	for( pClient = globalNetworkData.AvailableClients; pClient; pClient = pClient->next )
		if( !( pClient->dwFlags & CF_CLOSING ) )
			break;
	if( pClient )
	{
		int d;
		// oterhwise we'll deadlock the closing client...
		// an opening condition has global lock (above)
		// and a closing socket will want the global lock before it's done.
		pClient = GrabClient( pClient );
		do {
#ifdef USE_NATIVE_CRITICAL_SECTION
			d = EnterCriticalSecNoWait( &pClient->csLockRead, NULL );
#else
			d = EnterCriticalSecNoWaitEx( &pClient->csLockRead, NULL DBG_RELAY );
#endif
			if( d < 1 ) {
				LeaveCriticalSec( &globalNetworkData.csNetwork );
				goto get_client;
			}
		} while( d < 1 );
		do {
#ifdef USE_NATIVE_CRITICAL_SECTION
			d = EnterCriticalSecNoWait( &pClient->csLockWrite, NULL );
#else
			d = EnterCriticalSecNoWaitEx( &pClient->csLockWrite, NULL DBG_RELAY );
#endif
			if( d < 1 ) {
				LeaveCriticalSec( &pClient->csLockRead );
				LeaveCriticalSec( &globalNetworkData.csNetwork );
				goto get_client;
			}
		} while( d < 1 );
		if( pClient->dwFlags & CF_STATEFLAGS )
			DebugBreak();
 // clear client is redundant here... but saves the critical section now
		ClearClient( pClient DBG_SRC );
		//Log1( WIDE("New network client %p"), client );
	}
	else
	{
		LeaveCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
		lprintf( WIDE("GetFreeNetworkClient left global") );
#endif
		Relinquish();
		if( globalNetworkData.AvailableClients )
		{
			lprintf( WIDE( "there were clients available... just in a closing state..." ) );
			goto get_client;
		}
		lprintf( WIDE("No unused network clients are available.") );
		return NULL;
	}
	LeaveCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_NETWORK_LOCKING
	lprintf( WIDE("GetFreeNetworkClient left global") );
#endif
	return pClient;
}
//----------------------------------------------------------------------------
NETWORK_PROC( void, SetNetworkLong )(PCLIENT lpClient, int nLong, uintptr_t dwValue)
{
	if( lpClient && ( nLong < globalNetworkData.nUserData ) )
	{
		lpClient->lpUserData[nLong] = dwValue;
	}
	return;
}
//----------------------------------------------------------------------------
int GetAddressParts( SOCKADDR *sa, uint32_t *pdwIP, uint16_t *pdwPort )
{
	int result = TRUE;
	if( sa )
	{
		if( sa->sa_family == AF_INET ) {
			if( pdwIP )
				(*pdwIP) = (uint32_t)(((SOCKADDR_IN*)sa)->sin_addr.S_un.S_addr);
		}
		else if( sa->sa_family == AF_INET6 ) {
			if( pdwIP )
				memcpy( pdwIP, &(((SOCKADDR_IN*)sa)->sin_addr.S_un.S_addr), 16 );
		}
		else
			result = FALSE;
		if( (sa->sa_family == AF_INET) || (sa->sa_family = AF_INET6) ) {
			if( pdwPort )
				(*pdwPort) = ntohs((uint16_t)( (SOCKADDR_IN*)sa)->sin_port);
		}
		else
			result = FALSE;
	}
	return result;
}
NETWORK_PROC( uintptr_t, GetNetworkLong )(PCLIENT lpClient,int nLong)
{
	if( !lpClient )
	{
		return (uintptr_t)-1;
	}
	if( nLong < 0 )
	{
		switch( nLong )
		{
  // IP of destination
		case GNL_IP:
			if( lpClient->saClient )
				return *(uint32_t*)(lpClient->saClient->sa_data+2);
			break;
  // IP of destination
		case GNL_REMOTE_ADDRESS:
			  return (uintptr_t)lpClient->saClient;
			break;
  // IP of local side
		case GNL_LOCAL_ADDRESS:
			  return (uintptr_t)lpClient->saSource;
			break;
  // port of server...  STUPID PATCH?!  maybe...
		case GNL_PORT:
			if( lpClient->saClient )
				return ntohs( *(uint16_t*)(lpClient->saClient->sa_data) );
			break;
  // port of server...  STUPID PATCH?!  maybe...
		case GNL_MYPORT:
			if( lpClient->saSource )
				return ntohs( *(uint16_t*)(lpClient->saSource->sa_data) );
			break;
 // IP of myself (after connect?)
		case GNL_MYIP:
			if( lpClient->saSource )
				return *(uint32_t*)(lpClient->saSource->sa_data+2);
			break;
			//TODO if less than zero return a (high/low)portion of the  hardware address (MAC).
		}
	}
	else if( nLong < globalNetworkData.nUserData )
	{
		return lpClient->lpUserData[nLong];
	}
   //spv:980303
	return (uintptr_t)-1;
}
//----------------------------------------------------------------------------
 // return a copy of this address...
SOCKADDR* DuplicateAddressEx( SOCKADDR *pAddr DBG_PASS )
{
	POINTER tmp = (POINTER)( ( (uintptr_t)pAddr ) - 2*sizeof(uintptr_t) );
	SOCKADDR *dup = AllocAddrEx( DBG_VOIDRELAY );
	POINTER tmp2 = (POINTER)( ( (uintptr_t)dup ) - 2*sizeof(uintptr_t) );
	MemCpy( tmp2, tmp, SOCKADDR_LENGTH( pAddr ) + 2*sizeof(uintptr_t) );
	if( ((char**)( ( (uintptr_t)pAddr ) - sizeof(char*) ))[0] )
		( (char**)( ( (uintptr_t)dup ) - sizeof( char* ) ) )[0]
				= strdup( ((char**)( ( (uintptr_t)pAddr ) - sizeof( char* ) ))[0] );
	return dup;
}
//---------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *,CreateAddress_hton)( uint32_t dwIP,uint16_t nHisPort)
{
	SOCKADDR_IN *lpsaAddr=(SOCKADDR_IN*)AllocAddr();
	if (!lpsaAddr)
		return(NULL);
	SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
	lpsaAddr->sin_family       = AF_INET;
	lpsaAddr->sin_addr.S_un.S_addr  = htonl(dwIP);
	lpsaAddr->sin_port         = htons(nHisPort);
	return((SOCKADDR*)lpsaAddr);
}
//---------------------------------------------------------------------------
#if defined( __LINUX__ ) && !defined( __CYGWIN__ )
 #define UNIX_PATH_MAX	 108
struct sockaddr_un {
#ifdef __MAC__
	u_char   sa_len;
#endif
	sa_family_t  sun_family;
	char	       sun_path[UNIX_PATH_MAX];
};
NETWORK_PROC( SOCKADDR *,CreateUnixAddress)( CTEXTSTR path )
{
	struct sockaddr_un *lpsaAddr;
#ifdef UNICODE
	char *tmp_path = CStrDup( path );
#endif
   lpsaAddr=(struct sockaddr_un*)AllocAddr();
	if (!lpsaAddr)
		return(NULL);
	((uintptr_t*)lpsaAddr)[-1] = StrLen( path ) + 1;
	lpsaAddr->sun_family = PF_UNIX;
#ifdef UNICODE
	strncpy( lpsaAddr->sun_path, tmp_path, 107 );
	Deallocate( char*, tmp_path );
#else
	strncpy( lpsaAddr->sun_path, path, 107 );
#endif
#ifdef __MAC__
	lpsaAddr->sa_len = 2+strlen( lpsaAddr->sun_path );
#endif
	return((SOCKADDR*)lpsaAddr);
}
#else
NETWORK_PROC( SOCKADDR *,CreateUnixAddress)( CTEXTSTR path )
{
	lprintf( WIDE( "-- CreateUnixAddress -- not available. " ) );
	return NULL;
}
#endif
//---------------------------------------------------------------------------
SOCKADDR *CreateAddress( uint32_t dwIP,uint16_t nHisPort)
{
	SOCKADDR_IN *lpsaAddr=(SOCKADDR_IN*)AllocAddr();
	if (!lpsaAddr)
		return(NULL);
	SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
	lpsaAddr->sin_family	    = AF_INET;
	lpsaAddr->sin_addr.S_un.S_addr  = dwIP;
	lpsaAddr->sin_port         = htons(nHisPort);
	return((SOCKADDR*)lpsaAddr);
}
//---------------------------------------------------------------------------
SOCKADDR *CreateRemote( CTEXTSTR lpName,uint16_t nHisPort)
{
	SOCKADDR_IN *lpsaAddr;
	int conversion_success = FALSE;
	char *tmpName = NULL;
#ifdef UNICODE
	char *_lpName = CStrDup( lpName );
#  define lpName _lpName
#endif
#ifndef WIN32
	PHOSTENT phe;
	// a IP type name will never have a / in it, therefore
	// we can assume it's a unix type address....
	if( lpName && StrChr( lpName, '/' ) )
		return CreateUnixAddress( lpName );
#endif
	if( lpName[0] == '[' && lpName[StrLen( lpName ) - 1] == ']' ) {
		size_t len;
		tmpName = NewArray( char, len = StrLen( lpName ) );
		memcpy( tmpName, lpName + 1, len - 2 );
		tmpName[len - 2] = 0;
		lpName = tmpName;
	}
	lpsaAddr=(SOCKADDR_IN*)AllocAddr();
	if( !lpsaAddr )
	{
#ifdef UNICODE
		Deallocate( char *, _lpName );
#endif
		return(NULL);
	}
	SetAddrName( (SOCKADDR*)lpsaAddr, lpName );
	// if it's a numeric name... attempt to use as an address.
#ifdef __LINUX__
	if( lpName &&
		( lpName[0] >= '0' && lpName[0] <= '9' )
	  && StrChr( lpName, '.' ) )
	{
#ifdef UNICODE
		char *tmp = CStrDup( lpName );
		if( inet_pton( AF_INET, tmp, (struct in_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET;
			conversion_success = TRUE;
		}
		Deallocate( char *, tmp );
#else
		if( inet_pton( AF_INET, lpName, (struct in6_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET;
			conversion_success = TRUE;
		}
#endif
	}
	else if( lpName
		   && ( ( lpName[0] >= '0' && lpName[0] <= '9' )
		      || ( lpName[0] >= 'a' && lpName[0] <= 'f' )
		      || ( lpName[0] >= 'A' && lpName[0] <= 'F' )
		      || lpName[0] == ':'
		      || ( lpName[0] == '[' && lpName[StrLen( lpName ) - 1] == ']' ) )
		   && StrChr( lpName, ':' )!=StrRChr( lpName, ':' ) )
	{
#ifdef UNICODE
		char *tmp = CStrDup( lpName );
		if( inet_pton( AF_INET6, tmp, (struct in_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN6_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET6;
			conversion_success = TRUE;
		}
		Deallocate( char *, tmp );
#else
		if( inet_pton( AF_INET6, lpName, (struct in6_addr*)&lpsaAddr->sin_addr ) > 0 )
		{
			SET_SOCKADDR_LENGTH( lpsaAddr, IN6_SOCKADDR_LENGTH );
         // InetAddress Type.
			lpsaAddr->sin_family       = AF_INET6;
			conversion_success = TRUE;
		}
#endif
	}
#endif
	if( !conversion_success )
	{
		if( lpName )
		{
#ifdef WIN32
			{
				struct addrinfo *result;
				struct addrinfo *test;
				int error;
				error = getaddrinfo( lpName, NULL, NULL, (struct addrinfo**)&result );
				if( error == 0 )
				{
					for( test = result; test; test = test->ai_next )
					{
						//SOCKADDR *tmp;
						//AddLink( &globalNetworkData.addresses, tmp = AllocAddr() );
						MemCpy( lpsaAddr, test->ai_addr, test->ai_addrlen );
						SET_SOCKADDR_LENGTH( lpsaAddr, test->ai_addrlen );
						break;
					}
				}
				else
					lprintf( WIDE( "getaddrinfo Error: %d for [%s]" ), error, lpName );
			}
 //WIN32
#else
			char *tmp = CStrDup( lpName );
//!(phe=gethostbyname(tmp)))
			if( 1 )
			{
				if( !(phe=gethostbyname2(tmp,AF_INET6) ) )
				{
					if( !(phe=gethostbyname2(tmp,AF_INET) ) )
					{
						 // could not find the name in the host file.
						Log1( WIDE("Could not Resolve to %s"), lpName );
						Deallocate(SOCKADDR_IN*, lpsaAddr);
						Deallocate( char*, tmp );
						if( tmpName ) Deallocate( char*, tmpName );
						return(NULL);
					}
					else
					{
						lprintf( WIDE( "Strange, gethostbyname failed, but AF_INET worked..." ) );
						SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
						lpsaAddr->sin_family = AF_INET;
           // save IP address from host entry.
						memcpy( &lpsaAddr->sin_addr.S_un.S_addr,
							 phe->h_addr,
							 phe->h_length);
					}
				}
				else
				{
					SET_SOCKADDR_LENGTH( lpsaAddr, IN6_SOCKADDR_LENGTH );
         // InetAddress Type.
					lpsaAddr->sin_family = AF_INET6;
#if note
	{
		__SOCKADDR_COMMON (sin6_);
		n_port_t sin6_port;
		uint32_t sin6_flowinfo;
		struct in6_addr sin6_addr;
		uint32_t sin6_scope_id;
	};
#endif
           // save IP address from host entry.
					memcpy( ((struct sockaddr_in6*)lpsaAddr)->sin6_addr.s6_addr,
							 phe->h_addr,
							 phe->h_length);
				}
			}
			else
			{
				Deallocate( char *, tmp );
				SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
         // InetAddress Type.
				lpsaAddr->sin_family = AF_INET;
           // save IP address from host entry.
				memcpy( &lpsaAddr->sin_addr.S_un.S_addr,
					 phe->h_addr,
					 phe->h_length);
			}
#endif
		}
		else
		{
         // InetAddress Type.
			lpsaAddr->sin_family      = AF_INET;
			lpsaAddr->sin_addr.S_un.S_addr = 0;
			SET_SOCKADDR_LENGTH( lpsaAddr, IN_SOCKADDR_LENGTH );
		}
	}
#ifdef UNICODE
	Deallocate( char *, _lpName );
#  undef lpName
#endif
	// put in his(destination) port number...
	if( tmpName ) Deallocate( char*, tmpName );
	lpsaAddr->sin_port         = htons(nHisPort);
	return((SOCKADDR*)lpsaAddr);
}
//----------------------------------------------------------------------------
#ifdef __cplusplus
namespace udp {
#endif
NETWORK_PROC( void, DumpAddrEx)( CTEXTSTR name, SOCKADDR *sa DBG_PASS )
	{
		if( !sa ) { _lprintf(DBG_RELAY)( "%s: NULL", name ); return; }
		LogBinary( (uint8_t *)sa, SOCKADDR_LENGTH( sa ) );
		if( sa->sa_family == AF_INET ) {
			_lprintf(DBG_RELAY)( WIDE("%s: (%s) %d.%d.%d.%d:%d "), name
			       , ( ((uintptr_t*)sa)[-1] & 0xFFFF0000 )?( ((char**)sa)[-1] ) : "no name"
			       //*(((unsigned char *)sa)+0),
			       //*(((unsigned char *)sa)+1),
			       ,*(((unsigned char *)sa)+4),
			       *(((unsigned char *)sa)+5),
			       *(((unsigned char *)sa)+6),
			       *(((unsigned char *)sa)+7)
			       , ntohs( *(((unsigned short *)((unsigned char*)sa + 2))) )
			);
		} else if( sa->sa_family == AF_INET6 )
		{
			lprintf( WIDE( "Socket address binary: %s" ), name );
			_lprintf(DBG_RELAY)( WIDE("%s: (%s) %03d %04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x ")
					 , name
					, ( ((uintptr_t*)sa)[-1] & 0xFFFF0000 )?( ((char**)sa)[-1] ) : "no name"
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+2))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+8))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+10))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+12))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+14))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+16))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+18))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+20))))
					 , ntohs(*(((unsigned short *)((unsigned char*)sa+22))))
					 );
		}
}
#ifdef __cplusplus
}
#endif
//----------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *, SetAddressPort )( SOCKADDR *pAddr, uint16_t nDefaultPort )
{
	if( pAddr )
		((SOCKADDR_IN *)pAddr)->sin_port = htons(nDefaultPort);
	return pAddr;
}
//----------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *, SetNonDefaultPort )( SOCKADDR *pAddr, uint16_t nDefaultPort )
{
	if( pAddr && !((SOCKADDR_IN *)pAddr)->sin_port )
		((SOCKADDR_IN *)pAddr)->sin_port = htons(nDefaultPort);
	return pAddr;
}
//----------------------------------------------------------------------------
NETWORK_PROC( SOCKADDR *,CreateSockAddress)(CTEXTSTR name, uint16_t nDefaultPort )
{
// blah... should process a ip:port - but - default port?!
	uint32_t bTmpName = 0;
	char * tmp;
	SOCKADDR *sa = NULL;
	char *port;
	uint16_t wPort;
	CTEXTSTR portName = name;
#ifdef UNICODE
	char *_name = CStrDup( name );
#  define name _name
#endif
	if( name[0] == '[' ) {
		while( portName[0] && portName[0] != ']' )
			portName++;
		if( portName[0] ) portName++;
	}
	if( name && portName[0] && ( port = (char*)strrchr( portName, ':' ) ) )
	{
		tmp = StrDup( name );
		bTmpName = 1;
		port = tmp + (port-name);
		name = tmp;
		//Log1( WIDE("Found ':' assuming %s is IP:PORT"), name );
		*port = 0;
		port++;
  // a trailing : could be IPV6 abbreviation.
		if( port[0] )
		{
			if( isdigit( *port ) )
			{
				wPort = (short)atoi( port );
			}
			else
			{
				struct servent *se;
				se = getservbyname( port, NULL );
				if( !se )
				{
#ifdef UNICODE
#define FMT WIDE("S")
#else
#define FMT WIDE("s")
#endif
					Log1( WIDE("Could not resolve \"%" ) FMT WIDE("\" as a valid service name"), port );
					//return NULL;
					wPort = nDefaultPort;
				}
				else
					wPort = htons(se->s_port);
				//Log1( WIDE("port alpha - name resolve to %d"), wPort );
			}
		}
		else
			wPort = nDefaultPort;
#ifdef UNICODE
#  undef name
#endif
		sa = CreateRemote( name, wPort );
		if( port )
		{
  // incase we obliterated it
			port[-1] = ':';
		}
	}
  // no port specification...
	else
	{
		//Log1( WIDE("%s does not have a ':'"), name );
		sa = CreateRemote( name, nDefaultPort );
	}
#ifdef UNICODE
	Deallocate( char *, _name );
#endif
	if( bTmpName ) Deallocate( char*, tmp );
	return sa;
}
//----------------------------------------------------------------------------
SOCKADDR *CreateLocal(uint16_t nMyPort)
{
	char lpHostName[HOSTNAME_LEN];
	if (gethostname(lpHostName,HOSTNAME_LEN))
	{
		return(NULL);
	}
	return CreateRemote( WIDE("0.0.0.0"), nMyPort );
}
//----------------------------------------------------------------------------
LOGICAL CompareAddressEx( SOCKADDR *sa1, SOCKADDR *sa2, int method )
{
	if( method == SA_COMPARE_FULL )
	{
		if( sa1 && sa2 )
		{
			if( ((SOCKADDR_IN*)sa1)->sin_family == ((SOCKADDR_IN*)sa2)->sin_family )
			{
				switch( ((SOCKADDR_IN*)sa1)->sin_family )
				{
				case AF_INET:
					{
						SOCKADDR_IN *sin1 = (SOCKADDR_IN*)sa1;
						SOCKADDR_IN *sin2 = (SOCKADDR_IN*)sa2;
						if( MemCmp( sin1, sin2, sizeof( SOCKADDR_IN ) ) == 0 )
							return 1;
					}
					break;
				default:
					xlprintf( LOG_ALWAYS )( WIDE("unhandled address type passed to compare, resulting FAILURE") );
					return 0;
				}
			}
		}
	}
	else
	{
		if( sa1 && sa2 )
		{
			if( ((SOCKADDR_IN*)sa1)->sin_family == ((SOCKADDR_IN*)sa2)->sin_family )
			{
				switch( ((SOCKADDR_IN*)sa1)->sin_family )
				{
				case AF_INET:
					{
						if( MemCmp( &((SOCKADDR_IN*)sa1)->sin_addr, &((SOCKADDR_IN*)sa2)->sin_addr, sizeof( ((SOCKADDR_IN*)sa2)->sin_addr ) ) == 0 )
							return 1;
					}
					break;
				default:
					xlprintf( LOG_ALWAYS )( WIDE("unhandled address type passed to compare, resulting FAILURE") );
					return 0;
				}
			}
		}
	}
	return 0;
}
//----------------------------------------------------------------------------
LOGICAL CompareAddress( SOCKADDR *sa1, SOCKADDR *sa2 )
{
	return CompareAddressEx( sa1, sa2, SA_COMPARE_FULL );
}
//----------------------------------------------------------------------------
PLIST GetLocalAddresses( void )
{
	return globalNetworkData.addresses;
}
//----------------------------------------------------------------------------
LOGICAL IsThisAddressMe( SOCKADDR *addr, uint16_t myport )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, &((SOCKADDR_IN*)test_addr->sa)->sin_addr, sizeof(((SOCKADDR_IN*)addr)->sin_addr)  ) == 0 )
					{
						return TRUE;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL IsBroadcastAddressForInterface( struct interfaceAddress *address, SOCKADDR *addr ) {
	if( addr->sa_family == AF_INET ) {
      //lprintf( "can test for broadcast... %08x %08x %08x", ( ((uint32_t*)(address->saMask->sa_data+2))[0] | ((uint32_t*)(addr->sa_data+2))[0] ), ((uint32_t*)address->saMask->sa_data)[0] , ((uint32_t*)addr->sa_data)[0] );
		if( ( ((uint32_t*)(address->saMask->sa_data+2))[0] | ((uint32_t*)(addr->sa_data+2))[0] ) == 0xFFFFFFFFU )
         return TRUE;
	}
   return FALSE;
}
//----------------------------------------------------------------------------
struct interfaceAddress* GetInterfaceForAddress( SOCKADDR *addr )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	if( !globalNetworkData.addresses )
		LoadNetworkAddresses();
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, sizeof(((SOCKADDR_IN*)addr)->sin_addr)  ) == 0 )
					{
						return test_addr;
					}
				}
				break;
			case AF_INET6:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, 16 ) == 0 )
					{
						return test_addr;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return NULL;
}
//----------------------------------------------------------------------------
SOCKADDR* GetBroadcastAddressForInterface( SOCKADDR *addr )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	if( !globalNetworkData.addresses )
		LoadNetworkAddresses();
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, sizeof(((SOCKADDR_IN*)addr)->sin_addr)  ) == 0 )
					{
						return test_addr->saBroadcast;
					}
				}
				break;
			case AF_INET6:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->sa->sa_data + 2, 16 ) == 0 )
					{
						return test_addr->saBroadcast;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
SOCKADDR* GetInterfaceAddressForBroadcast( SOCKADDR *addr )
{
	struct interfaceAddress *test_addr;
	INDEX idx;
	if( !globalNetworkData.addresses )
		LoadNetworkAddresses();
	LIST_FORALL( globalNetworkData.addresses, idx, struct interfaceAddress *, test_addr )
	{
		if( ((SOCKADDR_IN*)addr)->sin_family == ((SOCKADDR_IN*)test_addr->sa)->sin_family )
		{
			switch( ((SOCKADDR_IN*)addr)->sin_family )
			{
			case AF_INET:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->saBroadcast->sa_data + 2, 4 ) == 0 )
					{
						return test_addr->sa;
					}
				}
				break;
			case AF_INET6:
				{
					if( MemCmp( &((SOCKADDR_IN*)addr)->sin_addr, test_addr->saBroadcast->sa_data + 2, 16  ) == 0 )
					{
						return test_addr->sa;
					}
				}
				break;
			default:
				lprintf( WIDE( "Unknown comparison" ) );
			}
		}
	}
	return FALSE;
}
//----------------------------------------------------------------------------
void ReleaseAddress(SOCKADDR *lpsaAddr)
{
	// sockaddr is often skewed from what I would expect it. (contains its own length)
	if( lpsaAddr )
	{
		/* strdup is used for the addr part so use free instead of release */
		free( ((POINTER*)( ( (uintptr_t)lpsaAddr ) - sizeof(uintptr_t) ))[0] );
		Deallocate(POINTER, (POINTER)( ( (uintptr_t)lpsaAddr ) - 2 * sizeof(uintptr_t) ));
	}
}
//----------------------------------------------------------------------------
// creates class C broadcast address
SOCKADDR *CreateBroadcast(uint16_t nPort)
{
	SOCKADDR_IN *bcast=(SOCKADDR_IN*)AllocAddr();
	SOCKADDR *lpMyAddr;
	if (!bcast)
		return(NULL);
	lpMyAddr = CreateLocal(0);
	SET_SOCKADDR_LENGTH( bcast, IN_SOCKADDR_LENGTH );
	bcast->sin_family	    = AF_INET;
	bcast->sin_addr.S_un.S_addr  = ((SOCKADDR_IN*)lpMyAddr)->sin_addr.S_un.S_addr;
 // Fake a subnet broadcast address
	bcast->sin_addr.S_un.S_un_b.s_b4 = 0xFF;
	bcast->sin_port        = htons(nPort);
	ReleaseAddress(lpMyAddr);
	return((SOCKADDR*)bcast);
}
//----------------------------------------------------------------------------
void DumpSocket( PCLIENT pc )
{
	DumpAddr( WIDE("REMOT"), pc->saClient );
	DumpAddr( WIDE("LOCAL"), pc->saSource );
	return;
}
#ifdef __cplusplus
namespace udp {
#endif
#undef DumpAddr
NETWORK_PROC( void, DumpAddr)( CTEXTSTR name, SOCKADDR *sa )
{
	DumpAddrEx( name, sa DBG_SRC );
}
#ifdef __cplusplus
}
#endif
//----------------------------------------------------------------------------
NETWORK_PROC( PCLIENT, NetworkLockEx)( PCLIENT lpClient, int readWrite DBG_PASS )
{
	if( lpClient )
	{
		//lpClient->dwFlags |= CF_WANTS_GLOBAL_LOCK;
		//_lprintf(DBG_RELAY)( WIDE( "Lock %p" ), lpClient );
#ifdef USE_NATIVE_CRITICAL_SECTION
		if( EnterCriticalSecNoWait( &globalNetworkData.csNetwork, NULL ) < 1 )
#else
		if( EnterCriticalSecNoWaitEx( &globalNetworkData.csNetwork, NULL DBG_RELAY ) < 1 )
#endif
		{
			//lpClient->dwFlags &= ~CF_WANTS_GLOBAL_LOCK;
#ifdef LOG_NETWORK_LOCKING
			_lprintf(DBG_RELAY)( WIDE( "Failed enter global? %llx" ), globalNetworkData.csNetwork.dwThreadID  );
#endif
			Relinquish();
			return NULL;
			//DebugBreak();
		}
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )( WIDE( "Got global lock %p %d" ), lpClient, readWrite );
#endif
		//lpClient->dwFlags &= ~CF_WANTS_GLOBAL_LOCK;
#ifdef USE_NATIVE_CRITICAL_SECTION
		if( !EnterCriticalSecNoWait( (readWrite? &lpClient->csLockRead:&lpClient->csLockWrite), NULL ) )
#else
		if( EnterCriticalSecNoWaitEx( ( readWrite ?&lpClient->csLockRead : &lpClient->csLockWrite ), NULL DBG_RELAY ) < 1 )
#endif
		{
			// unlock the global section for a moment..
			// client may be requiring both local and global locks (already has local lock)
#ifdef USE_NATIVE_CRITICAL_SECTION
			LeaveCriticalSec( &globalNetworkData.csNetwork);
#else
			LeaveCriticalSecEx( &globalNetworkData.csNetwork  DBG_RELAY);
#endif
			//lprintf( "Idle... socket lock failed, had global though..." );
			Relinquish();
			return NULL;
			//goto start_lock;
		}
		//EnterCriticalSec( readWrite ? &lpClient->csLockRead : &lpClient->csLockWrite );
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSec( &globalNetworkData.csNetwork );
#else
		LeaveCriticalSecEx( &globalNetworkData.csNetwork  DBG_RELAY);
#endif
		if( !(lpClient->dwFlags & (CF_ACTIVE|CF_CLOSED) ) )
		{
			// change to inactive status by the time we got here...
#ifdef USE_NATIVE_CRITICAL_SECTION
			LeaveCriticalSec( readWrite ? &lpClient->csLockRead : &lpClient->csLockWrite );
#else
			LeaveCriticalSecEx( readWrite?&lpClient->csLockRead:&lpClient->csLockWrite DBG_RELAY );
#endif
			_lprintf( DBG_RELAY )( WIDE( "Failed lock" ) );
			lprintf( WIDE( "%p  %08x %08x inactive, cannot lock." ), lpClient, lpClient->dwFlags, CF_ACTIVE );
			// this client is not available for client use!
			return NULL;
		}
	}
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )( WIDE( "Got private lock %p %d" ), lpClient, readWrite );
#endif
	return lpClient;
}
//----------------------------------------------------------------------------
NETWORK_PROC( void, NetworkUnlockEx)( PCLIENT lpClient, int readWrite DBG_PASS )
{
	//_lprintf(DBG_RELAY)( WIDE( "Unlock %p" ), lpClient );
	// simple unlock.
	if( lpClient )
	{
#ifdef LOG_NETWORK_LOCKING
		_lprintf( DBG_RELAY )( WIDE( "Leave private lock %p %d" ), lpClient, readWrite );
#endif
#ifdef USE_NATIVE_CRITICAL_SECTION
		LeaveCriticalSec( readWrite ? &lpClient->csLockRead : &lpClient->csLockWrite );
#else
		LeaveCriticalSecEx( readWrite?&lpClient->csLockRead:&lpClient->csLockWrite DBG_RELAY );
#endif
	}
}
//----------------------------------------------------------------------------
void InternalRemoveClientExx(PCLIENT lpClient, LOGICAL bBlockNotify, LOGICAL bLinger DBG_PASS )
{
#ifdef LOG_SOCKET_CREATION
	_lprintf( DBG_RELAY )( WIDE("InternalRemoveClient Removing this client %p (%d)"), lpClient, lpClient->Socket );
#endif
	if( lpClient && IsValid(lpClient->Socket) )
	{
		if( !bLinger )
		{
#ifdef LOG_DEBUG_CLOSING
			lprintf( WIDE("Setting quick close?!") );
#endif
			if( 0 )
			{
				int nAllowReuse = 1;
				if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEADDR,
									(char*)&nAllowReuse, sizeof(nAllowReuse)) <0 )
				{
					//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse addr." << endl;
				}
				/*
				// missing symbol in windows?
				if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEPORT,
									(char*)&nAllowReuse, sizeof(nAllowReuse)) <0 )
				{
					//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse port." << endl;
					}
				*/
			}
			if( 1 )
			{
				// www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html
				//  the idea is to NEVER do this; but I had to do this for lots of parallel connections that were short lived...
				// windows registry http://technet.microsoft.com/en-us/library/cc938217.aspx 240 seconds time_wait timeout
				struct linger lingerSet;
 // on , with no time = off.
				lingerSet.l_onoff = 1;
 // 0 timeout sends reset.
				lingerSet.l_linger = 0;
										 // set server to allow reuse of socket port
            //lprintf( "Set no linger" );
				if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_LINGER,
									(char*)&lingerSet, sizeof(lingerSet)) <0 )
				{
					lprintf( WIDE( "error setting no linger in close." ) );
					//cerr << "NFMSim:setHost:ERROR: could not set socket to linger." << endl;
				}
			}
		}
		else {
			struct linger lingerSet;
			// linger ON causes delay on close... otherwise close returns immediately
 // on , with no time = off.
			lingerSet.l_onoff = 1;
			lingerSet.l_linger = 2;
			// set server to allow reuse of socket port
			if( setsockopt( lpClient->Socket, SOL_SOCKET, SO_LINGER,
				(char*)&lingerSet, sizeof( lingerSet ) ) <0 )
			{
				lprintf( WIDE( "error setting 2 second linger in close." ) );
			}
		}
		if( !(lpClient->dwFlags & CF_ACTIVE) )
		{
			if( lpClient->dwFlags & CF_AVAILABLE )
			{
				lprintf( WIDE("Client was inactive?!?!?! removing from list and putting in available") );
				AddAvailable( GrabClient( lpClient ) );
			}
			// this is probably true, we've definatly already moved it from
			// active list to clsoed list.
			else if( !(lpClient->dwFlags & CF_CLOSED) )
			{
#ifdef LOG_DEBUG_CLOSING
				lprintf( WIDE("Client was NOT already closed?!?!") );
#endif
				AddClosed( GrabClient( lpClient ) );
			}
#ifdef LOG_DEBUG_CLOSING
			else
				lprintf( WIDE("Client's state is CLOSED") );
#endif
			return;
		}
		if( lpClient->lpFirstPending || ( lpClient->dwFlags & CF_WRITEPENDING ) ) {
#ifdef LOG_DEBUG_CLOSING
			lprintf( "CLOSE WHILE WAITING FOR WRITE TO FINISH..." );
#endif
			//lpClient->dwFlags |= CF_TOCLOSE;
			//return;
			// continue on; otherwise the close event gets lost...
		}
		while( !NetworkLockEx( lpClient, 0 DBG_SRC ) )
		{
			if( !(lpClient->dwFlags & CF_ACTIVE ) )
			{
				return;
			}
			Relinquish();
		}
		while( !NetworkLockEx( lpClient, 1 DBG_SRC ) )
		{
			if( !(lpClient->dwFlags & CF_ACTIVE) )
			{
				return;
			}
			Relinquish();
		}
		// allow application a chance to clean it's references
		// to this structure before closing and cleaning it.
		if( !bBlockNotify )
		{
			lpClient->dwFlags |= CF_CONNECT_CLOSED;
			if( lpClient->pWaiting )
			{
				WakeThread( lpClient->pWaiting );
				while( lpClient->dwFlags & CF_CONNECT_WAITING )
					Relinquish();
			}
			lpClient->dwFlags &= ~CF_CONNECT_CLOSED;
 // prevent multiple notifications...
			if( !(lpClient->dwFlags & CF_CLOSING) )
			{
#ifdef LOG_DEBUG_CLOSING
				lprintf( WIDE( "Marked closing first, and dispatching callback?" ) );
#endif
				lpClient->dwFlags |= CF_CLOSING;
				if( lpClient->close.CloseCallback )
				{
					// during thisi if it wants a lock... and the application
					// is dispatching like
					if( lpClient->dwFlags & CF_CPPCLOSE )
						lpClient->close.CPPCloseCallback( lpClient->psvClose );
					else
						lpClient->close.CloseCallback( lpClient );
				}
#ifdef LOG_DEBUG_CLOSING
				else
					lprintf( WIDE( "no close callback!?" ) );
#endif
				// leave the flag closing set... we'll use that later
				// to avoid the double-lock;
				//lpClient->dwFlags &= ~CF_CLOSING;
			}
#ifdef LOG_DEBUG_CLOSING
			else
				lprintf( WIDE( "socket was already ispatched callback?" ) );
#endif
		}
		else
		{
#ifdef LOG_DEBUG_CLOSING
			lprintf( WIDE( "blocknotify on close..." ) );
#endif
		}
		EnterCriticalSec( &globalNetworkData.csNetwork );
#ifdef LOG_DEBUG_CLOSING
		lprintf( WIDE( "Adding current client to closed clients." ) );
#endif
		AddClosed( GrabClient( lpClient ) );
#ifdef LOG_DEBUG_CLOSING
		lprintf( WIDE( "Leaving client critical section" ) );
#endif
		//lprintf( WIDE( "Leaving network critical section" ) );
		LeaveCriticalSec( &globalNetworkData.csNetwork );
		NetworkUnlockEx( lpClient, 0 DBG_SRC );
		NetworkUnlockEx( lpClient, 1 DBG_SRC );
	}
#ifdef LOG_DEBUG_CLOSING
	else
	{
		lprintf( WIDE("No Client, or socket already closed?") );
	}
#endif
}
void RemoveClientExx(PCLIENT lpClient, LOGICAL bBlockNotify, LOGICAL bLinger DBG_PASS )
{
#ifdef _WIN32
#  define SHUT_WR SD_SEND
#endif
	if( !lpClient ) return;
#if 0
	if( !( lpClient->dwFlags & CF_UDP ) ) {
		lprintf( "TRIGGER SHUTDOWN WRITES" );
		shutdown( lpClient->Socket, SHUT_WR );
	} else
#endif
	{
		int n = 0;
		// UDP still needs to be done this way...
		//
		InternalRemoveClientExx( lpClient, bBlockNotify, bLinger DBG_RELAY );
		if( NetworkLock( lpClient, 0 ) && ((n=1),NetworkLock( lpClient, 1 )) ) {
			TerminateClosedClient( lpClient );
			NetworkUnlock( lpClient, 0 );
			NetworkUnlock( lpClient, 1 );
		}
		else if( n ) {
			NetworkUnlock( lpClient, 0 );
		}
	}
}
CTEXTSTR GetSystemName( void )
{
	// start the network with defaults... we're able to reallocate later.
#ifdef __ANDROID__
#if 0
	// dont' actually have to start winsock; but we do have to do work to get our IP
	int sock_startup = socket( AF_INET, SOCK_RAW, 0);
	if( sock_startup == -1 )
		sock_startup = socket( AF_INET, SOCK_DGRAM, 0);
	if( sock_startup == -1 )
		sock_startup = socket( AF_INET, SOCK_STREAM, 0);
	if( sock_startup >= 0 )
	{
		struct ifconf buffer;
		struct ifreq ifr[10];
		int ifc_num;
		int n;
		buffer.ifc_len = sizeof(ifr);
		buffer.ifc_ifcu.ifcu_buf = (char*)ifr;
		ioctl( sock_startup, SIOCGIFCONF, &buffer);
		ifc_num = buffer.ifc_len / sizeof(struct ifreq);
#define INT_TO_ADDR(_addr) (_addr & 0xFF), (_addr >> 8 & 0xFF), (_addr >> 16 & 0xFF), (_addr >> 24 & 0xFF)
		for( n = 0; n < ifc_num; n++ )
		{
			int sd, ifc_num, addr, bcast, mask, network;
			lprintf( "interface %d : %s", n, ifr[n].ifr_name );
			if (ifr[n].ifr_addr.sa_family != AF_INET)
			{
				continue;
			}
			/* display the interface name */
			lprintf("%d) interface: %s\n", n+1, ifr[n].ifr_name);
			/* Retrieve the IP address, broadcast address, and subnet mask. */
			if (ioctl(sd, SIOCGIFADDR, &ifr[n]) == 0)
			{
				addr = ((struct sockaddr_in *)(&ifr[n].ifr_addr))->sin_addr.s_addr;
				lprintf("%d) address: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(addr));
			}
			if (ioctl(sd, SIOCGIFBRDADDR, &ifr[n]) == 0)
			{
				bcast = ((struct sockaddr_in *)(&ifr[n].ifr_broadaddr))->sin_addr.s_addr;
				lprintf("%d) broadcast: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(bcast));
			}
			if (ioctl(sd, SIOCGIFNETMASK, &ifr[n]) == 0)
			{
				mask = ((struct sockaddr_in *)(&ifr[n].ifr_netmask))->sin_addr.s_addr;
				lprintf("%d) netmask: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(mask));
			}
			/* Compute the current network value from the address and netmask. */
			network = addr & mask;
			lprintf("%d) network: %d.%d.%d.%d\n", n+1, INT_TO_ADDR(network));
		}
		close( sock_startup );
	}
	else
#endif
		globalNetworkData.system_name = WIDE("No Name Available");
#else
	NetworkStart();
#endif
	return globalNetworkData.system_name;
}
#undef NetworkLock
#undef NetworkUnlock
NETWORK_PROC( PCLIENT, NetworkLock)( PCLIENT lpClient, int readWrite )
{
	return NetworkLockEx( lpClient, readWrite DBG_SRC );
}
NETWORK_PROC( void, NetworkUnlock)( PCLIENT lpClient, int readWrite )
{
	NetworkUnlockEx( lpClient, readWrite DBG_SRC );
}
NETWORK_PROC( void, GetNetworkAddressBinary )( SOCKADDR *addr, uint8_t **data, size_t *datalen ) {
	if( addr ) {
		size_t namelen;
		size_t addrlen = SOCKADDR_LENGTH( addr );
		const char * tmp = ((const char**)addr)[-1];
		if( !( (uintptr_t)tmp & 0xFFFF0000 ) )
		{
			lprintf( WIDE("corrupted sockaddr.") );
			DebugBreak();
		}
		if( tmp )
		{
			namelen = StrLen( tmp );
		}
		else
			namelen = 0;
		(*datalen) = namelen + 1 + 1 + SOCKADDR_LENGTH( addr );
		(*data) = NewArray( uint8_t, (*datalen) );
		MemCpy( (*data), tmp, namelen + 1 );
		(*data)[namelen+1] = (uint8_t)addrlen;
		MemCpy( (*data) + namelen + 1, addr, addrlen );
	}
}
NETWORK_PROC( SOCKADDR *, MakeNetworkAddressFromBinary )( uintptr_t *data, size_t datalen ) {
	SOCKADDR *addr = AllocAddr();
	size_t namelen = strlen( (const char*)data );
 // if empty name, don't include it.
	if( namelen )
		SetAddrName( addr, (const char*)data );
	SET_SOCKADDR_LENGTH( addr, data[1] );
	MemCpy( addr, data + 2, data[1] );
	return addr;
}
#ifdef __LINUX__
void LoadNetworkAddresses( void ) {
	struct ifaddrs *addrs, *tmp;
	struct interfaceAddress *ia;
	getifaddrs( &addrs );
	tmp = addrs;
	ia = New( struct interfaceAddress );
	ia->sa = CreateRemote( "0.0.0.0", 0 );
	ia->saMask = NULL;
	ia->saBroadcast = CreateRemote( "255.255.255.255", 0 );
	AddLink( &globalNetworkData.addresses, ia );
	for( ; tmp; tmp = tmp->ifa_next )
	{
		SOCKADDR *dup;
		if( !tmp->ifa_addr )
			continue;
#  ifndef __MAC__
		if( tmp->ifa_addr && tmp->ifa_addr->sa_family == AF_PACKET )
			continue;
#  endif
		ia = New( struct interfaceAddress );
		dup = AllocAddr();
		if( tmp->ifa_addr->sa_family == AF_INET6 ) {
			continue;
			//memcpy( dup, tmp->ifa_addr, IN6_SOCKADDR_LENGTH );
			//SET_SOCKADDR_LENGTH( dup, IN6_SOCKADDR_LENGTH );
		}
		else {
			memcpy( dup, tmp->ifa_addr, IN_SOCKADDR_LENGTH );
			SET_SOCKADDR_LENGTH( dup, IN_SOCKADDR_LENGTH );
		}
		ia->sa = dup;
		dup = AllocAddr();
		if( tmp->ifa_addr->sa_family == AF_INET6 ) {
			//memcpy( dup, tmp->ifa_netmask, IN6_SOCKADDR_LENGTH );
			//SET_SOCKADDR_LENGTH( dup, IN6_SOCKADDR_LENGTH );
		}
		else {
			if( tmp->ifa_netmask ) {
				memcpy( dup, tmp->ifa_netmask, IN_SOCKADDR_LENGTH );
				SET_SOCKADDR_LENGTH( dup, IN_SOCKADDR_LENGTH );
			} else {
				memset( dup, 0, IN_SOCKADDR_LENGTH );
				SET_SOCKADDR_LENGTH( dup, IN_SOCKADDR_LENGTH );
			}
		}
		ia->saMask = dup;
		ia->saBroadcast = AllocAddr();
		ia->saBroadcast->sa_family = ia->sa->sa_family;
		ia->saBroadcast->sa_data[0] = 0;
		ia->saBroadcast->sa_data[1] = 0;
		ia->saBroadcast->sa_data[2] = (ia->sa->sa_data[2] & ia->saMask->sa_data[2]) | (~ia->saMask->sa_data[2]);
		ia->saBroadcast->sa_data[3] = (ia->sa->sa_data[3] & ia->saMask->sa_data[3]) | (~ia->saMask->sa_data[3]);
		ia->saBroadcast->sa_data[4] = (ia->sa->sa_data[4] & ia->saMask->sa_data[4]) | (~ia->saMask->sa_data[4]);
		ia->saBroadcast->sa_data[5] = (ia->sa->sa_data[5] & ia->saMask->sa_data[5]) | (~ia->saMask->sa_data[5]);
		SET_SOCKADDR_LENGTH( ia->saBroadcast, SOCKADDR_LENGTH( ia->sa ) );
		AddLink( &globalNetworkData.addresses, ia );
	}
	freeifaddrs( addrs );
}
#endif
#ifdef _WIN32
#if 0
#ifdef WIN32
	{
		struct addrinfo *result;
		struct addrinfo *test;
#ifdef _UNICODE
		char *tmp = WcharConvert( globalNetworkData.system_name );
		getaddrinfo( tmp, NULL, NULL, (struct addrinfo**)&result );
		Deallocate( char*, tmp );
#else
		getaddrinfo( globalNetworkData.system_name, NULL, NULL, (struct addrinfo**)&result );
#endif
		for( test = result; test; test = test->ai_next )
		{
			//if( test->ai_family == AF_INET )
			{
				SOCKADDR *tmp;
				AddLink( &globalNetworkData.addresses, tmp = AllocAddr() );
				((uintptr_t*)tmp)[-1] = test->ai_addrlen;
				MemCpy( tmp, test->ai_addr, test->ai_addrlen );
				//lprintf( "initialize addres..." );
				//DumpAddr( "blah", tmp );
			}
		}
	}
#endif
#endif
void LoadNetworkAddresses( void ) {
	// Declare and initialize variables
	PIP_INTERFACE_INFO pInfo;
	pInfo = (IP_INTERFACE_INFO *) malloc( sizeof(IP_INTERFACE_INFO) );
	DWORD dwRetVal = 0;
	PIP_ADAPTER_INFO pAdapterInfo;
	PIP_ADAPTER_INFO pAdapter = NULL;
	ULONG ulOutBufLen = sizeof (IP_ADAPTER_INFO);
	pAdapterInfo = New(IP_ADAPTER_INFO);
	if (pAdapterInfo == NULL) {
		lprintf("Error allocating memory needed to call GetAdaptersinfo\n");
		return;
	}
	// Make an initial call to GetAdaptersInfo to get
	// the necessary size into the ulOutBufLen variable
	if (GetAdaptersInfo(pAdapterInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW) {
		Deallocate( PIP_ADAPTER_INFO, pAdapterInfo);
		pAdapterInfo = (IP_ADAPTER_INFO *) NewArray(uint8_t, ulOutBufLen);
		if (pAdapterInfo == NULL) {
			lprintf("Error allocating memory needed to call GetAdaptersinfo\n");
			return;
		}
	}
	if ((dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen)) == NO_ERROR) {
		pAdapter = pAdapterInfo;
		while (pAdapter) {
			PIP_ADDR_STRING ipadd = &pAdapter->IpAddressList;
			for( ; ipadd; ipadd = ipadd->Next ) {
			/*
			typedef struct _IP_ADDR_STRING {
			  struct _IP_ADDR_STRING  *Next;
			  IP_ADDRESS_STRING      IpAddress;
			  IP_MASK_STRING         IpMask;
			  DWORD                  Context;
			} IP_ADDR_STRING, *PIP_ADDR_STRING;
			*/
				if( StrCmp( ipadd->IpAddress.String, "0.0.0.0" ) == 0 )
					continue;
				struct interfaceAddress *ia = New( struct interfaceAddress );
				ia->sa = CreateRemote( ipadd->IpAddress.String, 0 );
				ia->saMask = CreateRemote( ipadd->IpMask.String, 0 );
				ia->saBroadcast = AllocAddr();
				ia->saBroadcast->sa_family = ia->sa->sa_family;
				ia->saBroadcast->sa_data[0] = 0;
				ia->saBroadcast->sa_data[1] = 0;
				ia->saBroadcast->sa_data[2] = (ia->sa->sa_data[2] & ia->saMask->sa_data[2]) | (~ia->saMask->sa_data[2]);
				ia->saBroadcast->sa_data[3] = (ia->sa->sa_data[3] & ia->saMask->sa_data[3]) | (~ia->saMask->sa_data[3]);
				ia->saBroadcast->sa_data[4] = (ia->sa->sa_data[4] & ia->saMask->sa_data[4]) | (~ia->saMask->sa_data[4]);
				ia->saBroadcast->sa_data[5] = (ia->sa->sa_data[5] & ia->saMask->sa_data[5]) | (~ia->saMask->sa_data[5]);
				AddLink( &globalNetworkData.addresses, ia );
			}
			pAdapter = pAdapter->Next;
		}
	}
	else {
		lprintf( "GetAdaptersInfo failed with error: %d\n", dwRetVal );
	}
#if 0
//msdn.microsoft.com/en-us/library/windows/desktop/aa365915%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396
https:
    PIP_ADAPTER_ADDRESSES pAddresses = NULL;
    ULONG outBufLen = 0;
    ULONG Iterations = 0;
    PIP_ADAPTER_ADDRESSES pCurrAddresses = NULL;
    PIP_ADAPTER_UNICAST_ADDRESS pUnicast = NULL;
    PIP_ADAPTER_ANYCAST_ADDRESS pAnycast = NULL;
    PIP_ADAPTER_MULTICAST_ADDRESS pMulticast = NULL;
    IP_ADAPTER_DNS_SERVER_ADDRESS *pDnServer = NULL;
    IP_ADAPTER_PREFIX *pPrefix = NULL;
  do {
        pAddresses = (IP_ADAPTER_ADDRESSES *) MALLOC(outBufLen);
        if (pAddresses == NULL) {
            printf
                ("Memory allocation failed for IP_ADAPTER_ADDRESSES struct\n");
            exit(1);
        }
        dwRetVal =
            GetAdaptersAddresses(AF_UNSPEC
		, GAA_FLAG_SKIP_DNS_SERVER|GAA_FLAG_SKIP_FRIENDLY_NAME|GAA_FLAG_INCLUDE_ALL_INTERFACES
		, NULL, pAddresses, &outBufLen);
        if (dwRetVal == ERROR_BUFFER_OVERFLOW) {
            FREE(pAddresses);
            pAddresses = NULL;
        } else {
            break;
        }
        Iterations++;
    } while ((dwRetVal == ERROR_BUFFER_OVERFLOW) && (Iterations < MAX_TRIES));
#endif
}
#endif
SACK_NETWORK_NAMESPACE_END
// DEBUG FALGS in netstruc.h
//TODO: after the connect and just before the call to the connect callback fill in the PCLIENT's MAC addr field.
//TODO: After the accept, put in this code:
/*
NETWORK_PROC( int, GetMacAddress)(CTEXTSTR device, CTEXTSTR buffer )//int get_mac_addr (char *device, unsigned char *buffer)
{
int fd;
struct ifreq ifr;
fd = socket(PF_UNIX, SOCK_DGRAM, 0);
if (fd == -1)
{
perr ("Unable to create socket for device: %s", device);
return -1;
}
strcpy (ifr.ifr_name, device);
if (ioctl (fd, SIOCGIFFLAGS, &ifr) < 0)
{
close (fd);
return -1;
}
if (ioctl (fd, SIOCGIFHWADDR, &ifr) < 0)
{
close (fd);
return -1;
}
close (fd);
memcpy (buffer, ifr.ifr_hwaddr.sa_data, 6);
return 0;
}
*/
//#define DEBUG_SOCK_IO
#define LIBRARY_DEF
#ifndef UNDER_CE
#endif
#ifdef __LINUX__
#ifdef __LINUX__
#undef s_addr
 // IPPROTO_TCP
//#include <linux/in.h>  // IPPROTO_TCP
 // TCP_NODELAY
#include <netinet/tcp.h>
//#include <linux/tcp.h> // TCP_NODELAY
#else
#endif
 // SIGHUP defined
#define NetWakeSignal SIGHUP
#else
#define ioctl ioctlsocket
#endif
//#define NO_LOGGING // force neverlog....
SACK_NETWORK_NAMESPACE
	extern int CPROC ProcessNetworkMessages( struct peer_thread_info *thread, uintptr_t quick_check );
_TCP_NAMESPACE
//----------------------------------------------------------------------------
LOGICAL TCPDrainRead( PCLIENT pClient );
//----------------------------------------------------------------------------
void AcceptClient(PCLIENT pListen)
{
#ifdef __LINUX__
	socklen_t
#else
		int
#endif
		nTemp;
// just to be safe.
	PCLIENT pNewClient = NULL;
	pNewClient = GetFreeNetworkClient();
	// new client will be locked...
	if( !pNewClient )
	{
		SOCKADDR *junk = AllocAddr();
		nTemp = MAGIC_SOCKADDR_LENGTH;
		lprintf(WIDE( "GetFreeNetwork() returned NULL. Exiting AcceptClient, accept and drop connection" ));
		closesocket( accept( pListen->Socket, junk ,&nTemp	));
		ReleaseAddress( junk );
		return;
	}
	// without setting this value - the pointer to the value
	// contains a value which may be less than a valid address
	// length... usually didn't JAB: 980203
	nTemp = MAGIC_SOCKADDR_LENGTH;
	pNewClient->saClient = AllocAddr();
	pNewClient->flags.bSecure = pListen->flags.bSecure;
	pNewClient->flags.bAllowDowngrade = pListen->flags.bAllowDowngrade;
	pNewClient->Socket = accept( pListen->Socket
										, pNewClient->saClient
										,&nTemp
										);
	//lprintf( "Accept new client....%d", pNewClient->Socket );
#if WIN32
	SetHandleInformation( (HANDLE)pNewClient->Socket, HANDLE_FLAG_INHERIT, 0 );
#endif
#ifdef LOG_SOCKET_CREATION
	lprintf( WIDE("Accepted socket %p %d  (%d)"), pNewClient, pNewClient->Socket, nTemp );
#endif
	//DumpAddr( WIDE("Client's Address"), pNewClient->saClient );
	{
#ifdef __LINUX__
		socklen_t
#else
			int
#endif
			nLen = MAGIC_SOCKADDR_LENGTH;
		if( !pNewClient->saSource )
			pNewClient->saSource = AllocAddr();
		if( getsockname( pNewClient->Socket, pNewClient->saSource, &nLen ) )
		{
			lprintf( WIDE("getsockname errno = %d"), errno );
		}
		//lprintf( "sockaddrlen: %d", nLen );
		if( pNewClient->saSource->sa_family == AF_INET )
			SET_SOCKADDR_LENGTH( pNewClient->saSource, IN_SOCKADDR_LENGTH );
		else if( pNewClient->saSource->sa_family == AF_INET6 )
			SET_SOCKADDR_LENGTH( pNewClient->saSource, IN6_SOCKADDR_LENGTH );
		else
			SET_SOCKADDR_LENGTH( pNewClient->saSource, nLen );
	}
	pNewClient->read.ReadComplete = pListen->read.ReadComplete;
	pNewClient->psvRead = pListen->psvRead;
	pNewClient->close.CloseCallback     = pListen->close.CloseCallback;
	pNewClient->psvClose = pListen->psvClose;
	pNewClient->write.WriteComplete     = pListen->write.WriteComplete;
	pNewClient->psvWrite = pListen->psvWrite;
	pNewClient->dwFlags |= CF_CONNECTED | ( pListen->dwFlags & CF_CALLBACKTYPES );
	if( IsValid(pNewClient->Socket) )
 // and we get one from the accept...
	{
#ifdef _WIN32
#  ifdef USE_WSA_EVENTS
		pNewClient->event = WSACreateEvent();
#ifdef LOG_NETWORK_EVENT_THREAD
		lprintf( "New event on accepted %p", pNewClient->event );
#endif
		WSAEventSelect( pNewClient->Socket, pNewClient->event,
			FD_READ|FD_WRITE|FD_CLOSE );
#  else
		if( WSAAsyncSelect( pNewClient->Socket,globalNetworkData.ghWndNetwork, SOCKMSG_TCP
		                  , FD_READ | FD_WRITE | FD_CLOSE))
 // if there was a select error...
		{
			lprintf(WIDE( " Accept select Error" ));
			InternalRemoveClientEx( pNewClient, TRUE, FALSE );
			NetworkUnlockEx( pNewClient, 0 DBG_SRC );
			NetworkUnlockEx( pNewClient, 1 DBG_SRC );
			pNewClient = NULL;
		}
		else
#  endif
#else
		// yes this is an ugly transition from the above dangling
		// else...
			fcntl( pNewClient->Socket, F_SETFL, O_NONBLOCK );
#endif
		AddActive( pNewClient );
		{
			//lprintf( WIDE("Accepted and notifying...") );
			if( pListen->connect.ClientConnected )
			{
				if( pListen->dwFlags & CF_CPPCONNECT )
					pListen->connect.CPPClientConnected( pListen->psvConnect, pNewClient );
				else
					pListen->connect.ClientConnected( pListen, pNewClient );
			}
			// signal initial read.
			//lprintf(" Initial notifications...");
 // may be... at least we can fail sooner...
			pNewClient->dwFlags |= CF_READREADY;
			if( pNewClient->read.ReadComplete )
			{
				if( pListen->dwFlags & CF_CPPREAD )
  // process read to get data already pending...
					pNewClient->read.CPPReadComplete( pNewClient->psvRead, NULL, 0 );
				else
  // process read to get data already pending...
					pNewClient->read.ReadComplete( pNewClient, NULL, 0 );
			}
			if( pNewClient->write.WriteComplete  &&
				!pNewClient->bWriteComplete )
			{
				pNewClient->bWriteComplete = TRUE;
				if( pNewClient->dwFlags & CF_CPPWRITE )
					pNewClient->write.CPPWriteComplete( pNewClient->psvWrite );
				else
					pNewClient->write.WriteComplete( pNewClient );
				pNewClient->bWriteComplete = FALSE;
			}
			//lprintf( "Is it already closed HERE????");
			if( pNewClient->Socket ) {
#ifdef USE_WSA_EVENTS
				if( globalNetworkData.flags.bLogNotices )
					lprintf( WIDE( "SET GLOBAL EVENT (accepted socket added)  %p  %p" ), pNewClient, pNewClient->event );
				EnqueLink( &globalNetworkData.client_schedule, pNewClient );
				WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
#ifdef __LINUX__
				AddThreadEvent( pNewClient, 0 );
#endif
			}
			NetworkUnlockEx( pNewClient, 0 DBG_SRC );
			NetworkUnlockEx( pNewClient, 1 DBG_SRC );
		}
	}
 // accept failed...
	else
	{
		InternalRemoveClientEx( pNewClient, TRUE, FALSE );
		NetworkUnlockEx( pNewClient, 0 DBG_SRC );
		NetworkUnlockEx( pNewClient, 1 DBG_SRC );
		pNewClient = NULL;
	}
	if( !pNewClient )
	{
		lprintf(WIDE( "Failed Accept..." ));
	}
}
//----------------------------------------------------------------------------
PCLIENT CPPOpenTCPListenerAddrExx( SOCKADDR *pAddr
                                 , cppNotifyCallback NotifyCallback
                                 , uintptr_t psvConnect
                                 DBG_PASS )
{
	PCLIENT pListen;
	if( !pAddr )
		return NULL;
	pListen = GetFreeNetworkClient();
	if( !pListen )
	{
		lprintf( WIDE("Network has not been started.") );
		return NULL;
	}
	//	pListen->Socket = socket( *(uint16_t*)pAddr, SOCK_STREAM, 0 );
#ifdef WIN32
	pListen->Socket = OpenSocket( ((*(uint16_t*)pAddr) == AF_INET)?TRUE:FALSE, TRUE, FALSE, 0 );
	if( pListen->Socket == INVALID_SOCKET )
#endif
#ifdef __MAC__
		pListen->Socket = socket( ((uint8_t*)pAddr)[1]
										, SOCK_STREAM
										, ((((uint8_t*)pAddr)[1] == AF_INET)||((((uint8_t*)pAddr)[1]) == AF_INET6))?IPPROTO_TCP:0 );
#else
		pListen->Socket = socket( *(uint16_t*)pAddr
										, SOCK_STREAM
										, (((*(uint16_t*)pAddr) == AF_INET)||((*(uint16_t*)pAddr) == AF_INET6))?IPPROTO_TCP:0 );
#endif
#if WIN32
	SetHandleInformation( (HANDLE)pListen->Socket, HANDLE_FLAG_INHERIT, 0 );
#endif
#ifdef LOG_SOCKET_CREATION
	lprintf( WIDE( "Created new socket %d" ), pListen->Socket );
#endif
 // make sure this flag is clear!
	pListen->dwFlags &= ~CF_UDP;
	pListen->dwFlags |= CF_LISTEN;
	if( pListen->Socket == INVALID_SOCKET )
	{
		lprintf( WIDE(" Open Listen Socket Fail... %d"), errno);
		DumpAddr( "passed address to select:", pAddr );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		pListen = NULL;
		return NULL;
	}
#ifdef _WIN32
#  ifdef USE_WSA_EVENTS
	pListen->event = WSACreateEvent();
	WSAEventSelect( pListen->Socket, pListen->event, FD_ACCEPT|FD_CLOSE );
#  else
	if( WSAAsyncSelect( pListen->Socket, globalNetworkData.ghWndNetwork,
                       SOCKMSG_TCP, FD_ACCEPT|FD_CLOSE ) )
	{
		lprintf( WIDE("Windows AsynchSelect failed: %d"), WSAGetLastError() );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		return NULL;
	}
#  endif
	{
		int t = FALSE;
		setsockopt( pListen->Socket, IPPROTO_IPV6, IPV6_V6ONLY, (const char *)&t, 4 );
	}
#else
	{
		int t = TRUE;
		setsockopt( pListen->Socket, SOL_SOCKET, SO_REUSEADDR, &t, 4 );
		t = TRUE;
		fcntl( pListen->Socket, F_SETFL, O_NONBLOCK );
	}
#endif
#ifndef _WIN32
	if( pAddr->sa_family==AF_UNIX )
		unlink( (char*)(((uint16_t*)pAddr)+1));
#endif
	if (!pAddr ||
		 bind(pListen->Socket ,pAddr, SOCKADDR_LENGTH( pAddr ) ) )
	{
		_lprintf(DBG_RELAY)( WIDE("Cannot bind to address..:%d"), WSAGetLastError() );
		DumpAddr( "Bind address:", pAddr );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		return NULL;
	}
	pListen->saSource = DuplicateAddress( pAddr );
	if(listen(pListen->Socket, SOMAXCONN ) == SOCKET_ERROR )
	{
		lprintf( WIDE("listen(5) failed: %d"), WSAGetLastError() );
		InternalRemoveClientEx( pListen, TRUE, FALSE );
		NetworkUnlockEx( pListen, 0 DBG_SRC );
		NetworkUnlockEx( pListen, 1 DBG_SRC );
		return NULL;
	}
	pListen->connect.CPPClientConnected = NotifyCallback;
	pListen->psvConnect = psvConnect;
	pListen->dwFlags |= CF_CPPCONNECT;
	NetworkUnlockEx( pListen, 0 DBG_SRC );
	NetworkUnlockEx( pListen, 1 DBG_SRC );
	AddActive( pListen );
   // make sure to schedule this socket for events (connect)
#ifdef USE_WSA_EVENTS
	if( globalNetworkData.flags.bLogNotices )
		lprintf( WIDE( "SET GLOBAL EVENT (listener added)" ) );
	EnqueLink( &globalNetworkData.client_schedule, pListen );
	WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
#ifdef __LINUX__
	AddThreadEvent( pListen, 0 );
#endif
	return pListen;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPListenerAddrExx( SOCKADDR *pAddr
                              , cNotifyCallback NotifyCallback DBG_PASS )
{
	PCLIENT result = CPPOpenTCPListenerAddrExx( pAddr, (cppNotifyCallback)NotifyCallback, 0 DBG_RELAY );
	if( result )
		result->dwFlags &= ~CF_CPPCONNECT;
	return result;
}
//----------------------------------------------------------------------------
PCLIENT CPPOpenTCPListenerExx( uint16_t wPort
                             , cppNotifyCallback NotifyCallback
                             , uintptr_t psvConnect
                             DBG_PASS
                             )
{
	SOCKADDR *lpMyAddr = CreateLocal(wPort);
	PCLIENT pc = CPPOpenTCPListenerAddrExx( lpMyAddr, NotifyCallback, psvConnect DBG_RELAY );
	ReleaseAddress( lpMyAddr );
	if( pc )
	{
		// have to have the base one open or pcOther cannot be set.
		lpMyAddr = CreateSockAddress( WIDE(":::"), wPort );
		pc->pcOther = CPPOpenTCPListenerAddrExx( lpMyAddr, NotifyCallback, psvConnect DBG_RELAY );
		ReleaseAddress( lpMyAddr );
	}
	return pc;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPListenerExx(uint16_t wPort, cNotifyCallback NotifyCallback DBG_PASS )
{
	PCLIENT result = CPPOpenTCPListenerExx( wPort, (cppNotifyCallback)NotifyCallback, 0 DBG_RELAY );
	if( result )
		result->dwFlags &= ~CF_CPPCONNECT;
	return result;
}
//----------------------------------------------------------------------------
int NetworkConnectTCPEx( PCLIENT pc DBG_PASS ) {
	int err;
	while( !NetworkLockEx( pc, 0 DBG_SRC ) )
	{
		if( !(pc->dwFlags & CF_ACTIVE) )
		{
			return -1;
		}
		Relinquish();
	}
	pc->dwFlags |= CF_CONNECTING;
	//DumpAddr( WIDE("Connect to"), &pResult->saClient );
	if( (err = connect( pc->Socket, pc->saClient
		, SOCKADDR_LENGTH( pc->saClient ) )) )
	{
		uint32_t dwError;
		dwError = WSAGetLastError();
		if( dwError != WSAEWOULDBLOCK
#ifdef __LINUX__
			&& dwError != EINPROGRESS
#else
			&& dwError != WSAEINPROGRESS
#endif
			)
		{
			_lprintf( DBG_RELAY )(WIDE( "Connect FAIL: %d %d %" ) _32f, pc->Socket, err, dwError);
			InternalRemoveClientEx( pc, TRUE, FALSE );
			NetworkUnlockEx( pc, 0 DBG_SRC );
			pc = NULL;
			return -1;
		}
		else
		{
			//lprintf( WIDE("Pending connect has begun...") );
		}
	}
	else
	{
#ifdef VERBOSE_DEBUG
		lprintf( WIDE( "Connected before we even get a chance to wait" ) );
#endif
	}
	NetworkUnlockEx( pc, 0 DBG_SRC );
	return 0;
}
//----------------------------------------------------------------------------
static PCLIENT InternalTCPClientAddrFromAddrExxx( SOCKADDR *lpAddr, SOCKADDR *pFromAddr,
                                                  int bCPP,
                                                  cppReadComplete  pReadComplete,
                                                  uintptr_t psvRead,
                                                  cppCloseCallback CloseCallback,
                                                  uintptr_t psvClose,
                                                  cppWriteComplete WriteComplete,
                                                  uintptr_t psvWrite,
                                                  cppConnectCallback pConnectComplete,
                                                  uintptr_t psvConnect,
                                                  int flags
                                                  DBG_PASS
                                                )
{
	// Server's Port and Name.
	PCLIENT pResult;
	if( !lpAddr )
		return NULL;
	pResult = GetFreeNetworkClient();
	if( pResult )
	{
		struct peer_thread_info *this_thread = IsNetworkThread();
		// use the sockaddr to switch what type of socket this is.
#ifdef WIN32
		pResult->Socket = OpenSocket( ((*(uint16_t*)lpAddr) == AF_INET)?TRUE:FALSE, TRUE, FALSE, 0 );
		if( pResult->Socket == INVALID_SOCKET )
#endif
#ifdef __MAC__
			pResult->Socket=socket( ((uint8_t*)lpAddr)[1]
			                      , SOCK_STREAM
			                      , (((((uint8_t*)lpAddr)[1]) == AF_INET)||((((uint8_t*)lpAddr)[1]) == AF_INET6))?IPPROTO_TCP:0 );
#else
			pResult->Socket=socket( *(uint16_t*)lpAddr
			                      , SOCK_STREAM
			                      , (((*(uint16_t*)lpAddr) == AF_INET)||((*(uint16_t*)lpAddr) == AF_INET6))?IPPROTO_TCP:0 );
#endif
#ifdef LOG_SOCKET_CREATION
		lprintf( WIDE( "Created new socket %d" ), pResult->Socket );
#endif
		if (pResult->Socket==INVALID_SOCKET)
		{
			lprintf( WIDE("Create socket failed. %d"), WSAGetLastError() );
			InternalRemoveClientEx( pResult, TRUE, FALSE );
			NetworkUnlockEx( pResult, 1 DBG_SRC );
			NetworkUnlockEx( pResult, 0 DBG_SRC );
			return NULL;
		}
		else
		{
			int err;
#ifdef _WIN32
			if( 0 )
			{
				DWORD dwFlags;
				GetHandleInformation( (HANDLE)pResult->Socket, &dwFlags );
				lprintf( WIDE( "Natural was %d" ), dwFlags );
			}
			SetHandleInformation( (HANDLE)pResult->Socket, HANDLE_FLAG_INHERIT, 0 );
#  ifdef USE_WSA_EVENTS
			pResult->event = WSACreateEvent();
#    ifdef LOG_NETWORK_EVENT_THREAD
			lprintf( "new event is %p", pResult->event );
#    endif
			WSAEventSelect( pResult->Socket, pResult->event, FD_READ|FD_WRITE|FD_CONNECT|FD_CLOSE );
#  else
			if( WSAAsyncSelect( pResult->Socket,globalNetworkData.ghWndNetwork,SOCKMSG_TCP
			                  , FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT) )
			{
				lprintf( WIDE(" Select NewClient Fail! %d"), WSAGetLastError() );
				InternalRemoveClientEx( pResult, TRUE, FALSE );
				NetworkUnlockEx( pResult, 1 DBG_SRC );
				NetworkUnlockEx( pResult, 0 DBG_SRC );
				pResult = NULL;
				goto LeaveNow;
			}
#  endif
#else
			fcntl( pResult->Socket, F_SETFL, O_NONBLOCK );
#endif
			if( pFromAddr )
			{
				LOGICAL opt = 1;
				err = setsockopt( pResult->Socket, SOL_SOCKET, SO_REUSEADDR, (const char *)&opt, sizeof( opt ) );
				if( err )
				{
					uint32_t dwError = WSAGetLastError();
					lprintf( WIDE("Failed to set socket option REUSEADDR : %d"), dwError );
				}
				pResult->saSource = DuplicateAddress( pFromAddr );
				//DumpAddr( "source", pResult->saSource );
				if( ( err = bind( pResult->Socket, pResult->saSource
				                , SOCKADDR_LENGTH( pResult->saSource ) ) ) )
				{
					uint32_t dwError;
					dwError = WSAGetLastError();
					lprintf( WIDE("Error binding connecting socket to source address... continuing with connect : %d"), dwError );
				}
			}
			pResult->saClient = DuplicateAddress( lpAddr );
			// set up callbacks before asynch select...
			pResult->connect.CPPThisConnected  = pConnectComplete;
			pResult->psvConnect                = psvConnect;
			pResult->read.CPPReadComplete      = pReadComplete;
			pResult->psvRead                   = psvRead;
			pResult->close.CPPCloseCallback    = CloseCallback;
			pResult->psvClose                  = psvClose;
			pResult->write.CPPWriteComplete    = WriteComplete;
			pResult->psvWrite                  = psvWrite;
			if( bCPP )
				pResult->dwFlags |= ( CF_CALLBACKTYPES );
			AddActive( pResult );
			if( !(flags & OPEN_TCP_FLAG_DELAY_CONNECT) ) {
				NetworkConnectTCPEx( pResult DBG_RELAY );
			}
			//lprintf( WIDE("Leaving Client's critical section") );
			NetworkUnlockEx( pResult, 1 DBG_SRC );
			NetworkUnlockEx( pResult, 0 DBG_SRC );
			// socket should now get scheduled for events, after unlocking it?
#ifdef USE_WSA_EVENTS
			if( globalNetworkData.flags.bLogNotices )
				lprintf( WIDE( "SET GLOBAL EVENT (wait for connect) new %p %p  %08x %p" ), pResult, pResult->event, pResult->dwFlags, globalNetworkData.hMonitorThreadControlEvent );
			EnqueLink( &globalNetworkData.client_schedule, pResult );
			if( this_thread == globalNetworkData.root_thread ) {
				ProcessNetworkMessages( this_thread, 1 );
				if( !pResult->this_thread ) {
					WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
					//lprintf( "Failed to schedule myself in a single run of root thread that I am running on." );
				}
			}
			else {
				WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
				while( !pResult->this_thread )
 // wait for it to be added to waiting lists?
					Relinquish();
			}
#endif
#ifdef __LINUX__
			AddThreadEvent( pResult, 0 );
#endif
			if( !pConnectComplete && !(flags & OPEN_TCP_FLAG_DELAY_CONNECT) )
			{
				int Start, bProcessing = 0;
				// should trigger a rebuild (if it's the root thread)
				Start = (GetTickCount()&0xFFFFFFF);
				pResult->dwFlags |= CF_CONNECT_WAITING;
				// caller was expecting connect to block....
				while( !( pResult->dwFlags & (CF_CONNECTED|CF_CONNECTERROR|CF_CONNECT_CLOSED) ) &&
						( ( (GetTickCount()&0xFFFFFFF) - Start ) < globalNetworkData.dwConnectTimeout ) )
				{
					// may be this thread itself which connects...
					if( this_thread )
					{
						if( !bProcessing )
						{
							if( ProcessNetworkMessages( this_thread, 0 ) >= 0 )
								bProcessing = 1;
							else
								bProcessing = 2;
						}
						else
						{
							if( bProcessing >= 0 )
								ProcessNetworkMessages( this_thread, 0 );
						}
					}
					else
					{
						// isn't a network thread; so wait as an external thread
						bProcessing = 2;
					}
					if( bProcessing == 2 )
					{
						pResult->pWaiting = MakeThread();
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "Falling asleep 3 seconds waiting for connect on %p." ), pResult );
						pResult->tcp_delay_count++;
						WakeableSleep( 3000 );
						pResult->pWaiting = NULL;
						if( pResult->dwFlags & CF_CLOSING )
							return NULL;
					}
					else
					{
						lprintf( WIDE( "Spin wait for connect" ) );
						Relinquish();
					}
				}
				if( (( (GetTickCount()&0xFFFFFFF) - Start ) >= 10000)
					|| (pResult->dwFlags &  CF_CONNECTERROR ) )
				{
					if( pResult->dwFlags &  CF_CONNECTERROR )
					{
						//DumpAddr( WIDE("Connect to: "), lpAddr );
						//lprintf( WIDE("Connect FAIL: message result") );
					}
					else
						lprintf( WIDE("Connect FAIL: Timeout") );
					InternalRemoveClientEx( pResult, TRUE, FALSE );
					pResult->dwFlags &= ~CF_CONNECT_WAITING;
					pResult = NULL;
					goto LeaveNow;
				}
				{
			#ifdef __LINUX__
					socklen_t
			#else
						int
			#endif
						nLen = MAGIC_SOCKADDR_LENGTH;
					if( !pResult->saSource )
						pResult->saSource = AllocAddr();
					if( getsockname( pResult->Socket, pResult->saSource, &nLen ) )
					{
						lprintf( WIDE("getsockname errno = %d"), errno );
					}
				}
				//lprintf( WIDE("Connect did complete... returning to application"));
			}
#ifdef VERBOSE_DEBUG
			else
				lprintf( WIDE("Connect in progress, will notify application when done.") );
#endif
			pResult->dwFlags &= ~CF_CONNECT_WAITING;
		}
	}
LeaveNow:
  // didn't break out of the loop with a good return.
	if( !pResult )
	{
		//lprintf( WIDE("Failed Open TCP Client.") );
	}
	return pResult;
}
//----------------------------------------------------------------------------
NETWORK_PROC( PCLIENT, CPPOpenTCPClientAddrExxx )(SOCKADDR *lpAddr
                                                 , cppReadComplete  pReadComplete
                                                 , uintptr_t psvRead
                                                 , cppCloseCallback CloseCallback
                                                 , uintptr_t psvClose
                                                 , cppWriteComplete WriteComplete
                                                 , uintptr_t psvWrite
                                                 , cppConnectCallback pConnectComplete
                                                 , uintptr_t psvConnect
                                                 , int flags
                                                 DBG_PASS  )
{
	return InternalTCPClientAddrFromAddrExxx( lpAddr, NULL, TRUE
											 , pReadComplete, psvRead
											 , CloseCallback, psvClose
											 , WriteComplete, psvWrite
											 , pConnectComplete, psvConnect, flags DBG_RELAY );
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientAddrExxx( SOCKADDR *lpAddr
                             , cReadComplete     pReadComplete
                             , cCloseCallback    CloseCallback
                             , cWriteComplete    WriteComplete
                             , cConnectCallback  pConnectComplete
                             , int flags
                             DBG_PASS
                             )
{
	return InternalTCPClientAddrFromAddrExxx( lpAddr, NULL, FALSE
											 , (cppReadComplete)pReadComplete, 0
											 , (cppCloseCallback)CloseCallback, 0
											 , (cppWriteComplete)WriteComplete, 0
											 , (cppConnectCallback)pConnectComplete, 0, flags DBG_RELAY );
}
PCLIENT OpenTCPClientAddrFromAddrEx(SOCKADDR *lpAddr, SOCKADDR *pFromAddr
															  , cReadComplete     pReadComplete
															  , cCloseCallback    CloseCallback
															  , cWriteComplete    WriteComplete
															  , cConnectCallback  pConnectComplete
	, int flags
                                               DBG_PASS
															 )
{
	return InternalTCPClientAddrFromAddrExxx( lpAddr, pFromAddr, FALSE
											 , (cppReadComplete)pReadComplete, 0
											 , (cppCloseCallback)CloseCallback, 0
											 , (cppWriteComplete)WriteComplete, 0
											 , (cppConnectCallback)pConnectComplete, 0, flags DBG_RELAY );
}
PCLIENT OpenTCPClientAddrFromEx(SOCKADDR *lpAddr, int port
															  , cReadComplete     pReadComplete															  , cCloseCallback    CloseCallback
															  , cWriteComplete    WriteComplete
															  , cConnectCallback  pConnectComplete
	, int flags
                                               DBG_PASS
															 )
{
	PCLIENT result;
	SOCKADDR *pFromAddr = CreateSockAddress( NULL, port );
	result = InternalTCPClientAddrFromAddrExxx( lpAddr, pFromAddr, FALSE
											 , (cppReadComplete)pReadComplete, 0
											 , (cppCloseCallback)CloseCallback, 0
											 , (cppWriteComplete)WriteComplete, 0
											 , (cppConnectCallback)pConnectComplete, 0, flags DBG_RELAY );
	ReleaseAddress( pFromAddr );
	return result;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientAddrExEx( SOCKADDR *lpAddr
                             , cReadComplete  pReadComplete
                             , cCloseCallback CloseCallback
                             , cWriteComplete WriteComplete
                             DBG_PASS )
{
   return OpenTCPClientAddrExxx( lpAddr, pReadComplete, CloseCallback, WriteComplete, NULL, 0 DBG_RELAY );
}
//----------------------------------------------------------------------------
PCLIENT CPPOpenTCPClientExEx(CTEXTSTR lpName,uint16_t wPort,
             cppReadComplete	 pReadComplete, uintptr_t psvRead,
             cppCloseCallback CloseCallback, uintptr_t psvClose,
             cppWriteComplete WriteComplete, uintptr_t psvWrite,
             cppConnectCallback pConnectComplete, uintptr_t psvConnect, int flags DBG_PASS )
{
	PCLIENT pClient;
	SOCKADDR *lpsaDest;
	pClient = NULL;
	if( lpName &&
	   (lpsaDest = CreateSockAddress(lpName,wPort) ) )
	{
		pClient = CPPOpenTCPClientAddrExxx( lpsaDest
		                                  , pReadComplete
		                                  , psvRead
		                                  , CloseCallback
		                                  , psvClose
		                                  , WriteComplete
		                                  , psvWrite
		                                  , pConnectComplete
		                                  , psvConnect
		                                  , flags
		                                    DBG_RELAY
		                                  );
		ReleaseAddress( lpsaDest );
	}
	return pClient;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientExxx(CTEXTSTR lpName,uint16_t wPort,
             cReadComplete  pReadComplete,
             cCloseCallback CloseCallback,
             cWriteComplete WriteComplete,
             cConnectCallback pConnectComplete,
             int flags
             DBG_PASS )
{
	PCLIENT pClient;
	SOCKADDR *lpsaDest;
	pClient = NULL;
	if( lpName &&
		(lpsaDest = CreateSockAddress(lpName,wPort) ) )
	{
		pClient = OpenTCPClientAddrExxx( lpsaDest
		                               , pReadComplete
		                               , CloseCallback
		                               , WriteComplete
		                               , pConnectComplete
		                               , flags DBG_RELAY );
		ReleaseAddress( lpsaDest );
	}
	return pClient;
}
//----------------------------------------------------------------------------
PCLIENT OpenTCPClientExEx(CTEXTSTR lpName,uint16_t wPort,
                          cReadComplete	 pReadComplete,
                          cCloseCallback CloseCallback,
                          cWriteComplete WriteComplete
                          DBG_PASS )
{
	return OpenTCPClientExxx( lpName, wPort, pReadComplete, CloseCallback, WriteComplete, NULL, 0 DBG_RELAY );
}
//----------------------------------------------------------------------------
  // only time this should be called is when there IS, cause
int FinishPendingRead(PCLIENT lpClient DBG_PASS )
                                 // we definaly have already gotten SOME data to leave in
                                 // a pending state...
{
	int nRecv;
#ifdef VERBOSE_DEBUG
	int nCount;
#endif
	uint32_t dwError;
	// returns amount of information left to get.
#ifdef VERBOSE_DEBUG
	nCount = 0;
#endif
	if( !( lpClient->dwFlags & CF_READPENDING ) )
	{
		//lpClient->dwFlags |= CF_READREADY; // read ready is set if FinishPendingRead returns 0; and it's from the core read...
		//lprintf( WIDE( "Finish pending - return, no pending read. %08x" ), lpClient->dwFlags );
	}
	do
	{
		if( lpClient->bDraining )
		{
			lprintf(WIDE( "LOG:ERROR trying to read during a drain state..." ) );
 // why error on draining with pending finish??
			return -1;
		}
		if( !(lpClient->dwFlags & CF_CONNECTED)  )
		{
#ifdef DEBUG_SOCK_IO
			lprintf( WIDE( "Finsih pending - return, not connected." ) );
#endif
 // amount of data available...
			return (int)lpClient->RecvPending.dwUsed;
		}
		//lprintf( WIDE(WIDE( "FinishPendingRead of %d" )), lpClient->RecvPending.dwAvail );
		if( !( lpClient->dwFlags & CF_READPENDING ) )
		{
			//lpClient->dwFlags |= CF_READREADY; // read ready is set if FinishPendingRead returns 0; and it's from the core read...
#ifdef DEBUG_SOCK_IO
			lprintf( WIDE( "Finish pending - return, no pending read. %08x" ), lpClient->dwFlags );
#endif
			// without a pending read, don't read, the buffers are not correct.
			return 0;
		}
  // if any room is availiable.
		while( lpClient->RecvPending.dwAvail )
		{
#ifdef DEBUG_SOCK_IO
			//nCount++;
			_lprintf( DBG_RELAY )( WIDE("FinishPendingRead %p %d %d" ), lpClient
				, lpClient->RecvPending.dwUsed, lpClient->RecvPending.dwAvail );
#endif
			nRecv = recv(lpClient->Socket,
							 (char*)lpClient->RecvPending.buffer.p +
							 lpClient->RecvPending.dwUsed,
							 (int)lpClient->RecvPending.dwAvail,0);
			 dwError = WSAGetLastError();
			//lprintf( "Network receive %d %d %d", nRecv, lpClient->RecvPending.dwUsed, lpClient->RecvPending.dwAvail );
			if (nRecv == SOCKET_ERROR)
			{
#ifdef DEBUG_SOCK_IO
				lprintf( "Received error (-1) %d", nRecv );
#endif
				switch( dwError)
				{
 // no data avail yet...
				case WSAEWOULDBLOCK:
					//lprintf( WIDE("Pending Receive would block...") );
					lpClient->dwFlags &= ~CF_READREADY;
					return (int)lpClient->RecvPending.dwUsed;
#ifdef __LINUX__
				case ECONNRESET:
#else
				case WSAECONNRESET:
				case WSAECONNABORTED:
#endif
#ifdef LOG_DEBUG_CLOSING
					lprintf( WIDE("Read from reset connection - closing. %p"), lpClient );
#endif
					if(0)
					{
					default:
						Log5( WIDE("Failed reading from %d (err:%d) into %p %") _size_f WIDE(" bytes %") _size_f WIDE(" read already."),
							  lpClient->Socket,
							  WSAGetLastError(),
							  lpClient->RecvPending.buffer.p,
							  lpClient->RecvPending.dwAvail,
							  lpClient->RecvPending.dwUsed );
						lprintf(WIDE("LOG:ERROR FinishPending discovered unhandled error (closing connection) %") _32f WIDE(""), dwError );
					}
					//InternalRemoveClient( lpClient );  // invalid channel now.
					lpClient->dwFlags |= CF_TOCLOSE;
   // return pending finished...
					return -1;
				}
			}
 // channel closed if received 0 bytes...
			else if (!nRecv)
   // otherwise WSAEWOULDBLOCK would be generated.
			{
#ifdef DEBUG_SOCK_IO
				lprintf( "Received (0) %d", nRecv );
#endif
				WakeableSleep( 100 );
				//_lprintf( DBG_RELAY )( WIDE("Closing closed socket... Hope there's also an event... "));
				lpClient->dwFlags |= CF_TOCLOSE;
 // while dwAvail... try read...
				break;
				//return -1;
			}
			else
			{
#ifdef DEBUG_SOCK_IO
				lprintf( "Received %d", nRecv );
#endif
				if( globalNetworkData.flags.bShortLogReceivedData )
				{
					LogBinary( (uint8_t*)lpClient->RecvPending.buffer.p
					         + lpClient->RecvPending.dwUsed,  (nRecv < 64) ? nRecv:64 );
				}
				if( globalNetworkData.flags.bLogReceivedData )
				{
					LogBinary( (uint8_t*)lpClient->RecvPending.buffer.p
					         + lpClient->RecvPending.dwUsed, nRecv );
				}
				if( lpClient->RecvPending.s.bStream )
					lpClient->dwFlags &= ~CF_READREADY;
				lpClient->RecvPending.dwLastRead = nRecv;
				lpClient->RecvPending.dwAvail -= nRecv;
				//lprintf( "Receive pending is now %d after %d", lpClient->RecvPending.dwAvail, nRecv );
				lpClient->RecvPending.dwUsed  += nRecv;
				if( lpClient->RecvPending.s.bStream &&
				    lpClient->RecvPending.dwAvail )
					break;
				//else
				//	lprintf( WIDE("Was not a stream read - try reading more...") );
			}
		}
		// if read notification okay - then do callback.
		if( !( lpClient->dwFlags & CF_READWAITING ) )
		{
#ifdef LOG_PENDING
			//lprintf( WIDE("Waiting on a queued read... result to callback.") );
#endif
 // completed all of the read
			if( ( !lpClient->RecvPending.dwAvail ||
   // or completed some of the read
				  ( lpClient->RecvPending.dwUsed &&
					lpClient->RecvPending.s.bStream ) ) )
			{
#ifdef LOG_PENDING
				//lprintf( WIDE("Sending completed read to application") );
#endif
				lpClient->dwFlags &= ~CF_READPENDING;
  // and there's a read complete callback available
				if( lpClient->read.ReadComplete )
				{
					// need to clear dwUsed...
					// otherwise the on-close notificatino can cause this to dispatch again.
					size_t length = lpClient->RecvPending.dwUsed;
					lpClient->RecvPending.dwUsed = 0;
#ifdef LOG_PENDING
					lprintf( WIDE( "Send to application...." ) );
#endif
					if( lpClient->dwFlags & CF_CPPREAD )
					{
						lpClient->read.CPPReadComplete( lpClient->psvRead
																, lpClient->RecvPending.buffer.p
																, length );
					}
					else
					{
						lpClient->read.ReadComplete( lpClient,
															 lpClient->RecvPending.buffer.p,
															 length );
					}
					if( !lpClient->Socket )
						return -1;
#ifdef LOG_PENDING
 // new read probably pending ehre...
					lprintf( WIDE( "back from applciation... (loop to next)" ) );
#endif
					continue;
				}
			}
			if( !( lpClient->dwFlags & CF_READPENDING ) )
			{
				lprintf( WIDE("somehow we didn't get a good read.") );
			}
		}
		else
		{
#ifdef LOG_PENDING
			lprintf( WIDE("Client is waiting for this data... should we wake him? %d"), lpClient->RecvPending.s.bStream );
#endif
 // completed all of the read
			if( ( !lpClient->RecvPending.dwAvail ||
   // or completed some of the read
				  ( lpClient->RecvPending.dwUsed &&
					lpClient->RecvPending.s.bStream ) ) )
			{
				lprintf( WIDE("Wake waiting thread... clearing pending read flag.") );
				lpClient->dwFlags &= ~CF_READPENDING;
				if( lpClient->pWaiting )
					WakeThread( lpClient->pWaiting );
			}
		}
		if( lpClient->dwFlags & CF_TOCLOSE )
			return -1;
 // returns amount of information which is available NOW.
		return (int)lpClient->RecvPending.dwUsed;
	} while ( 1 );
}
//----------------------------------------------------------------------------
size_t doReadExx2(PCLIENT lpClient,POINTER lpBuffer,size_t nBytes, LOGICAL bIsStream, LOGICAL bWait, int user_timeout DBG_PASS )
{
#ifdef LOG_PENDING
	_lprintf(DBG_RELAY)( WIDE( "Reading ... %p(%d) int %p %d (%s,%s)" ), lpClient, lpClient->Socket, lpBuffer, (uint32_t)nBytes, bIsStream?WIDE( "stream" ):WIDE( "block" ), bWait?WIDE( "Wait" ):WIDE( "NoWait" ) );
#endif
	if( !lpClient || !lpBuffer )
 // nothing read.... ???
		return 0;
	// don't try to read closed/inactive sockets.
	if( !(lpClient->dwFlags & CF_ACTIVE ) )
		return 0;
  //draining....
	if( TCPDrainRead( lpClient ) &&
 // and already queued next read.
		lpClient->RecvPending.dwAvail )
	{
		lprintf(WIDE( "LOG:ERROR is draining, and NEXT pending queued ALSO..." ));
  // read not queued... (ERROR)
		return -1;
	}
 // existing read was not a stream...
	if( !lpClient->RecvPending.s.bStream &&
   // AND is not at completion...
		lpClient->RecvPending.dwAvail )
	{
		lprintf(WIDE("LOG:ERROR was not a stream, and is not complete...%") _32f WIDE(" left "),
			  (uint32_t)lpClient->RecvPending.dwAvail );
 // this I guess is an error since we're queueing another
		return -1;
		// read on top of existing incoming 'guaranteed data'
	}
#ifdef REQUIRE_READ_LOCK
	while( !NetworkLockEx( lpClient, 1 DBG_RELAY ) )
	{
		if( !(lpClient->dwFlags & CF_ACTIVE ) )
		{
			return -1;
		}
		Relinquish();
	}
#endif
	if( !(lpClient->dwFlags & CF_ACTIVE ) )
	{
		// like say the callback we're being invoked from closed it;
		lprintf( WIDE( "inactive client, will not pend read." ) );
#ifdef REQUIRE_READ_LOCK
		NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
		return -1;
	}
	//lprintf( "read %d", nBytes );
   // only worry if there IS data to read.
	if( nBytes )
	{
		// we can assume there is nothing now pending...
		lpClient->RecvPending.buffer.p = lpBuffer;
		//_lprintf(DBG_RELAY)( "Setup read avail: %d", nBytes );
		lpClient->RecvPending.dwAvail = nBytes;
		lpClient->RecvPending.dwUsed = 0;
		lpClient->RecvPending.s.bStream = bIsStream;
		// if the pending finishes it will call the ReadComplete Callback.
		// otherwise there will be more data to read...
		//lprintf( WIDE("Ok ... buffers set up - now we can handle read events") );
#ifdef LOG_PENDING
		lprintf( WIDE( "Setup read pending %08x" ), lpClient->dwFlags );
#endif
		lpClient->dwFlags |= CF_READPENDING;
#ifdef LOG_PENDING
		lprintf( WIDE( "Setup read pending %p %08x" ), lpClient, lpClient->dwFlags );
#endif
		if( bWait )
		{
			//lprintf( WIDE("setting read waiting so we get awoken... and callback dispatch does not happen.") );
			lpClient->dwFlags |= CF_READWAITING;
		}
		//else
		//   lprintf( WIDE("No read waiting... allow forward going...") );
		if( lpClient->dwFlags & CF_READREADY )
		{
#ifdef LOG_PENDING
			lprintf( WIDE("Data already present for read...") );
#endif
			FinishPendingRead( lpClient DBG_SRC );
		}
	}
	else
	{
		lprintf( WIDE( "zero byte read...." ) );
		if( !bWait )
		{
  // and there's a read complete callback available
			if( lpClient->read.ReadComplete )
			{
				lprintf( WIDE( "Read complete with 0 bytes immediate..." ) );
				lpClient->read.ReadComplete( lpClient, lpBuffer, 0 );
			}
		}
		else
		{
			lpClient->dwFlags &= ~CF_READWAITING;
		 }
	}
	if( bWait )
	{
		int this_timeout = user_timeout?user_timeout:globalNetworkData.dwReadTimeout;
		int timeout = 0;
		//lprintf( WIDE("Waiting for TCP data result...") );
		{
			uint32_t tick = timeGetTime();
			lpClient->pWaiting = MakeThread();
#ifdef REQUIRE_READ_LOCK
			NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
			while( lpClient->dwFlags & CF_READPENDING )
			{
				// wait 5 seconds, then bail.
				if( ( tick + this_timeout ) < timeGetTime() )
				{
					//lprintf( "pending has timed out! return now." );
					timeout = 1;
					break;
				}
				if( !Idle() )
				{
					//lprintf( WIDE("Nothing significant to idle on... going to sleep forever.") );
					WakeableSleep( 1000 );
				}
			}
		}
		while( !NetworkLockEx( lpClient, 1 DBG_SRC ) )
		{
			if( !(lpClient->dwFlags & CF_ACTIVE ) )
			{
				return 0;
			}
			Relinquish();
		}
		if( !(lpClient->dwFlags & CF_ACTIVE ) )
		{
#ifdef REQUIRE_READ_LOCK
			NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
			return -1;
		}
		 lpClient->dwFlags &= ~CF_READWAITING;
#ifdef REQUIRE_READ_LOCK
		NetworkUnlockEx( lpClient, 1 DBG_SRC);
#endif
		if( timeout )
			return 0;
		else
			return lpClient->RecvPending.dwUsed;
	}
#ifdef REQUIRE_READ_LOCK
	else
		NetworkUnlockEx( lpClient, 1 DBG_SRC );
#endif
 // unknown result really... success prolly
	return 0;
}
//----------------------------------------------------------------------------
static void PendWrite( PCLIENT pClient
                     , CPOINTER lpBuffer
                     , size_t nLen, int bLongBuffer )
{
	PendingBuffer *lpPend;
#ifdef LOG_PENDING
	{
		lprintf( WIDE("Pending %d Bytes to network...") , nLen );
	}
#endif
	lpPend = New( PendingBuffer );
	//lprintf( "Write pend %d", nLen );
	lpPend->dwAvail = nLen;
	lpPend->dwUsed	= 0;
	lpPend->lpNext	= NULL;
	if( !bLongBuffer )
	{
		 lpPend->s.bDynBuffer = TRUE;
		 lpPend->buffer.p = Allocate( nLen );
		 MemCpy( lpPend->buffer.p, lpBuffer, nLen );
	}
	else
	{
		 lpPend->s.bDynBuffer = FALSE;
		 lpPend->buffer.c = lpBuffer;
	}
	if (pClient->lpLastPending)
		pClient->lpLastPending->lpNext = lpPend;
	else
		pClient->lpFirstPending = lpPend;
	pClient->lpLastPending = lpPend;
}
//----------------------------------------------------------------------------
int TCPWriteEx(PCLIENT pc DBG_PASS)
{
	int nSent;
	PendingBuffer *lpNext;
	if( !pc || !(pc->dwFlags & CF_CONNECTED ) )
		return TRUE;
	while (pc->lpFirstPending)
	{
#ifdef VERBOSE_DEBUG
		if( pc->dwFlags & CF_CONNECTING )
			lprintf( WIDE("Sending previously queued data.") );
#endif
		if( pc->lpFirstPending->dwAvail )
		{
			  uint32_t dwError;
			if( globalNetworkData.flags.bLogSentData )
			{
				LogBinary( (uint8_t*)pc->lpFirstPending->buffer.c +
							 pc->lpFirstPending->dwUsed,
							 (int)pc->lpFirstPending->dwAvail );
			}
#ifdef DEBUG_SOCK_IO
			_lprintf(DBG_RELAY)( "Try to send... %d  %d", pc->lpFirstPending->dwUsed, pc->lpFirstPending->dwAvail );
#endif
			nSent = send(pc->Socket,
							 (char*)pc->lpFirstPending->buffer.c +
							 pc->lpFirstPending->dwUsed,
							 (int)pc->lpFirstPending->dwAvail,
							 0);
			  dwError = WSAGetLastError();
			//lprintf( "sent result: %d %d %d", nSent, pc->lpFirstPending->dwUsed, pc->lpFirstPending->dwAvail );
			if (nSent == SOCKET_ERROR) {
  // this is alright.
				if( dwError == WSAEWOULDBLOCK )
				{
#ifdef VERBOSE_DEBUG
					lprintf( WIDE("Pending write...") );
#endif
					pc->dwFlags |= CF_WRITEPENDING;
#ifdef __LINUX__
					//if( !(pc->dwFlags & CF_WRITEISPENDED ) )
					//{
					//	   lprintf( WIDE("Sending signal") );
					//    WakeThread( globalNetworkData.pThread );
					//}
					//else
					//    lprintf( WIDE("Yes... it was already pending..(no signal)") );
#endif
					return TRUE;
				}
				{
					_lprintf(DBG_RELAY)(WIDE(" Network Send Error: %5d(buffer:%p ofs: %") _size_f WIDE("  Len: %") _size_f WIDE(")"),
											  dwError,
											  pc->lpFirstPending->buffer.c,
											  pc->lpFirstPending->dwUsed,
											  pc->lpFirstPending->dwAvail );
 // ENOTCONN
					if( dwError == 10057
 // EFAULT
						||dwError == 10014
#ifdef __LINUX__
						|| dwError == EPIPE
#endif
					  )
					{
						InternalRemoveClient( pc );
					}
 // get out of here!
					return FALSE;
				}
 // other side closed.
			} else if (!nSent) {
				lprintf( WIDE("sent zero bytes - assume it was closed - and HOPE there's an event...") );
				InternalRemoveClient( pc );
				// if this happened - don't return TRUE result which would
				// result in queuing a pending buffer...
  // no sence processing the rest of this.
				return FALSE;
			} else if( pc->lpFirstPending && ( nSent < (int)pc->lpFirstPending->dwAvail ) ) {
				//pc->lpFirstPending->dwUsed += nSent;
				//pc->lpFirstPending->dwAvail -= nSent;
				pc->dwFlags |= CF_WRITEPENDING;
				//lprintf( "THIS IS ANOTHER PENDING CONDITION THAT WASN'T ACCOUNTED %d of %d", nSent, pc->lpFirstPending->dwAvail  );
			}
		}
		else
			nSent = 0;
#ifdef DEBUG_SOCK_IO
		lprintf( "sent... %d %d %d", nSent, pc->lpFirstPending->dwUsed, pc->lpFirstPending->dwAvail );
#endif
  // sent some data - update pending buffer status.
		{
			if( pc->lpFirstPending )
			{
				pc->lpFirstPending->dwAvail -= nSent;
				//lprintf( "Subtracted %d got %d", nSent, pc->lpFirstPending->dwAvail );
				pc->lpFirstPending->dwUsed  += nSent;
  // no more to send...
				if (!pc->lpFirstPending->dwAvail)
				{
					lpNext = pc->lpFirstPending -> lpNext;
					if( pc->lpFirstPending->s.bDynBuffer )
						Release(pc->lpFirstPending->buffer.p );
					// there is one pending holder in the client
					// structure that was NOT allocated...
					if( pc->lpFirstPending != &pc->FirstWritePending )
					{
#ifdef LOG_PENDING
						lprintf( WIDE("Finished sending a pending buffer.") );
#endif
						Release(pc->lpFirstPending );
					}
					else
					{
#ifdef LOG_PENDING
 // this happens 99.99% of the time.
						if(0)
						{
							lprintf( WIDE("Normal send complete.") );
						}
#endif
					}
					if (!lpNext)
						pc->lpLastPending = NULL;
					pc->lpFirstPending = lpNext;
					if( pc->write.WriteComplete &&
						!pc->bWriteComplete )
					{
						pc->bWriteComplete = TRUE;
						if( pc->dwFlags & CF_CPPWRITE )
  // SOME WRITE!!!
							pc->write.CPPWriteComplete( pc->psvWrite );
						else
  // SOME WRITE!!!
							pc->write.WriteComplete( pc );
						pc->bWriteComplete = FALSE;
					}
					if( !pc->lpFirstPending )
						pc->dwFlags &= ~CF_WRITEPENDING;
				}
				else
				{
					if( !(pc->dwFlags & CF_WRITEPENDING) )
					{
						pc->dwFlags |= CF_WRITEPENDING;
#ifdef USE_WSA_EVENTS
						if( globalNetworkData.flags.bLogNotices )
							lprintf( WIDE( "SET GLOBAL EVENT (write pending)" ) );
						EnqueLink( &globalNetworkData.client_schedule, pc );
						WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
#ifdef __LINUX__
						AddThreadEvent( pc, 0 );
#endif
					}
					return TRUE;
				}
			}
		}
	}
 // 0 = everything sent / nothing left to send...
	return FALSE;
}
//----------------------------------------------------------------------------
LOGICAL doTCPWriteExx( PCLIENT lpClient
                     , CPOINTER pInBuffer
                     , size_t nInLen
                     , int bLongBuffer
                     , int failpending
                     DBG_PASS
                     )
{
	if( !lpClient )
	{
#ifdef VERBOSE_DEBUG
		lprintf( WIDE("TCP Write failed - invalid client.") );
#endif
  // cannot process a closed channel. data not sent.
		return FALSE;
	}
	while( !NetworkLockEx( lpClient, 0 DBG_SRC ) )
	{
		if( (!(lpClient->dwFlags & CF_ACTIVE )) || (lpClient->dwFlags & CF_TOCLOSE) )
		{
			_lprintf(DBG_RELAY)( "Failing send... inactive or closing" );
			LogBinary( (uint8_t*)pInBuffer, nInLen );
			return FALSE;
		}
		Relinquish();
	}
	if( !(lpClient->dwFlags & CF_ACTIVE ) )
	{
#ifdef VERBOSE_DEBUG
		lprintf( WIDE("TCP Write failed - client is inactive") );
#endif
		// change to inactive status by the time we got here...
		NetworkUnlockEx( lpClient, 0 DBG_SRC );
		return FALSE;
	}
 // will already be in a wait on network state...
	if( lpClient->lpFirstPending )
	{
#ifdef VERBOSE_DEBUG
		_lprintf( DBG_RELAY )(  "Data already pending, pending buffer...%p %d", pInBuffer, nInLen );
#endif
		if( !failpending )
		{
#ifdef VERBOSE_DEBUG
			lprintf( WIDE("Queuing pending data anyhow...") );
#endif
			PendWrite( lpClient, pInBuffer, nInLen, bLongBuffer );
			//TCPWriteEx( lpClient DBG_SRC ); // make sure we don't lose a write event during the queuing...
			NetworkUnlockEx( lpClient, 0 DBG_SRC );
			return TRUE;
		}
		else
		{
#ifdef VERBOSE_DEBUG
			lprintf( WIDE("Failing pend.") );
#endif
			NetworkUnlockEx( lpClient, 0 DBG_SRC );
			return FALSE;
		}
	}
	else
	{
		// have to steal the buffer - :(
		lpClient->FirstWritePending.buffer.c   = pInBuffer;
		//lprintf( "First pending Write set to %d", nInLen );
		lpClient->FirstWritePending.dwAvail    = nInLen;
		lpClient->FirstWritePending.dwUsed     = 0;
		lpClient->FirstWritePending.s.bStream    = FALSE;
		lpClient->FirstWritePending.s.bDynBuffer = FALSE;
		lpClient->FirstWritePending.lpNext       = NULL;
		lpClient->lpLastPending =
		lpClient->lpFirstPending = &lpClient->FirstWritePending;
		if( TCPWriteEx( lpClient DBG_RELAY ) )
		{
#ifdef VERBOSE_DEBUG
			Log2( WIDE("Data not sent, pending buffer... %d bytes %d remain"), nInLen, lpClient->FirstWritePending.dwAvail );
#endif
 // caller will assume the buffer usable on return
			if( !bLongBuffer )
			{
				lpClient->FirstWritePending.buffer.p = Allocate( nInLen );
				MemCpy( lpClient->FirstWritePending.buffer.p, pInBuffer, nInLen );
				lpClient->FirstWritePending.s.bDynBuffer = TRUE;
			}
		}
#ifdef VERBOSE_DEBUG
		else
			_xlprintf( 1 DBG_RELAY )( WIDE("Data has been compeltely sent.") );
#endif
	}
	NetworkUnlockEx( lpClient, 0 DBG_SRC );
 // assume the data was sent.
	return TRUE;
}
//----------------------------------------------------------------------------
#define DRAIN_MAX_READ 2048
// used internally to read directly to drain buffer.
LOGICAL TCPDrainRead( PCLIENT pClient )
{
	size_t nDrainRead;
	char byBuffer[DRAIN_MAX_READ];
	while( pClient && pClient->nDrainLength )
	{
		nDrainRead = pClient->nDrainLength;
		if( nDrainRead > DRAIN_MAX_READ )
			nDrainRead = DRAIN_MAX_READ;
		nDrainRead = recv( pClient->Socket
							  , byBuffer
						 , (int)nDrainRead, 0 );
//SOCKET_ERROR )
		if( nDrainRead == 0 )
		{
			uint32_t dwError;
			dwError = WSAGetLastError();
			if( dwError == WSAEWOULDBLOCK )
			{
				if( !pClient->bDrainExact )
					pClient->nDrainLength = 0;
				break;
			}
			lprintf(WIDE(" Network Error during drain: %d (from: %p  to: %p  has: %") _size_f WIDE("  toget: %") _size_f WIDE(")")
			       , dwError
			       , pClient->Socket
			       , pClient->RecvPending.buffer.p
			       , pClient->RecvPending.dwUsed
			       , pClient->RecvPending.dwAvail );
			InternalRemoveClient( pClient );
			NetworkUnlockEx( pClient, 1 DBG_SRC );
			return FALSE;
		}
		else
		{
			if( globalNetworkData.flags.bShortLogReceivedData )
			{
				LogBinary( (uint8_t*)byBuffer, (nDrainRead<64 )?nDrainRead:64 );
			}
			if( globalNetworkData.flags.bLogReceivedData )
			{
				LogBinary( (uint8_t*)byBuffer, nDrainRead );
			}
		}
		if( nDrainRead == 0 )
		{
 // closed.
			InternalRemoveClient( pClient );
			NetworkUnlockEx( pClient, 1 DBG_SRC );
			return FALSE;
		}
		if( pClient->bDrainExact )
			pClient->nDrainLength -= nDrainRead;
	}
	if( pClient )
		return pClient->bDraining = (pClient->nDrainLength != 0);
 // no data available....
	return 0;
}
//----------------------------------------------------------------------------
NETWORK_PROC( LOGICAL, TCPDrainEx)( PCLIENT pClient, size_t nLength, int bExact )
{
	if( pClient )
	{
		LOGICAL bytes;
		while( !NetworkLockEx( pClient, 0 DBG_SRC ) )
		{
			if( !(pClient->dwFlags & CF_ACTIVE ) )
			{
				return FALSE;
			}
			Relinquish();
		}
		if( pClient->bDraining )
		{
			pClient->nDrainLength += nLength;
		}
		else
		{
			pClient->bDraining = TRUE;
			pClient->nDrainLength = nLength;
		}
		pClient->bDrainExact = bExact;
		if( !pClient->bDrainExact )
 // default optimal read
			pClient->nDrainLength = DRAIN_MAX_READ;
		bytes = TCPDrainRead( pClient );
		NetworkUnlockEx( pClient, 1 DBG_SRC );
		return bytes;
	}
	return 0;
}
//----------------------------------------------------------------------------
void SetTCPNoDelay( PCLIENT pClient, int bEnable )
{
	if( setsockopt( pClient->Socket, IPPROTO_TCP,
						TCP_NODELAY,
						(const char *)&bEnable, sizeof(bEnable) ) == SOCKET_ERROR )
	{
		lprintf( WIDE("Error(%d) setting Delay to : %d"), WSAGetLastError(), bEnable );
		// log some sort of error... and ignore...
	}
}
//----------------------------------------------------------------------------
void SetClientKeepAlive( PCLIENT pClient, int bEnable )
{
	if( setsockopt( pClient->Socket, SOL_SOCKET,
						SO_KEEPALIVE,
						(const char *)&bEnable, sizeof(bEnable) ) == SOCKET_ERROR )
	{
		lprintf( WIDE("Error(%d) setting KeepAlive to : %d"), WSAGetLastError(), bEnable );
		// log some sort of error... and ignore...
	}
}
SACK_NETWORK_TCP_NAMESPACE_END
#define LIBRARY_DEF
#ifdef __LINUX__
 // SIGHUP defined
#define NetWakeSignal SIGHUP
#else
#define ioctl ioctlsocket
#endif
//#define NO_LOGGING // force neverlog....
#define DO_LOGGING
SACK_NETWORK_NAMESPACE
// local extern in network.c
void DumpSocket( PCLIENT pc );
_UDP_NAMESPACE
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PCLIENT CPPServeUDPAddrEx( SOCKADDR *pAddr
                         , cReadCompleteEx pReadComplete
                         , uintptr_t psvRead
                         , cCloseCallback Close
                         , uintptr_t psvClose
                         , int bCPP DBG_PASS )
{
	PCLIENT pc;
	// open a UDP Port to listen for Pings for server...
	pc = GetFreeNetworkClient();
	if( !pc )
	{
		Log( WIDE("Network Resource Fail"));
		return NULL;
	}
#ifdef WIN32
	pc->Socket = OpenSocket(((*(uint16_t*)pAddr) == AF_INET)?TRUE:FALSE,FALSE, FALSE, 0);
	if( pc->Socket == INVALID_SOCKET )
#endif
#ifdef __MAC__
		pc->Socket = socket( PF_INET
		                   , SOCK_DGRAM
		                   , (((((uint8_t*)pAddr)[1]) == AF_INET)||((((uint8_t*)pAddr)[1]) == AF_INET6))?IPPROTO_UDP:0);
#else
    pc->Socket = socket( PF_INET
                       , SOCK_DGRAM
                       , (((*(uint16_t*)pAddr) == AF_INET)||((*(uint16_t*)pAddr) == AF_INET6))?IPPROTO_UDP:0);
#endif
	if( pc->Socket == INVALID_SOCKET )
	{
		_lprintf(DBG_RELAY)( WIDE("UDP Socket Fail") );
		InternalRemoveClientEx( pc, TRUE, FALSE );
		NetworkUnlock( pc, 0 );
		NetworkUnlock( pc, 1 );
		return NULL;
	}
#if WIN32
	if( 0 )
	{
		DWORD dwFlags;
		GetHandleInformation( (HANDLE)pc->Socket, &dwFlags );
		lprintf( WIDE( "Natural was %d" ), dwFlags );
	}
	SetHandleInformation( (HANDLE)pc->Socket, HANDLE_FLAG_INHERIT, 0 );
#endif
#ifdef LOG_SOCKET_CREATION
	lprintf( WIDE( "Created UDP %p(%d)" ), pc, pc->Socket );
#endif
	pc->dwFlags |= CF_UDP;
	if( pAddr? pc->saSource = DuplicateAddress( pAddr ),1:0 )
	{
		if (bind(pc->Socket,pc->saSource,SOCKADDR_LENGTH(pc->saSource)))
		{
			uint32_t err = WSAGetLastError();
			_lprintf(DBG_RELAY)( WIDE("Bind Fail: %d"), err );
			DumpAddr( WIDE( "BIND FAIL:" ), pc->saSource );
			InternalRemoveClientEx( pc, TRUE, FALSE );
			NetworkUnlock( pc, 0 );
			NetworkUnlock( pc, 1 );
			return NULL;
		}
		// get the port address back immediately.
		getsockname(pc->Socket, pc->saSource, (socklen_t*)(((uintptr_t)pc->saSource)-2*sizeof(uintptr_t)));
	}
	else
	{
		Log( WIDE("Bind Will Fail") );
		InternalRemoveClientEx( pc, TRUE, FALSE );
		NetworkUnlock( pc, 0 );
		NetworkUnlock( pc, 1 );
		return NULL;
	}
#ifdef _WIN32
#  ifdef USE_WSA_EVENTS
	pc->event = WSACreateEvent();
	WSAEventSelect( pc->Socket, pc->event, FD_READ|FD_WRITE );
#  else
	if (WSAAsyncSelect( pc->Socket,
	                   globalNetworkData.ghWndNetwork,
	                   SOCKMSG_UDP,
	                   FD_READ|FD_WRITE ) )
	{
		Log( WIDE("Select Fail"));
		InternalRemoveClientEx( pc, TRUE, FALSE );
		NetworkUnlock( pc, 0 );
		NetworkUnlock( pc, 1 );
		return NULL;
	}
#  endif
#else
	{
		int t = TRUE;
		ioctl( pc->Socket, FIONBIO, &t );
	}
#endif
	pc->read.ReadCompleteEx = pReadComplete;
	pc->psvRead = psvRead;
	pc->close.CloseCallback = Close;
	pc->psvClose = psvClose;
	if( bCPP )
		pc->dwFlags |= (CF_CPPREAD|CF_CPPCLOSE );
#ifdef __LINUX__
	AddThreadEvent( pc, 0 );
#endif
	if( pReadComplete )
	{
		if( pc->dwFlags & CF_CPPREAD )
			pc->read.CPPReadCompleteEx( pc->psvRead, NULL, 0, pc->saSource );
		else
			pc->read.ReadCompleteEx( pc, NULL, 0, pc->saSource );
	}else
		lprintf( "NO READ CALLBACK IS SET?!" );
#ifdef LOG_SOCKET_CREATION
	DumpSocket( pc );
#endif
	AddActive( pc );
	NetworkUnlock( pc, 0 );
	NetworkUnlock( pc, 1 );
#ifdef USE_WSA_EVENTS
	if( globalNetworkData.flags.bLogNotices )
		lprintf( WIDE( "SET GLOBAL EVENT (new udp socket %p)" ), pc );
	EnqueLink( &globalNetworkData.client_schedule, pc );
	WSASetEvent( globalNetworkData.hMonitorThreadControlEvent );
#endif
	return pc;
}
//----------------------------------------------------------------------------
PCLIENT ServeUDPAddrEx( SOCKADDR *pAddr
                      , cReadCompleteEx pReadComplete
                      , cCloseCallback Close DBG_PASS )
{
	PCLIENT result = CPPServeUDPAddrEx( pAddr, pReadComplete, 0, Close, 0, FALSE DBG_RELAY );
	if( result )
		result->dwFlags &= ~(CF_CPPREAD|CF_CPPCLOSE);
	return result;
}
//----------------------------------------------------------------------------
PCLIENT ServeUDPEx( CTEXTSTR pAddr, uint16_t wPort
                  , cReadCompleteEx pReadComplete
                  , cCloseCallback Close DBG_PASS )
{
	SOCKADDR *lpMyAddr;
	if( pAddr )
		lpMyAddr = CreateSockAddress( pAddr, wPort);
	else
	{
		// NOTE this is NOT create local which binds to only
		// one address and port - this IS "0.0.0.0" which is
		// any IP inteface on the box...
 // assume bind to any address...
		lpMyAddr = CreateSockAddress( WIDE("0.0.0.0"), wPort );
	}
	return ServeUDPAddrEx( lpMyAddr, pReadComplete, Close DBG_RELAY );
}
//----------------------------------------------------------------------------
void UDPEnableBroadcast( PCLIENT pc, int bEnable )
{
	if( pc ) {
#ifdef __LINUX__
		if( bEnable ) {
			uint16_t port;
			SOCKADDR *broadcastAddr;
			//RemoveThreadEvent( pc );
			//pc->Socket = close( pc->Socket );
			pc->interfaceAddress = GetInterfaceForAddress( pc->saSource );
			if( pc->interfaceAddress ) {
				pc->SocketBroadcast = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
				{
					int t = TRUE;
					ioctl( pc->SocketBroadcast, FIONBIO, &t );
				}
				broadcastAddr = DuplicateAddress( GetBroadcastAddressForInterface( pc->saSource ) );
				GetAddressParts( pc->saSource, NULL, &port );
				SetAddressPort( broadcastAddr, port );
				if( bind( pc->SocketBroadcast, broadcastAddr, SOCKADDR_LENGTH( broadcastAddr ) ) ) {
					lprintf( "Failed to rebind to broadcast address when enabling... %d", errno );
				}
				if( setsockopt( pc->SocketBroadcast, SOL_SOCKET
				              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
				{
					uint32_t error = WSAGetLastError();
					lprintf( WIDE("Failed to set sock opt - BROADCAST(%d)"), error );
				}
				AddThreadEvent( pc, 1 );
#ifdef __LINUX__
				// need to set EAGAIN state on socket.
  // do actual read.... (results in read callback)
				FinishUDPRead( pc, 1 );
#endif
				ReleaseAddress( broadcastAddr );
			} else
				lprintf( "Network interface for socket address not found." );
		}
#else
		if( setsockopt( pc->Socket, SOL_SOCKET
		              , SO_BROADCAST, (char*)&bEnable, sizeof( bEnable ) ) )
		{
			uint32_t error = WSAGetLastError();
			lprintf( WIDE("Failed to set sock opt - BROADCAST(%d)"), error );
		}
#endif
	}
}
//----------------------------------------------------------------------------
LOGICAL GuaranteeAddr( PCLIENT pc, SOCKADDR *sa )
{
	if( sa )
	{
		pc->saClient = DuplicateAddress( sa );
	}
	else
		return FALSE;
#ifdef VERBOSE_DEBUG
	DumpSocket( pc );
#endif
	return TRUE;
}
//----------------------------------------------------------------------------
LOGICAL Guarantee( PCLIENT pc, CTEXTSTR pAddr, uint16_t wPort )
{
	SOCKADDR *lpMyAddr = CreateSockAddress( pAddr, wPort);
	int res = GuaranteeAddr( pc, lpMyAddr );
	ReleaseAddress( lpMyAddr );
	return res;
}
//----------------------------------------------------------------------------
PCLIENT CPPConnectUDPAddrEx( SOCKADDR *sa
                           , SOCKADDR *saTo
                           , cReadCompleteEx pReadComplete
                           , uintptr_t psvRead
                           , cCloseCallback Close
                           , uintptr_t psvClose DBG_PASS )
{
	PCLIENT pc;
	int bFixed = FALSE;
	if( !sa )
	{
 // use any address...
		sa = CreateLocal( 0 );
		bFixed = TRUE;
	}
	pc = ServeUDPAddrEx( sa, NULL, NULL DBG_RELAY );
	if( !pc )
	{
		Log( WIDE("Failed to establish incoming side of UDP Socket") );
		return NULL;
	}
	if( !GuaranteeAddr( pc, saTo ) )
	{
		Log( WIDE("Failed to set guaranteed UDP Send Address."));
		InternalRemoveClient( pc );
		return NULL;
	}
	if( bFixed )
		ReleaseAddress( sa );
	pc->read.ReadCompleteEx = pReadComplete;
	pc->psvRead = psvRead;
	pc->close.CloseCallback = Close;
	pc->psvClose = psvClose;
	pc->dwFlags |= (CF_CPPREAD|CF_CPPCLOSE );
	if( pReadComplete )
 // allow server to start a read method...
		pReadComplete( pc, NULL, 0, NULL );
	return pc;
}
PCLIENT CPPConnectUDPAddr( SOCKADDR *sa
                         , SOCKADDR *saTo
                         , cReadCompleteEx pReadComplete
                         , uintptr_t psvRead
                         , cCloseCallback Close
                         , uintptr_t psvClose )
{
	return CPPConnectUDPAddrEx( sa, saTo, pReadComplete, psvRead, Close, psvClose DBG_SRC );
}
//----------------------------------------------------------------------------
PCLIENT ConnectUDPAddrEx( SOCKADDR *sa
                        , SOCKADDR *saTo
                        , cReadCompleteEx pReadComplete
                        , cCloseCallback Close DBG_PASS )
{
	PCLIENT result = CPPConnectUDPAddrEx( sa, saTo, pReadComplete, 0, Close, 0 DBG_RELAY );
	if( result )
		result->dwFlags &= ~( CF_CPPREAD|CF_CPPCLOSE );
	return result;
}
//----------------------------------------------------------------------------
static PCLIENT CPPConnectUDPExx( CTEXTSTR pFromAddr, uint16_t wFromPort
                               , CTEXTSTR pToAddr, uint16_t wToPort
                               , cReadCompleteEx pReadComplete
                               , uintptr_t psvRead
                               , cCloseCallback Close
                               , uintptr_t psvClose
                               , LOGICAL bCPP
                               DBG_PASS )
{
	PCLIENT pc;
	pc = ServeUDPEx( pFromAddr, wFromPort, NULL, NULL DBG_RELAY );
	if( !pc )
	{
		Log( WIDE("Failed to establish incoming side of UDP Socket") );
		return NULL;
	}
	if( !Guarantee( pc, pToAddr, wToPort ) )
	{
		Log( WIDE("Failed to set guaranteed UDP Send Address."));
		InternalRemoveClient( pc );
		return NULL;
	}
	pc->read.ReadCompleteEx = pReadComplete;
	pc->psvRead = psvRead;
	pc->close.CloseCallback = Close;
	pc->psvClose = psvClose;
	if( bCPP )
	{
		pc->dwFlags |= (CF_CPPREAD|CF_CPPCLOSE );
		if( pReadComplete )
 // allow server to start a read method...
			pc->read.CPPReadCompleteEx( psvRead, NULL, 0, NULL );
	}
	else
	{
		pc->dwFlags &= ~( CF_CPPREAD|CF_CPPCLOSE );
		if( pReadComplete )
 // allow server to start a read method...
			pReadComplete( pc, NULL, 0, NULL );
	}
	return pc;
}
PCLIENT CPPConnectUDPEx( CTEXTSTR pFromAddr, uint16_t wFromPort,
                         CTEXTSTR pToAddr, uint16_t wToPort,
                         cReadCompleteEx pReadComplete,
                         uintptr_t psvRead,
                         cCloseCallback Close,
                         uintptr_t psvClose DBG_PASS )
{
	return CPPConnectUDPExx( pFromAddr, wFromPort, pToAddr, wToPort, pReadComplete, psvRead, Close, psvClose, TRUE DBG_RELAY );
}
PCLIENT ConnectUDPEx( CTEXTSTR pFromAddr, uint16_t wFromPort,
                      CTEXTSTR pToAddr, uint16_t wToPort,
                      cReadCompleteEx pReadComplete,
                      cCloseCallback Close DBG_PASS )
{
	return CPPConnectUDPExx( pFromAddr, wFromPort, pToAddr, wToPort, pReadComplete, 0, Close, 0, FALSE DBG_RELAY );
}
//----------------------------------------------------------------------------
NETWORK_PROC( LOGICAL, SendUDPEx )( PCLIENT pc, CPOINTER pBuf, size_t nSize, SOCKADDR *sa )
{
	int nSent;
	SOCKET sendSocket = pc->Socket;
	if( !sa)
		sa = pc->saClient;
	if( !sa )
      return FALSE;
	if( !pc )
		return FALSE;
#ifdef __LINUX__
	if( IsBroadcastAddressForInterface( pc->interfaceAddress, sa ) ) {
		sendSocket = pc->SocketBroadcast;
	}
#endif
	//LogBinary( (uint8_t*)pBuf, nSize );
	nSent = sendto( sendSocket
	              , (const char*)pBuf
	              , (int)nSize
	              , 0
	              , (sa)
	              , SOCKADDR_LENGTH((sa))
	              );
	if( nSent < 0 )
	{
		Log1( WIDE("SendUDP: Error (%d)"), WSAGetLastError() );
		DumpAddr( WIDE( "SendTo Socket" ), (sa) );
		return FALSE;
	}
 // this is all so very vague.....
	else if( SUS_LT( nSent, int, nSize, size_t ) )
	{
		Log( WIDE("SendUDP: Small send :(") );
		return FALSE;
	}
	return TRUE;
}
//----------------------------------------------------------------------------
NETWORK_PROC( LOGICAL, ReconnectUDP )( PCLIENT pc, CTEXTSTR pToAddr, uint16_t wPort )
{
	return Guarantee( pc, pToAddr, wPort );
}
//----------------------------------------------------------------------------
extern uint32_t uNetworkPauseTimer, uTCPPendingTimer;
//----------------------------------------------------------------------------
NETWORK_PROC( int, doUDPRead )( PCLIENT pc, POINTER lpBuffer, int nBytes )
{
	if( pc->RecvPending.dwAvail )
	{
		lprintf( WIDE("Read already pending for %")_size_fs WIDE("... not doing anything for this one..")
		        , pc->RecvPending.dwAvail );
		return FALSE;
	}
	//Log1( WIDE("UDPRead Pending:%d bytes"), nBytes );
	pc->RecvPending.dwAvail = nBytes;
	pc->RecvPending.dwUsed = 0;
	pc->RecvPending.buffer.p = lpBuffer;
	{
		pc->dwFlags |= CF_READPENDING;
		// we are now able to read, so schedule the socket.
	}
#if 0
#ifdef __LINUX__
	// need to set EAGAIN state on socket.
  // do actual read.... (results in read callback)
	FinishUDPRead( pc, 0 );
	if( pc->SocketBroadcast )
  // do actual read.... (results in read callback)
		FinishUDPRead( pc, 1 );
#endif
#endif
	return TRUE;
}
//----------------------------------------------------------------------------
int FinishUDPRead( PCLIENT pc, int broadcastEvent )
  // all UDP Reads return the address of the other side's message...
{
	int nReturn;
#ifdef __LINUX__
	socklen_t
#else
		int
#endif
  // echoed from server.
		Size=MAGIC_SOCKADDR_LENGTH;
	if( !pc->RecvPending.buffer.p || !pc->RecvPending.dwAvail )
	{
		//lprintf( WIDE("UDP Read without queued buffer for result. %p %") _size_fs, pc->RecvPending.buffer.p, pc->RecvPending.dwAvail );
		return FALSE;
	}
	//do{
	if( !pc->saLastClient )
		pc->saLastClient = AllocAddr();
	nReturn = recvfrom( broadcastEvent?pc->SocketBroadcast:pc->Socket,
	                    (char*)pc->RecvPending.buffer.p,
	                    (int)pc->RecvPending.dwAvail,0,
	                    pc->saLastClient,
// get address...
	                    &Size);
	uintptr_t name = (((uintptr_t*)pc->saLastClient) - 1)[0];
	if( name ) free( (void*)name );
	(((uintptr_t*)pc->saLastClient) - 1)[0] = 0;
	// address size in recvfrom on linux results with '256' which
	// then results with a sockaddr that can't sendto with.
	if( pc->saLastClient->sa_family == AF_INET )
		SET_SOCKADDR_LENGTH( pc->saLastClient, IN_SOCKADDR_LENGTH );
	else if( pc->saLastClient->sa_family == AF_INET6 )
		SET_SOCKADDR_LENGTH( pc->saLastClient, IN6_SOCKADDR_LENGTH );
	//lprintf( WIDE("Recvfrom result:%d"), nReturn );
	if (nReturn == SOCKET_ERROR)
	{
		uint32_t dwErr = WSAGetLastError();
		// shutdown the udp socket... not needed...???
		//lprintf( WIDE("Recvfrom result:%d"), dwErr );
		switch( dwErr )
		{
 // NO data returned....
		case WSAEWOULDBLOCK:
			//lprintf( "got EWOULDBLOCK(EAGAIN)..." );
			pc->dwFlags |= CF_READPENDING;
			return TRUE;
#ifdef _WIN32
		// this happens on WIN2K/XP - ICMP Port Unreachable (nothing listening there)
 // just ignore this error.
		case WSAECONNRESET:
			  Log( WIDE("ICMP Port unreachable on previous send.") );
			return TRUE;
#endif
		default:
				Log2( WIDE("FinishUDPRead Unknown error: %d %") _size_fs WIDE(""), WSAGetLastError(), pc->RecvPending.dwAvail );
			InternalRemoveClient( pc );
			return FALSE;
			break;
		}
	}
	//Log1( WIDE("UDPRead:%d bytes"), nReturn );
	if( globalNetworkData.flags.bShortLogReceivedData )
	{
		DumpAddr( WIDE("UDPRead at"), pc->saSource );
		LogBinary( (uint8_t*)pc->RecvPending.buffer.p +
					 pc->RecvPending.dwUsed, ( nReturn< 64 )?nReturn:64 );
	}
	if( globalNetworkData.flags.bLogReceivedData )
	{
		DumpAddr( WIDE("UDPRead at"), pc->saSource );
		LogBinary( (uint8_t*)pc->RecvPending.buffer.p +
					 pc->RecvPending.dwUsed, nReturn );
	}
	pc->dwFlags &= ~CF_READPENDING;
  // allow further reads...
	pc->RecvPending.dwAvail = 0;
	pc->RecvPending.dwUsed += nReturn;
	if( pc->read.ReadCompleteEx )
	{
		if( pc->dwFlags & CF_CPPREAD )
			pc->read.CPPReadCompleteEx( pc->psvRead, pc->RecvPending.buffer.p, nReturn, pc->saLastClient );
		else
		{
			//lprintf( WIDE("Calling UDP complete %p %p %d"), pc, pc->RecvPending.buffer.p, nReturn );
			pc->read.ReadCompleteEx( pc, pc->RecvPending.buffer.p, nReturn, pc->saLastClient );
		}
	}
	//}while(1);
	return TRUE;
}
int SetSocketReuseAddress( PCLIENT lpClient, int32_t enable )
{
	if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEADDR,
						(char*)&enable, sizeof(enable)) <0 )
	{
		return 0;
		//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse addr." << endl;
	}
	return 1;
}
int SetSocketReusePort( PCLIENT lpClient, int32_t enable )
{
#ifdef __LINUX__
	if (setsockopt(lpClient->Socket, SOL_SOCKET, SO_REUSEPORT,
						(char*)&enable, sizeof(enable)) < 0 )
	{
		return 0;
		//cerr << "NFMSim:setHost:ERROR: could not set socket to reuse addr." << endl;
	}
#else
	SetSocketReuseAddress( lpClient, enable );
#endif
	return 1;
}
_UDP_NAMESPACE_END
SACK_NETWORK_NAMESPACE_END
#ifndef __LINUX__
///////////////////////////////////////////////////////////////////////////
//
// Filename    -  Network.C
//
// Description -  Network services for Communications Client
//
// Author      -  James Buckeyne
//
// Create Date -  Before now.
// Conversion update for Linux GLIBC 2.1 9/26/2000
//
///////////////////////////////////////////////////////////////////////////
//
//  DEBUG FLAGS IN netstruc.h
//
SACK_NETWORK_NAMESPACE
   // should pass ipv4? v6? to switch?
SOCKET OpenSocket( LOGICAL v4, LOGICAL bStream, LOGICAL bRaw, int another_offset )
{
	if( another_offset )
	{
		SOCKET result;
      // need to index into saved sockets and try another provider.
		result = WSASocketW(v4?AF_INET:AF_INET6
										 , bRaw?SOCK_RAW:0
										 , 0
										 , v4
										  ?bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocol
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocol
										  :bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocolv6
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocolv6
										 , 0, 0 );
		return result;
	}
	else
	{
		SOCKET result = WSASocketW(v4?AF_INET:AF_INET6
										 , bRaw?SOCK_RAW:0
										 , 0
										 , v4
										  ?bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocol
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocol
										  :bStream
										  ?globalNetworkData.pProtos+globalNetworkData.tcp_protocolv6
										  :globalNetworkData.pProtos+globalNetworkData.udp_protocolv6
										 , 0, 0 );
		return result;
	}
}
int SystemCheck( void )
{
	WSADATA wd;
	int i;
	int protoIndex = -1;
	int size;
	//lprintf( "Global is %d %p", sizeof( globalNetworkData ), &globalNetworkData.uNetworkPauseTimer, &globalNetworkData.nProtos );
	if (WSAStartup(MAKEWORD(2, 0), &wd) != 0)
	{
		lprintf(WIDE( "WSAStartup 2.0 failed: %d" ), h_errno);
		return 0;
	}
	if( globalNetworkData.flags.bLogProtocols )
		lprintf(WIDE( "Winsock Version: %d.%d" ), LOBYTE(wd.wVersion), HIBYTE(wd.wVersion));
	size = 0;
	if ((globalNetworkData.nProtos = WSAEnumProtocolsW(NULL, NULL, (DWORD *) &size)) == -1)
	{
		if( WSAGetLastError() != WSAENOBUFS )
		{
			lprintf(WIDE( "WSAEnumProtocols: %d" ), h_errno);
			return 0;
		}
	}
	globalNetworkData.pProtos = (WSAPROTOCOL_INFOW*)Allocate( size );
	if ((globalNetworkData.nProtos = WSAEnumProtocolsW(NULL, globalNetworkData.pProtos, (DWORD *) &size)) == -1)
	{
		lprintf(WIDE( "WSAEnumProtocols: %d" ), h_errno);
		return 0;
	}
	for (i = 0; i < globalNetworkData.nProtos; i++)
	{
		// IPv6
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [TCP/IP]" ) == 0)
		{
			globalNetworkData.tcp_protocol = i;
			protoIndex = i;
		}
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [UDP/IP]" ) == 0)
		{
			globalNetworkData.udp_protocol = i;
		}
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [TCP/IPv6]" ) == 0)
		{
			globalNetworkData.tcp_protocolv6 = i;
		}
		if (wcscmp(globalNetworkData.pProtos[i].szProtocol, L"MSAFD Tcpip [UDP/IPv6]" ) == 0)
		{
			globalNetworkData.udp_protocolv6 = i;
		}
		if( globalNetworkData.flags.bLogProtocols )
			lprintf(WIDE( "Index #%d - name: '%S', type: %d, proto: %d" ), i, globalNetworkData.pProtos[i].szProtocol,
					  globalNetworkData.pProtos[i].iSocketType, globalNetworkData.pProtos[i].iProtocol);
	}
	if (protoIndex == -1)
	{
		lprintf(WIDE( "no valid TCP/IP protocol available" ));
		return 0;
	}
	return 0;
}
SACK_NETWORK_NAMESPACE_END
#endif
#ifdef BUILD_NODE_ADDON
#  include <node_version.h>
#endif
#ifdef BUILD_NODE_ADDON
#  ifdef NODE_MAJOR_VERSION
#    if NODE_MAJOR_VERSION >= 10
#      define HACK_NODE_TLS
#    endif
#  endif
#endif
#ifdef _WIN32
#  include <prsht.h>
#  include <cryptuiapi.h>
#endif
//#define DEBUG_SSL_IO
#if NO_SSL
SACK_NETWORK_NAMESPACE
LOGICAL ssl_Send( PCLIENT pc, CPOINTER buffer, size_t length ) {
	return FALSE;
}
LOGICAL ssl_BeginServer( PCLIENT pc, CPOINTER cert, size_t certlen, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen ) {
	return FALSE;
}
LOGICAL ssl_BeginClientSession( PCLIENT pc, CPOINTER client_keypair, size_t client_keypairlen, CPOINTER keypass, size_t keypasslen, CPOINTER rootCert, size_t rootCertLen ) {
	return FALSE;
}
LOGICAL ssl_IsClientSecure( PCLIENT pc ) {
	return FALSE;
}
SACK_NETWORK_NAMESPACE_END
#else
#define _LIB
#include <openssl/ssl.h>
#include <openssl/tls1.h>
#include <openssl/err.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include <openssl/pkcs12.h>
SACK_NETWORK_NAMESPACE
//#define RSA_KEY_SIZE (1024)
const int serverKBits = 4096;
// 4096;
const int kBits = 1024;
const int kExp = RSA_F4;
struct internalCert {
	X509_REQ *req;
	X509 * x509;
	EVP_PKEY *pkey;
	STACK_OF( X509 ) *chain;
};
void loadSystemCerts(X509_STORE *store );
//static void gencp
struct internalCert * MakeRequest( void );
EVP_PKEY *genKey() {
	EVP_PKEY *keypair = EVP_PKEY_new();
	//int keylen;
	//char *pem_key;
	//BN_GENCB cb = { }
	BIGNUM          *bne = BN_new();
	RSA *rsa = RSA_new();
	int ret;
	ret = BN_set_word( bne, kExp );
	if( ret != 1 ) {
		BN_free( bne );
		RSA_free( rsa );
		EVP_PKEY_free( keypair );
		return NULL;
	}
	RSA_generate_key_ex( rsa, kBits, bne, NULL );
	EVP_PKEY_set1_RSA( keypair, rsa );
	BN_free( bne );
	RSA_free( rsa );
	return keypair;
}
#define ALLOW_ANON_CONNECTIONS	1
#ifndef UNICODE
struct ssl_session {
	SSL_CTX        *ctx;
	LOGICAL ignoreVerification;
	BIO *rbio;
	BIO *wbio;
	//EVP_PKEY *privkey;
	struct internalCert *cert;
	SSL            *ssl;
 // CF_CPPREAD
	uint32_t       dwOriginalFlags;
	cReadComplete  user_read;
	cppReadComplete  cpp_user_read;
	cNotifyCallback user_connected;
	cppNotifyCallback cpp_user_connected;
	cCloseCallback user_close;
	cppCloseCallback cpp_user_close;
	uint8_t *obuffer;
	size_t obuflen;
	uint8_t *ibuffer;
	size_t ibuflen;
	uint8_t *dbuffer;
	size_t dbuflen;
	CRITICALSECTION csRead;
	CRITICALSECTION csWrite;
};
static struct ssl_global
{
	struct {
		BIT_FIELD bInited : 1;
	} flags;
	LOGICAL trace;
	struct tls_config *tls_config;
	uint8_t cipherlen;
}ssl_global;
ATEXIT( CloseSSL )
{
	if( ssl_global.flags.bInited ) {
	}
}
void CloseSession( PCLIENT pc )
{
	if( pc->ssl_session )
	{
		Release( pc->ssl_session );
		pc->ssl_session = NULL;
	}
	if( !( pc->dwFlags & ( CF_CLOSED|CF_CLOSING ) ) )
		RemoveClient( pc );
}
static int logerr( const char *str, size_t len, void *userdata ) {
	lprintf( "%d: %s", *((int*)&userdata), str );
	return 0;
}
static int handshake( PCLIENT pc ) {
	struct ssl_session *ses = pc->ssl_session;
	if (!SSL_is_init_finished(ses->ssl)) {
		int r;
#ifdef DEBUG_SSL_IO
		lprintf( "doing handshake...." );
#endif
		/* NOT INITIALISED */
		r = SSL_do_handshake(ses->ssl);
#ifdef DEBUG_SSL_IO
		lprintf( "handle data posted to SSL? %d", r );
#endif
		if( r == 0 ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
			r = SSL_get_error( ses->ssl, r );
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
#ifdef DEBUG_SSL_IO
			lprintf( "SSL_Read failed... %d", r );
#endif
			return -1;
		}
		if (r < 0) {
			r = SSL_get_error(ses->ssl, r);
			if( SSL_ERROR_SSL == r ) {
#ifdef DEBUG_SSL_IO
				lprintf( "SSL_Read failed... %d", r );
#endif
				ERR_print_errors_cb( logerr, (void*)__LINE__ );
				return -1;
			}
			if (SSL_ERROR_WANT_READ == r)
			{
				size_t pending;
				while( ( pending = BIO_ctrl_pending( ses->wbio) ) > 0 ) {
					if (pending > 0) {
						int read;
						if( pending > ses->obuflen ) {
							if( ses->obuffer )
								Deallocate( uint8_t *, ses->obuffer );
							ses->obuffer = NewArray( uint8_t, ses->obuflen = pending*2 );
							//lprintf( "making obuffer bigger %d %d", pending, pending * 2 );
						}
						read = BIO_read(ses->wbio, ses->obuffer, (int)pending);
#ifdef DEBUG_SSL_IO
						lprintf( "send %d %d for handshake", pending, read );
#endif
						if( read > 0 ) {
#ifdef DEBUG_SSL_IO
							lprintf( "handshake send %d", read );
#endif
							SendTCP( pc, ses->obuffer, read );
						}
					}
				}
			}
			else {
				ERR_print_errors_cb( logerr, (void*)__LINE__ );
			}
			return 0;
		}
		return 2;
	}
	else {
		/* SSL IS INITIALISED */
		return 1;
	}
}
static void ssl_ReadComplete( PCLIENT pc, POINTER buffer, size_t length )
{
#ifdef DEBUG_SSL_IO
	lprintf( "SSL Read complete %p %zd", buffer, length );
#endif
	if( pc->ssl_session )
	{
		EnterCriticalSec( &pc->ssl_session->csRead );
		if( buffer )
		{
			int len;
			int hs_rc;
			//lprintf( "Read from network: %d", length );
			//LogBinary( (const uint8_t*)buffer, length );
			len = BIO_write( pc->ssl_session->rbio, buffer, (int)length );
#ifdef DEBUG_SSL_IO
			lprintf( "Wrote %zd", len );
#endif
			if( len < (int)length ) {
				lprintf( "Protocol failure?" );
				LeaveCriticalSec( &pc->ssl_session->csRead );
				Release( pc->ssl_session );
				RemoveClient( pc );
				return;
			}
			if( !( hs_rc = handshake( pc ) ) ) {
				if( !pc->ssl_session ) return;
#ifdef DEBUG_SSL_IO
				// normal condition...
				lprintf( "Receive handshake not complete iBuffer" );
#endif
				LeaveCriticalSec( &pc->ssl_session->csRead );
				ReadTCP( pc, pc->ssl_session->ibuffer, pc->ssl_session->ibuflen );
				return;
			}
			if( !pc->ssl_session ) return;
			// == 1 if is already done, and not newly done
			if( hs_rc == 2 ) {
				// newly completed handshake.
				if( !(pc->dwFlags & CF_READPENDING) ) {
					if( !pc->ssl_session->ignoreVerification && SSL_get_peer_certificate( pc->ssl_session->ssl ) ) {
						int r;
						if( ( r = SSL_get_verify_result( pc->ssl_session->ssl ) ) != X509_V_OK ) {
							lprintf( "Certificate verification failed. %d", r );
							LeaveCriticalSec( &pc->ssl_session->csRead );
							RemoveClientEx( pc, 0, 1 );
							return;
							//ERR_print_errors_cb( logerr, (void*)__LINE__ );
						}
					}
					//lprintf( "Initial read dispatch.." );
					if( pc->ssl_session->dwOriginalFlags & CF_CPPREAD )
						pc->ssl_session->cpp_user_read( pc->psvRead, NULL, 0 );
					else
						pc->ssl_session->user_read( pc, NULL, 0 );
				}
				len = 0;
			}
			else if( hs_rc == 1 )
			{
			read_more:
				len = SSL_read( pc->ssl_session->ssl, NULL, 0 );
				//lprintf( "return of 0 read: %d", len );
				//if( len < 0 )
				//	lprintf( "error of 0 read is %d", SSL_get_error( pc->ssl_session->ssl, len ) );
				len = SSL_pending( pc->ssl_session->ssl );
				//lprintf( "do read.. pending %d", len );
				if( len ) {
					if( len > (int)pc->ssl_session->dbuflen ) {
						//lprintf( "Needed to expand buffer..." );
						Release( pc->ssl_session->dbuffer );
						pc->ssl_session->dbuflen = ( len + 4095 ) & 0xFFFF000;
						pc->ssl_session->dbuffer = NewArray( uint8_t, pc->ssl_session->dbuflen );
					}
					len = SSL_read( pc->ssl_session->ssl, pc->ssl_session->dbuffer, (int)pc->ssl_session->dbuflen );
#ifdef DEBUG_SSL_IO
					lprintf( "normal read - just get the data from the other buffer : %d", len );
#endif
					if( len < 0 ) {
						int error = SSL_get_error( pc->ssl_session->ssl, len );
						if( error == SSL_ERROR_WANT_READ ) {
							lprintf( "want more data?" );
						} else
							lprintf( "SSL_Read failed. %d", error );
						//ERR_print_errors_cb( logerr, (void*)__LINE__ );
						//RemoveClient( pc );
						//return;
					}
				}
			}
			else if( hs_rc == -1 ) {
				LeaveCriticalSec( &pc->ssl_session->csRead );
				  RemoveClient( pc );
				  return;
			}
			else
				len = 0;
			{
				// the read generated write data, output that data
				size_t pending = BIO_ctrl_pending( pc->ssl_session->wbio );
				if( !pc->ssl_session ) {
					lprintf( "SSL SESSION SELF DESTRUCTED!" );
				}
				if( pending > 0 ) {
					int read;
#ifdef DEBUG_SSL_IO
					lprintf( "pending to send is %zd into %zd %p " , pending, pc->ssl_session->obuflen, pc->ssl_session->obuffer );
#endif
					if( pending > pc->ssl_session->obuflen ) {
						if( pc->ssl_session->obuffer )
							Deallocate( uint8_t *, pc->ssl_session->obuffer );
						pc->ssl_session->obuffer = NewArray( uint8_t, pc->ssl_session->obuflen = pending * 2 );
						//lprintf( "making obuffer bigger %d %d", pending, pending * 2 );
					}
					read  = BIO_read( pc->ssl_session->wbio, pc->ssl_session->obuffer, (int)pending );
					if( read < 0 ) {
						ERR_print_errors_cb( logerr, (void*)__LINE__ );
						lprintf( "failed to read pending control data...SSL will fail without it." );
					} else {
#ifdef DEBUG_SSL_IO
						lprintf( "Send pending control %p %d", pc->ssl_session->obuffer, read );
#endif
						SendTCP( pc, pc->ssl_session->obuffer, read );
						if( !pc->ssl_session ) return;
					}
				}
			}
			// do was have any decrypted data to give to the application?
			if( len > 0 ) {
#ifdef DEBUG_SSL_IO
				lprintf( "READ BUFFER:" );
				LogBinary( pc->ssl_session->dbuffer, len );
#endif
				if( pc->ssl_session->dwOriginalFlags & CF_CPPREAD )
					pc->ssl_session->cpp_user_read( pc->psvRead, pc->ssl_session->dbuffer, len );
				else
					pc->ssl_session->user_read( pc, pc->ssl_session->dbuffer, len );
 // might have closed during read.
				if( pc->ssl_session )
					goto read_more;
			}
			else if( len == 0 ) {
#ifdef DEBUG_SSL_IO
				lprintf( "incomplete read" );
#endif
			}
			//else {
			//	lprintf( "SSL_Read failed." );
			//	ERR_print_errors_cb( logerr, (void*)__LINE__ );
			//	RemoveClient( pc );
			//}
		}
		else {
			pc->ssl_session->ibuffer = NewArray( uint8_t, pc->ssl_session->ibuflen = (4327 + 39) );
			pc->ssl_session->dbuffer = NewArray( uint8_t, pc->ssl_session->dbuflen = 4096 );
			{
				int r;
				if( ( r = SSL_do_handshake( pc->ssl_session->ssl ) ) < 0 ) {
					//char buf[256];
					//r = SSL_get_error( ses->ssl, r );
					ERR_print_errors_cb( logerr, (void*)__LINE__ );
					//lprintf( "err: %s", ERR_error_string( r, buf ) );
				}
				{
					// the read generated write data, output that data
					size_t pending = BIO_ctrl_pending( pc->ssl_session->wbio );
#ifdef DEBUG_SSL_IO
					lprintf( "Pending Control To Send: %d", pending );
#endif
					if( pending > 0 ) {
						int read;
						if( pending > pc->ssl_session->obuflen ) {
							if( pc->ssl_session->obuffer )
								Deallocate( uint8_t *, pc->ssl_session->obuffer );
							pc->ssl_session->obuffer = NewArray( uint8_t, pc->ssl_session->obuflen = pending * 2 );
							//lprintf( "making obuffer bigger %d %d", pending, pending * 2 );
						}
						read = BIO_read( pc->ssl_session->wbio, pc->ssl_session->obuffer, (int)pc->ssl_session->obuflen );
						SendTCP( pc, pc->ssl_session->obuffer, read );
					}
				}
			}
		}
		//lprintf( "Read more data..." );
		if( pc->ssl_session ) {
			LeaveCriticalSec( &pc->ssl_session->csRead );
			ReadTCP( pc, pc->ssl_session->ibuffer, pc->ssl_session->ibuflen );
		}
	}
}
LOGICAL ssl_Send( PCLIENT pc, CPOINTER buffer, size_t length )
{
	int len;
	int32_t len_out;
	size_t offset = 0;
	size_t pending_out = length;
	struct ssl_session *ses = pc->ssl_session;
	if( !ses )
		return FALSE;
	while( length ) {
#ifdef DEBUG_SSL_IO
		lprintf( "SSL SEND...." );
		LogBinary( (uint8_t*)buffer, length );
#endif
		if( pending_out > 4327 )
			pending_out = 4327;
#ifdef DEBUG_SSL_IO
		lprintf( "Sending %d of %d at %d", pending_out, length, offset );
#endif
		EnterCriticalSec( &pc->ssl_session->csWrite );
		len = SSL_write( pc->ssl_session->ssl, (((uint8_t*)buffer) + offset), (int)pending_out );
		if (len < 0) {
			ERR_print_errors_cb(logerr, (void*)__LINE__);
			LeaveCriticalSec( &pc->ssl_session->csWrite );
			return FALSE;
		}
		offset += len;
		length -= (size_t)len;
		pending_out = length;
		// signed/unsigned comparison here.
		// the signed value is known to be greater than 0 and less than max unsigned int
		// so it is in a valid range to check, and is NOT a warning or error condition EVER.
		len = BIO_pending( pc->ssl_session->wbio );
		//lprintf( "resulting send is %d", len );
		if( SUS_GT( len, int, ses->obuflen, size_t ) )
		{
			Release( ses->obuffer );
#ifdef DEBUG_SSL_IO
			lprintf( "making obuffer bigger %d %d", len, len * 2 );
#endif
			ses->obuffer = NewArray( uint8_t, len * 2 );
			ses->obuflen = len * 2;
		}
		len_out = BIO_read( pc->ssl_session->wbio, ses->obuffer, (int)ses->obuflen );
#ifdef DEBUG_SSL_IO
		lprintf( "ssl_Send  %d", len_out );
#endif
		SendTCP( pc, ses->obuffer, len_out );
		if( pc->ssl_session )
			LeaveCriticalSec( &pc->ssl_session->csWrite );
	}
	return TRUE;
}
static LOGICAL ssl_InitLibrary( void ){
	if( !ssl_global.flags.bInited )
	{
		SSL_library_init();
		//tls_init();
		//ssl_global.tls_config = tls_config_new();
		SSL_load_error_strings();
		ERR_load_BIO_strings();
		OpenSSL_add_all_algorithms();
		ssl_global.flags.bInited = 1;
	}
	return TRUE;
}
static void ssl_InitSession( struct ssl_session *ses ) {
	ses->rbio = BIO_new( BIO_s_mem() );
	ses->wbio = BIO_new( BIO_s_mem() );
	SSL_set_bio( ses->ssl, ses->rbio, ses->wbio );
	InitializeCriticalSec( &ses->csRead );
	InitializeCriticalSec( &ses->csWrite );
}
static void ssl_CloseCallback( PCLIENT pc ) {
	struct ssl_session *ses = pc->ssl_session;
	if (!ses) {
		lprintf("already closed?");
		return;
	}
	pc->ssl_session = NULL;
	//lprintf( "Socket got close event... notify application..." );
	if( ses->dwOriginalFlags & CF_CPPCLOSE )
		ses->cpp_user_close( pc->psvClose );
	else
		ses->user_close( pc );
	DeleteCriticalSec( &ses->csRead );
	DeleteCriticalSec( &ses->csWrite );
	Release( ses->dbuffer );
	Release( ses->ibuffer );
	Release( ses->obuffer );
	if( ses->cert ) {
		EVP_PKEY_free( ses->cert->pkey );
		X509_free( ses->cert->x509 );
		Release( ses->cert );
	}
	SSL_free( ses->ssl );
	SSL_CTX_free( ses->ctx );
	// these are closed... with the ssl connection.
	//BIO_free( ses->rbio );
	//BIO_free( ses->wbio );
	Release( ses );
}
static void ssl_ClientConnected( PCLIENT pcServer, PCLIENT pcNew ) {
	struct ssl_session *ses;
	ses = New( struct ssl_session );
	MemSet( ses, 0, sizeof( struct ssl_session ) );
	ses->ssl = SSL_new( pcServer->ssl_session->ctx );
	{
		static uint32_t tick;
		tick++;
//sizeof( ses->ctx ) );
		SSL_set_session_id_context( ses->ssl, (const unsigned char*)&tick, 4 );
	}
	ssl_InitSession( ses );
	SSL_set_accept_state( ses->ssl );
	pcNew->ssl_session = ses;
	if( pcServer->ssl_session->dwOriginalFlags & CF_CPPCONNECT )
		pcServer->ssl_session->cpp_user_connected( pcServer->psvConnect, pcNew );
	else
		pcServer->ssl_session->user_connected( pcServer, pcNew);
	ses->user_read = pcNew->read.ReadComplete;
	ses->cpp_user_read = pcNew->read.CPPReadComplete;
	ses->user_close = pcNew->close.CloseCallback;
	ses->cpp_user_close = pcNew->close.CPPCloseCallback;
	pcNew->read.ReadComplete = ssl_ReadComplete;
	pcNew->dwFlags &= ~CF_CPPREAD;
	pcNew->close.CloseCallback = ssl_CloseCallback;
	pcNew->dwFlags &= ~CF_CPPCLOSE;
	ses->dwOriginalFlags = pcServer->ssl_session->dwOriginalFlags;
}
struct info_params {
	char *password;
	int passlen;
};
static int pem_password( char *buf, int size, int rwflag, void *u )
{
	// rwflag = 0  = used for decryption
	// rwflag = 1  = used for encryption
	struct info_params *params = (struct info_params*)u;
	int len;
	memcpy( buf, params->password, len = (size<params->passlen ? size : params->passlen) );
	return len;
}
LOGICAL ssl_BeginServer( PCLIENT pc, CPOINTER cert, size_t certlen, CPOINTER keypair, size_t keylen, CPOINTER keypass, size_t keypasslen ) {
	struct ssl_session * ses;
	ses = New( struct ssl_session );
	MemSet( ses, 0, sizeof( struct ssl_session ) );
	ssl_InitLibrary();
	pc->flags.bSecure = 1;
	if( !cert ) {
		ses->cert = MakeRequest();
	} else {
		struct internalCert *certStruc = New( struct internalCert );
		BIO *keybuf = BIO_new( BIO_s_mem() );
		X509 *x509, *result;
		certStruc->chain = NULL;
		certStruc->chain = sk_X509_new_null();
		//PKCS12_parse( )
		BIO_write( keybuf, cert, (int)certlen );
		do {
			if( !BIO_pending( keybuf ) )
				break;
			x509 = X509_new();
			result = PEM_read_bio_X509( keybuf, &x509, NULL, NULL );
			if( result )
				sk_X509_push( certStruc->chain, x509 );
			else {
				ERR_print_errors_cb( logerr, (void*)__LINE__ );
				X509_free( x509 );
			}
		} while( result );
		BIO_free( keybuf );
		ses->cert = certStruc;
	}
	if( !keypair ) {
		if( !ses->cert->pkey )
			ses->cert->pkey = genKey();
	} else {
		BIO *keybuf = BIO_new( BIO_s_mem() );
		struct info_params params;
		EVP_PKEY *result;
		ses->cert->pkey = EVP_PKEY_new();
		BIO_write( keybuf, keypair, (int)keylen );
		params.password = (char*)keypass;
		params.passlen = (int)keypasslen;
		result = PEM_read_bio_PrivateKey( keybuf, &ses->cert->pkey, pem_password, &params );
		if( !result ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
		}
		BIO_free( keybuf );
	}
#ifdef HACK_NODE_TLS
/*TLSv1_2_server_method()*/
	ses->ctx = SSL_CTX_new( TLS_server_method() );
#else
	ses->ctx = SSL_CTX_new( TLSv1_2_server_method() );
#endif
	{
		int r;
		SSL_CTX_set_cipher_list( ses->ctx, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH" );
		/*
		r = SSL_CTX_set0_chain( ses->ctx, ses->cert->chain );
		if( r <= 0 ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
		}
		*/
		r = SSL_CTX_use_certificate( ses->ctx, sk_X509_value( ses->cert->chain, 0 ) );
		if( r <= 0 ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
		}
		r = SSL_CTX_use_PrivateKey( ses->ctx, ses->cert->pkey );
		if( r <= 0 ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
		}
		{
			int n;
			for( n = 1; n < sk_X509_num( ses->cert->chain ); n++ ) {
				r = SSL_CTX_add_extra_chain_cert( ses->ctx, sk_X509_value( ses->cert->chain, n ) );
				if( r <= 0 ) {
					ERR_print_errors_cb( logerr, (void*)__LINE__ );
				}
			}
		}
		r = SSL_CTX_check_private_key( ses->ctx );
		if( r <= 0 ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
		}
//sizeof( ses->ctx ) );
		r = SSL_CTX_set_session_id_context( ses->ctx, (const unsigned char*)"12345678", 8 );
		if( r <= 0 ) {
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
		}
		//r = SSL_CTX_get_session_cache_mode( ses->ctx );
		//r = SSL_CTX_set_session_cache_mode( ses->ctx, SSL_SESS_CACHE_SERVER );
		r = SSL_CTX_set_session_cache_mode( ses->ctx, SSL_SESS_CACHE_OFF );
		if( r <= 0 )
			ERR_print_errors_cb( logerr, (void*)__LINE__ );
	}
	ses->dwOriginalFlags = pc->dwFlags;
	ses->user_connected = pc->connect.ClientConnected;
	ses->cpp_user_connected = pc->connect.CPPClientConnected;
	pc->connect.ClientConnected = ssl_ClientConnected;
	pc->dwFlags &= ~CF_CPPCONNECT;
	pc->ssl_session = ses;
	// at this point pretty much have to assume
	// that it will be OK.
	return TRUE;
}
LOGICAL ssl_GetPrivateKey( PCLIENT pc, POINTER *keyoutbuf, size_t *keylen ) {
	if( pc && keyoutbuf && keylen ) {
		struct ssl_session * ses = pc->ssl_session;
		BIO *keybuf = BIO_new( BIO_s_mem() );
		if( !ses->cert->pkey )
			ses->cert->pkey = genKey();
		PEM_write_bio_PrivateKey( keybuf, ses->cert->pkey, NULL, NULL, 0, NULL, NULL );
		(*keylen) = BIO_pending( keybuf );
		(*keyoutbuf) = NewArray( uint8_t, (*keylen) + 1 );
		BIO_read( keybuf, (*keyoutbuf), (int)(*keylen) );
		((char*)*keyoutbuf)[(*keylen)] = 0;
		return TRUE;
	}
	return FALSE;
}
LOGICAL ssl_BeginClientSession( PCLIENT pc, CPOINTER client_keypair, size_t client_keypairlen, CPOINTER keypass, size_t keypasslen, CPOINTER rootCert, size_t rootCertLen )
{
	struct ssl_session * ses;
	ssl_InitLibrary();
	ses = New( struct ssl_session );
	MemSet( ses, 0, sizeof( struct ssl_session ) );
	{
#ifdef NODE_MAJOR_VERSION
#  if NODE_MAJOR_VERSION >= 10
 /*TLSv1_2_client_method()*/
		ses->ctx = SSL_CTX_new( TLS_client_method() );
#  else
		ses->ctx = SSL_CTX_new( TLSv1_2_client_method() );
#  endif
#else
		ses->ctx = SSL_CTX_new( TLSv1_2_client_method() );
#endif
		SSL_CTX_set_cipher_list( ses->ctx, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH" );
		ses->cert = New( struct internalCert );
		if( !client_keypair )
			ses->cert->pkey = genKey();
		else {
			BIO *keybuf = BIO_new( BIO_s_mem() );
			struct info_params params;
			BIO_write( keybuf, client_keypair, (int)client_keypairlen );
			params.password = (char*)keypass;
			params.passlen = (int)keypasslen;
			ses->cert->pkey = EVP_PKEY_new();
			if( !PEM_read_bio_PrivateKey( keybuf, &ses->cert->pkey, pem_password, &params ) ) {
				ERR_print_errors_cb( logerr, (void*)__LINE__ );
				BIO_free( keybuf );
				return FALSE;
			}
			BIO_free( keybuf );
		}
		SSL_CTX_use_PrivateKey( ses->ctx, ses->cert->pkey );
		//SSL_CTX_set_default_read_buffer_len( ses->ctx, 16384 );
	}
	ses->ssl = SSL_new( ses->ctx );
	if( rootCert ) {
		BIO *keybuf = BIO_new( BIO_s_mem() );
		X509 *cert;
		cert = X509_new();
		BIO_write( keybuf, rootCert, (int)rootCertLen );
		PEM_read_bio_X509( keybuf, &cert, NULL, NULL );
		BIO_free( keybuf );
		X509_STORE *store = SSL_CTX_get_cert_store( ses->ctx );
		X509_STORE_add_cert( store, cert );
	} else {
		X509_STORE *store = SSL_CTX_get_cert_store( ses->ctx );
		loadSystemCerts( store );
	}
	ssl_InitSession( ses );
	//SSL_set_default_read_buffer_len( ses->ssl, 16384 );
	SSL_set_connect_state( ses->ssl );
	ses->dwOriginalFlags = pc->dwFlags;
	ses->user_read = pc->read.ReadComplete;
	ses->cpp_user_read = pc->read.CPPReadComplete;
	pc->read.ReadComplete = ssl_ReadComplete;
	pc->dwFlags &= ~CF_CPPREAD;
	pc->ssl_session = ses;
	return TRUE;
}
LOGICAL ssl_IsClientSecure(PCLIENT pc) {
	return pc->ssl_session != NULL;
}
void ssl_SetIgnoreVerification( PCLIENT pc ) {
	if( pc->ssl_session )
		pc->ssl_session->ignoreVerification = TRUE;
}
//--------------------- Make Cert Request
//#include <stdio.h>
//#include <stdlib.h>
//#include <openssl/x509.h>
//#include <openssl/x509v3.h>
//#include <openssl/err.h>
//#include <openssl/pem.h>
//#include <openssl/evp.h>
// Fatal error; abort with message, including file and line number
//
static int cb(const char *str, size_t len, void *u)  {
	lprintf( "%s", str);
	return 1;
}
static void fatal_error(const char *file, int line, const char *msg)
{
	fprintf(stderr, "**FATAL** %s:%i %s\n", file, line, msg);
	fprintf( stderr, "specific error available, but not dumped; ERR_print_errors_fp is gone" );
	ERR_print_errors_cb( cb, 0 );
	//ERR_print_errors_fp(stderr);
	exit(-1);
}
#define fatal(msg) fatal_error(__FILE__, __LINE__, msg)
// Parameter settings for this cert
//
#define ENTRIES (sizeof(entries)/sizeof(entries[0]))
// declare array of entries to assign to cert
struct entry
{
	const char *key;
	const char *value;
};
struct entry entries[] =
{
    { "countryName", "US" },
    { "stateOrProvinceName", "NV" },
    { "localityName", "Las Vegas" },
    { "organizationName", "d3x0r.org" },
    { "organizationalUnitName", "Development" },
    { "commonName", "Internal Project" },
};
// main ---
//
//
//int main(int argc, char *argv[])
struct internalCert * MakeRequest( void )
{
	 struct internalCert *cert = NewArray( struct internalCert, 1 );
	 int ca_len;
 // already cached key
	 int key_len;
	 char* ca;
	 char* key;
	 BIO *keybuf = BIO_new( BIO_s_mem() );
	 MemSet( cert, 0, sizeof( struct internalCert ) );
	 // Create evp obj to hold our rsakey
	 //
	 if( !(cert->pkey = EVP_PKEY_new()) )
		 fatal( "Could not create EVP object" );
#ifndef __NO_OPTIONS__
	 ca_len = SACK_GetProfileInt( "TLS", "CA Length", 0 );
#else
	 ca_len = 0;
#endif
	 if( ca_len ) {
		 ca = NewArray( char, ca_len + 2 );
#ifndef __NO_OPTIONS__
		 SACK_GetProfileString( "TLS", "CA Cert", "", ca, ca_len + 1 );
#endif
		 BIO_write( keybuf, ca, ca_len );
		 Deallocate( void *, ca );
		 cert->x509 = X509_new();
		 PEM_read_bio_X509( keybuf, &cert->x509, NULL, NULL );
	 }
#ifndef __NO_OPTIONS__
	 key_len = SACK_GetProfileInt( "TLS", "Key Length", 0 );
#else
	 key_len = 0;
#endif
	if( key_len ) {
		 key = NewArray( char, key_len + 2 );
#ifndef __NO_OPTIONS__
		 SACK_GetProfileString( "TLS", "Key", "", (TEXTCHAR*)key, key_len + 1 );
#endif
		 BIO_write( keybuf, key, key_len );
		 Deallocate( void *, key );
		 PEM_read_bio_PrivateKey( keybuf, &cert->pkey, NULL, NULL );
	} else {
		RSA *rsa = RSA_new();
		BIGNUM *bne = BN_new();
		int ret;
		ret = BN_set_word( bne, kExp );
		if( ret != 1 ) {
			BN_free( bne );
			RSA_free( rsa );
			fatal( "Could not set Bignum?" );
			return NULL;
		}
		RSA_generate_key_ex( rsa, serverKBits, bne, NULL );
		if( !(EVP_PKEY_set1_RSA( cert->pkey, rsa )) )
			fatal( "Could not assign RSA key to EVP object" );
		BN_free( bne );
		RSA_free( rsa );
		{
			PEM_write_bio_PrivateKey( keybuf, cert->pkey,
 //EVP_des_ede3_cbc(), /* default cipher for encrypting the key on disk */
				NULL,
 //"replace_me",       /* passphrase required for decrypting the key on disk */
				NULL,
				10,
				NULL,
				NULL
			);
			ca_len = BIO_pending( keybuf );
			ca = NewArray( char, ca_len + 1 );
			BIO_read( keybuf, ca, ca_len );
			ca[ca_len] = 0;
			SACK_WriteProfileInt( "TLS", "Key Length", ca_len );
			SACK_WriteProfileString( "TLS", "Key", (TEXTCHAR*)ca );
			Release( ca );
		}
	}
    // seed openssl's prng
    //
    /*
    if (RAND_load_file("/dev/random", -1))
        fatal("Could not seed prng");
    */
    // Generate the RSA key; we don't assign a callback to monitor progress
    // since generating keys is fast enough these days
    //
	if (!cert->x509)
	{
		X509 * x509;
		if (!cert->x509)
			cert->x509 = X509_new();
		x509 = cert->x509;
		ASN1_INTEGER_set( X509_get_serialNumber( x509 ), 1 );
		X509_gmtime_adj( X509_get_notBefore( x509 ), 0 );
		// (60 seconds * 60 minutes * 24 hours * 365 days) = 31536000.
		X509_gmtime_adj( X509_get_notAfter( x509 ), 31536000L );
		X509_set_pubkey( x509, cert->pkey );
		{
			X509_NAME *name;
			TEXTCHAR commonName[48];
			TEXTCHAR org[48];
			TEXTCHAR country[8];
#ifndef __NO_OPTIONS__
			SACK_GetProfileString( "TLS", "Default CA Common Name", "d3x0r.org", commonName, 48 );
			SACK_GetProfileString( "TLS", "Default CA Org", "Freedom Collective", org, 48 );
			SACK_GetProfileString( "TLS", "Default CA Country", "US", country, 8 );
#else
			strcpy( commonName, "d3x0r.org" );
			strcpy( org, "Freedom Collective" );
			strcpy( country, "US" );
#endif
			name = X509_get_subject_name( x509 );
			X509_NAME_add_entry_by_txt( name, "C", MBSTRING_ASC,
				(unsigned char *)country, -1, -1, 0 );
			X509_NAME_add_entry_by_txt( name, "O", MBSTRING_ASC,
				(unsigned char *)org, -1, -1, 0 );
			X509_NAME_add_entry_by_txt( name, "CN", MBSTRING_ASC,
				(unsigned char *)commonName, -1, -1, 0 );
			X509_set_issuer_name( x509, name );
			X509_sign( x509, cert->pkey, EVP_sha512() );
			cert->chain = sk_X509_new_null();
			sk_X509_push( cert->chain, x509 );
			{
				PEM_write_bio_X509( keybuf, x509 );
				ca_len = BIO_pending( keybuf );
				ca = NewArray( char, ca_len + 1 );
				BIO_read( keybuf, ca, ca_len );
				ca[ca_len] = 0;
				SACK_WriteProfileInt( "TLS", "CA Length", ca_len );
				SACK_WriteProfileString( "TLS", "CA Cert", (TEXTCHAR*)ca );
				Release( ca );
			}
		}
	}
	return cert;
}
#ifdef __LINUX__
void loadSystemCerts( X509_STORE *store )
{
   return;
}
#endif
#ifdef _WIN32
#define MY_ENCODING_TYPE  (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)
void loadSystemCerts( X509_STORE *store )
{
	HCERTSTORE hStore;
	PCCERT_CONTEXT pContext = NULL;
	X509 *x509;
	hStore = CertOpenSystemStore((HCRYPTPROV_LEGACY)NULL, "ROOT");
	if( !hStore ) {
		lprintf( "FATAL, CANNOT OPEN ROOT STORE" );
		return;
	}
	while (pContext = CertEnumCertificatesInStore(hStore, pContext))
	{
		//uncomment the line below if you want to see the certificates as pop ups
		//CryptUIDlgViewContext(CERT_STORE_CERTIFICATE_CONTEXT, pContext,   NULL, NULL, 0, NULL);
		const unsigned char *encoded_cert = (const unsigned char *)pContext->pbCertEncoded;
		x509 = NULL;
		x509 = d2i_X509(NULL, &encoded_cert, pContext->cbCertEncoded);
		if (x509)
		{
			int i = X509_STORE_add_cert(store, x509);
			//if (i == 1)
			//	std::cout << "certificate added" << std::endl;
			//printf( "adde cert to store?", i );
			X509_free(x509);
		}
	}
	CertFreeCertificateContext(pContext);
	CertCloseStore(hStore, 0);
}
#endif
SACK_NETWORK_NAMESPACE_END
#endif
#endif
#define NO_UNICODE_C
#ifdef __WATCOMC__
// definition of SH_DENYNO
#endif
#define SQLLIB_SOURCE
#define BUILDS_INTERFACE
#define DEFINES_SQLITE_INTERFACE
#ifndef SQL_STRUCT_DEFINED
#define SQL_STRUCT_DEFINED
# if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
/*
** 2001-09-15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This header file defines the interface that the SQLite library
** presents to client programs.  If a C-function, structure, datatype,
** or constant definition does not appear in this file, then it is
** not a published API of SQLite, is subject to change without
** notice, and should not be referenced by programs that use SQLite.
**
** Some of the definitions that are in this file are marked as
** "experimental".  Experimental interfaces are normally new
** features recently added to SQLite.  We do not anticipate changes
** to experimental interfaces but reserve the right to make minor changes
** if experience from use "in the wild" suggest such changes are prudent.
**
** The official C-language API documentation for SQLite is derived
** from comments in this file.  This file is the authoritative source
** on how SQLite interfaces are supposed to operate.
**
** The name of this file under configuration management is "sqlite.h.in".
** The makefile makes some minor changes to this file (such as inserting
** the version number) and changes its name to "sqlite3.h" as
** part of the build process.
*/
#ifndef SQLITE3_H
#define SQLITE3_H
/*
** Make sure we can call this stuff from C++.
*/
#ifdef __cplusplus
extern "C" {
#endif
/*
** Provide the ability to override linkage features of the interface.
*/
#ifndef SQLITE_EXTERN
# define SQLITE_EXTERN extern
#endif
#ifndef SQLITE_API
# define SQLITE_API
#endif
#ifndef SQLITE_CDECL
# define SQLITE_CDECL
#endif
#ifndef SQLITE_APICALL
# define SQLITE_APICALL
#endif
#ifndef SQLITE_STDCALL
# define SQLITE_STDCALL SQLITE_APICALL
#endif
#ifndef SQLITE_CALLBACK
# define SQLITE_CALLBACK
#endif
#ifndef SQLITE_SYSAPI
# define SQLITE_SYSAPI
#endif
/*
** These no-op macros are used in front of interfaces to mark those
** interfaces as either deprecated or experimental.  New applications
** should not use deprecated interfaces - they are supported for backwards
** compatibility only.  Application writers should be aware that
** experimental interfaces are subject to change in point releases.
**
** These macros used to resolve to various kinds of compiler magic that
** would generate warning messages when they were used.  But that
** compiler magic ended up generating such a flurry of bug reports
** that we have taken it all out and gone back to using simple
** noop macros.
*/
#define SQLITE_DEPRECATED
#define SQLITE_EXPERIMENTAL
/*
** Ensure these symbols were not defined by some previous header file.
*/
#ifdef SQLITE_VERSION
# undef SQLITE_VERSION
#endif
#ifdef SQLITE_VERSION_NUMBER
# undef SQLITE_VERSION_NUMBER
#endif
/*
** CAPI3REF: Compile-Time Library Version Numbers
**
** ^(The [SQLITE_VERSION] C preprocessor macro in the sqlite3.h header
** evaluates to a string literal that is the SQLite version in the
** format "X.Y.Z" where X is the major version number (always 3 for
** SQLite3) and Y is the minor version number and Z is the release number.)^
** ^(The [SQLITE_VERSION_NUMBER] C preprocessor macro resolves to an integer
** with the value (X*1000000 + Y*1000 + Z) where X, Y, and Z are the same
** numbers used in [SQLITE_VERSION].)^
** The SQLITE_VERSION_NUMBER for any given release of SQLite will also
** be larger than the release from which it is derived.  Either Y will
** be held constant and Z will be incremented or else Y will be incremented
** and Z will be reset to zero.
**
** Since [version 3.6.18] ([dateof:3.6.18]),
** SQLite source code has been stored in the
** <a href="http://www.fossil-scm.org/">Fossil configuration management
** system</a>.  ^The SQLITE_SOURCE_ID macro evaluates to
** a string which identifies a particular check-in of SQLite
** within its configuration management system.  ^The SQLITE_SOURCE_ID
** string contains the date and time of the check-in (UTC) and a SHA1
** or SHA3-256 hash of the entire source tree.  If the source code has
** been edited in any way since it was last checked in, then the last
** four hexadecimal digits of the hash may be modified.
**
** See also: [sqlite3_libversion()],
** [sqlite3_libversion_number()], [sqlite3_sourceid()],
** [sqlite_version()] and [sqlite_source_id()].
*/
#define SQLITE_VERSION        "3.23.0"
#define SQLITE_VERSION_NUMBER 3023000
#define SQLITE_SOURCE_ID      "2018-01-07 21:58:17 0a50c9e3bb0dbdaaec819ac6453276ba287b475ea322918ddda1ab3a1ec4alt1"
/*
** CAPI3REF: Run-Time Library Version Numbers
** KEYWORDS: sqlite3_version sqlite3_sourceid
**
** These interfaces provide the same information as the [SQLITE_VERSION],
** [SQLITE_VERSION_NUMBER], and [SQLITE_SOURCE_ID] C preprocessor macros
** but are associated with the library instead of the header file.  ^(Cautious
** programmers might include assert() statements in their application to
** verify that values returned by these interfaces match the macros in
** the header, and thus ensure that the application is
** compiled with matching library and header files.
**
** <blockquote><pre>
** assert( sqlite3_libversion_number()==SQLITE_VERSION_NUMBER );
** assert( strncmp(sqlite3_sourceid(),SQLITE_SOURCE_ID,80)==0 );
** assert( strcmp(sqlite3_libversion(),SQLITE_VERSION)==0 );
** </pre></blockquote>)^
**
** ^The sqlite3_version[] string constant contains the text of [SQLITE_VERSION]
** macro.  ^The sqlite3_libversion() function returns a pointer to the
** to the sqlite3_version[] string constant.  The sqlite3_libversion()
** function is provided for use in DLLs since DLL users usually do not have
** direct access to string constants within the DLL.  ^The
** sqlite3_libversion_number() function returns an integer equal to
** [SQLITE_VERSION_NUMBER].  ^(The sqlite3_sourceid() function returns
** a pointer to a string constant whose value is the same as the
** [SQLITE_SOURCE_ID] C preprocessor macro.  Except if SQLite is built
** using an edited copy of [the amalgamation], then the last four characters
** of the hash might be different from [SQLITE_SOURCE_ID].)^
**
** See also: [sqlite_version()] and [sqlite_source_id()].
*/
SQLITE_API SQLITE_EXTERN const char sqlite3_version[];
SQLITE_API const char *sqlite3_libversion(void);
SQLITE_API const char *sqlite3_sourceid(void);
SQLITE_API int sqlite3_libversion_number(void);
/*
** CAPI3REF: Run-Time Library Compilation Options Diagnostics
**
** ^The sqlite3_compileoption_used() function returns 0 or 1
** indicating whether the specified option was defined at
** compile time.  ^The SQLITE_ prefix may be omitted from the
** option name passed to sqlite3_compileoption_used().
**
** ^The sqlite3_compileoption_get() function allows iterating
** over the list of options that were defined at compile time by
** returning the N-th compile time option string.  ^If N is out of range,
** sqlite3_compileoption_get() returns a NULL pointer.  ^The SQLITE_
** prefix is omitted from any strings returned by
** sqlite3_compileoption_get().
**
** ^Support for the diagnostic functions sqlite3_compileoption_used()
** and sqlite3_compileoption_get() may be omitted by specifying the
** [SQLITE_OMIT_COMPILEOPTION_DIAGS] option at compile time.
**
** See also: SQL functions [sqlite_compileoption_used()] and
** [sqlite_compileoption_get()] and the [compile_options pragma].
*/
#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS
SQLITE_API int sqlite3_compileoption_used(const char *zOptName);
SQLITE_API const char *sqlite3_compileoption_get(int N);
#endif
/*
** CAPI3REF: Test To See If The Library Is Threadsafe
**
** ^The sqlite3_threadsafe() function returns zero if and only if
** SQLite was compiled with mutexing code omitted due to the
** [SQLITE_THREADSAFE] compile-time option being set to 0.
**
** SQLite can be compiled with or without mutexes.  When
** the [SQLITE_THREADSAFE] C preprocessor macro is 1 or 2, mutexes
** are enabled and SQLite is threadsafe.  When the
** [SQLITE_THREADSAFE] macro is 0,
** the mutexes are omitted.  Without the mutexes, it is not safe
** to use SQLite concurrently from more than one thread.
**
** Enabling mutexes incurs a measurable performance penalty.
** So if speed is of utmost importance, it makes sense to disable
** the mutexes.  But for maximum safety, mutexes should be enabled.
** ^The default behavior is for mutexes to be enabled.
**
** This interface can be used by an application to make sure that the
** version of SQLite that it is linking against was compiled with
** the desired setting of the [SQLITE_THREADSAFE] macro.
**
** This interface only reports on the compile-time mutex setting
** of the [SQLITE_THREADSAFE] flag.  If SQLite is compiled with
** SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but
** can be fully or partially disabled using a call to [sqlite3_config()]
** with the verbs [SQLITE_CONFIG_SINGLETHREAD], [SQLITE_CONFIG_MULTITHREAD],
** or [SQLITE_CONFIG_SERIALIZED].  ^(The return value of the
** sqlite3_threadsafe() function shows only the compile-time setting of
** thread safety, not any run-time changes to that setting made by
** sqlite3_config(). In other words, the return value from sqlite3_threadsafe()
** is unchanged by calls to sqlite3_config().)^
**
** See the [threading mode] documentation for additional information.
*/
SQLITE_API int sqlite3_threadsafe(void);
/*
** CAPI3REF: Database Connection Handle
** KEYWORDS: {database connection} {database connections}
**
** Each open SQLite database is represented by a pointer to an instance of
** the opaque structure named "sqlite3".  It is useful to think of an sqlite3
** pointer as an object.  The [sqlite3_open()], [sqlite3_open16()], and
** [sqlite3_open_v2()] interfaces are its constructors, and [sqlite3_close()]
** and [sqlite3_close_v2()] are its destructors.  There are many other
** interfaces (such as
** [sqlite3_prepare_v2()], [sqlite3_create_function()], and
** [sqlite3_busy_timeout()] to name but three) that are methods on an
** sqlite3 object.
*/
typedef struct sqlite3 sqlite3;
/*
** CAPI3REF: 64-Bit Integer Types
** KEYWORDS: sqlite_int64 sqlite_uint64
**
** Because there is no cross-platform way to specify 64-bit integer types
** SQLite includes typedefs for 64-bit signed and unsigned integers.
**
** The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions.
** The sqlite_int64 and sqlite_uint64 types are supported for backwards
** compatibility only.
**
** ^The sqlite3_int64 and sqlite_int64 types can store integer values
** between -9223372036854775808 and +9223372036854775807 inclusive.  ^The
** sqlite3_uint64 and sqlite_uint64 types can store integer values
** between 0 and +18446744073709551615 inclusive.
*/
#ifdef SQLITE_INT64_TYPE
  typedef SQLITE_INT64_TYPE sqlite_int64;
# ifdef SQLITE_UINT64_TYPE
    typedef SQLITE_UINT64_TYPE sqlite_uint64;
# else
    typedef unsigned SQLITE_INT64_TYPE sqlite_uint64;
# endif
#elif defined(_MSC_VER) || defined(__BORLANDC__)
  typedef __int64 sqlite_int64;
  typedef unsigned __int64 sqlite_uint64;
#else
  typedef long long int sqlite_int64;
  typedef unsigned long long int sqlite_uint64;
#endif
typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
/*
** If compiling for a processor that lacks floating point support,
** substitute integer for floating-point.
*/
#ifdef SQLITE_OMIT_FLOATING_POINT
# define double sqlite3_int64
#endif
/*
** CAPI3REF: Closing A Database Connection
** DESTRUCTOR: sqlite3
**
** ^The sqlite3_close() and sqlite3_close_v2() routines are destructors
** for the [sqlite3] object.
** ^Calls to sqlite3_close() and sqlite3_close_v2() return [SQLITE_OK] if
** the [sqlite3] object is successfully destroyed and all associated
** resources are deallocated.
**
** ^If the database connection is associated with unfinalized prepared
** statements or unfinished sqlite3_backup objects then sqlite3_close()
** will leave the database connection open and return [SQLITE_BUSY].
** ^If sqlite3_close_v2() is called with unfinalized prepared statements
** and/or unfinished sqlite3_backups, then the database connection becomes
** an unusable "zombie" which will automatically be deallocated when the
** last prepared statement is finalized or the last sqlite3_backup is
** finished.  The sqlite3_close_v2() interface is intended for use with
** host languages that are garbage collected, and where the order in which
** destructors are called is arbitrary.
**
** Applications should [sqlite3_finalize | finalize] all [prepared statements],
** [sqlite3_blob_close | close] all [BLOB handles], and
** [sqlite3_backup_finish | finish] all [sqlite3_backup] objects associated
** with the [sqlite3] object prior to attempting to close the object.  ^If
** sqlite3_close_v2() is called on a [database connection] that still has
** outstanding [prepared statements], [BLOB handles], and/or
** [sqlite3_backup] objects then it returns [SQLITE_OK] and the deallocation
** of resources is deferred until all [prepared statements], [BLOB handles],
** and [sqlite3_backup] objects are also destroyed.
**
** ^If an [sqlite3] object is destroyed while a transaction is open,
** the transaction is automatically rolled back.
**
** The C parameter to [sqlite3_close(C)] and [sqlite3_close_v2(C)]
** must be either a NULL
** pointer or an [sqlite3] object pointer obtained
** from [sqlite3_open()], [sqlite3_open16()], or
** [sqlite3_open_v2()], and not previously closed.
** ^Calling sqlite3_close() or sqlite3_close_v2() with a NULL pointer
** argument is a harmless no-op.
*/
SQLITE_API int sqlite3_close(sqlite3*);
SQLITE_API int sqlite3_close_v2(sqlite3*);
/*
** The type for a callback function.
** This is legacy and deprecated.  It is included for historical
** compatibility and is not documented.
** sqlite3_exec
*/
typedef int (*sqlite3_callback)(void*,int,char**, char**);
/*
** The type for a v2 callback function.
** This is revival of legacy and deprecated.
** it is used with sqlite3_exec_v2();
*/
typedef int (*sqlite3_callback_v2)(void*,int,char**, char**, int*, int*);
/*
** CAPI3REF: One-Step Query Execution Interface
** METHOD: sqlite3
**
** The sqlite3_exec() interface is a convenience wrapper around
** [sqlite3_prepare_v2()], [sqlite3_step()], and [sqlite3_finalize()],
** that allows an application to run multiple statements of SQL
** without having to use a lot of C code.
**
** ^The sqlite3_exec() interface runs zero or more UTF-8 encoded,
** semicolon-separate SQL statements passed into its 2nd argument,
** in the context of the [database connection] passed in as its 1st
** argument.  ^If the callback function of the 3rd argument to
** sqlite3_exec() is not NULL, then it is invoked for each result row
** coming out of the evaluated SQL statements.  ^The 4th argument to
** sqlite3_exec() is relayed through to the 1st argument of each
** callback invocation.  ^If the callback pointer to sqlite3_exec()
** is NULL, then no callback is ever invoked and result rows are
** ignored.
**
** ^If an error occurs while evaluating the SQL statements passed into
** sqlite3_exec(), then execution of the current statement stops and
** subsequent statements are skipped.  ^If the 5th parameter to sqlite3_exec()
** is not NULL then any error message is written into memory obtained
** from [sqlite3_malloc()] and passed back through the 5th parameter.
** To avoid memory leaks, the application should invoke [sqlite3_free()]
** on error message strings returned through the 5th parameter of
** sqlite3_exec() after the error message string is no longer needed.
** ^If the 5th parameter to sqlite3_exec() is not NULL and no errors
** occur, then sqlite3_exec() sets the pointer in its 5th parameter to
** NULL before returning.
**
** ^If an sqlite3_exec() callback returns non-zero, the sqlite3_exec()
** routine returns SQLITE_ABORT without invoking the callback again and
** without running any subsequent SQL statements.
**
** ^The 2nd argument to the sqlite3_exec() callback function is the
** number of columns in the result.  ^The 3rd argument to the sqlite3_exec()
** callback is an array of pointers to strings obtained as if from
** [sqlite3_column_text()], one for each column.  ^If an element of a
** result row is NULL then the corresponding string pointer for the
** sqlite3_exec() callback is a NULL pointer.  ^The 4th argument to the
** sqlite3_exec() callback is an array of pointers to strings where each
** entry represents the name of corresponding result column as obtained
** from [sqlite3_column_name()].
**
** ^If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer
** to an empty string, or a pointer that contains only whitespace and/or
** SQL comments, then no SQL statements are evaluated and the database
** is not changed.
**
** Restrictions:
**
** <ul>
** <li> The application must ensure that the 1st parameter to sqlite3_exec()
**      is a valid and open [database connection].
** <li> The application must not close the [database connection] specified by
**      the 1st parameter to sqlite3_exec() while sqlite3_exec() is running.
** <li> The application must not modify the SQL statement text passed into
**      the 2nd parameter of sqlite3_exec() while sqlite3_exec() is running.
** </ul>
*/
SQLITE_API int sqlite3_exec(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**),
  void *,
  char **errmsg
);
SQLITE_API int sqlite3_exec_v2(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**,int*,int*),
  void *,
  char **errmsg
);
/*
** CAPI3REF: Result Codes
** KEYWORDS: {result code definitions}
**
** Many SQLite functions return an integer result code from the set shown
** here in order to indicate success or failure.
**
** New error codes may be added in future versions of SQLite.
**
** See also: [extended result code definitions]
*/
#define SQLITE_OK           0
/* beginning-of-error-codes */
#define SQLITE_ERROR        1
#define SQLITE_INTERNAL     2
#define SQLITE_PERM         3
#define SQLITE_ABORT        4
#define SQLITE_BUSY         5
#define SQLITE_LOCKED       6
#define SQLITE_NOMEM        7
#define SQLITE_READONLY     8
#define SQLITE_INTERRUPT    9
#define SQLITE_IOERR       10
#define SQLITE_CORRUPT     11
#define SQLITE_NOTFOUND    12
#define SQLITE_FULL        13
#define SQLITE_CANTOPEN    14
#define SQLITE_PROTOCOL    15
#define SQLITE_EMPTY       16
#define SQLITE_SCHEMA      17
#define SQLITE_TOOBIG      18
#define SQLITE_CONSTRAINT  19
#define SQLITE_MISMATCH    20
#define SQLITE_MISUSE      21
#define SQLITE_NOLFS       22
#define SQLITE_AUTH        23
#define SQLITE_FORMAT      24
#define SQLITE_RANGE       25
#define SQLITE_NOTADB      26
#define SQLITE_NOTICE      27
#define SQLITE_WARNING     28
#define SQLITE_ROW         100
#define SQLITE_DONE        101
/* end-of-error-codes */
/*
** CAPI3REF: Extended Result Codes
** KEYWORDS: {extended result code definitions}
**
** In its default configuration, SQLite API routines return one of 30 integer
** [result codes].  However, experience has shown that many of
** these result codes are too coarse-grained.  They do not provide as
** much information about problems as programmers might like.  In an effort to
** address this, newer versions of SQLite (version 3.3.8 [dateof:3.3.8]
** and later) include
** support for additional result codes that provide more detailed information
** about errors. These [extended result codes] are enabled or disabled
** on a per database connection basis using the
** [sqlite3_extended_result_codes()] API.  Or, the extended code for
** the most recent error can be obtained using
** [sqlite3_extended_errcode()].
*/
#define SQLITE_ERROR_MISSING_COLLSEQ   (SQLITE_ERROR | (1<<8))
#define SQLITE_ERROR_RETRY             (SQLITE_ERROR | (2<<8))
#define SQLITE_IOERR_READ              (SQLITE_IOERR | (1<<8))
#define SQLITE_IOERR_SHORT_READ        (SQLITE_IOERR | (2<<8))
#define SQLITE_IOERR_WRITE             (SQLITE_IOERR | (3<<8))
#define SQLITE_IOERR_FSYNC             (SQLITE_IOERR | (4<<8))
#define SQLITE_IOERR_DIR_FSYNC         (SQLITE_IOERR | (5<<8))
#define SQLITE_IOERR_TRUNCATE          (SQLITE_IOERR | (6<<8))
#define SQLITE_IOERR_FSTAT             (SQLITE_IOERR | (7<<8))
#define SQLITE_IOERR_UNLOCK            (SQLITE_IOERR | (8<<8))
#define SQLITE_IOERR_RDLOCK            (SQLITE_IOERR | (9<<8))
#define SQLITE_IOERR_DELETE            (SQLITE_IOERR | (10<<8))
#define SQLITE_IOERR_BLOCKED           (SQLITE_IOERR | (11<<8))
#define SQLITE_IOERR_NOMEM             (SQLITE_IOERR | (12<<8))
#define SQLITE_IOERR_ACCESS            (SQLITE_IOERR | (13<<8))
#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))
#define SQLITE_IOERR_LOCK              (SQLITE_IOERR | (15<<8))
#define SQLITE_IOERR_CLOSE             (SQLITE_IOERR | (16<<8))
#define SQLITE_IOERR_DIR_CLOSE         (SQLITE_IOERR | (17<<8))
#define SQLITE_IOERR_SHMOPEN           (SQLITE_IOERR | (18<<8))
#define SQLITE_IOERR_SHMSIZE           (SQLITE_IOERR | (19<<8))
#define SQLITE_IOERR_SHMLOCK           (SQLITE_IOERR | (20<<8))
#define SQLITE_IOERR_SHMMAP            (SQLITE_IOERR | (21<<8))
#define SQLITE_IOERR_SEEK              (SQLITE_IOERR | (22<<8))
#define SQLITE_IOERR_DELETE_NOENT      (SQLITE_IOERR | (23<<8))
#define SQLITE_IOERR_MMAP              (SQLITE_IOERR | (24<<8))
#define SQLITE_IOERR_GETTEMPPATH       (SQLITE_IOERR | (25<<8))
#define SQLITE_IOERR_CONVPATH          (SQLITE_IOERR | (26<<8))
#define SQLITE_IOERR_VNODE             (SQLITE_IOERR | (27<<8))
#define SQLITE_IOERR_AUTH              (SQLITE_IOERR | (28<<8))
#define SQLITE_IOERR_BEGIN_ATOMIC      (SQLITE_IOERR | (29<<8))
#define SQLITE_IOERR_COMMIT_ATOMIC     (SQLITE_IOERR | (30<<8))
#define SQLITE_IOERR_ROLLBACK_ATOMIC   (SQLITE_IOERR | (31<<8))
#define SQLITE_LOCKED_SHAREDCACHE      (SQLITE_LOCKED |  (1<<8))
#define SQLITE_BUSY_RECOVERY           (SQLITE_BUSY   |  (1<<8))
#define SQLITE_BUSY_SNAPSHOT           (SQLITE_BUSY   |  (2<<8))
#define SQLITE_CANTOPEN_NOTEMPDIR      (SQLITE_CANTOPEN | (1<<8))
#define SQLITE_CANTOPEN_ISDIR          (SQLITE_CANTOPEN | (2<<8))
#define SQLITE_CANTOPEN_FULLPATH       (SQLITE_CANTOPEN | (3<<8))
#define SQLITE_CANTOPEN_CONVPATH       (SQLITE_CANTOPEN | (4<<8))
#define SQLITE_CORRUPT_VTAB            (SQLITE_CORRUPT | (1<<8))
#define SQLITE_READONLY_RECOVERY       (SQLITE_READONLY | (1<<8))
#define SQLITE_READONLY_CANTLOCK       (SQLITE_READONLY | (2<<8))
#define SQLITE_READONLY_ROLLBACK       (SQLITE_READONLY | (3<<8))
#define SQLITE_READONLY_DBMOVED        (SQLITE_READONLY | (4<<8))
#define SQLITE_READONLY_CANTINIT       (SQLITE_READONLY | (5<<8))
#define SQLITE_READONLY_DIRECTORY      (SQLITE_READONLY | (6<<8))
#define SQLITE_ABORT_ROLLBACK          (SQLITE_ABORT | (2<<8))
#define SQLITE_CONSTRAINT_CHECK        (SQLITE_CONSTRAINT | (1<<8))
#define SQLITE_CONSTRAINT_COMMITHOOK   (SQLITE_CONSTRAINT | (2<<8))
#define SQLITE_CONSTRAINT_FOREIGNKEY   (SQLITE_CONSTRAINT | (3<<8))
#define SQLITE_CONSTRAINT_FUNCTION     (SQLITE_CONSTRAINT | (4<<8))
#define SQLITE_CONSTRAINT_NOTNULL      (SQLITE_CONSTRAINT | (5<<8))
#define SQLITE_CONSTRAINT_PRIMARYKEY   (SQLITE_CONSTRAINT | (6<<8))
#define SQLITE_CONSTRAINT_TRIGGER      (SQLITE_CONSTRAINT | (7<<8))
#define SQLITE_CONSTRAINT_UNIQUE       (SQLITE_CONSTRAINT | (8<<8))
#define SQLITE_CONSTRAINT_VTAB         (SQLITE_CONSTRAINT | (9<<8))
#define SQLITE_CONSTRAINT_ROWID        (SQLITE_CONSTRAINT |(10<<8))
#define SQLITE_NOTICE_RECOVER_WAL      (SQLITE_NOTICE | (1<<8))
#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))
#define SQLITE_WARNING_AUTOINDEX       (SQLITE_WARNING | (1<<8))
#define SQLITE_AUTH_USER               (SQLITE_AUTH | (1<<8))
#define SQLITE_OK_LOAD_PERMANENTLY     (SQLITE_OK | (1<<8))
/*
** CAPI3REF: Flags For File Open Operations
**
** These bit values are intended for use in the
** 3rd parameter to the [sqlite3_open_v2()] interface and
** in the 4th parameter to the [sqlite3_vfs.xOpen] method.
*/
#define SQLITE_OPEN_READONLY         0x00000001
#define SQLITE_OPEN_READWRITE        0x00000002
#define SQLITE_OPEN_CREATE           0x00000004
#define SQLITE_OPEN_DELETEONCLOSE    0x00000008
#define SQLITE_OPEN_EXCLUSIVE        0x00000010
#define SQLITE_OPEN_AUTOPROXY        0x00000020
#define SQLITE_OPEN_URI              0x00000040
#define SQLITE_OPEN_MEMORY           0x00000080
#define SQLITE_OPEN_MAIN_DB          0x00000100
#define SQLITE_OPEN_TEMP_DB          0x00000200
#define SQLITE_OPEN_TRANSIENT_DB     0x00000400
#define SQLITE_OPEN_MAIN_JOURNAL     0x00000800
#define SQLITE_OPEN_TEMP_JOURNAL     0x00001000
#define SQLITE_OPEN_SUBJOURNAL       0x00002000
#define SQLITE_OPEN_MASTER_JOURNAL   0x00004000
#define SQLITE_OPEN_NOMUTEX          0x00008000
#define SQLITE_OPEN_FULLMUTEX        0x00010000
#define SQLITE_OPEN_SHAREDCACHE      0x00020000
#define SQLITE_OPEN_PRIVATECACHE     0x00040000
#define SQLITE_OPEN_WAL              0x00080000
/* Reserved:                         0x00F00000 */
/*
** CAPI3REF: Device Characteristics
**
** The xDeviceCharacteristics method of the [sqlite3_io_methods]
** object returns an integer which is a vector of these
** bit values expressing I/O characteristics of the mass storage
** device that holds the file that the [sqlite3_io_methods]
** refers to.
**
** The SQLITE_IOCAP_ATOMIC property means that all writes of
** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
** mean that writes of blocks that are nnn bytes in size and
** are aligned to an address which is an integer multiple of
** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
** that when data is appended to a file, the data is appended
** first then the size of the file is extended, never the other
** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
** information is written to disk in the same order as calls
** to xWrite().  The SQLITE_IOCAP_POWERSAFE_OVERWRITE property means that
** after reboot following a crash or power loss, the only bytes in a
** file that were written at the application level might have changed
** and that adjacent bytes, even bytes within the same sector are
** guaranteed to be unchanged.  The SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN
** flag indicates that a file cannot be deleted when open.  The
** SQLITE_IOCAP_IMMUTABLE flag indicates that the file is on
** read-only media and cannot be changed even by processes with
** elevated privileges.
**
** The SQLITE_IOCAP_BATCH_ATOMIC property means that the underlying
** filesystem supports doing multiple write operations atomically when those
** write operations are bracketed by [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] and
** [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].
*/
#define SQLITE_IOCAP_ATOMIC                 0x00000001
#define SQLITE_IOCAP_ATOMIC512              0x00000002
#define SQLITE_IOCAP_ATOMIC1K               0x00000004
#define SQLITE_IOCAP_ATOMIC2K               0x00000008
#define SQLITE_IOCAP_ATOMIC4K               0x00000010
#define SQLITE_IOCAP_ATOMIC8K               0x00000020
#define SQLITE_IOCAP_ATOMIC16K              0x00000040
#define SQLITE_IOCAP_ATOMIC32K              0x00000080
#define SQLITE_IOCAP_ATOMIC64K              0x00000100
#define SQLITE_IOCAP_SAFE_APPEND            0x00000200
#define SQLITE_IOCAP_SEQUENTIAL             0x00000400
#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN  0x00000800
#define SQLITE_IOCAP_POWERSAFE_OVERWRITE    0x00001000
#define SQLITE_IOCAP_IMMUTABLE              0x00002000
#define SQLITE_IOCAP_BATCH_ATOMIC           0x00004000
/*
** CAPI3REF: File Locking Levels
**
** SQLite uses one of these integer values as the second
** argument to calls it makes to the xLock() and xUnlock() methods
** of an [sqlite3_io_methods] object.
*/
#define SQLITE_LOCK_NONE          0
#define SQLITE_LOCK_SHARED        1
#define SQLITE_LOCK_RESERVED      2
#define SQLITE_LOCK_PENDING       3
#define SQLITE_LOCK_EXCLUSIVE     4
/*
** CAPI3REF: Synchronization Type Flags
**
** When SQLite invokes the xSync() method of an
** [sqlite3_io_methods] object it uses a combination of
** these integer values as the second argument.
**
** When the SQLITE_SYNC_DATAONLY flag is used, it means that the
** sync operation only needs to flush data to mass storage.  Inode
** information need not be flushed. If the lower four bits of the flag
** equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics.
** If the lower four bits equal SQLITE_SYNC_FULL, that means
** to use Mac OS X style fullsync instead of fsync().
**
** Do not confuse the SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags
** with the [PRAGMA synchronous]=NORMAL and [PRAGMA synchronous]=FULL
** settings.  The [synchronous pragma] determines when calls to the
** xSync VFS method occur and applies uniformly across all platforms.
** The SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL flags determine how
** energetic or rigorous or forceful the sync operations are and
** only make a difference on Mac OSX for the default SQLite code.
** (Third-party VFS implementations might also make the distinction
** between SQLITE_SYNC_NORMAL and SQLITE_SYNC_FULL, but among the
** operating systems natively supported by SQLite, only Mac OSX
** cares about the difference.)
*/
#define SQLITE_SYNC_NORMAL        0x00002
#define SQLITE_SYNC_FULL          0x00003
#define SQLITE_SYNC_DATAONLY      0x00010
/*
** CAPI3REF: OS Interface Open File Handle
**
** An [sqlite3_file] object represents an open file in the
** [sqlite3_vfs | OS interface layer].  Individual OS interface
** implementations will
** want to subclass this object by appending additional fields
** for their own use.  The pMethods entry is a pointer to an
** [sqlite3_io_methods] object that defines methods for performing
** I/O operations on the open file.
*/
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file {
  const struct sqlite3_io_methods *pMethods;
};
/*
** CAPI3REF: OS Interface File Virtual Methods Object
**
** Every file opened by the [sqlite3_vfs.xOpen] method populates an
** [sqlite3_file] object (or, more commonly, a subclass of the
** [sqlite3_file] object) with a pointer to an instance of this object.
** This object defines the methods used to perform various operations
** against the open file represented by the [sqlite3_file] object.
**
** If the [sqlite3_vfs.xOpen] method sets the sqlite3_file.pMethods element
** to a non-NULL pointer, then the sqlite3_io_methods.xClose method
** may be invoked even if the [sqlite3_vfs.xOpen] reported that it failed.  The
** only way to prevent a call to xClose following a failed [sqlite3_vfs.xOpen]
** is for the [sqlite3_vfs.xOpen] to set the sqlite3_file.pMethods element
** to NULL.
**
** The flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or
** [SQLITE_SYNC_FULL].  The first choice is the normal fsync().
** The second choice is a Mac OS X style fullsync.  The [SQLITE_SYNC_DATAONLY]
** flag may be ORed in to indicate that only the data of the file
** and not its inode needs to be synced.
**
** The integer values to xLock() and xUnlock() are one of
** <ul>
** <li> [SQLITE_LOCK_NONE],
** <li> [SQLITE_LOCK_SHARED],
** <li> [SQLITE_LOCK_RESERVED],
** <li> [SQLITE_LOCK_PENDING], or
** <li> [SQLITE_LOCK_EXCLUSIVE].
** </ul>
** xLock() increases the lock. xUnlock() decreases the lock.
** The xCheckReservedLock() method checks whether any database connection,
** either in this process or in some other process, is holding a RESERVED,
** PENDING, or EXCLUSIVE lock on the file.  It returns true
** if such a lock exists and false otherwise.
**
** The xFileControl() method is a generic interface that allows custom
** VFS implementations to directly control an open file using the
** [sqlite3_file_control()] interface.  The second "op" argument is an
** integer opcode.  The third argument is a generic pointer intended to
** point to a structure that may contain arguments or space in which to
** write return values.  Potential uses for xFileControl() might be
** functions to enable blocking locks with timeouts, to change the
** locking strategy (for example to use dot-file locks), to inquire
** about the status of a lock, or to break stale locks.  The SQLite
** core reserves all opcodes less than 100 for its own use.
** A [file control opcodes | list of opcodes] less than 100 is available.
** Applications that define a custom xFileControl method should use opcodes
** greater than 100 to avoid conflicts.  VFS implementations should
** return [SQLITE_NOTFOUND] for file control opcodes that they do not
** recognize.
**
** The xSectorSize() method returns the sector size of the
** device that underlies the file.  The sector size is the
** minimum write that can be performed without disturbing
** other bytes in the file.  The xDeviceCharacteristics()
** method returns a bit vector describing behaviors of the
** underlying device:
**
** <ul>
** <li> [SQLITE_IOCAP_ATOMIC]
** <li> [SQLITE_IOCAP_ATOMIC512]
** <li> [SQLITE_IOCAP_ATOMIC1K]
** <li> [SQLITE_IOCAP_ATOMIC2K]
** <li> [SQLITE_IOCAP_ATOMIC4K]
** <li> [SQLITE_IOCAP_ATOMIC8K]
** <li> [SQLITE_IOCAP_ATOMIC16K]
** <li> [SQLITE_IOCAP_ATOMIC32K]
** <li> [SQLITE_IOCAP_ATOMIC64K]
** <li> [SQLITE_IOCAP_SAFE_APPEND]
** <li> [SQLITE_IOCAP_SEQUENTIAL]
** <li> [SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]
** <li> [SQLITE_IOCAP_POWERSAFE_OVERWRITE]
** <li> [SQLITE_IOCAP_IMMUTABLE]
** <li> [SQLITE_IOCAP_BATCH_ATOMIC]
** </ul>
**
** The SQLITE_IOCAP_ATOMIC property means that all writes of
** any size are atomic.  The SQLITE_IOCAP_ATOMICnnn values
** mean that writes of blocks that are nnn bytes in size and
** are aligned to an address which is an integer multiple of
** nnn are atomic.  The SQLITE_IOCAP_SAFE_APPEND value means
** that when data is appended to a file, the data is appended
** first then the size of the file is extended, never the other
** way around.  The SQLITE_IOCAP_SEQUENTIAL property means that
** information is written to disk in the same order as calls
** to xWrite().
**
** If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
** in the unread portions of the buffer with zeros.  A VFS that
** fails to zero-fill short reads might seem to work.  However,
** failure to zero-fill short reads will eventually lead to
** database corruption.
*/
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
  int iVersion;
  int (*xClose)(sqlite3_file*);
  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
  int (*xSync)(sqlite3_file*, int flags);
  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
  int (*xLock)(sqlite3_file*, int);
  int (*xUnlock)(sqlite3_file*, int);
  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
  int (*xFileControl)(sqlite3_file*, int op, void *pArg);
  int (*xSectorSize)(sqlite3_file*);
  int (*xDeviceCharacteristics)(sqlite3_file*);
  /* Methods above are valid for version 1 */
  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);
  void (*xShmBarrier)(sqlite3_file*);
  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);
  /* Methods above are valid for version 2 */
  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);
  /* Methods above are valid for version 3 */
  /* Additional methods may be added in future releases */
};
/*
** CAPI3REF: Standard File Control Opcodes
** KEYWORDS: {file control opcodes} {file control opcode}
**
** These integer constants are opcodes for the xFileControl method
** of the [sqlite3_io_methods] object and for the [sqlite3_file_control()]
** interface.
**
** <ul>
** <li>[[SQLITE_FCNTL_LOCKSTATE]]
** The [SQLITE_FCNTL_LOCKSTATE] opcode is used for debugging.  This
** opcode causes the xFileControl method to write the current state of
** the lock (one of [SQLITE_LOCK_NONE], [SQLITE_LOCK_SHARED],
** [SQLITE_LOCK_RESERVED], [SQLITE_LOCK_PENDING], or [SQLITE_LOCK_EXCLUSIVE])
** into an integer that the pArg argument points to. This capability
** is used during testing and is only available when the SQLITE_TEST
** compile-time option is used.
**
** <li>[[SQLITE_FCNTL_SIZE_HINT]]
** The [SQLITE_FCNTL_SIZE_HINT] opcode is used by SQLite to give the VFS
** layer a hint of how large the database file will grow to be during the
** current transaction.  This hint is not guaranteed to be accurate but it
** is often close.  The underlying VFS might choose to preallocate database
** file space based on this hint in order to help writes to the database
** file run faster.
**
** <li>[[SQLITE_FCNTL_CHUNK_SIZE]]
** The [SQLITE_FCNTL_CHUNK_SIZE] opcode is used to request that the VFS
** extends and truncates the database file in chunks of a size specified
** by the user. The fourth argument to [sqlite3_file_control()] should
** point to an integer (type int) containing the new chunk-size to use
** for the nominated database. Allocating database file space in large
** chunks (say 1MB at a time), may reduce file-system fragmentation and
** improve performance on some systems.
**
** <li>[[SQLITE_FCNTL_FILE_POINTER]]
** The [SQLITE_FCNTL_FILE_POINTER] opcode is used to obtain a pointer
** to the [sqlite3_file] object associated with a particular database
** connection.  See also [SQLITE_FCNTL_JOURNAL_POINTER].
**
** <li>[[SQLITE_FCNTL_JOURNAL_POINTER]]
** The [SQLITE_FCNTL_JOURNAL_POINTER] opcode is used to obtain a pointer
** to the [sqlite3_file] object associated with the journal file (either
** the [rollback journal] or the [write-ahead log]) for a particular database
** connection.  See also [SQLITE_FCNTL_FILE_POINTER].
**
** <li>[[SQLITE_FCNTL_SYNC_OMITTED]]
** No longer in use.
**
** <li>[[SQLITE_FCNTL_SYNC]]
** The [SQLITE_FCNTL_SYNC] opcode is generated internally by SQLite and
** sent to the VFS immediately before the xSync method is invoked on a
** database file descriptor. Or, if the xSync method is not invoked
** because the user has configured SQLite with
** [PRAGMA synchronous | PRAGMA synchronous=OFF] it is invoked in place
** of the xSync method. In most cases, the pointer argument passed with
** this file-control is NULL. However, if the database file is being synced
** as part of a multi-database commit, the argument points to a nul-terminated
** string containing the transactions master-journal file name. VFSes that
** do not need this signal should silently ignore this opcode. Applications
** should not call [sqlite3_file_control()] with this opcode as doing so may
** disrupt the operation of the specialized VFSes that do require it.
**
** <li>[[SQLITE_FCNTL_COMMIT_PHASETWO]]
** The [SQLITE_FCNTL_COMMIT_PHASETWO] opcode is generated internally by SQLite
** and sent to the VFS after a transaction has been committed immediately
** but before the database is unlocked. VFSes that do not need this signal
** should silently ignore this opcode. Applications should not call
** [sqlite3_file_control()] with this opcode as doing so may disrupt the
** operation of the specialized VFSes that do require it.
**
** <li>[[SQLITE_FCNTL_WIN32_AV_RETRY]]
** ^The [SQLITE_FCNTL_WIN32_AV_RETRY] opcode is used to configure automatic
** retry counts and intervals for certain disk I/O operations for the
** windows [VFS] in order to provide robustness in the presence of
** anti-virus programs.  By default, the windows VFS will retry file read,
** file write, and file delete operations up to 10 times, with a delay
** of 25 milliseconds before the first retry and with the delay increasing
** by an additional 25 milliseconds with each subsequent retry.  This
** opcode allows these two values (10 retries and 25 milliseconds of delay)
** to be adjusted.  The values are changed for all database connections
** within the same process.  The argument is a pointer to an array of two
** integers where the first integer is the new retry count and the second
** integer is the delay.  If either integer is negative, then the setting
** is not changed but instead the prior value of that setting is written
** into the array entry, allowing the current retry settings to be
** interrogated.  The zDbName parameter is ignored.
**
** <li>[[SQLITE_FCNTL_PERSIST_WAL]]
** ^The [SQLITE_FCNTL_PERSIST_WAL] opcode is used to set or query the
** persistent [WAL | Write Ahead Log] setting.  By default, the auxiliary
** write ahead log and shared memory files used for transaction control
** are automatically deleted when the latest connection to the database
** closes.  Setting persistent WAL mode causes those files to persist after
** close.  Persisting the files is useful when other processes that do not
** have write permission on the directory containing the database file want
** to read the database file, as the WAL and shared memory files must exist
** in order for the database to be readable.  The fourth parameter to
** [sqlite3_file_control()] for this opcode should be a pointer to an integer.
** That integer is 0 to disable persistent WAL mode or 1 to enable persistent
** WAL mode.  If the integer is -1, then it is overwritten with the current
** WAL persistence setting.
**
** <li>[[SQLITE_FCNTL_POWERSAFE_OVERWRITE]]
** ^The [SQLITE_FCNTL_POWERSAFE_OVERWRITE] opcode is used to set or query the
** persistent "powersafe-overwrite" or "PSOW" setting.  The PSOW setting
** determines the [SQLITE_IOCAP_POWERSAFE_OVERWRITE] bit of the
** xDeviceCharacteristics methods. The fourth parameter to
** [sqlite3_file_control()] for this opcode should be a pointer to an integer.
** That integer is 0 to disable zero-damage mode or 1 to enable zero-damage
** mode.  If the integer is -1, then it is overwritten with the current
** zero-damage mode setting.
**
** <li>[[SQLITE_FCNTL_OVERWRITE]]
** ^The [SQLITE_FCNTL_OVERWRITE] opcode is invoked by SQLite after opening
** a write transaction to indicate that, unless it is rolled back for some
** reason, the entire database file will be overwritten by the current
** transaction. This is used by VACUUM operations.
**
** <li>[[SQLITE_FCNTL_VFSNAME]]
** ^The [SQLITE_FCNTL_VFSNAME] opcode can be used to obtain the names of
** all [VFSes] in the VFS stack.  The names are of all VFS shims and the
** final bottom-level VFS are written into memory obtained from
** [sqlite3_malloc()] and the result is stored in the char* variable
** that the fourth parameter of [sqlite3_file_control()] points to.
** The caller is responsible for freeing the memory when done.  As with
** all file-control actions, there is no guarantee that this will actually
** do anything.  Callers should initialize the char* variable to a NULL
** pointer in case this file-control is not implemented.  This file-control
** is intended for diagnostic use only.
**
** <li>[[SQLITE_FCNTL_VFS_POINTER]]
** ^The [SQLITE_FCNTL_VFS_POINTER] opcode finds a pointer to the top-level
** [VFSes] currently in use.  ^(The argument X in
** sqlite3_file_control(db,SQLITE_FCNTL_VFS_POINTER,X) must be
** of type "[sqlite3_vfs] **".  This opcodes will set *X
** to a pointer to the top-level VFS.)^
** ^When there are multiple VFS shims in the stack, this opcode finds the
** upper-most shim only.
**
** <li>[[SQLITE_FCNTL_PRAGMA]]
** ^Whenever a [PRAGMA] statement is parsed, an [SQLITE_FCNTL_PRAGMA]
** file control is sent to the open [sqlite3_file] object corresponding
** to the database file to which the pragma statement refers. ^The argument
** to the [SQLITE_FCNTL_PRAGMA] file control is an array of
** pointers to strings (char**) in which the second element of the array
** is the name of the pragma and the third element is the argument to the
** pragma or NULL if the pragma has no argument.  ^The handler for an
** [SQLITE_FCNTL_PRAGMA] file control can optionally make the first element
** of the char** argument point to a string obtained from [sqlite3_mprintf()]
** or the equivalent and that string will become the result of the pragma or
** the error message if the pragma fails. ^If the
** [SQLITE_FCNTL_PRAGMA] file control returns [SQLITE_NOTFOUND], then normal
** [PRAGMA] processing continues.  ^If the [SQLITE_FCNTL_PRAGMA]
** file control returns [SQLITE_OK], then the parser assumes that the
** VFS has handled the PRAGMA itself and the parser generates a no-op
** prepared statement if result string is NULL, or that returns a copy
** of the result string if the string is non-NULL.
** ^If the [SQLITE_FCNTL_PRAGMA] file control returns
** any result code other than [SQLITE_OK] or [SQLITE_NOTFOUND], that means
** that the VFS encountered an error while handling the [PRAGMA] and the
** compilation of the PRAGMA fails with an error.  ^The [SQLITE_FCNTL_PRAGMA]
** file control occurs at the beginning of pragma statement analysis and so
** it is able to override built-in [PRAGMA] statements.
**
** <li>[[SQLITE_FCNTL_BUSYHANDLER]]
** ^The [SQLITE_FCNTL_BUSYHANDLER]
** file-control may be invoked by SQLite on the database file handle
** shortly after it is opened in order to provide a custom VFS with access
** to the connections busy-handler callback. The argument is of type (void **)
** - an array of two (void *) values. The first (void *) actually points
** to a function of type (int (*)(void *)). In order to invoke the connections
** busy-handler, this function should be invoked with the second (void *) in
** the array as the only argument. If it returns non-zero, then the operation
** should be retried. If it returns zero, the custom VFS should abandon the
** current operation.
**
** <li>[[SQLITE_FCNTL_TEMPFILENAME]]
** ^Application can invoke the [SQLITE_FCNTL_TEMPFILENAME] file-control
** to have SQLite generate a
** temporary filename using the same algorithm that is followed to generate
** temporary filenames for TEMP tables and other internal uses.  The
** argument should be a char** which will be filled with the filename
** written into memory obtained from [sqlite3_malloc()].  The caller should
** invoke [sqlite3_free()] on the result to avoid a memory leak.
**
** <li>[[SQLITE_FCNTL_MMAP_SIZE]]
** The [SQLITE_FCNTL_MMAP_SIZE] file control is used to query or set the
** maximum number of bytes that will be used for memory-mapped I/O.
** The argument is a pointer to a value of type sqlite3_int64 that
** is an advisory maximum number of bytes in the file to memory map.  The
** pointer is overwritten with the old value.  The limit is not changed if
** the value originally pointed to is negative, and so the current limit
** can be queried by passing in a pointer to a negative number.  This
** file-control is used internally to implement [PRAGMA mmap_size].
**
** <li>[[SQLITE_FCNTL_TRACE]]
** The [SQLITE_FCNTL_TRACE] file control provides advisory information
** to the VFS about what the higher layers of the SQLite stack are doing.
** This file control is used by some VFS activity tracing [shims].
** The argument is a zero-terminated string.  Higher layers in the
** SQLite stack may generate instances of this file control if
** the [SQLITE_USE_FCNTL_TRACE] compile-time option is enabled.
**
** <li>[[SQLITE_FCNTL_HAS_MOVED]]
** The [SQLITE_FCNTL_HAS_MOVED] file control interprets its argument as a
** pointer to an integer and it writes a boolean into that integer depending
** on whether or not the file has been renamed, moved, or deleted since it
** was first opened.
**
** <li>[[SQLITE_FCNTL_WIN32_GET_HANDLE]]
** The [SQLITE_FCNTL_WIN32_GET_HANDLE] opcode can be used to obtain the
** underlying native file handle associated with a file handle.  This file
** control interprets its argument as a pointer to a native file handle and
** writes the resulting value there.
**
** <li>[[SQLITE_FCNTL_WIN32_SET_HANDLE]]
** The [SQLITE_FCNTL_WIN32_SET_HANDLE] opcode is used for debugging.  This
** opcode causes the xFileControl method to swap the file handle with the one
** pointed to by the pArg argument.  This capability is used during testing
** and only needs to be supported when SQLITE_TEST is defined.
**
** <li>[[SQLITE_FCNTL_WAL_BLOCK]]
** The [SQLITE_FCNTL_WAL_BLOCK] is a signal to the VFS layer that it might
** be advantageous to block on the next WAL lock if the lock is not immediately
** available.  The WAL subsystem issues this signal during rare
** circumstances in order to fix a problem with priority inversion.
** Applications should <em>not</em> use this file-control.
**
** <li>[[SQLITE_FCNTL_ZIPVFS]]
** The [SQLITE_FCNTL_ZIPVFS] opcode is implemented by zipvfs only. All other
** VFS should return SQLITE_NOTFOUND for this opcode.
**
** <li>[[SQLITE_FCNTL_RBU]]
** The [SQLITE_FCNTL_RBU] opcode is implemented by the special VFS used by
** the RBU extension only.  All other VFS should return SQLITE_NOTFOUND for
** this opcode.
**
** <li>[[SQLITE_FCNTL_BEGIN_ATOMIC_WRITE]]
** If the [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] opcode returns SQLITE_OK, then
** the file descriptor is placed in "batch write mode", which
** means all subsequent write operations will be deferred and done
** atomically at the next [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE].  Systems
** that do not support batch atomic writes will return SQLITE_NOTFOUND.
** ^Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to
** the closing [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] or
** [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE], SQLite will make
** no VFS interface calls on the same [sqlite3_file] file descriptor
** except for calls to the xWrite method and the xFileControl method
** with [SQLITE_FCNTL_SIZE_HINT].
**
** <li>[[SQLITE_FCNTL_COMMIT_ATOMIC_WRITE]]
** The [SQLITE_FCNTL_COMMIT_ATOMIC_WRITE] opcode causes all write
** operations since the previous successful call to
** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be performed atomically.
** This file control returns [SQLITE_OK] if and only if the writes were
** all performed successfully and have been committed to persistent storage.
** ^Regardless of whether or not it is successful, this file control takes
** the file descriptor out of batch write mode so that all subsequent
** write operations are independent.
** ^SQLite will never invoke SQLITE_FCNTL_COMMIT_ATOMIC_WRITE without
** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
**
** <li>[[SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE]]
** The [SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE] opcode causes all write
** operations since the previous successful call to
** [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE] to be rolled back.
** ^This file control takes the file descriptor out of batch write mode
** so that all subsequent write operations are independent.
** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
** </ul>
*/
#define SQLITE_FCNTL_LOCKSTATE               1
#define SQLITE_FCNTL_GET_LOCKPROXYFILE       2
#define SQLITE_FCNTL_SET_LOCKPROXYFILE       3
#define SQLITE_FCNTL_LAST_ERRNO              4
#define SQLITE_FCNTL_SIZE_HINT               5
#define SQLITE_FCNTL_CHUNK_SIZE              6
#define SQLITE_FCNTL_FILE_POINTER            7
#define SQLITE_FCNTL_SYNC_OMITTED            8
#define SQLITE_FCNTL_WIN32_AV_RETRY          9
#define SQLITE_FCNTL_PERSIST_WAL            10
#define SQLITE_FCNTL_OVERWRITE              11
#define SQLITE_FCNTL_VFSNAME                12
#define SQLITE_FCNTL_POWERSAFE_OVERWRITE    13
#define SQLITE_FCNTL_PRAGMA                 14
#define SQLITE_FCNTL_BUSYHANDLER            15
#define SQLITE_FCNTL_TEMPFILENAME           16
#define SQLITE_FCNTL_MMAP_SIZE              18
#define SQLITE_FCNTL_TRACE                  19
#define SQLITE_FCNTL_HAS_MOVED              20
#define SQLITE_FCNTL_SYNC                   21
#define SQLITE_FCNTL_COMMIT_PHASETWO        22
#define SQLITE_FCNTL_WIN32_SET_HANDLE       23
#define SQLITE_FCNTL_WAL_BLOCK              24
#define SQLITE_FCNTL_ZIPVFS                 25
#define SQLITE_FCNTL_RBU                    26
#define SQLITE_FCNTL_VFS_POINTER            27
#define SQLITE_FCNTL_JOURNAL_POINTER        28
#define SQLITE_FCNTL_WIN32_GET_HANDLE       29
#define SQLITE_FCNTL_PDB                    30
#define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE     31
#define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE    32
#define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33
/* deprecated names */
#define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
#define SQLITE_SET_LOCKPROXYFILE      SQLITE_FCNTL_SET_LOCKPROXYFILE
#define SQLITE_LAST_ERRNO             SQLITE_FCNTL_LAST_ERRNO
/*
** CAPI3REF: Mutex Handle
**
** The mutex module within SQLite defines [sqlite3_mutex] to be an
** abstract type for a mutex object.  The SQLite core never looks
** at the internal representation of an [sqlite3_mutex].  It only
** deals with pointers to the [sqlite3_mutex] object.
**
** Mutexes are created using [sqlite3_mutex_alloc()].
*/
typedef struct sqlite3_mutex sqlite3_mutex;
/*
** CAPI3REF: Loadable Extension Thunk
**
** A pointer to the opaque sqlite3_api_routines structure is passed as
** the third parameter to entry points of [loadable extensions].  This
** structure must be typedefed in order to work around compiler warnings
** on some platforms.
*/
typedef struct sqlite3_api_routines sqlite3_api_routines;
/*
** CAPI3REF: OS Interface Object
**
** An instance of the sqlite3_vfs object defines the interface between
** the SQLite core and the underlying operating system.  The "vfs"
** in the name of the object stands for "virtual file system".  See
** the [VFS | VFS documentation] for further information.
**
** The VFS interface is sometimes extended by adding new methods onto
** the end.  Each time such an extension occurs, the iVersion field
** is incremented.  The iVersion value started out as 1 in
** SQLite [version 3.5.0] on [dateof:3.5.0], then increased to 2
** with SQLite [version 3.7.0] on [dateof:3.7.0], and then increased
** to 3 with SQLite [version 3.7.6] on [dateof:3.7.6].  Additional fields
** may be appended to the sqlite3_vfs object and the iVersion value
** may increase again in future versions of SQLite.
** Note that the structure
** of the sqlite3_vfs object changes in the transition from
** SQLite [version 3.5.9] to [version 3.6.0] on [dateof:3.6.0]
** and yet the iVersion field was not modified.
**
** The szOsFile field is the size of the subclassed [sqlite3_file]
** structure used by this VFS.  mxPathname is the maximum length of
** a pathname in this VFS.
**
** Registered sqlite3_vfs objects are kept on a linked list formed by
** the pNext pointer.  The [sqlite3_vfs_register()]
** and [sqlite3_vfs_unregister()] interfaces manage this list
** in a thread-safe way.  The [sqlite3_vfs_find()] interface
** searches the list.  Neither the application code nor the VFS
** implementation should use the pNext pointer.
**
** The pNext field is the only field in the sqlite3_vfs
** structure that SQLite will ever modify.  SQLite will only access
** or modify this field while holding a particular static mutex.
** The application should never modify anything within the sqlite3_vfs
** object once the object has been registered.
**
** The zName field holds the name of the VFS module.  The name must
** be unique across all VFS modules.
**
** [[sqlite3_vfs.xOpen]]
** ^SQLite guarantees that the zFilename parameter to xOpen
** is either a NULL pointer or string obtained
** from xFullPathname() with an optional suffix added.
** ^If a suffix is added to the zFilename parameter, it will
** consist of a single "-" character followed by no more than
** 11 alphanumeric and/or "-" characters.
** ^SQLite further guarantees that
** the string will be valid and unchanged until xClose() is
** called. Because of the previous sentence,
** the [sqlite3_file] can safely store a pointer to the
** filename if it needs to remember the filename for some reason.
** If the zFilename parameter to xOpen is a NULL pointer then xOpen
** must invent its own temporary name for the file.  ^Whenever the
** xFilename parameter is NULL it will also be the case that the
** flags parameter will include [SQLITE_OPEN_DELETEONCLOSE].
**
** The flags argument to xOpen() includes all bits set in
** the flags argument to [sqlite3_open_v2()].  Or if [sqlite3_open()]
** or [sqlite3_open16()] is used, then flags includes at least
** [SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE].
** If xOpen() opens a file read-only then it sets *pOutFlags to
** include [SQLITE_OPEN_READONLY].  Other bits in *pOutFlags may be set.
**
** ^(SQLite will also add one of the following flags to the xOpen()
** call, depending on the object being opened:
**
** <ul>
** <li>  [SQLITE_OPEN_MAIN_DB]
** <li>  [SQLITE_OPEN_MAIN_JOURNAL]
** <li>  [SQLITE_OPEN_TEMP_DB]
** <li>  [SQLITE_OPEN_TEMP_JOURNAL]
** <li>  [SQLITE_OPEN_TRANSIENT_DB]
** <li>  [SQLITE_OPEN_SUBJOURNAL]
** <li>  [SQLITE_OPEN_MASTER_JOURNAL]
** <li>  [SQLITE_OPEN_WAL]
** </ul>)^
**
** The file I/O implementation can use the object type flags to
** change the way it deals with files.  For example, an application
** that does not care about crash recovery or rollback might make
** the open of a journal file a no-op.  Writes to this journal would
** also be no-ops, and any attempt to read the journal would return
** SQLITE_IOERR.  Or the implementation might recognize that a database
** file will be doing page-aligned sector reads and writes in a random
** order and set up its I/O subsystem accordingly.
**
** SQLite might also add one of the following flags to the xOpen method:
**
** <ul>
** <li> [SQLITE_OPEN_DELETEONCLOSE]
** <li> [SQLITE_OPEN_EXCLUSIVE]
** </ul>
**
** The [SQLITE_OPEN_DELETEONCLOSE] flag means the file should be
** deleted when it is closed.  ^The [SQLITE_OPEN_DELETEONCLOSE]
** will be set for TEMP databases and their journals, transient
** databases, and subjournals.
**
** ^The [SQLITE_OPEN_EXCLUSIVE] flag is always used in conjunction
** with the [SQLITE_OPEN_CREATE] flag, which are both directly
** analogous to the O_EXCL and O_CREAT flags of the POSIX open()
** API.  The SQLITE_OPEN_EXCLUSIVE flag, when paired with the
** SQLITE_OPEN_CREATE, is used to indicate that file should always
** be created, and that it is an error if it already exists.
** It is <i>not</i> used to indicate the file should be opened
** for exclusive access.
**
** ^At least szOsFile bytes of memory are allocated by SQLite
** to hold the  [sqlite3_file] structure passed as the third
** argument to xOpen.  The xOpen method does not have to
** allocate the structure; it should just fill it in.  Note that
** the xOpen method must set the sqlite3_file.pMethods to either
** a valid [sqlite3_io_methods] object or to NULL.  xOpen must do
** this even if the open fails.  SQLite expects that the sqlite3_file.pMethods
** element will be valid after xOpen returns regardless of the success
** or failure of the xOpen call.
**
** [[sqlite3_vfs.xAccess]]
** ^The flags argument to xAccess() may be [SQLITE_ACCESS_EXISTS]
** to test for the existence of a file, or [SQLITE_ACCESS_READWRITE] to
** test whether a file is readable and writable, or [SQLITE_ACCESS_READ]
** to test whether a file is at least readable.   The file can be a
** directory.
**
** ^SQLite will always allocate at least mxPathname+1 bytes for the
** output buffer xFullPathname.  The exact size of the output buffer
** is also passed as a parameter to both  methods. If the output buffer
** is not large enough, [SQLITE_CANTOPEN] should be returned. Since this is
** handled as a fatal error by SQLite, vfs implementations should endeavor
** to prevent this by setting mxPathname to a sufficiently large value.
**
** The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64()
** interfaces are not strictly a part of the filesystem, but they are
** included in the VFS structure for completeness.
** The xRandomness() function attempts to return nBytes bytes
** of good-quality randomness into zOut.  The return value is
** the actual number of bytes of randomness obtained.
** The xSleep() method causes the calling thread to sleep for at
** least the number of microseconds given.  ^The xCurrentTime()
** method returns a Julian Day Number for the current date and time as
** a floating point value.
** ^The xCurrentTimeInt64() method returns, as an integer, the Julian
** Day Number multiplied by 86400000 (the number of milliseconds in
** a 24-hour day).
** ^SQLite will use the xCurrentTimeInt64() method to get the current
** date and time if that method is available (if iVersion is 2 or
** greater and the function pointer is not NULL) and will fall back
** to xCurrentTime() if xCurrentTimeInt64() is unavailable.
**
** ^The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces
** are not used by the SQLite core.  These optional interfaces are provided
** by some VFSes to facilitate testing of the VFS code. By overriding
** system calls with functions under its control, a test program can
** simulate faults and error conditions that would otherwise be difficult
** or impossible to induce.  The set of system calls that can be overridden
** varies from one VFS to another, and from one version of the same VFS to the
** next.  Applications that use these interfaces must be prepared for any
** or all of these interfaces to be NULL or for their behavior to change
** from one release to the next.  Applications must not attempt to access
** any of these methods if the iVersion of the VFS is less than 3.
*/
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs {
  int iVersion;
  int szOsFile;
  int mxPathname;
  sqlite3_vfs *pNext;
  const char *zName;
  void *pAppData;
  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
               int flags, int *pOutFlags);
  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
  void (*xDlClose)(sqlite3_vfs*, void*);
  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
  int (*xSleep)(sqlite3_vfs*, int microseconds);
  int (*xCurrentTime)(sqlite3_vfs*, double*);
  int (*xGetLastError)(sqlite3_vfs*, int, char *);
  /*
  ** The methods above are in version 1 of the sqlite_vfs object
  ** definition.  Those that follow are added in version 2 or later
  */
  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);
  /*
  ** The methods above are in versions 1 and 2 of the sqlite_vfs object.
  ** Those below are for version 3 and greater.
  */
  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);
  /*
  ** The methods above are in versions 1 through 3 of the sqlite_vfs object.
  ** New fields may be appended in future versions.  The iVersion
  ** value will increment whenever this happens.
  */
};
/*
** CAPI3REF: Flags for the xAccess VFS method
**
** These integer constants can be used as the third parameter to
** the xAccess method of an [sqlite3_vfs] object.  They determine
** what kind of permissions the xAccess method is looking for.
** With SQLITE_ACCESS_EXISTS, the xAccess method
** simply checks whether the file exists.
** With SQLITE_ACCESS_READWRITE, the xAccess method
** checks whether the named directory is both readable and writable
** (in other words, if files can be added, removed, and renamed within
** the directory).
** The SQLITE_ACCESS_READWRITE constant is currently used only by the
** [temp_store_directory pragma], though this could change in a future
** release of SQLite.
** With SQLITE_ACCESS_READ, the xAccess method
** checks whether the file is readable.  The SQLITE_ACCESS_READ constant is
** currently unused, though it might be used in a future release of
** SQLite.
*/
#define SQLITE_ACCESS_EXISTS    0
#define SQLITE_ACCESS_READWRITE 1
#define SQLITE_ACCESS_READ      2
/*
** CAPI3REF: Flags for the xShmLock VFS method
**
** These integer constants define the various locking operations
** allowed by the xShmLock method of [sqlite3_io_methods].  The
** following are the only legal combinations of flags to the
** xShmLock method:
**
** <ul>
** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_SHARED
** <li>  SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE
** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED
** <li>  SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE
** </ul>
**
** When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as
** was given on the corresponding lock.
**
** The xShmLock method can transition between unlocked and SHARED or
** between unlocked and EXCLUSIVE.  It cannot transition between SHARED
** and EXCLUSIVE.
*/
#define SQLITE_SHM_UNLOCK       1
#define SQLITE_SHM_LOCK         2
#define SQLITE_SHM_SHARED       4
#define SQLITE_SHM_EXCLUSIVE    8
/*
** CAPI3REF: Maximum xShmLock index
**
** The xShmLock method on [sqlite3_io_methods] may use values
** between 0 and this upper bound as its "offset" argument.
** The SQLite core will never attempt to acquire or release a
** lock outside of this range
*/
#define SQLITE_SHM_NLOCK        8
/*
** CAPI3REF: Initialize The SQLite Library
**
** ^The sqlite3_initialize() routine initializes the
** SQLite library.  ^The sqlite3_shutdown() routine
** deallocates any resources that were allocated by sqlite3_initialize().
** These routines are designed to aid in process initialization and
** shutdown on embedded systems.  Workstation applications using
** SQLite normally do not need to invoke either of these routines.
**
** A call to sqlite3_initialize() is an "effective" call if it is
** the first time sqlite3_initialize() is invoked during the lifetime of
** the process, or if it is the first time sqlite3_initialize() is invoked
** following a call to sqlite3_shutdown().  ^(Only an effective call
** of sqlite3_initialize() does any initialization.  All other calls
** are harmless no-ops.)^
**
** A call to sqlite3_shutdown() is an "effective" call if it is the first
** call to sqlite3_shutdown() since the last sqlite3_initialize().  ^(Only
** an effective call to sqlite3_shutdown() does any deinitialization.
** All other valid calls to sqlite3_shutdown() are harmless no-ops.)^
**
** The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown()
** is not.  The sqlite3_shutdown() interface must only be called from a
** single thread.  All open [database connections] must be closed and all
** other SQLite resources must be deallocated prior to invoking
** sqlite3_shutdown().
**
** Among other things, ^sqlite3_initialize() will invoke
** sqlite3_os_init().  Similarly, ^sqlite3_shutdown()
** will invoke sqlite3_os_end().
**
** ^The sqlite3_initialize() routine returns [SQLITE_OK] on success.
** ^If for some reason, sqlite3_initialize() is unable to initialize
** the library (perhaps it is unable to allocate a needed resource such
** as a mutex) it returns an [error code] other than [SQLITE_OK].
**
** ^The sqlite3_initialize() routine is called internally by many other
** SQLite interfaces so that an application usually does not need to
** invoke sqlite3_initialize() directly.  For example, [sqlite3_open()]
** calls sqlite3_initialize() so the SQLite library will be automatically
** initialized when [sqlite3_open()] is called if it has not be initialized
** already.  ^However, if SQLite is compiled with the [SQLITE_OMIT_AUTOINIT]
** compile-time option, then the automatic calls to sqlite3_initialize()
** are omitted and the application must call sqlite3_initialize() directly
** prior to using any other SQLite interface.  For maximum portability,
** it is recommended that applications always invoke sqlite3_initialize()
** directly prior to using any other SQLite interface.  Future releases
** of SQLite may require this.  In other words, the behavior exhibited
** when SQLite is compiled with [SQLITE_OMIT_AUTOINIT] might become the
** default behavior in some future release of SQLite.
**
** The sqlite3_os_init() routine does operating-system specific
** initialization of the SQLite library.  The sqlite3_os_end()
** routine undoes the effect of sqlite3_os_init().  Typical tasks
** performed by these routines include allocation or deallocation
** of static resources, initialization of global variables,
** setting up a default [sqlite3_vfs] module, or setting up
** a default configuration using [sqlite3_config()].
**
** The application should never invoke either sqlite3_os_init()
** or sqlite3_os_end() directly.  The application should only invoke
** sqlite3_initialize() and sqlite3_shutdown().  The sqlite3_os_init()
** interface is called automatically by sqlite3_initialize() and
** sqlite3_os_end() is called by sqlite3_shutdown().  Appropriate
** implementations for sqlite3_os_init() and sqlite3_os_end()
** are built into SQLite when it is compiled for Unix, Windows, or OS/2.
** When [custom builds | built for other platforms]
** (using the [SQLITE_OS_OTHER=1] compile-time
** option) the application must supply a suitable implementation for
** sqlite3_os_init() and sqlite3_os_end().  An application-supplied
** implementation of sqlite3_os_init() or sqlite3_os_end()
** must return [SQLITE_OK] on success and some other [error code] upon
** failure.
*/
SQLITE_API int sqlite3_initialize(void);
SQLITE_API int sqlite3_shutdown(void);
SQLITE_API int sqlite3_os_init(void);
SQLITE_API int sqlite3_os_end(void);
/*
** CAPI3REF: Configuring The SQLite Library
**
** The sqlite3_config() interface is used to make global configuration
** changes to SQLite in order to tune SQLite to the specific needs of
** the application.  The default configuration is recommended for most
** applications and so this routine is usually not necessary.  It is
** provided to support rare applications with unusual needs.
**
** <b>The sqlite3_config() interface is not threadsafe. The application
** must ensure that no other SQLite interfaces are invoked by other
** threads while sqlite3_config() is running.</b>
**
** The sqlite3_config() interface
** may only be invoked prior to library initialization using
** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].
** ^If sqlite3_config() is called after [sqlite3_initialize()] and before
** [sqlite3_shutdown()] then it will return SQLITE_MISUSE.
** Note, however, that ^sqlite3_config() can be called as part of the
** implementation of an application-defined [sqlite3_os_init()].
**
** The first argument to sqlite3_config() is an integer
** [configuration option] that determines
** what property of SQLite is to be configured.  Subsequent arguments
** vary depending on the [configuration option]
** in the first argument.
**
** ^When a configuration option is set, sqlite3_config() returns [SQLITE_OK].
** ^If the option is unknown or SQLite is unable to set the option
** then this routine returns a non-zero [error code].
*/
SQLITE_API int sqlite3_config(int, ...);
/*
** CAPI3REF: Configure database connections
** METHOD: sqlite3
**
** The sqlite3_db_config() interface is used to make configuration
** changes to a [database connection].  The interface is similar to
** [sqlite3_config()] except that the changes apply to a single
** [database connection] (specified in the first argument).
**
** The second argument to sqlite3_db_config(D,V,...)  is the
** [SQLITE_DBCONFIG_LOOKASIDE | configuration verb] - an integer code
** that indicates what aspect of the [database connection] is being configured.
** Subsequent arguments vary depending on the configuration verb.
**
** ^Calls to sqlite3_db_config() return SQLITE_OK if and only if
** the call is considered successful.
*/
SQLITE_API int sqlite3_db_config(sqlite3*, int op, ...);
/*
** CAPI3REF: Memory Allocation Routines
**
** An instance of this object defines the interface between SQLite
** and low-level memory allocation routines.
**
** This object is used in only one place in the SQLite interface.
** A pointer to an instance of this object is the argument to
** [sqlite3_config()] when the configuration option is
** [SQLITE_CONFIG_MALLOC] or [SQLITE_CONFIG_GETMALLOC].
** By creating an instance of this object
** and passing it to [sqlite3_config]([SQLITE_CONFIG_MALLOC])
** during configuration, an application can specify an alternative
** memory allocation subsystem for SQLite to use for all of its
** dynamic memory needs.
**
** Note that SQLite comes with several [built-in memory allocators]
** that are perfectly adequate for the overwhelming majority of applications
** and that this object is only useful to a tiny minority of applications
** with specialized memory allocation requirements.  This object is
** also used during testing of SQLite in order to specify an alternative
** memory allocator that simulates memory out-of-memory conditions in
** order to verify that SQLite recovers gracefully from such
** conditions.
**
** The xMalloc, xRealloc, and xFree methods must work like the
** malloc(), realloc() and free() functions from the standard C library.
** ^SQLite guarantees that the second argument to
** xRealloc is always a value returned by a prior call to xRoundup.
**
** xSize should return the allocated size of a memory allocation
** previously obtained from xMalloc or xRealloc.  The allocated size
** is always at least as big as the requested size but may be larger.
**
** The xRoundup method returns what would be the allocated size of
** a memory allocation given a particular requested size.  Most memory
** allocators round up memory allocations at least to the next multiple
** of 8.  Some allocators round up to a larger multiple or to a power of 2.
** Every memory allocation request coming in through [sqlite3_malloc()]
** or [sqlite3_realloc()] first calls xRoundup.  If xRoundup returns 0,
** that causes the corresponding memory allocation to fail.
**
** The xInit method initializes the memory allocator.  For example,
** it might allocate any require mutexes or initialize internal data
** structures.  The xShutdown method is invoked (indirectly) by
** [sqlite3_shutdown()] and should deallocate any resources acquired
** by xInit.  The pAppData pointer is used as the only parameter to
** xInit and xShutdown.
**
** SQLite holds the [SQLITE_MUTEX_STATIC_MASTER] mutex when it invokes
** the xInit method, so the xInit method need not be threadsafe.  The
** xShutdown method is only called from [sqlite3_shutdown()] so it does
** not need to be threadsafe either.  For all other methods, SQLite
** holds the [SQLITE_MUTEX_STATIC_MEM] mutex as long as the
** [SQLITE_CONFIG_MEMSTATUS] configuration option is turned on (which
** it is by default) and so the methods are automatically serialized.
** However, if [SQLITE_CONFIG_MEMSTATUS] is disabled, then the other
** methods must be threadsafe or else make their own arrangements for
** serialization.
**
** SQLite will never invoke xInit() more than once without an intervening
** call to xShutdown().
*/
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
  void *(*xMalloc)(int);
  void (*xFree)(void*);
  void *(*xRealloc)(void*,int);
  int (*xSize)(void*);
  int (*xRoundup)(int);
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  void *pAppData;
};
/*
** CAPI3REF: Configuration Options
** KEYWORDS: {configuration option}
**
** These constants are the available integer configuration options that
** can be passed as the first argument to the [sqlite3_config()] interface.
**
** New configuration options may be added in future releases of SQLite.
** Existing configuration options might be discontinued.  Applications
** should check the return code from [sqlite3_config()] to make sure that
** the call worked.  The [sqlite3_config()] interface will return a
** non-zero [error code] if a discontinued or unsupported configuration option
** is invoked.
**
** <dl>
** [[SQLITE_CONFIG_SINGLETHREAD]] <dt>SQLITE_CONFIG_SINGLETHREAD</dt>
** <dd>There are no arguments to this option.  ^This option sets the
** [threading mode] to Single-thread.  In other words, it disables
** all mutexing and puts SQLite into a mode where it can only be used
** by a single thread.   ^If SQLite is compiled with
** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then
** it is not possible to change the [threading mode] from its default
** value of Single-thread and so [sqlite3_config()] will return
** [SQLITE_ERROR] if called with the SQLITE_CONFIG_SINGLETHREAD
** configuration option.</dd>
**
** [[SQLITE_CONFIG_MULTITHREAD]] <dt>SQLITE_CONFIG_MULTITHREAD</dt>
** <dd>There are no arguments to this option.  ^This option sets the
** [threading mode] to Multi-thread.  In other words, it disables
** mutexing on [database connection] and [prepared statement] objects.
** The application is responsible for serializing access to
** [database connections] and [prepared statements].  But other mutexes
** are enabled so that SQLite will be safe to use in a multi-threaded
** environment as long as no two threads attempt to use the same
** [database connection] at the same time.  ^If SQLite is compiled with
** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then
** it is not possible to set the Multi-thread [threading mode] and
** [sqlite3_config()] will return [SQLITE_ERROR] if called with the
** SQLITE_CONFIG_MULTITHREAD configuration option.</dd>
**
** [[SQLITE_CONFIG_SERIALIZED]] <dt>SQLITE_CONFIG_SERIALIZED</dt>
** <dd>There are no arguments to this option.  ^This option sets the
** [threading mode] to Serialized. In other words, this option enables
** all mutexes including the recursive
** mutexes on [database connection] and [prepared statement] objects.
** In this mode (which is the default when SQLite is compiled with
** [SQLITE_THREADSAFE=1]) the SQLite library will itself serialize access
** to [database connections] and [prepared statements] so that the
** application is free to use the same [database connection] or the
** same [prepared statement] in different threads at the same time.
** ^If SQLite is compiled with
** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then
** it is not possible to set the Serialized [threading mode] and
** [sqlite3_config()] will return [SQLITE_ERROR] if called with the
** SQLITE_CONFIG_SERIALIZED configuration option.</dd>
**
** [[SQLITE_CONFIG_MALLOC]] <dt>SQLITE_CONFIG_MALLOC</dt>
** <dd> ^(The SQLITE_CONFIG_MALLOC option takes a single argument which is
** a pointer to an instance of the [sqlite3_mem_methods] structure.
** The argument specifies
** alternative low-level memory allocation routines to be used in place of
** the memory allocation routines built into SQLite.)^ ^SQLite makes
** its own private copy of the content of the [sqlite3_mem_methods] structure
** before the [sqlite3_config()] call returns.</dd>
**
** [[SQLITE_CONFIG_GETMALLOC]] <dt>SQLITE_CONFIG_GETMALLOC</dt>
** <dd> ^(The SQLITE_CONFIG_GETMALLOC option takes a single argument which
** is a pointer to an instance of the [sqlite3_mem_methods] structure.
** The [sqlite3_mem_methods]
** structure is filled with the currently defined memory allocation routines.)^
** This option can be used to overload the default memory allocation
** routines with a wrapper that simulations memory allocation failure or
** tracks memory usage, for example. </dd>
**
** [[SQLITE_CONFIG_SMALL_MALLOC]] <dt>SQLITE_CONFIG_SMALL_MALLOC</dt>
** <dd> ^The SQLITE_CONFIG_SMALL_MALLOC option takes single argument of
** type int, interpreted as a boolean, which if true provides a hint to
** SQLite that it should avoid large memory allocations if possible.
** SQLite will run faster if it is free to make large memory allocations,
** but some application might prefer to run slower in exchange for
** guarantees about memory fragmentation that are possible if large
** allocations are avoided.  This hint is normally off.
** </dd>
**
** [[SQLITE_CONFIG_MEMSTATUS]] <dt>SQLITE_CONFIG_MEMSTATUS</dt>
** <dd> ^The SQLITE_CONFIG_MEMSTATUS option takes single argument of type int,
** interpreted as a boolean, which enables or disables the collection of
** memory allocation statistics. ^(When memory allocation statistics are
** disabled, the following SQLite interfaces become non-operational:
**   <ul>
**   <li> [sqlite3_memory_used()]
**   <li> [sqlite3_memory_highwater()]
**   <li> [sqlite3_soft_heap_limit64()]
**   <li> [sqlite3_status64()]
**   </ul>)^
** ^Memory allocation statistics are enabled by default unless SQLite is
** compiled with [SQLITE_DEFAULT_MEMSTATUS]=0 in which case memory
** allocation statistics are disabled by default.
** </dd>
**
** [[SQLITE_CONFIG_SCRATCH]] <dt>SQLITE_CONFIG_SCRATCH</dt>
** <dd> The SQLITE_CONFIG_SCRATCH option is no longer used.
** </dd>
**
** [[SQLITE_CONFIG_PAGECACHE]] <dt>SQLITE_CONFIG_PAGECACHE</dt>
** <dd> ^The SQLITE_CONFIG_PAGECACHE option specifies a memory pool
** that SQLite can use for the database page cache with the default page
** cache implementation.
** This configuration option is a no-op if an application-define page
** cache implementation is loaded using the [SQLITE_CONFIG_PCACHE2].
** ^There are three arguments to SQLITE_CONFIG_PAGECACHE: A pointer to
** 8-byte aligned memory (pMem), the size of each page cache line (sz),
** and the number of cache lines (N).
** The sz argument should be the size of the largest database page
** (a power of two between 512 and 65536) plus some extra bytes for each
** page header.  ^The number of extra bytes needed by the page header
** can be determined using [SQLITE_CONFIG_PCACHE_HDRSZ].
** ^It is harmless, apart from the wasted memory,
** for the sz parameter to be larger than necessary.  The pMem
** argument must be either a NULL pointer or a pointer to an 8-byte
** aligned block of memory of at least sz*N bytes, otherwise
** subsequent behavior is undefined.
** ^When pMem is not NULL, SQLite will strive to use the memory provided
** to satisfy page cache needs, falling back to [sqlite3_malloc()] if
** a page cache line is larger than sz bytes or if all of the pMem buffer
** is exhausted.
** ^If pMem is NULL and N is non-zero, then each database connection
** does an initial bulk allocation for page cache memory
** from [sqlite3_malloc()] sufficient for N cache lines if N is positive or
** of -1024*N bytes if N is negative, . ^If additional
** page cache memory is needed beyond what is provided by the initial
** allocation, then SQLite goes to [sqlite3_malloc()] separately for each
** additional cache line. </dd>
**
** [[SQLITE_CONFIG_HEAP]] <dt>SQLITE_CONFIG_HEAP</dt>
** <dd> ^The SQLITE_CONFIG_HEAP option specifies a static memory buffer
** that SQLite will use for all of its dynamic memory allocation needs
** beyond those provided for by [SQLITE_CONFIG_PAGECACHE].
** ^The SQLITE_CONFIG_HEAP option is only available if SQLite is compiled
** with either [SQLITE_ENABLE_MEMSYS3] or [SQLITE_ENABLE_MEMSYS5] and returns
** [SQLITE_ERROR] if invoked otherwise.
** ^There are three arguments to SQLITE_CONFIG_HEAP:
** An 8-byte aligned pointer to the memory,
** the number of bytes in the memory buffer, and the minimum allocation size.
** ^If the first pointer (the memory pointer) is NULL, then SQLite reverts
** to using its default memory allocator (the system malloc() implementation),
** undoing any prior invocation of [SQLITE_CONFIG_MALLOC].  ^If the
** memory pointer is not NULL then the alternative memory
** allocator is engaged to handle all of SQLites memory allocation needs.
** The first pointer (the memory pointer) must be aligned to an 8-byte
** boundary or subsequent behavior of SQLite will be undefined.
** The minimum allocation size is capped at 2**12. Reasonable values
** for the minimum allocation size are 2**5 through 2**8.</dd>
**
** [[SQLITE_CONFIG_MUTEX]] <dt>SQLITE_CONFIG_MUTEX</dt>
** <dd> ^(The SQLITE_CONFIG_MUTEX option takes a single argument which is a
** pointer to an instance of the [sqlite3_mutex_methods] structure.
** The argument specifies alternative low-level mutex routines to be used
** in place the mutex routines built into SQLite.)^  ^SQLite makes a copy of
** the content of the [sqlite3_mutex_methods] structure before the call to
** [sqlite3_config()] returns. ^If SQLite is compiled with
** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then
** the entire mutexing subsystem is omitted from the build and hence calls to
** [sqlite3_config()] with the SQLITE_CONFIG_MUTEX configuration option will
** return [SQLITE_ERROR].</dd>
**
** [[SQLITE_CONFIG_GETMUTEX]] <dt>SQLITE_CONFIG_GETMUTEX</dt>
** <dd> ^(The SQLITE_CONFIG_GETMUTEX option takes a single argument which
** is a pointer to an instance of the [sqlite3_mutex_methods] structure.  The
** [sqlite3_mutex_methods]
** structure is filled with the currently defined mutex routines.)^
** This option can be used to overload the default mutex allocation
** routines with a wrapper used to track mutex usage for performance
** profiling or testing, for example.   ^If SQLite is compiled with
** the [SQLITE_THREADSAFE | SQLITE_THREADSAFE=0] compile-time option then
** the entire mutexing subsystem is omitted from the build and hence calls to
** [sqlite3_config()] with the SQLITE_CONFIG_GETMUTEX configuration option will
** return [SQLITE_ERROR].</dd>
**
** [[SQLITE_CONFIG_LOOKASIDE]] <dt>SQLITE_CONFIG_LOOKASIDE</dt>
** <dd> ^(The SQLITE_CONFIG_LOOKASIDE option takes two arguments that determine
** the default size of lookaside memory on each [database connection].
** The first argument is the
** size of each lookaside buffer slot and the second is the number of
** slots allocated to each database connection.)^  ^(SQLITE_CONFIG_LOOKASIDE
** sets the <i>default</i> lookaside size. The [SQLITE_DBCONFIG_LOOKASIDE]
** option to [sqlite3_db_config()] can be used to change the lookaside
** configuration on individual connections.)^ </dd>
**
** [[SQLITE_CONFIG_PCACHE2]] <dt>SQLITE_CONFIG_PCACHE2</dt>
** <dd> ^(The SQLITE_CONFIG_PCACHE2 option takes a single argument which is
** a pointer to an [sqlite3_pcache_methods2] object.  This object specifies
** the interface to a custom page cache implementation.)^
** ^SQLite makes a copy of the [sqlite3_pcache_methods2] object.</dd>
**
** [[SQLITE_CONFIG_GETPCACHE2]] <dt>SQLITE_CONFIG_GETPCACHE2</dt>
** <dd> ^(The SQLITE_CONFIG_GETPCACHE2 option takes a single argument which
** is a pointer to an [sqlite3_pcache_methods2] object.  SQLite copies of
** the current page cache implementation into that object.)^ </dd>
**
** [[SQLITE_CONFIG_LOG]] <dt>SQLITE_CONFIG_LOG</dt>
** <dd> The SQLITE_CONFIG_LOG option is used to configure the SQLite
** global [error log].
** (^The SQLITE_CONFIG_LOG option takes two arguments: a pointer to a
** function with a call signature of void(*)(void*,int,const char*),
** and a pointer to void. ^If the function pointer is not NULL, it is
** invoked by [sqlite3_log()] to process each logging event.  ^If the
** function pointer is NULL, the [sqlite3_log()] interface becomes a no-op.
** ^The void pointer that is the second argument to SQLITE_CONFIG_LOG is
** passed through as the first parameter to the application-defined logger
** function whenever that function is invoked.  ^The second parameter to
** the logger function is a copy of the first parameter to the corresponding
** [sqlite3_log()] call and is intended to be a [result code] or an
** [extended result code].  ^The third parameter passed to the logger is
** log message after formatting via [sqlite3_snprintf()].
** The SQLite logging interface is not reentrant; the logger function
** supplied by the application must not invoke any SQLite interface.
** In a multi-threaded application, the application-defined logger
** function must be threadsafe. </dd>
**
** [[SQLITE_CONFIG_URI]] <dt>SQLITE_CONFIG_URI
** <dd>^(The SQLITE_CONFIG_URI option takes a single argument of type int.
** If non-zero, then URI handling is globally enabled. If the parameter is zero,
** then URI handling is globally disabled.)^ ^If URI handling is globally
** enabled, all filenames passed to [sqlite3_open()], [sqlite3_open_v2()],
** [sqlite3_open16()] or
** specified as part of [ATTACH] commands are interpreted as URIs, regardless
** of whether or not the [SQLITE_OPEN_URI] flag is set when the database
** connection is opened. ^If it is globally disabled, filenames are
** only interpreted as URIs if the SQLITE_OPEN_URI flag is set when the
** database connection is opened. ^(By default, URI handling is globally
** disabled. The default value may be changed by compiling with the
** [SQLITE_USE_URI] symbol defined.)^
**
** [[SQLITE_CONFIG_COVERING_INDEX_SCAN]] <dt>SQLITE_CONFIG_COVERING_INDEX_SCAN
** <dd>^The SQLITE_CONFIG_COVERING_INDEX_SCAN option takes a single integer
** argument which is interpreted as a boolean in order to enable or disable
** the use of covering indices for full table scans in the query optimizer.
** ^The default setting is determined
** by the [SQLITE_ALLOW_COVERING_INDEX_SCAN] compile-time option, or is "on"
** if that compile-time option is omitted.
** The ability to disable the use of covering indices for full table scans
** is because some incorrectly coded legacy applications might malfunction
** when the optimization is enabled.  Providing the ability to
** disable the optimization allows the older, buggy application code to work
** without change even with newer versions of SQLite.
**
** [[SQLITE_CONFIG_PCACHE]] [[SQLITE_CONFIG_GETPCACHE]]
** <dt>SQLITE_CONFIG_PCACHE and SQLITE_CONFIG_GETPCACHE
** <dd> These options are obsolete and should not be used by new code.
** They are retained for backwards compatibility but are now no-ops.
** </dd>
**
** [[SQLITE_CONFIG_SQLLOG]]
** <dt>SQLITE_CONFIG_SQLLOG
** <dd>This option is only available if sqlite is compiled with the
** [SQLITE_ENABLE_SQLLOG] pre-processor macro defined. The first argument should
** be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int).
** The second should be of type (void*). The callback is invoked by the library
** in three separate circumstances, identified by the value passed as the
** fourth parameter. If the fourth parameter is 0, then the database connection
** passed as the second argument has just been opened. The third argument
** points to a buffer containing the name of the main database file. If the
** fourth parameter is 1, then the SQL statement that the third parameter
** points to has just been executed. Or, if the fourth parameter is 2, then
** the connection being passed as the second parameter is being closed. The
** third parameter is passed NULL In this case.  An example of using this
** configuration option can be seen in the "test_sqllog.c" source file in
** the canonical SQLite source tree.</dd>
**
** [[SQLITE_CONFIG_MMAP_SIZE]]
** <dt>SQLITE_CONFIG_MMAP_SIZE
** <dd>^SQLITE_CONFIG_MMAP_SIZE takes two 64-bit integer (sqlite3_int64) values
** that are the default mmap size limit (the default setting for
** [PRAGMA mmap_size]) and the maximum allowed mmap size limit.
** ^The default setting can be overridden by each database connection using
** either the [PRAGMA mmap_size] command, or by using the
** [SQLITE_FCNTL_MMAP_SIZE] file control.  ^(The maximum allowed mmap size
** will be silently truncated if necessary so that it does not exceed the
** compile-time maximum mmap size set by the
** [SQLITE_MAX_MMAP_SIZE] compile-time option.)^
** ^If either argument to this option is negative, then that argument is
** changed to its compile-time default.
**
** [[SQLITE_CONFIG_WIN32_HEAPSIZE]]
** <dt>SQLITE_CONFIG_WIN32_HEAPSIZE
** <dd>^The SQLITE_CONFIG_WIN32_HEAPSIZE option is only available if SQLite is
** compiled for Windows with the [SQLITE_WIN32_MALLOC] pre-processor macro
** defined. ^SQLITE_CONFIG_WIN32_HEAPSIZE takes a 32-bit unsigned integer value
** that specifies the maximum size of the created heap.
**
** [[SQLITE_CONFIG_PCACHE_HDRSZ]]
** <dt>SQLITE_CONFIG_PCACHE_HDRSZ
** <dd>^The SQLITE_CONFIG_PCACHE_HDRSZ option takes a single parameter which
** is a pointer to an integer and writes into that integer the number of extra
** bytes per page required for each page in [SQLITE_CONFIG_PAGECACHE].
** The amount of extra space required can change depending on the compiler,
** target platform, and SQLite version.
**
** [[SQLITE_CONFIG_PMASZ]]
** <dt>SQLITE_CONFIG_PMASZ
** <dd>^The SQLITE_CONFIG_PMASZ option takes a single parameter which
** is an unsigned integer and sets the "Minimum PMA Size" for the multithreaded
** sorter to that integer.  The default minimum PMA Size is set by the
** [SQLITE_SORTER_PMASZ] compile-time option.  New threads are launched
** to help with sort operations when multithreaded sorting
** is enabled (using the [PRAGMA threads] command) and the amount of content
** to be sorted exceeds the page size times the minimum of the
** [PRAGMA cache_size] setting and this value.
**
** [[SQLITE_CONFIG_STMTJRNL_SPILL]]
** <dt>SQLITE_CONFIG_STMTJRNL_SPILL
** <dd>^The SQLITE_CONFIG_STMTJRNL_SPILL option takes a single parameter which
** becomes the [statement journal] spill-to-disk threshold.
** [Statement journals] are held in memory until their size (in bytes)
** exceeds this threshold, at which point they are written to disk.
** Or if the threshold is -1, statement journals are always held
** exclusively in memory.
** Since many statement journals never become large, setting the spill
** threshold to a value such as 64KiB can greatly reduce the amount of
** I/O required to support statement rollback.
** The default value for this setting is controlled by the
** [SQLITE_STMTJRNL_SPILL] compile-time option.
** </dl>
*/
#define SQLITE_CONFIG_SINGLETHREAD  1
#define SQLITE_CONFIG_MULTITHREAD   2
#define SQLITE_CONFIG_SERIALIZED    3
#define SQLITE_CONFIG_MALLOC        4
#define SQLITE_CONFIG_GETMALLOC     5
#define SQLITE_CONFIG_SCRATCH       6
#define SQLITE_CONFIG_PAGECACHE     7
#define SQLITE_CONFIG_HEAP          8
#define SQLITE_CONFIG_MEMSTATUS     9
#define SQLITE_CONFIG_MUTEX        10
#define SQLITE_CONFIG_GETMUTEX     11
/* previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. */
#define SQLITE_CONFIG_LOOKASIDE    13
#define SQLITE_CONFIG_PCACHE       14
#define SQLITE_CONFIG_GETPCACHE    15
#define SQLITE_CONFIG_LOG          16
#define SQLITE_CONFIG_URI          17
#define SQLITE_CONFIG_PCACHE2      18
#define SQLITE_CONFIG_GETPCACHE2   19
#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20
#define SQLITE_CONFIG_SQLLOG       21
#define SQLITE_CONFIG_MMAP_SIZE    22
#define SQLITE_CONFIG_WIN32_HEAPSIZE      23
#define SQLITE_CONFIG_PCACHE_HDRSZ        24
#define SQLITE_CONFIG_PMASZ               25
#define SQLITE_CONFIG_STMTJRNL_SPILL      26
#define SQLITE_CONFIG_SMALL_MALLOC        27
/*
** CAPI3REF: Database Connection Configuration Options
**
** These constants are the available integer configuration options that
** can be passed as the second argument to the [sqlite3_db_config()] interface.
**
** New configuration options may be added in future releases of SQLite.
** Existing configuration options might be discontinued.  Applications
** should check the return code from [sqlite3_db_config()] to make sure that
** the call worked.  ^The [sqlite3_db_config()] interface will return a
** non-zero [error code] if a discontinued or unsupported configuration option
** is invoked.
**
** <dl>
** <dt>SQLITE_DBCONFIG_LOOKASIDE</dt>
** <dd> ^This option takes three additional arguments that determine the
** [lookaside memory allocator] configuration for the [database connection].
** ^The first argument (the third parameter to [sqlite3_db_config()] is a
** pointer to a memory buffer to use for lookaside memory.
** ^The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb
** may be NULL in which case SQLite will allocate the
** lookaside buffer itself using [sqlite3_malloc()]. ^The second argument is the
** size of each lookaside buffer slot.  ^The third argument is the number of
** slots.  The size of the buffer in the first argument must be greater than
** or equal to the product of the second and third arguments.  The buffer
** must be aligned to an 8-byte boundary.  ^If the second argument to
** SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally
** rounded down to the next smaller multiple of 8.  ^(The lookaside memory
** configuration for a database connection can only be changed when that
** connection is not currently using lookaside memory, or in other words
** when the "current value" returned by
** [sqlite3_db_status](D,[SQLITE_CONFIG_LOOKASIDE],...) is zero.
** Any attempt to change the lookaside memory configuration when lookaside
** memory is in use leaves the configuration unchanged and returns
** [SQLITE_BUSY].)^</dd>
**
** <dt>SQLITE_DBCONFIG_ENABLE_FKEY</dt>
** <dd> ^This option is used to enable or disable the enforcement of
** [foreign key constraints].  There should be two additional arguments.
** The first argument is an integer which is 0 to disable FK enforcement,
** positive to enable FK enforcement or negative to leave FK enforcement
** unchanged.  The second parameter is a pointer to an integer into which
** is written 0 or 1 to indicate whether FK enforcement is off or on
** following this call.  The second parameter may be a NULL pointer, in
** which case the FK enforcement setting is not reported back. </dd>
**
** <dt>SQLITE_DBCONFIG_ENABLE_TRIGGER</dt>
** <dd> ^This option is used to enable or disable [CREATE TRIGGER | triggers].
** There should be two additional arguments.
** The first argument is an integer which is 0 to disable triggers,
** positive to enable triggers or negative to leave the setting unchanged.
** The second parameter is a pointer to an integer into which
** is written 0 or 1 to indicate whether triggers are disabled or enabled
** following this call.  The second parameter may be a NULL pointer, in
** which case the trigger setting is not reported back. </dd>
**
** <dt>SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER</dt>
** <dd> ^This option is used to enable or disable the two-argument
** version of the [fts3_tokenizer()] function which is part of the
** [FTS3] full-text search engine extension.
** There should be two additional arguments.
** The first argument is an integer which is 0 to disable fts3_tokenizer() or
** positive to enable fts3_tokenizer() or negative to leave the setting
** unchanged.
** The second parameter is a pointer to an integer into which
** is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled
** following this call.  The second parameter may be a NULL pointer, in
** which case the new setting is not reported back. </dd>
**
** <dt>SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION</dt>
** <dd> ^This option is used to enable or disable the [sqlite3_load_extension()]
** interface independently of the [load_extension()] SQL function.
** The [sqlite3_enable_load_extension()] API enables or disables both the
** C-API [sqlite3_load_extension()] and the SQL function [load_extension()].
** There should be two additional arguments.
** When the first argument to this interface is 1, then only the C-API is
** enabled and the SQL function remains disabled.  If the first argument to
** this interface is 0, then both the C-API and the SQL function are disabled.
** If the first argument is -1, then no changes are made to state of either the
** C-API or the SQL function.
** The second parameter is a pointer to an integer into which
** is written 0 or 1 to indicate whether [sqlite3_load_extension()] interface
** is disabled or enabled following this call.  The second parameter may
** be a NULL pointer, in which case the new setting is not reported back.
** </dd>
**
** <dt>SQLITE_DBCONFIG_MAINDBNAME</dt>
** <dd> ^This option is used to change the name of the "main" database
** schema.  ^The sole argument is a pointer to a constant UTF8 string
** which will become the new schema name in place of "main".  ^SQLite
** does not make a copy of the new main schema name string, so the application
** must ensure that the argument passed into this DBCONFIG option is unchanged
** until after the database connection closes.
** </dd>
**
** <dt>SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE</dt>
** <dd> Usually, when a database in wal mode is closed or detached from a
** database handle, SQLite checks if this will mean that there are now no
** connections at all to the database. If so, it performs a checkpoint
** operation before closing the connection. This option may be used to
** override this behaviour. The first parameter passed to this operation
** is an integer - non-zero to disable checkpoints-on-close, or zero (the
** default) to enable them. The second parameter is a pointer to an integer
** into which is written 0 or 1 to indicate whether checkpoints-on-close
** have been disabled - 0 if they are not disabled, 1 if they are.
** </dd>
** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>
** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates
** the [query planner stability guarantee] (QPSG).  When the QPSG is active,
** a single SQL query statement will always use the same algorithm regardless
** of values of [bound parameters].)^ The QPSG disables some query optimizations
** that look at the values of bound parameters, which can make some queries
** slower.  But the QPSG has the advantage of more predictable behavior.  With
** the QPSG active, SQLite will always use the same query plan in the field as
** was used during testing in the lab.
** </dd>
** <dt>SQLITE_DBCONFIG_TRIGGER_EQP</dt>
** <dd> By default, the output of EXPLAIN QUERY PLAN commands does not
** include output for any operations performed by trigger programs. This
** option is used to set or clear (the default) a flag that governs this
** behavior. The first parameter passed to this operation is an integer -
** non-zero to enable output for trigger programs, or zero to disable it.
** The second parameter is a pointer to an integer into which is written
** 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if
** it is not disabled, 1 if it is.
** </dd>
** </dl>
*/
#define SQLITE_DBCONFIG_MAINDBNAME            1000
#define SQLITE_DBCONFIG_LOOKASIDE             1001
#define SQLITE_DBCONFIG_ENABLE_FKEY           1002
#define SQLITE_DBCONFIG_ENABLE_TRIGGER        1003
#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004
#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005
#define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE      1006
#define SQLITE_DBCONFIG_ENABLE_QPSG           1007
#define SQLITE_DBCONFIG_TRIGGER_EQP           1008
#define SQLITE_DBCONFIG_MAX                   1008
/*
** CAPI3REF: Enable Or Disable Extended Result Codes
** METHOD: sqlite3
**
** ^The sqlite3_extended_result_codes() routine enables or disables the
** [extended result codes] feature of SQLite. ^The extended result
** codes are disabled by default for historical compatibility.
*/
SQLITE_API int sqlite3_extended_result_codes(sqlite3*, int onoff);
/*
** CAPI3REF: Last Insert Rowid
** METHOD: sqlite3
**
** ^Each entry in most SQLite tables (except for [WITHOUT ROWID] tables)
** has a unique 64-bit signed
** integer key called the [ROWID | "rowid"]. ^The rowid is always available
** as an undeclared column named ROWID, OID, or _ROWID_ as long as those
** names are not also used by explicitly declared columns. ^If
** the table has a column of type [INTEGER PRIMARY KEY] then that column
** is another alias for the rowid.
**
** ^The sqlite3_last_insert_rowid(D) interface usually returns the [rowid] of
** the most recent successful [INSERT] into a rowid table or [virtual table]
** on database connection D. ^Inserts into [WITHOUT ROWID] tables are not
** recorded. ^If no successful [INSERT]s into rowid tables have ever occurred
** on the database connection D, then sqlite3_last_insert_rowid(D) returns
** zero.
**
** As well as being set automatically as rows are inserted into database
** tables, the value returned by this function may be set explicitly by
** [sqlite3_set_last_insert_rowid()]
**
** Some virtual table implementations may INSERT rows into rowid tables as
** part of committing a transaction (e.g. to flush data accumulated in memory
** to disk). In this case subsequent calls to this function return the rowid
** associated with these internal INSERT operations, which leads to
** unintuitive results. Virtual table implementations that do write to rowid
** tables in this way can avoid this problem by restoring the original
** rowid value using [sqlite3_set_last_insert_rowid()] before returning
** control to the user.
**
** ^(If an [INSERT] occurs within a trigger then this routine will
** return the [rowid] of the inserted row as long as the trigger is
** running. Once the trigger program ends, the value returned
** by this routine reverts to what it was before the trigger was fired.)^
**
** ^An [INSERT] that fails due to a constraint violation is not a
** successful [INSERT] and does not change the value returned by this
** routine.  ^Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK,
** and INSERT OR ABORT make no changes to the return value of this
** routine when their insertion fails.  ^(When INSERT OR REPLACE
** encounters a constraint violation, it does not fail.  The
** INSERT continues to completion after deleting rows that caused
** the constraint problem so INSERT OR REPLACE will always change
** the return value of this interface.)^
**
** ^For the purposes of this routine, an [INSERT] is considered to
** be successful even if it is subsequently rolled back.
**
** This function is accessible to SQL statements via the
** [last_insert_rowid() SQL function].
**
** If a separate thread performs a new [INSERT] on the same
** database connection while the [sqlite3_last_insert_rowid()]
** function is running and thus changes the last insert [rowid],
** then the value returned by [sqlite3_last_insert_rowid()] is
** unpredictable and might not equal either the old or the new
** last insert [rowid].
*/
SQLITE_API sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
/*
** CAPI3REF: Set the Last Insert Rowid value.
** METHOD: sqlite3
**
** The sqlite3_set_last_insert_rowid(D, R) method allows the application to
** set the value returned by calling sqlite3_last_insert_rowid(D) to R
** without inserting a row into the database.
*/
SQLITE_API void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);
/*
** CAPI3REF: Count The Number Of Rows Modified
** METHOD: sqlite3
**
** ^This function returns the number of rows modified, inserted or
** deleted by the most recently completed INSERT, UPDATE or DELETE
** statement on the database connection specified by the only parameter.
** ^Executing any other type of SQL statement does not modify the value
** returned by this function.
**
** ^Only changes made directly by the INSERT, UPDATE or DELETE statement are
** considered - auxiliary changes caused by [CREATE TRIGGER | triggers],
** [foreign key actions] or [REPLACE] constraint resolution are not counted.
**
** Changes to a view that are intercepted by
** [INSTEAD OF trigger | INSTEAD OF triggers] are not counted. ^The value
** returned by sqlite3_changes() immediately after an INSERT, UPDATE or
** DELETE statement run on a view is always zero. Only changes made to real
** tables are counted.
**
** Things are more complicated if the sqlite3_changes() function is
** executed while a trigger program is running. This may happen if the
** program uses the [changes() SQL function], or if some other callback
** function invokes sqlite3_changes() directly. Essentially:
**
** <ul>
**   <li> ^(Before entering a trigger program the value returned by
**        sqlite3_changes() function is saved. After the trigger program
**        has finished, the original value is restored.)^
**
**   <li> ^(Within a trigger program each INSERT, UPDATE and DELETE
**        statement sets the value returned by sqlite3_changes()
**        upon completion as normal. Of course, this value will not include
**        any changes performed by sub-triggers, as the sqlite3_changes()
**        value will be saved and restored after each sub-trigger has run.)^
** </ul>
**
** ^This means that if the changes() SQL function (or similar) is used
** by the first INSERT, UPDATE or DELETE statement within a trigger, it
** returns the value as set when the calling statement began executing.
** ^If it is used by the second or subsequent such statement within a trigger
** program, the value returned reflects the number of rows modified by the
** previous INSERT, UPDATE or DELETE statement within the same trigger.
**
** See also the [sqlite3_total_changes()] interface, the
** [count_changes pragma], and the [changes() SQL function].
**
** If a separate thread makes changes on the same database connection
** while [sqlite3_changes()] is running then the value returned
** is unpredictable and not meaningful.
*/
SQLITE_API int sqlite3_changes(sqlite3*);
/*
** CAPI3REF: Total Number Of Rows Modified
** METHOD: sqlite3
**
** ^This function returns the total number of rows inserted, modified or
** deleted by all [INSERT], [UPDATE] or [DELETE] statements completed
** since the database connection was opened, including those executed as
** part of trigger programs. ^Executing any other type of SQL statement
** does not affect the value returned by sqlite3_total_changes().
**
** ^Changes made as part of [foreign key actions] are included in the
** count, but those made as part of REPLACE constraint resolution are
** not. ^Changes to a view that are intercepted by INSTEAD OF triggers
** are not counted.
**
** See also the [sqlite3_changes()] interface, the
** [count_changes pragma], and the [total_changes() SQL function].
**
** If a separate thread makes changes on the same database connection
** while [sqlite3_total_changes()] is running then the value
** returned is unpredictable and not meaningful.
*/
SQLITE_API int sqlite3_total_changes(sqlite3*);
/*
** CAPI3REF: Interrupt A Long-Running Query
** METHOD: sqlite3
**
** ^This function causes any pending database operation to abort and
** return at its earliest opportunity. This routine is typically
** called in response to a user action such as pressing "Cancel"
** or Ctrl-C where the user wants a long query operation to halt
** immediately.
**
** ^It is safe to call this routine from a thread different from the
** thread that is currently running the database operation.  But it
** is not safe to call this routine with a [database connection] that
** is closed or might close before sqlite3_interrupt() returns.
**
** ^If an SQL operation is very nearly finished at the time when
** sqlite3_interrupt() is called, then it might not have an opportunity
** to be interrupted and might continue to completion.
**
** ^An SQL operation that is interrupted will return [SQLITE_INTERRUPT].
** ^If the interrupted SQL operation is an INSERT, UPDATE, or DELETE
** that is inside an explicit transaction, then the entire transaction
** will be rolled back automatically.
**
** ^The sqlite3_interrupt(D) call is in effect until all currently running
** SQL statements on [database connection] D complete.  ^Any new SQL statements
** that are started after the sqlite3_interrupt() call and before the
** running statements reaches zero are interrupted as if they had been
** running prior to the sqlite3_interrupt() call.  ^New SQL statements
** that are started after the running statement count reaches zero are
** not effected by the sqlite3_interrupt().
** ^A call to sqlite3_interrupt(D) that occurs when there are no running
** SQL statements is a no-op and has no effect on SQL statements
** that are started after the sqlite3_interrupt() call returns.
*/
SQLITE_API void sqlite3_interrupt(sqlite3*);
/*
** CAPI3REF: Determine If An SQL Statement Is Complete
**
** These routines are useful during command-line input to determine if the
** currently entered text seems to form a complete SQL statement or
** if additional input is needed before sending the text into
** SQLite for parsing.  ^These routines return 1 if the input string
** appears to be a complete SQL statement.  ^A statement is judged to be
** complete if it ends with a semicolon token and is not a prefix of a
** well-formed CREATE TRIGGER statement.  ^Semicolons that are embedded within
** string literals or quoted identifier names or comments are not
** independent tokens (they are part of the token in which they are
** embedded) and thus do not count as a statement terminator.  ^Whitespace
** and comments that follow the final semicolon are ignored.
**
** ^These routines return 0 if the statement is incomplete.  ^If a
** memory allocation fails, then SQLITE_NOMEM is returned.
**
** ^These routines do not parse the SQL statements thus
** will not detect syntactically incorrect SQL.
**
** ^(If SQLite has not been initialized using [sqlite3_initialize()] prior
** to invoking sqlite3_complete16() then sqlite3_initialize() is invoked
** automatically by sqlite3_complete16().  If that initialization fails,
** then the return value from sqlite3_complete16() will be non-zero
** regardless of whether or not the input SQL is complete.)^
**
** The input to [sqlite3_complete()] must be a zero-terminated
** UTF-8 string.
**
** The input to [sqlite3_complete16()] must be a zero-terminated
** UTF-16 string in native byte order.
*/
SQLITE_API int sqlite3_complete(const char *sql);
SQLITE_API int sqlite3_complete16(const void *sql);
/*
** CAPI3REF: Register A Callback To Handle SQLITE_BUSY Errors
** KEYWORDS: {busy-handler callback} {busy handler}
** METHOD: sqlite3
**
** ^The sqlite3_busy_handler(D,X,P) routine sets a callback function X
** that might be invoked with argument P whenever
** an attempt is made to access a database table associated with
** [database connection] D when another thread
** or process has the table locked.
** The sqlite3_busy_handler() interface is used to implement
** [sqlite3_busy_timeout()] and [PRAGMA busy_timeout].
**
** ^If the busy callback is NULL, then [SQLITE_BUSY]
** is returned immediately upon encountering the lock.  ^If the busy callback
** is not NULL, then the callback might be invoked with two arguments.
**
** ^The first argument to the busy handler is a copy of the void* pointer which
** is the third argument to sqlite3_busy_handler().  ^The second argument to
** the busy handler callback is the number of times that the busy handler has
** been invoked previously for the same locking event.  ^If the
** busy callback returns 0, then no additional attempts are made to
** access the database and [SQLITE_BUSY] is returned
** to the application.
** ^If the callback returns non-zero, then another attempt
** is made to access the database and the cycle repeats.
**
** The presence of a busy handler does not guarantee that it will be invoked
** when there is lock contention. ^If SQLite determines that invoking the busy
** handler could result in a deadlock, it will go ahead and return [SQLITE_BUSY]
** to the application instead of invoking the
** busy handler.
** Consider a scenario where one process is holding a read lock that
** it is trying to promote to a reserved lock and
** a second process is holding a reserved lock that it is trying
** to promote to an exclusive lock.  The first process cannot proceed
** because it is blocked by the second and the second process cannot
** proceed because it is blocked by the first.  If both processes
** invoke the busy handlers, neither will make any progress.  Therefore,
** SQLite returns [SQLITE_BUSY] for the first process, hoping that this
** will induce the first process to release its read lock and allow
** the second process to proceed.
**
** ^The default busy callback is NULL.
**
** ^(There can only be a single busy handler defined for each
** [database connection].  Setting a new busy handler clears any
** previously set handler.)^  ^Note that calling [sqlite3_busy_timeout()]
** or evaluating [PRAGMA busy_timeout=N] will change the
** busy handler and thus clear any previously set busy handler.
**
** The busy callback should not take any actions which modify the
** database connection that invoked the busy handler.  In other words,
** the busy handler is not reentrant.  Any such actions
** result in undefined behavior.
**
** A busy handler must not close the database connection
** or [prepared statement] that invoked the busy handler.
*/
SQLITE_API int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);
/*
** CAPI3REF: Set A Busy Timeout
** METHOD: sqlite3
**
** ^This routine sets a [sqlite3_busy_handler | busy handler] that sleeps
** for a specified amount of time when a table is locked.  ^The handler
** will sleep multiple times until at least "ms" milliseconds of sleeping
** have accumulated.  ^After at least "ms" milliseconds of sleeping,
** the handler returns 0 which causes [sqlite3_step()] to return
** [SQLITE_BUSY].
**
** ^Calling this routine with an argument less than or equal to zero
** turns off all busy handlers.
**
** ^(There can only be a single busy handler for a particular
** [database connection] at any given moment.  If another busy handler
** was defined  (using [sqlite3_busy_handler()]) prior to calling
** this routine, that other busy handler is cleared.)^
**
** See also:  [PRAGMA busy_timeout]
*/
SQLITE_API int sqlite3_busy_timeout(sqlite3*, int ms);
/*
** CAPI3REF: Convenience Routines For Running Queries
** METHOD: sqlite3
**
** This is a legacy interface that is preserved for backwards compatibility.
** Use of this interface is not recommended.
**
** Definition: A <b>result table</b> is memory data structure created by the
** [sqlite3_get_table()] interface.  A result table records the
** complete query results from one or more queries.
**
** The table conceptually has a number of rows and columns.  But
** these numbers are not part of the result table itself.  These
** numbers are obtained separately.  Let N be the number of rows
** and M be the number of columns.
**
** A result table is an array of pointers to zero-terminated UTF-8 strings.
** There are (N+1)*M elements in the array.  The first M pointers point
** to zero-terminated strings that  contain the names of the columns.
** The remaining entries all point to query results.  NULL values result
** in NULL pointers.  All other values are in their UTF-8 zero-terminated
** string representation as returned by [sqlite3_column_text()].
**
** A result table might consist of one or more memory allocations.
** It is not safe to pass a result table directly to [sqlite3_free()].
** A result table should be deallocated using [sqlite3_free_table()].
**
** ^(As an example of the result table format, suppose a query result
** is as follows:
**
** <blockquote><pre>
**        Name        | Age
**        -----------------------
**        Alice       | 43
**        Bob         | 28
**        Cindy       | 21
** </pre></blockquote>
**
** There are two column (M==2) and three rows (N==3).  Thus the
** result table has 8 entries.  Suppose the result table is stored
** in an array names azResult.  Then azResult holds this content:
**
** <blockquote><pre>
**        azResult&#91;0] = "Name";
**        azResult&#91;1] = "Age";
**        azResult&#91;2] = "Alice";
**        azResult&#91;3] = "43";
**        azResult&#91;4] = "Bob";
**        azResult&#91;5] = "28";
**        azResult&#91;6] = "Cindy";
**        azResult&#91;7] = "21";
** </pre></blockquote>)^
**
** ^The sqlite3_get_table() function evaluates one or more
** semicolon-separated SQL statements in the zero-terminated UTF-8
** string of its 2nd parameter and returns a result table to the
** pointer given in its 3rd parameter.
**
** After the application has finished with the result from sqlite3_get_table(),
** it must pass the result table pointer to sqlite3_free_table() in order to
** release the memory that was malloced.  Because of the way the
** [sqlite3_malloc()] happens within sqlite3_get_table(), the calling
** function must not try to call [sqlite3_free()] directly.  Only
** [sqlite3_free_table()] is able to release the memory properly and safely.
**
** The sqlite3_get_table() interface is implemented as a wrapper around
** [sqlite3_exec()].  The sqlite3_get_table() routine does not have access
** to any internal data structures of SQLite.  It uses only the public
** interface defined here.  As a consequence, errors that occur in the
** wrapper layer outside of the internal [sqlite3_exec()] call are not
** reflected in subsequent calls to [sqlite3_errcode()] or
** [sqlite3_errmsg()].
*/
SQLITE_API int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrmsg
);
SQLITE_API void sqlite3_free_table(char **result);
/*
** CAPI3REF: Formatted String Printing Functions
**
** These routines are work-alikes of the "printf()" family of functions
** from the standard C library.
** These routines understand most of the common K&R formatting options,
** plus some additional non-standard formats, detailed below.
** Note that some of the more obscure formatting options from recent
** C-library standards are omitted from this implementation.
**
** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their
** results into memory obtained from [sqlite3_malloc()].
** The strings returned by these two routines should be
** released by [sqlite3_free()].  ^Both routines return a
** NULL pointer if [sqlite3_malloc()] is unable to allocate enough
** memory to hold the resulting string.
**
** ^(The sqlite3_snprintf() routine is similar to "snprintf()" from
** the standard C library.  The result is written into the
** buffer supplied as the second parameter whose size is given by
** the first parameter. Note that the order of the
** first two parameters is reversed from snprintf().)^  This is an
** historical accident that cannot be fixed without breaking
** backwards compatibility.  ^(Note also that sqlite3_snprintf()
** returns a pointer to its buffer instead of the number of
** characters actually written into the buffer.)^  We admit that
** the number of characters written would be a more useful return
** value but we cannot change the implementation of sqlite3_snprintf()
** now without breaking compatibility.
**
** ^As long as the buffer size is greater than zero, sqlite3_snprintf()
** guarantees that the buffer is always zero-terminated.  ^The first
** parameter "n" is the total size of the buffer, including space for
** the zero terminator.  So the longest string that can be completely
** written will be n-1 characters.
**
** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().
**
** These routines all implement some additional formatting
** options that are useful for constructing SQL statements.
** All of the usual printf() formatting options apply.  In addition, there
** is are "%q", "%Q", "%w" and "%z" options.
**
** ^(The %q option works like %s in that it substitutes a nul-terminated
** string from the argument list.  But %q also doubles every '\'' character.
** %q is designed for use inside a string literal.)^  By doubling each '\''
** character it escapes that character and allows it to be inserted into
** the string.
**
** For example, assume the string variable zText contains text as follows:
**
** <blockquote><pre>
**  char *zText = "It's a happy day!";
** </pre></blockquote>
**
** One can use this text in an SQL statement as follows:
**
** <blockquote><pre>
**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES('%q')", zText);
**  sqlite3_exec(db, zSQL, 0, 0, 0);
**  sqlite3_free(zSQL);
** </pre></blockquote>
**
** Because the %q format string is used, the '\'' character in zText
** is escaped and the SQL generated is as follows:
**
** <blockquote><pre>
**  INSERT INTO table1 VALUES('It''s a happy day!')
** </pre></blockquote>
**
** This is correct.  Had we used %s instead of %q, the generated SQL
** would have looked like this:
**
** <blockquote><pre>
**  INSERT INTO table1 VALUES('It's a happy day!');
** </pre></blockquote>
**
** This second example is an SQL syntax error.  As a general rule you should
** always use %q instead of %s when inserting text into a string literal.
**
** ^(The %Q option works like %q except it also adds single quotes around
** the outside of the total string.  Additionally, if the parameter in the
** argument list is a NULL pointer, %Q substitutes the text "NULL" (without
** single quotes).)^  So, for example, one could say:
**
** <blockquote><pre>
**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES(%Q)", zText);
**  sqlite3_exec(db, zSQL, 0, 0, 0);
**  sqlite3_free(zSQL);
** </pre></blockquote>
**
** The code above will render a correct SQL statement in the zSQL
** variable even if the zText variable is a NULL pointer.
**
** ^(The "%w" formatting option is like "%q" except that it expects to
** be contained within double-quotes instead of single quotes, and it
** escapes the double-quote character instead of the single-quote
** character.)^  The "%w" formatting option is intended for safely inserting
** table and column names into a constructed SQL statement.
**
** ^(The "%z" formatting option works like "%s" but with the
** addition that after the string has been read and copied into
** the result, [sqlite3_free()] is called on the input string.)^
*/
SQLITE_API char *sqlite3_mprintf(const char*,...);
SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
SQLITE_API char *sqlite3_snprintf(int,char*,const char*, ...);
SQLITE_API char *sqlite3_vsnprintf(int,char*,const char*, va_list);
/*
** CAPI3REF: Memory Allocation Subsystem
**
** The SQLite core uses these three routines for all of its own
** internal memory allocation needs. "Core" in the previous sentence
** does not include operating-system specific VFS implementation.  The
** Windows VFS uses native malloc() and free() for some operations.
**
** ^The sqlite3_malloc() routine returns a pointer to a block
** of memory at least N bytes in length, where N is the parameter.
** ^If sqlite3_malloc() is unable to obtain sufficient free
** memory, it returns a NULL pointer.  ^If the parameter N to
** sqlite3_malloc() is zero or negative then sqlite3_malloc() returns
** a NULL pointer.
**
** ^The sqlite3_malloc64(N) routine works just like
** sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead
** of a signed 32-bit integer.
**
** ^Calling sqlite3_free() with a pointer previously returned
** by sqlite3_malloc() or sqlite3_realloc() releases that memory so
** that it might be reused.  ^The sqlite3_free() routine is
** a no-op if is called with a NULL pointer.  Passing a NULL pointer
** to sqlite3_free() is harmless.  After being freed, memory
** should neither be read nor written.  Even reading previously freed
** memory might result in a segmentation fault or other severe error.
** Memory corruption, a segmentation fault, or other severe error
** might result if sqlite3_free() is called with a non-NULL pointer that
** was not obtained from sqlite3_malloc() or sqlite3_realloc().
**
** ^The sqlite3_realloc(X,N) interface attempts to resize a
** prior memory allocation X to be at least N bytes.
** ^If the X parameter to sqlite3_realloc(X,N)
** is a NULL pointer then its behavior is identical to calling
** sqlite3_malloc(N).
** ^If the N parameter to sqlite3_realloc(X,N) is zero or
** negative then the behavior is exactly the same as calling
** sqlite3_free(X).
** ^sqlite3_realloc(X,N) returns a pointer to a memory allocation
** of at least N bytes in size or NULL if insufficient memory is available.
** ^If M is the size of the prior allocation, then min(N,M) bytes
** of the prior allocation are copied into the beginning of buffer returned
** by sqlite3_realloc(X,N) and the prior allocation is freed.
** ^If sqlite3_realloc(X,N) returns NULL and N is positive, then the
** prior allocation is not freed.
**
** ^The sqlite3_realloc64(X,N) interfaces works the same as
** sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead
** of a 32-bit signed integer.
**
** ^If X is a memory allocation previously obtained from sqlite3_malloc(),
** sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then
** sqlite3_msize(X) returns the size of that memory allocation in bytes.
** ^The value returned by sqlite3_msize(X) might be larger than the number
** of bytes requested when X was allocated.  ^If X is a NULL pointer then
** sqlite3_msize(X) returns zero.  If X points to something that is not
** the beginning of memory allocation, or if it points to a formerly
** valid memory allocation that has now been freed, then the behavior
** of sqlite3_msize(X) is undefined and possibly harmful.
**
** ^The memory returned by sqlite3_malloc(), sqlite3_realloc(),
** sqlite3_malloc64(), and sqlite3_realloc64()
** is always aligned to at least an 8 byte boundary, or to a
** 4 byte boundary if the [SQLITE_4_BYTE_ALIGNED_MALLOC] compile-time
** option is used.
**
** In SQLite version 3.5.0 and 3.5.1, it was possible to define
** the SQLITE_OMIT_MEMORY_ALLOCATION which would cause the built-in
** implementation of these routines to be omitted.  That capability
** is no longer provided.  Only built-in memory allocators can be used.
**
** Prior to SQLite version 3.7.10, the Windows OS interface layer called
** the system malloc() and free() directly when converting
** filenames between the UTF-8 encoding used by SQLite
** and whatever filename encoding is used by the particular Windows
** installation.  Memory allocation errors were detected, but
** they were reported back as [SQLITE_CANTOPEN] or
** [SQLITE_IOERR] rather than [SQLITE_NOMEM].
**
** The pointer arguments to [sqlite3_free()] and [sqlite3_realloc()]
** must be either NULL or else pointers obtained from a prior
** invocation of [sqlite3_malloc()] or [sqlite3_realloc()] that have
** not yet been released.
**
** The application must not read or write any part of
** a block of memory after it has been released using
** [sqlite3_free()] or [sqlite3_realloc()].
*/
SQLITE_API void *sqlite3_malloc(int);
SQLITE_API void *sqlite3_malloc64(sqlite3_uint64);
SQLITE_API void *sqlite3_realloc(void*, int);
SQLITE_API void *sqlite3_realloc64(void*, sqlite3_uint64);
SQLITE_API void sqlite3_free(void*);
SQLITE_API sqlite3_uint64 sqlite3_msize(void*);
/*
** CAPI3REF: Memory Allocator Statistics
**
** SQLite provides these two interfaces for reporting on the status
** of the [sqlite3_malloc()], [sqlite3_free()], and [sqlite3_realloc()]
** routines, which form the built-in memory allocation subsystem.
**
** ^The [sqlite3_memory_used()] routine returns the number of bytes
** of memory currently outstanding (malloced but not freed).
** ^The [sqlite3_memory_highwater()] routine returns the maximum
** value of [sqlite3_memory_used()] since the high-water mark
** was last reset.  ^The values returned by [sqlite3_memory_used()] and
** [sqlite3_memory_highwater()] include any overhead
** added by SQLite in its implementation of [sqlite3_malloc()],
** but not overhead added by the any underlying system library
** routines that [sqlite3_malloc()] may call.
**
** ^The memory high-water mark is reset to the current value of
** [sqlite3_memory_used()] if and only if the parameter to
** [sqlite3_memory_highwater()] is true.  ^The value returned
** by [sqlite3_memory_highwater(1)] is the high-water mark
** prior to the reset.
*/
SQLITE_API sqlite3_int64 sqlite3_memory_used(void);
SQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
/*
** CAPI3REF: Pseudo-Random Number Generator
**
** SQLite contains a high-quality pseudo-random number generator (PRNG) used to
** select random [ROWID | ROWIDs] when inserting new records into a table that
** already uses the largest possible [ROWID].  The PRNG is also used for
** the build-in random() and randomblob() SQL functions.  This interface allows
** applications to access the same PRNG for other purposes.
**
** ^A call to this routine stores N bytes of randomness into buffer P.
** ^The P parameter can be a NULL pointer.
**
** ^If this routine has not been previously called or if the previous
** call had N less than one or a NULL pointer for P, then the PRNG is
** seeded using randomness obtained from the xRandomness method of
** the default [sqlite3_vfs] object.
** ^If the previous call to this routine had an N of 1 or more and a
** non-NULL P then the pseudo-randomness is generated
** internally and without recourse to the [sqlite3_vfs] xRandomness
** method.
*/
SQLITE_API void sqlite3_randomness(int N, void *P);
/*
** CAPI3REF: Compile-Time Authorization Callbacks
** METHOD: sqlite3
** KEYWORDS: {authorizer callback}
**
** ^This routine registers an authorizer callback with a particular
** [database connection], supplied in the first argument.
** ^The authorizer callback is invoked as SQL statements are being compiled
** by [sqlite3_prepare()] or its variants [sqlite3_prepare_v2()],
** [sqlite3_prepare_v3()], [sqlite3_prepare16()], [sqlite3_prepare16_v2()],
** and [sqlite3_prepare16_v3()].  ^At various
** points during the compilation process, as logic is being created
** to perform various actions, the authorizer callback is invoked to
** see if those actions are allowed.  ^The authorizer callback should
** return [SQLITE_OK] to allow the action, [SQLITE_IGNORE] to disallow the
** specific action but allow the SQL statement to continue to be
** compiled, or [SQLITE_DENY] to cause the entire SQL statement to be
** rejected with an error.  ^If the authorizer callback returns
** any value other than [SQLITE_IGNORE], [SQLITE_OK], or [SQLITE_DENY]
** then the [sqlite3_prepare_v2()] or equivalent call that triggered
** the authorizer will fail with an error message.
**
** When the callback returns [SQLITE_OK], that means the operation
** requested is ok.  ^When the callback returns [SQLITE_DENY], the
** [sqlite3_prepare_v2()] or equivalent call that triggered the
** authorizer will fail with an error message explaining that
** access is denied.
**
** ^The first parameter to the authorizer callback is a copy of the third
** parameter to the sqlite3_set_authorizer() interface. ^The second parameter
** to the callback is an integer [SQLITE_COPY | action code] that specifies
** the particular action to be authorized. ^The third through sixth parameters
** to the callback are either NULL pointers or zero-terminated strings
** that contain additional details about the action to be authorized.
** Applications must always be prepared to encounter a NULL pointer in any
** of the third through the sixth parameters of the authorization callback.
**
** ^If the action code is [SQLITE_READ]
** and the callback returns [SQLITE_IGNORE] then the
** [prepared statement] statement is constructed to substitute
** a NULL value in place of the table column that would have
** been read if [SQLITE_OK] had been returned.  The [SQLITE_IGNORE]
** return can be used to deny an untrusted user access to individual
** columns of a table.
** ^When a table is referenced by a [SELECT] but no column values are
** extracted from that table (for example in a query like
** "SELECT count(*) FROM tab") then the [SQLITE_READ] authorizer callback
** is invoked once for that table with a column name that is an empty string.
** ^If the action code is [SQLITE_DELETE] and the callback returns
** [SQLITE_IGNORE] then the [DELETE] operation proceeds but the
** [truncate optimization] is disabled and all rows are deleted individually.
**
** An authorizer is used when [sqlite3_prepare | preparing]
** SQL statements from an untrusted source, to ensure that the SQL statements
** do not try to access data they are not allowed to see, or that they do not
** try to execute malicious statements that damage the database.  For
** example, an application may allow a user to enter arbitrary
** SQL queries for evaluation by a database.  But the application does
** not want the user to be able to make arbitrary changes to the
** database.  An authorizer could then be put in place while the
** user-entered SQL is being [sqlite3_prepare | prepared] that
** disallows everything except [SELECT] statements.
**
** Applications that need to process SQL from untrusted sources
** might also consider lowering resource limits using [sqlite3_limit()]
** and limiting database size using the [max_page_count] [PRAGMA]
** in addition to using an authorizer.
**
** ^(Only a single authorizer can be in place on a database connection
** at a time.  Each call to sqlite3_set_authorizer overrides the
** previous call.)^  ^Disable the authorizer by installing a NULL callback.
** The authorizer is disabled by default.
**
** The authorizer callback must not do anything that will modify
** the database connection that invoked the authorizer callback.
** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their
** database connections for the meaning of "modify" in this paragraph.
**
** ^When [sqlite3_prepare_v2()] is used to prepare a statement, the
** statement might be re-prepared during [sqlite3_step()] due to a
** schema change.  Hence, the application should ensure that the
** correct authorizer callback remains in place during the [sqlite3_step()].
**
** ^Note that the authorizer callback is invoked only during
** [sqlite3_prepare()] or its variants.  Authorization is not
** performed during statement evaluation in [sqlite3_step()], unless
** as stated in the previous paragraph, sqlite3_step() invokes
** sqlite3_prepare_v2() to reprepare a statement after a schema change.
*/
SQLITE_API int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
/*
** CAPI3REF: Authorizer Return Codes
**
** The [sqlite3_set_authorizer | authorizer callback function] must
** return either [SQLITE_OK] or one of these two constants in order
** to signal SQLite whether or not the action is permitted.  See the
** [sqlite3_set_authorizer | authorizer documentation] for additional
** information.
**
** Note that SQLITE_IGNORE is also used as a [conflict resolution mode]
** returned from the [sqlite3_vtab_on_conflict()] interface.
*/
#define SQLITE_DENY   1
#define SQLITE_IGNORE 2
/*
** CAPI3REF: Authorizer Action Codes
**
** The [sqlite3_set_authorizer()] interface registers a callback function
** that is invoked to authorize certain SQL statement actions.  The
** second parameter to the callback is an integer code that specifies
** what action is being authorized.  These are the integer action codes that
** the authorizer callback may be passed.
**
** These action code values signify what kind of operation is to be
** authorized.  The 3rd and 4th parameters to the authorization
** callback function will be parameters or NULL depending on which of these
** codes is used as the second parameter.  ^(The 5th parameter to the
** authorizer callback is the name of the database ("main", "temp",
** etc.) if applicable.)^  ^The 6th parameter to the authorizer callback
** is the name of the inner-most trigger or view that is responsible for
** the access attempt or NULL if this access attempt is directly from
** top-level SQL code.
*/
/******************************************* 3rd ************ 4th ***********/
#define SQLITE_CREATE_INDEX          1
#define SQLITE_CREATE_TABLE          2
#define SQLITE_CREATE_TEMP_INDEX     3
#define SQLITE_CREATE_TEMP_TABLE     4
#define SQLITE_CREATE_TEMP_TRIGGER   5
#define SQLITE_CREATE_TEMP_VIEW      6
#define SQLITE_CREATE_TRIGGER        7
#define SQLITE_CREATE_VIEW           8
#define SQLITE_DELETE                9
#define SQLITE_DROP_INDEX           10
#define SQLITE_DROP_TABLE           11
#define SQLITE_DROP_TEMP_INDEX      12
#define SQLITE_DROP_TEMP_TABLE      13
#define SQLITE_DROP_TEMP_TRIGGER    14
#define SQLITE_DROP_TEMP_VIEW       15
#define SQLITE_DROP_TRIGGER         16
#define SQLITE_DROP_VIEW            17
#define SQLITE_INSERT               18
#define SQLITE_PRAGMA               19
#define SQLITE_READ                 20
#define SQLITE_SELECT               21
#define SQLITE_TRANSACTION          22
#define SQLITE_UPDATE               23
#define SQLITE_ATTACH               24
#define SQLITE_DETACH               25
#define SQLITE_ALTER_TABLE          26
#define SQLITE_REINDEX              27
#define SQLITE_ANALYZE              28
#define SQLITE_CREATE_VTABLE        29
#define SQLITE_DROP_VTABLE          30
#define SQLITE_FUNCTION             31
#define SQLITE_SAVEPOINT            32
#define SQLITE_COPY                  0
#define SQLITE_RECURSIVE            33
/*
** CAPI3REF: Tracing And Profiling Functions
** METHOD: sqlite3
**
** These routines are deprecated. Use the [sqlite3_trace_v2()] interface
** instead of the routines described here.
**
** These routines register callback functions that can be used for
** tracing and profiling the execution of SQL statements.
**
** ^The callback function registered by sqlite3_trace() is invoked at
** various times when an SQL statement is being run by [sqlite3_step()].
** ^The sqlite3_trace() callback is invoked with a UTF-8 rendering of the
** SQL statement text as the statement first begins executing.
** ^(Additional sqlite3_trace() callbacks might occur
** as each triggered subprogram is entered.  The callbacks for triggers
** contain a UTF-8 SQL comment that identifies the trigger.)^
**
** The [SQLITE_TRACE_SIZE_LIMIT] compile-time option can be used to limit
** the length of [bound parameter] expansion in the output of sqlite3_trace().
**
** ^The callback function registered by sqlite3_profile() is invoked
** as each SQL statement finishes.  ^The profile callback contains
** the original statement text and an estimate of wall-clock time
** of how long that statement took to run.  ^The profile callback
** time is in units of nanoseconds, however the current implementation
** is only capable of millisecond resolution so the six least significant
** digits in the time are meaningless.  Future versions of SQLite
** might provide greater resolution on the profiler callback.  The
** sqlite3_profile() function is considered experimental and is
** subject to change in future versions of SQLite.
*/
SQLITE_API SQLITE_DEPRECATED void *sqlite3_trace(sqlite3*,
   void(*xTrace)(void*,const char*), void*);
SQLITE_API SQLITE_DEPRECATED void *sqlite3_profile(sqlite3*,
   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
/*
** CAPI3REF: SQL Trace Event Codes
** KEYWORDS: SQLITE_TRACE
**
** These constants identify classes of events that can be monitored
** using the [sqlite3_trace_v2()] tracing logic.  The M argument
** to [sqlite3_trace_v2(D,M,X,P)] is an OR-ed combination of one or more of
** the following constants.  ^The first argument to the trace callback
** is one of the following constants.
**
** New tracing constants may be added in future releases.
**
** ^A trace callback has four arguments: xCallback(T,C,P,X).
** ^The T argument is one of the integer type codes above.
** ^The C argument is a copy of the context pointer passed in as the
** fourth argument to [sqlite3_trace_v2()].
** The P and X arguments are pointers whose meanings depend on T.
**
** <dl>
** [[SQLITE_TRACE_STMT]] <dt>SQLITE_TRACE_STMT</dt>
** <dd>^An SQLITE_TRACE_STMT callback is invoked when a prepared statement
** first begins running and possibly at other times during the
** execution of the prepared statement, such as at the start of each
** trigger subprogram. ^The P argument is a pointer to the
** [prepared statement]. ^The X argument is a pointer to a string which
** is the unexpanded SQL text of the prepared statement or an SQL comment
** that indicates the invocation of a trigger.  ^The callback can compute
** the same text that would have been returned by the legacy [sqlite3_trace()]
** interface by using the X argument when X begins with "--" and invoking
** [sqlite3_expanded_sql(P)] otherwise.
**
** [[SQLITE_TRACE_PROFILE]] <dt>SQLITE_TRACE_PROFILE</dt>
** <dd>^An SQLITE_TRACE_PROFILE callback provides approximately the same
** information as is provided by the [sqlite3_profile()] callback.
** ^The P argument is a pointer to the [prepared statement] and the
** X argument points to a 64-bit integer which is the estimated of
** the number of nanosecond that the prepared statement took to run.
** ^The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.
**
** [[SQLITE_TRACE_ROW]] <dt>SQLITE_TRACE_ROW</dt>
** <dd>^An SQLITE_TRACE_ROW callback is invoked whenever a prepared
** statement generates a single row of result.
** ^The P argument is a pointer to the [prepared statement] and the
** X argument is unused.
**
** [[SQLITE_TRACE_CLOSE]] <dt>SQLITE_TRACE_CLOSE</dt>
** <dd>^An SQLITE_TRACE_CLOSE callback is invoked when a database
** connection closes.
** ^The P argument is a pointer to the [database connection] object
** and the X argument is unused.
** </dl>
*/
#define SQLITE_TRACE_STMT       0x01
#define SQLITE_TRACE_PROFILE    0x02
#define SQLITE_TRACE_ROW        0x04
#define SQLITE_TRACE_CLOSE      0x08
/*
** CAPI3REF: SQL Trace Hook
** METHOD: sqlite3
**
** ^The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback
** function X against [database connection] D, using property mask M
** and context pointer P.  ^If the X callback is
** NULL or if the M mask is zero, then tracing is disabled.  The
** M argument should be the bitwise OR-ed combination of
** zero or more [SQLITE_TRACE] constants.
**
** ^Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides
** (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().
**
** ^The X callback is invoked whenever any of the events identified by
** mask M occur.  ^The integer return value from the callback is currently
** ignored, though this may change in future releases.  Callback
** implementations should return zero to ensure future compatibility.
**
** ^A trace callback is invoked with four arguments: callback(T,C,P,X).
** ^The T argument is one of the [SQLITE_TRACE]
** constants to indicate why the callback was invoked.
** ^The C argument is a copy of the context pointer.
** The P and X arguments are pointers whose meanings depend on T.
**
** The sqlite3_trace_v2() interface is intended to replace the legacy
** interfaces [sqlite3_trace()] and [sqlite3_profile()], both of which
** are deprecated.
*/
SQLITE_API int sqlite3_trace_v2(
  sqlite3*,
  unsigned uMask,
  int(*xCallback)(unsigned,void*,void*,void*),
  void *pCtx
);
/*
**  Same as V2; except last parameter is lenngth of data pointed at by 3rd.
**  [SQLITE_TRACE], pCtx, (Expr*), data, length
**
*/
SQLITE_API int sqlite3_trace_v3(
  sqlite3*,
  unsigned uMask,
  // statements with nuls need length;
  int(*xCallback)(unsigned,void*,void*,void*,int),
  void *pCtx
);
/*
** CAPI3REF: Query Progress Callbacks
** METHOD: sqlite3
**
** ^The sqlite3_progress_handler(D,N,X,P) interface causes the callback
** function X to be invoked periodically during long running calls to
** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] for
** database connection D.  An example use for this
** interface is to keep a GUI updated during a large query.
**
** ^The parameter P is passed through as the only parameter to the
** callback function X.  ^The parameter N is the approximate number of
** [virtual machine instructions] that are evaluated between successive
** invocations of the callback X.  ^If N is less than one then the progress
** handler is disabled.
**
** ^Only a single progress handler may be defined at one time per
** [database connection]; setting a new progress handler cancels the
** old one.  ^Setting parameter X to NULL disables the progress handler.
** ^The progress handler is also disabled by setting N to a value less
** than 1.
**
** ^If the progress callback returns non-zero, the operation is
** interrupted.  This feature can be used to implement a
** "Cancel" button on a GUI progress dialog box.
**
** The progress handler callback must not do anything that will modify
** the database connection that invoked the progress handler.
** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their
** database connections for the meaning of "modify" in this paragraph.
**
*/
SQLITE_API void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
/*
** CAPI3REF: Opening A New Database Connection
** CONSTRUCTOR: sqlite3
**
** ^These routines open an SQLite database file as specified by the
** filename argument. ^The filename argument is interpreted as UTF-8 for
** sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte
** order for sqlite3_open16(). ^(A [database connection] handle is usually
** returned in *ppDb, even if an error occurs.  The only exception is that
** if SQLite is unable to allocate memory to hold the [sqlite3] object,
** a NULL will be written into *ppDb instead of a pointer to the [sqlite3]
** object.)^ ^(If the database is opened (and/or created) successfully, then
** [SQLITE_OK] is returned.  Otherwise an [error code] is returned.)^ ^The
** [sqlite3_errmsg()] or [sqlite3_errmsg16()] routines can be used to obtain
** an English language description of the error following a failure of any
** of the sqlite3_open() routines.
**
** ^The default encoding will be UTF-8 for databases created using
** sqlite3_open() or sqlite3_open_v2().  ^The default encoding for databases
** created using sqlite3_open16() will be UTF-16 in the native byte order.
**
** Whether or not an error occurs when it is opened, resources
** associated with the [database connection] handle should be released by
** passing it to [sqlite3_close()] when it is no longer required.
**
** The sqlite3_open_v2() interface works like sqlite3_open()
** except that it accepts two additional parameters for additional control
** over the new database connection.  ^(The flags parameter to
** sqlite3_open_v2() can take one of
** the following three values, optionally combined with the
** [SQLITE_OPEN_NOMUTEX], [SQLITE_OPEN_FULLMUTEX], [SQLITE_OPEN_SHAREDCACHE],
** [SQLITE_OPEN_PRIVATECACHE], and/or [SQLITE_OPEN_URI] flags:)^
**
** <dl>
** ^(<dt>[SQLITE_OPEN_READONLY]</dt>
** <dd>The database is opened in read-only mode.  If the database does not
** already exist, an error is returned.</dd>)^
**
** ^(<dt>[SQLITE_OPEN_READWRITE]</dt>
** <dd>The database is opened for reading and writing if possible, or reading
** only if the file is write protected by the operating system.  In either
** case the database must already exist, otherwise an error is returned.</dd>)^
**
** ^(<dt>[SQLITE_OPEN_READWRITE] | [SQLITE_OPEN_CREATE]</dt>
** <dd>The database is opened for reading and writing, and is created if
** it does not already exist. This is the behavior that is always used for
** sqlite3_open() and sqlite3_open16().</dd>)^
** </dl>
**
** If the 3rd parameter to sqlite3_open_v2() is not one of the
** combinations shown above optionally combined with other
** [SQLITE_OPEN_READONLY | SQLITE_OPEN_* bits]
** then the behavior is undefined.
**
** ^If the [SQLITE_OPEN_NOMUTEX] flag is set, then the database connection
** opens in the multi-thread [threading mode] as long as the single-thread
** mode has not been set at compile-time or start-time.  ^If the
** [SQLITE_OPEN_FULLMUTEX] flag is set then the database connection opens
** in the serialized [threading mode] unless single-thread was
** previously selected at compile-time or start-time.
** ^The [SQLITE_OPEN_SHAREDCACHE] flag causes the database connection to be
** eligible to use [shared cache mode], regardless of whether or not shared
** cache is enabled using [sqlite3_enable_shared_cache()].  ^The
** [SQLITE_OPEN_PRIVATECACHE] flag causes the database connection to not
** participate in [shared cache mode] even if it is enabled.
**
** ^The fourth parameter to sqlite3_open_v2() is the name of the
** [sqlite3_vfs] object that defines the operating system interface that
** the new database connection should use.  ^If the fourth parameter is
** a NULL pointer then the default [sqlite3_vfs] object is used.
**
** ^If the filename is ":memory:", then a private, temporary in-memory database
** is created for the connection.  ^This in-memory database will vanish when
** the database connection is closed.  Future versions of SQLite might
** make use of additional special filenames that begin with the ":" character.
** It is recommended that when a database filename actually does begin with
** a ":" character you should prefix the filename with a pathname such as
** "./" to avoid ambiguity.
**
** ^If the filename is an empty string, then a private, temporary
** on-disk database will be created.  ^This private database will be
** automatically deleted as soon as the database connection is closed.
**
** [[URI filenames in sqlite3_open()]] <h3>URI Filenames</h3>
**
** ^If [URI filename] interpretation is enabled, and the filename argument
** begins with "file:", then the filename is interpreted as a URI. ^URI
** filename interpretation is enabled if the [SQLITE_OPEN_URI] flag is
** set in the third argument to sqlite3_open_v2(), or if it has
** been enabled globally using the [SQLITE_CONFIG_URI] option with the
** [sqlite3_config()] method or by the [SQLITE_USE_URI] compile-time option.
** URI filename interpretation is turned off
** by default, but future releases of SQLite might enable URI filename
** interpretation by default.  See "[URI filenames]" for additional
** information.
**
** URI filenames are parsed according to RFC 3986. ^If the URI contains an
** authority, then it must be either an empty string or the string
** "localhost". ^If the authority is not an empty string or "localhost", an
** error is returned to the caller. ^The fragment component of a URI, if
** present, is ignored.
**
** ^SQLite uses the path component of the URI as the name of the disk file
** which contains the database. ^If the path begins with a '/' character,
** then it is interpreted as an absolute path. ^If the path does not begin
** with a '/' (meaning that the authority section is omitted from the URI)
** then the path is interpreted as a relative path.
** ^(On windows, the first component of an absolute path
** is a drive specification (e.g. "C:").)^
**
** [[core URI query parameters]]
** The query component of a URI may contain parameters that are interpreted
** either by SQLite itself, or by a [VFS | custom VFS implementation].
** SQLite and its built-in [VFSes] interpret the
** following query parameters:
**
** <ul>
**   <li> <b>vfs</b>: ^The "vfs" parameter may be used to specify the name of
**     a VFS object that provides the operating system interface that should
**     be used to access the database file on disk. ^If this option is set to
**     an empty string the default VFS object is used. ^Specifying an unknown
**     VFS is an error. ^If sqlite3_open_v2() is used and the vfs option is
**     present, then the VFS specified by the option takes precedence over
**     the value passed as the fourth parameter to sqlite3_open_v2().
**
**   <li> <b>mode</b>: ^(The mode parameter may be set to either "ro", "rw",
**     "rwc", or "memory". Attempting to set it to any other value is
**     an error)^.
**     ^If "ro" is specified, then the database is opened for read-only
**     access, just as if the [SQLITE_OPEN_READONLY] flag had been set in the
**     third argument to sqlite3_open_v2(). ^If the mode option is set to
**     "rw", then the database is opened for read-write (but not create)
**     access, as if SQLITE_OPEN_READWRITE (but not SQLITE_OPEN_CREATE) had
**     been set. ^Value "rwc" is equivalent to setting both
**     SQLITE_OPEN_READWRITE and SQLITE_OPEN_CREATE.  ^If the mode option is
**     set to "memory" then a pure [in-memory database] that never reads
**     or writes from disk is used. ^It is an error to specify a value for
**     the mode parameter that is less restrictive than that specified by
**     the flags passed in the third parameter to sqlite3_open_v2().
**
**   <li> <b>cache</b>: ^The cache parameter may be set to either "shared" or
**     "private". ^Setting it to "shared" is equivalent to setting the
**     SQLITE_OPEN_SHAREDCACHE bit in the flags argument passed to
**     sqlite3_open_v2(). ^Setting the cache parameter to "private" is
**     equivalent to setting the SQLITE_OPEN_PRIVATECACHE bit.
**     ^If sqlite3_open_v2() is used and the "cache" parameter is present in
**     a URI filename, its value overrides any behavior requested by setting
**     SQLITE_OPEN_PRIVATECACHE or SQLITE_OPEN_SHAREDCACHE flag.
**
**  <li> <b>psow</b>: ^The psow parameter indicates whether or not the
**     [powersafe overwrite] property does or does not apply to the
**     storage media on which the database file resides.
**
**  <li> <b>nolock</b>: ^The nolock parameter is a boolean query parameter
**     which if set disables file locking in rollback journal modes.  This
**     is useful for accessing a database on a filesystem that does not
**     support locking.  Caution:  Database corruption might result if two
**     or more processes write to the same database and any one of those
**     processes uses nolock=1.
**
**  <li> <b>immutable</b>: ^The immutable parameter is a boolean query
**     parameter that indicates that the database file is stored on
**     read-only media.  ^When immutable is set, SQLite assumes that the
**     database file cannot be changed, even by a process with higher
**     privilege, and so the database is opened read-only and all locking
**     and change detection is disabled.  Caution: Setting the immutable
**     property on a database file that does in fact change can result
**     in incorrect query results and/or [SQLITE_CORRUPT] errors.
**     See also: [SQLITE_IOCAP_IMMUTABLE].
**
** </ul>
**
** ^Specifying an unknown parameter in the query component of a URI is not an
** error.  Future versions of SQLite might understand additional query
** parameters.  See "[query parameters with special meaning to SQLite]" for
** additional information.
**
** [[URI filename examples]] <h3>URI filename examples</h3>
**
** <table border="1" align=center cellpadding=5>
** <tr><th> URI filenames <th> Results
** <tr><td> file:data.db <td>
**          Open the file "data.db" in the current directory.
** <tr><td> file:/home/fred/data.db<br>
**          file:///home/fred/data.db <br>
**          file://localhost/home/fred/data.db <br> <td>
**          Open the database file "/home/fred/data.db".
** <tr><td> file://darkstar/home/fred/data.db <td>
**          An error. "darkstar" is not a recognized authority.
** <tr><td style="white-space:nowrap">
**          file:///C:/Documents%20and%20Settings/fred/Desktop/data.db
**     <td> Windows only: Open the file "data.db" on fred's desktop on drive
**          C:. Note that the %20 escaping in this example is not strictly
**          necessary - space characters can be used literally
**          in URI filenames.
** <tr><td> file:data.db?mode=ro&cache=private <td>
**          Open file "data.db" in the current directory for read-only access.
**          Regardless of whether or not shared-cache mode is enabled by
**          default, use a private cache.
** <tr><td> file:/home/fred/data.db?vfs=unix-dotfile <td>
**          Open file "/home/fred/data.db". Use the special VFS "unix-dotfile"
**          that uses dot-files in place of posix advisory locking.
** <tr><td> file:data.db?mode=readonly <td>
**          An error. "readonly" is not a valid option for the "mode" parameter.
** </table>
**
** ^URI hexadecimal escape sequences (%HH) are supported within the path and
** query components of a URI. A hexadecimal escape sequence consists of a
** percent sign - "%" - followed by exactly two hexadecimal digits
** specifying an octet value. ^Before the path or query components of a
** URI filename are interpreted, they are encoded using UTF-8 and all
** hexadecimal escape sequences replaced by a single byte containing the
** corresponding octet. If this process generates an invalid UTF-8 encoding,
** the results are undefined.
**
** <b>Note to Windows users:</b>  The encoding used for the filename argument
** of sqlite3_open() and sqlite3_open_v2() must be UTF-8, not whatever
** codepage is currently defined.  Filenames containing international
** characters must be converted to UTF-8 prior to passing them into
** sqlite3_open() or sqlite3_open_v2().
**
** <b>Note to Windows Runtime users:</b>  The temporary directory must be set
** prior to calling sqlite3_open() or sqlite3_open_v2().  Otherwise, various
** features that require the use of temporary files may fail.
**
** See also: [sqlite3_temp_directory]
*/
SQLITE_API int sqlite3_open(
  const char *filename,
  sqlite3 **ppDb
);
SQLITE_API int sqlite3_open16(
  const void *filename,
  sqlite3 **ppDb
);
SQLITE_API int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
);
/*
** CAPI3REF: Obtain Values For URI Parameters
**
** These are utility routines, useful to VFS implementations, that check
** to see if a database file was a URI that contained a specific query
** parameter, and if so obtains the value of that query parameter.
**
** If F is the database filename pointer passed into the xOpen() method of
** a VFS implementation when the flags parameter to xOpen() has one or
** more of the [SQLITE_OPEN_URI] or [SQLITE_OPEN_MAIN_DB] bits set and
** P is the name of the query parameter, then
** sqlite3_uri_parameter(F,P) returns the value of the P
** parameter if it exists or a NULL pointer if P does not appear as a
** query parameter on F.  If P is a query parameter of F
** has no explicit value, then sqlite3_uri_parameter(F,P) returns
** a pointer to an empty string.
**
** The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean
** parameter and returns true (1) or false (0) according to the value
** of P.  The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the
** value of query parameter P is one of "yes", "true", or "on" in any
** case or if the value begins with a non-zero number.  The
** sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of
** query parameter P is one of "no", "false", or "off" in any case or
** if the value begins with a numeric zero.  If P is not a query
** parameter on F or if the value of P is does not match any of the
** above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).
**
** The sqlite3_uri_int64(F,P,D) routine converts the value of P into a
** 64-bit signed integer and returns that integer, or D if P does not
** exist.  If the value of P is something other than an integer, then
** zero is returned.
**
** If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and
** sqlite3_uri_boolean(F,P,B) returns B.  If F is not a NULL pointer and
** is not a database file pathname pointer that SQLite passed into the xOpen
** VFS method, then the behavior of this routine is undefined and probably
** undesirable.
*/
SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);
SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
/*
** CAPI3REF: Error Codes And Messages
** METHOD: sqlite3
**
** ^If the most recent sqlite3_* API call associated with
** [database connection] D failed, then the sqlite3_errcode(D) interface
** returns the numeric [result code] or [extended result code] for that
** API call.
** If the most recent API call was successful,
** then the return value from sqlite3_errcode() is undefined.
** ^The sqlite3_extended_errcode()
** interface is the same except that it always returns the
** [extended result code] even when extended result codes are
** disabled.
**
** ^The sqlite3_errmsg() and sqlite3_errmsg16() return English-language
** text that describes the error, as either UTF-8 or UTF-16 respectively.
** ^(Memory to hold the error message string is managed internally.
** The application does not need to worry about freeing the result.
** However, the error string might be overwritten or deallocated by
** subsequent calls to other SQLite interface functions.)^
**
** ^The sqlite3_errstr() interface returns the English-language text
** that describes the [result code], as UTF-8.
** ^(Memory to hold the error message string is managed internally
** and must not be freed by the application)^.
**
** When the serialized [threading mode] is in use, it might be the
** case that a second error occurs on a separate thread in between
** the time of the first error and the call to these interfaces.
** When that happens, the second error will be reported since these
** interfaces always report the most recent result.  To avoid
** this, each thread can obtain exclusive use of the [database connection] D
** by invoking [sqlite3_mutex_enter]([sqlite3_db_mutex](D)) before beginning
** to use D and invoking [sqlite3_mutex_leave]([sqlite3_db_mutex](D)) after
** all calls to the interfaces listed here are completed.
**
** If an interface fails with SQLITE_MISUSE, that means the interface
** was invoked incorrectly by the application.  In that case, the
** error code and message may or may not be set.
*/
SQLITE_API int sqlite3_errcode(sqlite3 *db);
SQLITE_API int sqlite3_extended_errcode(sqlite3 *db);
SQLITE_API const char *sqlite3_errmsg(sqlite3*);
SQLITE_API const void *sqlite3_errmsg16(sqlite3*);
SQLITE_API const char *sqlite3_errstr(int);
/*
** CAPI3REF: Prepared Statement Object
** KEYWORDS: {prepared statement} {prepared statements}
**
** An instance of this object represents a single SQL statement that
** has been compiled into binary form and is ready to be evaluated.
**
** Think of each SQL statement as a separate computer program.  The
** original SQL text is source code.  A prepared statement object
** is the compiled object code.  All SQL must be converted into a
** prepared statement before it can be run.
**
** The life-cycle of a prepared statement object usually goes like this:
**
** <ol>
** <li> Create the prepared statement object using [sqlite3_prepare_v2()].
** <li> Bind values to [parameters] using the sqlite3_bind_*()
**      interfaces.
** <li> Run the SQL by calling [sqlite3_step()] one or more times.
** <li> Reset the prepared statement using [sqlite3_reset()] then go back
**      to step 2.  Do this zero or more times.
** <li> Destroy the object using [sqlite3_finalize()].
** </ol>
*/
typedef struct sqlite3_stmt sqlite3_stmt;
/*
** CAPI3REF: Run-time Limits
** METHOD: sqlite3
**
** ^(This interface allows the size of various constructs to be limited
** on a connection by connection basis.  The first parameter is the
** [database connection] whose limit is to be set or queried.  The
** second parameter is one of the [limit categories] that define a
** class of constructs to be size limited.  The third parameter is the
** new limit for that construct.)^
**
** ^If the new limit is a negative number, the limit is unchanged.
** ^(For each limit category SQLITE_LIMIT_<i>NAME</i> there is a
** [limits | hard upper bound]
** set at compile-time by a C preprocessor macro called
** [limits | SQLITE_MAX_<i>NAME</i>].
** (The "_LIMIT_" in the name is changed to "_MAX_".))^
** ^Attempts to increase a limit above its hard upper bound are
** silently truncated to the hard upper bound.
**
** ^Regardless of whether or not the limit was changed, the
** [sqlite3_limit()] interface returns the prior value of the limit.
** ^Hence, to find the current value of a limit without changing it,
** simply invoke this interface with the third parameter set to -1.
**
** Run-time limits are intended for use in applications that manage
** both their own internal database and also databases that are controlled
** by untrusted external sources.  An example application might be a
** web browser that has its own databases for storing history and
** separate databases controlled by JavaScript applications downloaded
** off the Internet.  The internal databases can be given the
** large, default limits.  Databases managed by external sources can
** be given much smaller limits designed to prevent a denial of service
** attack.  Developers might also want to use the [sqlite3_set_authorizer()]
** interface to further control untrusted SQL.  The size of the database
** created by an untrusted script can be contained using the
** [max_page_count] [PRAGMA].
**
** New run-time limit categories may be added in future releases.
*/
SQLITE_API int sqlite3_limit(sqlite3*, int id, int newVal);
/*
** CAPI3REF: Run-Time Limit Categories
** KEYWORDS: {limit category} {*limit categories}
**
** These constants define various performance limits
** that can be lowered at run-time using [sqlite3_limit()].
** The synopsis of the meanings of the various limits is shown below.
** Additional information is available at [limits | Limits in SQLite].
**
** <dl>
** [[SQLITE_LIMIT_LENGTH]] ^(<dt>SQLITE_LIMIT_LENGTH</dt>
** <dd>The maximum size of any string or BLOB or table row, in bytes.<dd>)^
**
** [[SQLITE_LIMIT_SQL_LENGTH]] ^(<dt>SQLITE_LIMIT_SQL_LENGTH</dt>
** <dd>The maximum length of an SQL statement, in bytes.</dd>)^
**
** [[SQLITE_LIMIT_COLUMN]] ^(<dt>SQLITE_LIMIT_COLUMN</dt>
** <dd>The maximum number of columns in a table definition or in the
** result set of a [SELECT] or the maximum number of columns in an index
** or in an ORDER BY or GROUP BY clause.</dd>)^
**
** [[SQLITE_LIMIT_EXPR_DEPTH]] ^(<dt>SQLITE_LIMIT_EXPR_DEPTH</dt>
** <dd>The maximum depth of the parse tree on any expression.</dd>)^
**
** [[SQLITE_LIMIT_COMPOUND_SELECT]] ^(<dt>SQLITE_LIMIT_COMPOUND_SELECT</dt>
** <dd>The maximum number of terms in a compound SELECT statement.</dd>)^
**
** [[SQLITE_LIMIT_VDBE_OP]] ^(<dt>SQLITE_LIMIT_VDBE_OP</dt>
** <dd>The maximum number of instructions in a virtual machine program
** used to implement an SQL statement.  If [sqlite3_prepare_v2()] or
** the equivalent tries to allocate space for more than this many opcodes
** in a single prepared statement, an SQLITE_NOMEM error is returned.</dd>)^
**
** [[SQLITE_LIMIT_FUNCTION_ARG]] ^(<dt>SQLITE_LIMIT_FUNCTION_ARG</dt>
** <dd>The maximum number of arguments on a function.</dd>)^
**
** [[SQLITE_LIMIT_ATTACHED]] ^(<dt>SQLITE_LIMIT_ATTACHED</dt>
** <dd>The maximum number of [ATTACH | attached databases].)^</dd>
**
** [[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]]
** ^(<dt>SQLITE_LIMIT_LIKE_PATTERN_LENGTH</dt>
** <dd>The maximum length of the pattern argument to the [LIKE] or
** [GLOB] operators.</dd>)^
**
** [[SQLITE_LIMIT_VARIABLE_NUMBER]]
** ^(<dt>SQLITE_LIMIT_VARIABLE_NUMBER</dt>
** <dd>The maximum index number of any [parameter] in an SQL statement.)^
**
** [[SQLITE_LIMIT_TRIGGER_DEPTH]] ^(<dt>SQLITE_LIMIT_TRIGGER_DEPTH</dt>
** <dd>The maximum depth of recursion for triggers.</dd>)^
**
** [[SQLITE_LIMIT_WORKER_THREADS]] ^(<dt>SQLITE_LIMIT_WORKER_THREADS</dt>
** <dd>The maximum number of auxiliary worker threads that a single
** [prepared statement] may start.</dd>)^
** </dl>
*/
#define SQLITE_LIMIT_LENGTH                    0
#define SQLITE_LIMIT_SQL_LENGTH                1
#define SQLITE_LIMIT_COLUMN                    2
#define SQLITE_LIMIT_EXPR_DEPTH                3
#define SQLITE_LIMIT_COMPOUND_SELECT           4
#define SQLITE_LIMIT_VDBE_OP                   5
#define SQLITE_LIMIT_FUNCTION_ARG              6
#define SQLITE_LIMIT_ATTACHED                  7
#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH       8
#define SQLITE_LIMIT_VARIABLE_NUMBER           9
#define SQLITE_LIMIT_TRIGGER_DEPTH            10
#define SQLITE_LIMIT_WORKER_THREADS           11
/*
** CAPI3REF: Prepare Flags
**
** These constants define various flags that can be passed into
** "prepFlags" parameter of the [sqlite3_prepare_v3()] and
** [sqlite3_prepare16_v3()] interfaces.
**
** New flags may be added in future releases of SQLite.
**
** <dl>
** [[SQLITE_PREPARE_PERSISTENT]] ^(<dt>SQLITE_PREPARE_PERSISTENT</dt>
** <dd>The SQLITE_PREPARE_PERSISTENT flag is a hint to the query planner
** that the prepared statement will be retained for a long time and
** probably reused many times.)^ ^Without this flag, [sqlite3_prepare_v3()]
** and [sqlite3_prepare16_v3()] assume that the prepared statement will
** be used just once or at most a few times and then destroyed using
** [sqlite3_finalize()] relatively soon. The current implementation acts
** on this hint by avoiding the use of [lookaside memory] so as not to
** deplete the limited store of lookaside memory. Future versions of
** SQLite may act on this hint differently.
** </dl>
*/
#define SQLITE_PREPARE_PERSISTENT              0x01
/*
** CAPI3REF: Compiling An SQL Statement
** KEYWORDS: {SQL statement compiler}
** METHOD: sqlite3
** CONSTRUCTOR: sqlite3_stmt
**
** To execute an SQL statement, it must first be compiled into a byte-code
** program using one of these routines.  Or, in other words, these routines
** are constructors for the [prepared statement] object.
**
** The preferred routine to use is [sqlite3_prepare_v2()].  The
** [sqlite3_prepare()] interface is legacy and should be avoided.
** [sqlite3_prepare_v3()] has an extra "prepFlags" option that is used
** for special purposes.
**
** The use of the UTF-8 interfaces is preferred, as SQLite currently
** does all parsing using UTF-8.  The UTF-16 interfaces are provided
** as a convenience.  The UTF-16 interfaces work by converting the
** input text into UTF-8, then invoking the corresponding UTF-8 interface.
**
** The first argument, "db", is a [database connection] obtained from a
** prior successful call to [sqlite3_open()], [sqlite3_open_v2()] or
** [sqlite3_open16()].  The database connection must not have been closed.
**
** The second argument, "zSql", is the statement to be compiled, encoded
** as either UTF-8 or UTF-16.  The sqlite3_prepare(), sqlite3_prepare_v2(),
** and sqlite3_prepare_v3()
** interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(),
** and sqlite3_prepare16_v3() use UTF-16.
**
** ^If the nByte argument is negative, then zSql is read up to the
** first zero terminator. ^If nByte is positive, then it is the
** number of bytes read from zSql.  ^If nByte is zero, then no prepared
** statement is generated.
** If the caller knows that the supplied string is nul-terminated, then
** there is a small performance advantage to passing an nByte parameter that
** is the number of bytes in the input string <i>including</i>
** the nul-terminator.
**
** ^If pzTail is not NULL then *pzTail is made to point to the first byte
** past the end of the first SQL statement in zSql.  These routines only
** compile the first statement in zSql, so *pzTail is left pointing to
** what remains uncompiled.
**
** ^*ppStmt is left pointing to a compiled [prepared statement] that can be
** executed using [sqlite3_step()].  ^If there is an error, *ppStmt is set
** to NULL.  ^If the input text contains no SQL (if the input is an empty
** string or a comment) then *ppStmt is set to NULL.
** The calling procedure is responsible for deleting the compiled
** SQL statement using [sqlite3_finalize()] after it has finished with it.
** ppStmt may not be NULL.
**
** ^On success, the sqlite3_prepare() family of routines return [SQLITE_OK];
** otherwise an [error code] is returned.
**
** The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(),
** and sqlite3_prepare16_v3() interfaces are recommended for all new programs.
** The older interfaces (sqlite3_prepare() and sqlite3_prepare16())
** are retained for backwards compatibility, but their use is discouraged.
** ^In the "vX" interfaces, the prepared statement
** that is returned (the [sqlite3_stmt] object) contains a copy of the
** original SQL text. This causes the [sqlite3_step()] interface to
** behave differently in three ways:
**
** <ol>
** <li>
** ^If the database schema changes, instead of returning [SQLITE_SCHEMA] as it
** always used to do, [sqlite3_step()] will automatically recompile the SQL
** statement and try to run it again. As many as [SQLITE_MAX_SCHEMA_RETRY]
** retries will occur before sqlite3_step() gives up and returns an error.
** </li>
**
** <li>
** ^When an error occurs, [sqlite3_step()] will return one of the detailed
** [error codes] or [extended error codes].  ^The legacy behavior was that
** [sqlite3_step()] would only return a generic [SQLITE_ERROR] result code
** and the application would have to make a second call to [sqlite3_reset()]
** in order to find the underlying cause of the problem. With the "v2" prepare
** interfaces, the underlying reason for the error is returned immediately.
** </li>
**
** <li>
** ^If the specific value bound to [parameter | host parameter] in the
** WHERE clause might influence the choice of query plan for a statement,
** then the statement will be automatically recompiled, as if there had been
** a schema change, on the first  [sqlite3_step()] call following any change
** to the [sqlite3_bind_text | bindings] of that [parameter].
** ^The specific value of WHERE-clause [parameter] might influence the
** choice of query plan if the parameter is the left-hand side of a [LIKE]
** or [GLOB] operator or if the parameter is compared to an indexed column
** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
** </li>
**
** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
** the extra prepFlags parameter, which is a bit array consisting of zero or
** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^The
** sqlite3_prepare_v2() interface works exactly the same as
** sqlite3_prepare_v3() with a zero prepFlags parameter.
** </ol>
*/
SQLITE_API int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
SQLITE_API int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
SQLITE_API int sqlite3_prepare_v3(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
SQLITE_API int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
SQLITE_API int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
SQLITE_API int sqlite3_prepare16_v3(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
/*
** CAPI3REF: Retrieving Statement SQL
** METHOD: sqlite3_stmt
**
** ^The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8
** SQL text used to create [prepared statement] P if P was
** created by [sqlite3_prepare_v2()], [sqlite3_prepare_v3()],
** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].
** ^The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8
** string containing the SQL text of prepared statement P with
** [bound parameters] expanded.
**
** ^sqlite3_sql_utf8(P,pN) returns the sql statement, and will fill the
** integer pointed at by the second argument with the length of the string.
** NULL may be passed to ignore getting a length.
**
** ^(For example, if a prepared statement is created using the SQL
** text "SELECT $abc,:xyz" and if parameter $abc is bound to integer 2345
** and parameter :xyz is unbound, then sqlite3_sql() will return
** the original string, "SELECT $abc,:xyz" but sqlite3_expanded_sql()
** will return "SELECT 2345,NULL".)^
**
** ^The sqlite3_expanded_sql()/sqlite3_expanded_sql_utf8() interface returns
** NULL if insufficient memory is available to hold the result, or if the
** result would exceed the maximum string length determined by the
** [SQLITE_LIMIT_LENGTH].
**
** ^sqlite3_sql_expanded_utf8(P,pN) returns the expanded sql statement, and
** will fill the integer pointed at by the second argument with the length
** of the string.  NULL may be passed to ignore the result.
**
** ^The [SQLITE_TRACE_SIZE_LIMIT] compile-time option limits the size of
** bound parameter expansions.  ^The [SQLITE_OMIT_TRACE] compile-time
** option causes sqlite3_expanded_sql() to always return NULL.
**
** ^The string returned by sqlite3_sql(P), sqlite3_sql_utf8(p,pN) is managed
** by SQLite and is automatically freed when the prepared statement is
** finalized.
**
** ^The string returned by sqlite3_expanded_sql(P) or sqlite3_epxanded_sql_utf8,
** on the other hand, is obtained from [sqlite3_malloc()] and must be free by
** the application by passing it to [sqlite3_free()].
*/
SQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt);
SQLITE_API char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);
SQLITE_API const char *sqlite3_sql_utf8(sqlite3_stmt *pStmt, int *pnLen);
SQLITE_API char *sqlite3_expanded_sql_utf8(sqlite3_stmt *pStmt, int *pnLen);
/*
** CAPI3REF: Determine If An SQL Statement Writes The Database
** METHOD: sqlite3_stmt
**
** ^The sqlite3_stmt_readonly(X) interface returns true (non-zero) if
** and only if the [prepared statement] X makes no direct changes to
** the content of the database file.
**
** Note that [application-defined SQL functions] or
** [virtual tables] might change the database indirectly as a side effect.
** ^(For example, if an application defines a function "eval()" that
** calls [sqlite3_exec()], then the following SQL statement would
** change the database file through side-effects:
**
** <blockquote><pre>
**    SELECT eval('DELETE FROM t1') FROM t2;
** </pre></blockquote>
**
** But because the [SELECT] statement does not change the database file
** directly, sqlite3_stmt_readonly() would still return true.)^
**
** ^Transaction control statements such as [BEGIN], [COMMIT], [ROLLBACK],
** [SAVEPOINT], and [RELEASE] cause sqlite3_stmt_readonly() to return true,
** since the statements themselves do not actually modify the database but
** rather they control the timing of when other statements modify the
** database.  ^The [ATTACH] and [DETACH] statements also cause
** sqlite3_stmt_readonly() to return true since, while those statements
** change the configuration of a database connection, they do not make
** changes to the content of the database files on disk.
** ^The sqlite3_stmt_readonly() interface returns true for [BEGIN] since
** [BEGIN] merely sets internal flags, but the [BEGIN|BEGIN IMMEDIATE] and
** [BEGIN|BEGIN EXCLUSIVE] commands do touch the database and so
** sqlite3_stmt_readonly() returns false for those commands.
*/
SQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
/*
** CAPI3REF: Determine If A Prepared Statement Has Been Reset
** METHOD: sqlite3_stmt
**
** ^The sqlite3_stmt_busy(S) interface returns true (non-zero) if the
** [prepared statement] S has been stepped at least once using
** [sqlite3_step(S)] but has neither run to completion (returned
** [SQLITE_DONE] from [sqlite3_step(S)]) nor
** been reset using [sqlite3_reset(S)].  ^The sqlite3_stmt_busy(S)
** interface returns false if S is a NULL pointer.  If S is not a
** NULL pointer and is not a pointer to a valid [prepared statement]
** object, then the behavior is undefined and probably undesirable.
**
** This interface can be used in combination [sqlite3_next_stmt()]
** to locate all prepared statements associated with a database
** connection that are in need of being reset.  This can be used,
** for example, in diagnostic routines to search for prepared
** statements that are holding a transaction open.
*/
SQLITE_API int sqlite3_stmt_busy(sqlite3_stmt*);
/*
** CAPI3REF: Dynamically Typed Value Object
** KEYWORDS: {protected sqlite3_value} {unprotected sqlite3_value}
**
** SQLite uses the sqlite3_value object to represent all values
** that can be stored in a database table. SQLite uses dynamic typing
** for the values it stores.  ^Values stored in sqlite3_value objects
** can be integers, floating point values, strings, BLOBs, or NULL.
**
** An sqlite3_value object may be either "protected" or "unprotected".
** Some interfaces require a protected sqlite3_value.  Other interfaces
** will accept either a protected or an unprotected sqlite3_value.
** Every interface that accepts sqlite3_value arguments specifies
** whether or not it requires a protected sqlite3_value.  The
** [sqlite3_value_dup()] interface can be used to construct a new
** protected sqlite3_value from an unprotected sqlite3_value.
**
** The terms "protected" and "unprotected" refer to whether or not
** a mutex is held.  An internal mutex is held for a protected
** sqlite3_value object but no mutex is held for an unprotected
** sqlite3_value object.  If SQLite is compiled to be single-threaded
** (with [SQLITE_THREADSAFE=0] and with [sqlite3_threadsafe()] returning 0)
** or if SQLite is run in one of reduced mutex modes
** [SQLITE_CONFIG_SINGLETHREAD] or [SQLITE_CONFIG_MULTITHREAD]
** then there is no distinction between protected and unprotected
** sqlite3_value objects and they can be used interchangeably.  However,
** for maximum code portability it is recommended that applications
** still make the distinction between protected and unprotected
** sqlite3_value objects even when not strictly required.
**
** ^The sqlite3_value objects that are passed as parameters into the
** implementation of [application-defined SQL functions] are protected.
** ^The sqlite3_value object returned by
** [sqlite3_column_value()] is unprotected.
** Unprotected sqlite3_value objects may only be used as arguments
** to [sqlite3_result_value()], [sqlite3_bind_value()], and
** [sqlite3_value_dup()].
** The [sqlite3_value_blob | sqlite3_value_type()] family of
** interfaces require protected sqlite3_value objects.
*/
typedef struct sqlite3_value sqlite3_value;
/*
** CAPI3REF: SQL Function Context Object
**
** The context in which an SQL function executes is stored in an
** sqlite3_context object.  ^A pointer to an sqlite3_context object
** is always first parameter to [application-defined SQL functions].
** The application-defined SQL function implementation will pass this
** pointer through into calls to [sqlite3_result_int | sqlite3_result()],
** [sqlite3_aggregate_context()], [sqlite3_user_data()],
** [sqlite3_context_db_handle()], [sqlite3_get_auxdata()],
** and/or [sqlite3_set_auxdata()].
*/
typedef struct sqlite3_context sqlite3_context;
/*
** CAPI3REF: Binding Values To Prepared Statements
** KEYWORDS: {host parameter} {host parameters} {host parameter name}
** KEYWORDS: {SQL parameter} {SQL parameters} {parameter binding}
** METHOD: sqlite3_stmt
**
** ^(In the SQL statement text input to [sqlite3_prepare_v2()] and its variants,
** literals may be replaced by a [parameter] that matches one of following
** templates:
**
** <ul>
** <li>  ?
** <li>  ?NNN
** <li>  :VVV
** <li>  @VVV
** <li>  $VVV
** </ul>
**
** In the templates above, NNN represents an integer literal,
** and VVV represents an alphanumeric identifier.)^  ^The values of these
** parameters (also called "host parameter names" or "SQL parameters")
** can be set using the sqlite3_bind_*() routines defined here.
**
** ^The first argument to the sqlite3_bind_*() routines is always
** a pointer to the [sqlite3_stmt] object returned from
** [sqlite3_prepare_v2()] or its variants.
**
** ^The second argument is the index of the SQL parameter to be set.
** ^The leftmost SQL parameter has an index of 1.  ^When the same named
** SQL parameter is used more than once, second and subsequent
** occurrences have the same index as the first occurrence.
** ^The index for named parameters can be looked up using the
** [sqlite3_bind_parameter_index()] API if desired.  ^The index
** for "?NNN" parameters is the value of NNN.
** ^The NNN value must be between 1 and the [sqlite3_limit()]
** parameter [SQLITE_LIMIT_VARIABLE_NUMBER] (default value: 999).
**
** ^The third argument is the value to bind to the parameter.
** ^If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16()
** or sqlite3_bind_blob() is a NULL pointer then the fourth parameter
** is ignored and the end result is the same as sqlite3_bind_null().
**
** ^(In those routines that have a fourth argument, its value is the
** number of bytes in the parameter.  To be clear: the value is the
** number of <u>bytes</u> in the value, not the number of characters.)^
** ^If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16()
** is negative, then the length of the string is
** the number of bytes up to the first zero terminator.
** If the fourth parameter to sqlite3_bind_blob() is negative, then
** the behavior is undefined.
** If a non-negative fourth parameter is provided to sqlite3_bind_text()
** or sqlite3_bind_text16() or sqlite3_bind_text64() then
** that parameter must be the byte offset
** where the NUL terminator would occur assuming the string were NUL
** terminated.  If any NUL characters occur at byte offsets less than
** the value of the fourth parameter then the resulting string value will
** contain embedded NULs.  The result of expressions involving strings
** with embedded NULs is undefined.
**
** ^The fifth argument to the BLOB and string binding interfaces
** is a destructor used to dispose of the BLOB or
** string after SQLite has finished with it.  ^The destructor is called
** to dispose of the BLOB or string even if the call to bind API fails.
** ^If the fifth argument is
** the special value [SQLITE_STATIC], then SQLite assumes that the
** information is in static, unmanaged space and does not need to be freed.
** ^If the fifth argument has the value [SQLITE_TRANSIENT], then
** SQLite makes its own private copy of the data immediately, before
** the sqlite3_bind_*() routine returns.
**
** ^The sixth argument to sqlite3_bind_text64() must be one of
** [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE]
** to specify the encoding of the text in the third parameter.  If
** the sixth argument to sqlite3_bind_text64() is not one of the
** allowed values shown above, or if the text encoding is different
** from the encoding specified by the sixth parameter, then the behavior
** is undefined.
**
** ^The sqlite3_bind_zeroblob() routine binds a BLOB of length N that
** is filled with zeroes.  ^A zeroblob uses a fixed amount of memory
** (just an integer to hold its size) while it is being processed.
** Zeroblobs are intended to serve as placeholders for BLOBs whose
** content is later written using
** [sqlite3_blob_open | incremental BLOB I/O] routines.
** ^A negative value for the zeroblob results in a zero-length BLOB.
**
** ^The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in
** [prepared statement] S to have an SQL value of NULL, but to also be
** associated with the pointer P of type T.  ^D is either a NULL pointer or
** a pointer to a destructor function for P. ^SQLite will invoke the
** destructor D with a single argument of P when it is finished using
** P.  The T parameter should be a static string, preferably a string
** literal. The sqlite3_bind_pointer() routine is part of the
** [pointer passing interface] added for SQLite 3.20.0.
**
** ^If any of the sqlite3_bind_*() routines are called with a NULL pointer
** for the [prepared statement] or with a prepared statement for which
** [sqlite3_step()] has been called more recently than [sqlite3_reset()],
** then the call will return [SQLITE_MISUSE].  If any sqlite3_bind_()
** routine is passed a [prepared statement] that has been finalized, the
** result is undefined and probably harmful.
**
** ^Bindings are not cleared by the [sqlite3_reset()] routine.
** ^Unbound parameters are interpreted as NULL.
**
** ^The sqlite3_bind_* routines return [SQLITE_OK] on success or an
** [error code] if anything goes wrong.
** ^[SQLITE_TOOBIG] might be returned if the size of a string or BLOB
** exceeds limits imposed by [sqlite3_limit]([SQLITE_LIMIT_LENGTH]) or
** [SQLITE_MAX_LENGTH].
** ^[SQLITE_RANGE] is returned if the parameter
** index is out of range.  ^[SQLITE_NOMEM] is returned if malloc() fails.
**
** See also: [sqlite3_bind_parameter_count()],
** [sqlite3_bind_parameter_name()], and [sqlite3_bind_parameter_index()].
*/
SQLITE_API int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
SQLITE_API int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                        void(*)(void*));
SQLITE_API int sqlite3_bind_double(sqlite3_stmt*, int, double);
SQLITE_API int sqlite3_bind_int(sqlite3_stmt*, int, int);
SQLITE_API int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
SQLITE_API int sqlite3_bind_null(sqlite3_stmt*, int);
SQLITE_API int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
SQLITE_API int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
SQLITE_API int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                         void(*)(void*), unsigned char encoding);
SQLITE_API int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
SQLITE_API int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
SQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
SQLITE_API int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
/*
** CAPI3REF: Number Of SQL Parameters
** METHOD: sqlite3_stmt
**
** ^This routine can be used to find the number of [SQL parameters]
** in a [prepared statement].  SQL parameters are tokens of the
** form "?", "?NNN", ":AAA", "$AAA", or "@AAA" that serve as
** placeholders for values that are [sqlite3_bind_blob | bound]
** to the parameters at a later time.
**
** ^(This routine actually returns the index of the largest (rightmost)
** parameter. For all forms except ?NNN, this will correspond to the
** number of unique parameters.  If parameters of the ?NNN form are used,
** there may be gaps in the list.)^
**
** See also: [sqlite3_bind_blob|sqlite3_bind()],
** [sqlite3_bind_parameter_name()], and
** [sqlite3_bind_parameter_index()].
*/
SQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt*);
/*
** CAPI3REF: Name Of A Host Parameter
** METHOD: sqlite3_stmt
**
** ^The sqlite3_bind_parameter_name(P,N) interface returns
** the name of the N-th [SQL parameter] in the [prepared statement] P.
** ^(SQL parameters of the form "?NNN" or ":AAA" or "@AAA" or "$AAA"
** have a name which is the string "?NNN" or ":AAA" or "@AAA" or "$AAA"
** respectively.
** In other words, the initial ":" or "$" or "@" or "?"
** is included as part of the name.)^
** ^Parameters of the form "?" without a following integer have no name
** and are referred to as "nameless" or "anonymous parameters".
**
** ^The first host parameter has an index of 1, not 0.
**
** ^If the value N is out of range or if the N-th parameter is
** nameless, then NULL is returned.  ^The returned string is
** always in UTF-8 encoding even if the named parameter was
** originally specified as UTF-16 in [sqlite3_prepare16()],
** [sqlite3_prepare16_v2()], or [sqlite3_prepare16_v3()].
**
** See also: [sqlite3_bind_blob|sqlite3_bind()],
** [sqlite3_bind_parameter_count()], and
** [sqlite3_bind_parameter_index()].
*/
SQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
/*
** CAPI3REF: Index Of A Parameter With A Given Name
** METHOD: sqlite3_stmt
**
** ^Return the index of an SQL parameter given its name.  ^The
** index value returned is suitable for use as the second
** parameter to [sqlite3_bind_blob|sqlite3_bind()].  ^A zero
** is returned if no matching parameter is found.  ^The parameter
** name must be given in UTF-8 even if the original statement
** was prepared from UTF-16 text using [sqlite3_prepare16_v2()] or
** [sqlite3_prepare16_v3()].
**
** See also: [sqlite3_bind_blob|sqlite3_bind()],
** [sqlite3_bind_parameter_count()], and
** [sqlite3_bind_parameter_name()].
*/
SQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
/*
** CAPI3REF: Reset All Bindings On A Prepared Statement
** METHOD: sqlite3_stmt
**
** ^Contrary to the intuition of many, [sqlite3_reset()] does not reset
** the [sqlite3_bind_blob | bindings] on a [prepared statement].
** ^Use this routine to reset all host parameters to NULL.
*/
SQLITE_API int sqlite3_clear_bindings(sqlite3_stmt*);
/*
** CAPI3REF: Number Of Columns In A Result Set
** METHOD: sqlite3_stmt
**
** ^Return the number of columns in the result set returned by the
** [prepared statement]. ^If this routine returns 0, that means the
** [prepared statement] returns no data (for example an [UPDATE]).
** ^However, just because this routine returns a positive number does not
** mean that one or more rows of data will be returned.  ^A SELECT statement
** will always have a positive sqlite3_column_count() but depending on the
** WHERE clause constraints and the table content, it might return no rows.
**
** See also: [sqlite3_data_count()]
*/
SQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt);
/*
** CAPI3REF: Column Names In A Result Set
** METHOD: sqlite3_stmt
**
** ^These routines return the name assigned to a particular column
** in the result set of a [SELECT] statement.  ^The sqlite3_column_name()
** interface returns a pointer to a zero-terminated UTF-8 string
** and sqlite3_column_name16() returns a pointer to a zero-terminated
** UTF-16 string.  ^The first parameter is the [prepared statement]
** that implements the [SELECT] statement. ^The second parameter is the
** column number.  ^The leftmost column is number 0.
**
** ^The returned string pointer is valid until either the [prepared statement]
** is destroyed by [sqlite3_finalize()] or until the statement is automatically
** reprepared by the first call to [sqlite3_step()] for a particular run
** or until the next call to
** sqlite3_column_name() or sqlite3_column_name16() on the same column.
**
** ^If sqlite3_malloc() fails during the processing of either routine
** (for example during a conversion from UTF-8 to UTF-16) then a
** NULL pointer is returned.
**
** ^The name of a result column is the value of the "AS" clause for
** that column, if there is an AS clause.  If there is no AS clause
** then the name of the column is unspecified and may change from
** one release of SQLite to the next.
*/
SQLITE_API const char *sqlite3_column_name(sqlite3_stmt*, int N);
SQLITE_API const void *sqlite3_column_name16(sqlite3_stmt*, int N);
/*
** CAPI3REF: Source Of Data In A Query Result
** METHOD: sqlite3_stmt
**
** ^These routines provide a means to determine the database, table, and
** table column that is the origin of a particular result column in
** [SELECT] statement.
** ^The name of the database or table or column can be returned as
** either a UTF-8 or UTF-16 string.  ^The _database_ routines return
** the database name, the _table_ routines return the table name, and
** the origin_ routines return the column name.
** ^The returned string is valid until the [prepared statement] is destroyed
** using [sqlite3_finalize()] or until the statement is automatically
** reprepared by the first call to [sqlite3_step()] for a particular run
** or until the same information is requested
** again in a different encoding.
**
** ^The names returned are the original un-aliased names of the
** database, table, and column.
**
** ^The first argument to these interfaces is a [prepared statement].
** ^These functions return information about the Nth result column returned by
** the statement, where N is the second function argument.
** ^The left-most column is column 0 for these routines.
**
** ^If the Nth column returned by the statement is an expression or
** subquery and is not a column value, then all of these functions return
** NULL.  ^These routine might also return NULL if a memory allocation error
** occurs.  ^Otherwise, they return the name of the attached database, table,
** or column that query result column was extracted from.
**
** ^As with all other SQLite APIs, those whose names end with "16" return
** UTF-16 encoded strings and the other functions return UTF-8.
**
** ^These APIs are only available if the library was compiled with the
** [SQLITE_ENABLE_COLUMN_METADATA] C-preprocessor symbol.
**
** If two or more threads call one or more of these routines against the same
** prepared statement and column at the same time then the results are
** undefined.
**
** If two or more threads call one or more
** [sqlite3_column_database_name | column metadata interfaces]
** for the same [prepared statement] and result column
** at the same time then the results are undefined.
*/
SQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
SQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
SQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
SQLITE_API const char *sqlite3_column_table_alias(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_table_alias16(sqlite3_stmt*,int);
/*
** CAPI3REF: Declared Datatype Of A Query Result
** METHOD: sqlite3_stmt
**
** ^(The first parameter is a [prepared statement].
** If this statement is a [SELECT] statement and the Nth column of the
** returned result set of that [SELECT] is a table column (not an
** expression or subquery) then the declared type of the table
** column is returned.)^  ^If the Nth column of the result set is an
** expression or subquery, then a NULL pointer is returned.
** ^The returned string is always UTF-8 encoded.
**
** ^(For example, given the database schema:
**
** CREATE TABLE t1(c1 VARIANT);
**
** and the following statement to be compiled:
**
** SELECT c1 + 1, c1 FROM t1;
**
** this routine would return the string "VARIANT" for the second result
** column (i==1), and a NULL pointer for the first result column (i==0).)^
**
** ^SQLite uses dynamic run-time typing.  ^So just because a column
** is declared to contain a particular type does not mean that the
** data stored in that column is of the declared type.  SQLite is
** strongly typed, but the typing is dynamic not static.  ^Type
** is associated with individual values, not with the containers
** used to hold those values.
*/
SQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt*,int);
SQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
/*
** CAPI3REF: Evaluate An SQL Statement
** METHOD: sqlite3_stmt
**
** After a [prepared statement] has been prepared using any of
** [sqlite3_prepare_v2()], [sqlite3_prepare_v3()], [sqlite3_prepare16_v2()],
** or [sqlite3_prepare16_v3()] or one of the legacy
** interfaces [sqlite3_prepare()] or [sqlite3_prepare16()], this function
** must be called one or more times to evaluate the statement.
**
** The details of the behavior of the sqlite3_step() interface depend
** on whether the statement was prepared using the newer "vX" interfaces
** [sqlite3_prepare_v3()], [sqlite3_prepare_v2()], [sqlite3_prepare16_v3()],
** [sqlite3_prepare16_v2()] or the older legacy
** interfaces [sqlite3_prepare()] and [sqlite3_prepare16()].  The use of the
** new "vX" interface is recommended for new applications but the legacy
** interface will continue to be supported.
**
** ^In the legacy interface, the return value will be either [SQLITE_BUSY],
** [SQLITE_DONE], [SQLITE_ROW], [SQLITE_ERROR], or [SQLITE_MISUSE].
** ^With the "v2" interface, any of the other [result codes] or
** [extended result codes] might be returned as well.
**
** ^[SQLITE_BUSY] means that the database engine was unable to acquire the
** database locks it needs to do its job.  ^If the statement is a [COMMIT]
** or occurs outside of an explicit transaction, then you can retry the
** statement.  If the statement is not a [COMMIT] and occurs within an
** explicit transaction then you should rollback the transaction before
** continuing.
**
** ^[SQLITE_DONE] means that the statement has finished executing
** successfully.  sqlite3_step() should not be called again on this virtual
** machine without first calling [sqlite3_reset()] to reset the virtual
** machine back to its initial state.
**
** ^If the SQL statement being executed returns any data, then [SQLITE_ROW]
** is returned each time a new row of data is ready for processing by the
** caller. The values may be accessed using the [column access functions].
** sqlite3_step() is called again to retrieve the next row of data.
**
** ^[SQLITE_ERROR] means that a run-time error (such as a constraint
** violation) has occurred.  sqlite3_step() should not be called again on
** the VM. More information may be found by calling [sqlite3_errmsg()].
** ^With the legacy interface, a more specific error code (for example,
** [SQLITE_INTERRUPT], [SQLITE_SCHEMA], [SQLITE_CORRUPT], and so forth)
** can be obtained by calling [sqlite3_reset()] on the
** [prepared statement].  ^In the "v2" interface,
** the more specific error code is returned directly by sqlite3_step().
**
** [SQLITE_MISUSE] means that the this routine was called inappropriately.
** Perhaps it was called on a [prepared statement] that has
** already been [sqlite3_finalize | finalized] or on one that had
** previously returned [SQLITE_ERROR] or [SQLITE_DONE].  Or it could
** be the case that the same database connection is being used by two or
** more threads at the same moment in time.
**
** For all versions of SQLite up to and including 3.6.23.1, a call to
** [sqlite3_reset()] was required after sqlite3_step() returned anything
** other than [SQLITE_ROW] before any subsequent invocation of
** sqlite3_step().  Failure to reset the prepared statement using
** [sqlite3_reset()] would result in an [SQLITE_MISUSE] return from
** sqlite3_step().  But after [version 3.6.23.1] ([dateof:3.6.23.1],
** sqlite3_step() began
** calling [sqlite3_reset()] automatically in this circumstance rather
** than returning [SQLITE_MISUSE].  This is not considered a compatibility
** break because any application that ever receives an SQLITE_MISUSE error
** is broken by definition.  The [SQLITE_OMIT_AUTORESET] compile-time option
** can be used to restore the legacy behavior.
**
** <b>Goofy Interface Alert:</b> In the legacy interface, the sqlite3_step()
** API always returns a generic error code, [SQLITE_ERROR], following any
** error other than [SQLITE_BUSY] and [SQLITE_MISUSE].  You must call
** [sqlite3_reset()] or [sqlite3_finalize()] in order to find one of the
** specific [error codes] that better describes the error.
** We admit that this is a goofy design.  The problem has been fixed
** with the "v2" interface.  If you prepare all of your SQL statements
** using [sqlite3_prepare_v3()] or [sqlite3_prepare_v2()]
** or [sqlite3_prepare16_v2()] or [sqlite3_prepare16_v3()] instead
** of the legacy [sqlite3_prepare()] and [sqlite3_prepare16()] interfaces,
** then the more specific [error codes] are returned directly
** by sqlite3_step().  The use of the "vX" interfaces is recommended.
*/
SQLITE_API int sqlite3_step(sqlite3_stmt*);
/*
** CAPI3REF: Number of columns in a result set
** METHOD: sqlite3_stmt
**
** ^The sqlite3_data_count(P) interface returns the number of columns in the
** current row of the result set of [prepared statement] P.
** ^If prepared statement P does not have results ready to return
** (via calls to the [sqlite3_column_int | sqlite3_column_*()] of
** interfaces) then sqlite3_data_count(P) returns 0.
** ^The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer.
** ^The sqlite3_data_count(P) routine returns 0 if the previous call to
** [sqlite3_step](P) returned [SQLITE_DONE].  ^The sqlite3_data_count(P)
** will return non-zero if previous call to [sqlite3_step](P) returned
** [SQLITE_ROW], except in the case of the [PRAGMA incremental_vacuum]
** where it always returns zero since each step of that multi-step
** pragma returns 0 columns of data.
**
** See also: [sqlite3_column_count()]
*/
SQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt);
/*
** CAPI3REF: Fundamental Datatypes
** KEYWORDS: SQLITE_TEXT
**
** ^(Every value in SQLite has one of five fundamental datatypes:
**
** <ul>
** <li> 64-bit signed integer
** <li> 64-bit IEEE floating point number
** <li> string
** <li> BLOB
** <li> NULL
** </ul>)^
**
** These constants are codes for each of those types.
**
** Note that the SQLITE_TEXT constant was also used in SQLite version 2
** for a completely different meaning.  Software that links against both
** SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not
** SQLITE_TEXT.
*/
#define SQLITE_INTEGER  1
#define SQLITE_FLOAT    2
#define SQLITE_BLOB     4
#define SQLITE_NULL     5
#ifdef SQLITE_TEXT
# undef SQLITE_TEXT
#else
# define SQLITE_TEXT     3
#endif
#define SQLITE3_TEXT     3
/*
** CAPI3REF: Result Values From A Query
** KEYWORDS: {column access functions}
** METHOD: sqlite3_stmt
**
** <b>Summary:</b>
** <blockquote><table border=0 cellpadding=0 cellspacing=0>
** <tr><td><b>sqlite3_column_blob</b><td>&rarr;<td>BLOB result
** <tr><td><b>sqlite3_column_double</b><td>&rarr;<td>REAL result
** <tr><td><b>sqlite3_column_int</b><td>&rarr;<td>32-bit INTEGER result
** <tr><td><b>sqlite3_column_int64</b><td>&rarr;<td>64-bit INTEGER result
** <tr><td><b>sqlite3_column_text</b><td>&rarr;<td>UTF-8 TEXT result
** <tr><td><b>sqlite3_column_text16</b><td>&rarr;<td>UTF-16 TEXT result
** <tr><td><b>sqlite3_column_value</b><td>&rarr;<td>The result as an
** [sqlite3_value|unprotected sqlite3_value] object.
** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;
** <tr><td><b>sqlite3_column_bytes</b><td>&rarr;<td>Size of a BLOB
** or a UTF-8 TEXT result in bytes
** <tr><td><b>sqlite3_column_bytes16&nbsp;&nbsp;</b>
** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16
** TEXT in bytes
** <tr><td><b>sqlite3_column_type</b><td>&rarr;<td>Default
** datatype of the result
** </table></blockquote>
**
** <b>Details:</b>
**
** ^These routines return information about a single column of the current
** result row of a query.  ^In every case the first argument is a pointer
** to the [prepared statement] that is being evaluated (the [sqlite3_stmt*]
** that was returned from [sqlite3_prepare_v2()] or one of its variants)
** and the second argument is the index of the column for which information
** should be returned. ^The leftmost column of the result set has the index 0.
** ^The number of columns in the result can be determined using
** [sqlite3_column_count()].
**
** If the SQL statement does not currently point to a valid row, or if the
** column index is out of range, the result is undefined.
** These routines may only be called when the most recent call to
** [sqlite3_step()] has returned [SQLITE_ROW] and neither
** [sqlite3_reset()] nor [sqlite3_finalize()] have been called subsequently.
** If any of these routines are called after [sqlite3_reset()] or
** [sqlite3_finalize()] or after [sqlite3_step()] has returned
** something other than [SQLITE_ROW], the results are undefined.
** If [sqlite3_step()] or [sqlite3_reset()] or [sqlite3_finalize()]
** are called from a different thread while any of these routines
** are pending, then the results are undefined.
**
** The first six interfaces (_blob, _double, _int, _int64, _text, and _text16)
** each return the value of a result column in a specific data format.  If
** the result column is not initially in the requested format (for example,
** if the query returns an integer but the sqlite3_column_text() interface
** is used to extract the value) then an automatic type conversion is performed.
**
** ^The sqlite3_column_type() routine returns the
** [SQLITE_INTEGER | datatype code] for the initial data type
** of the result column.  ^The returned value is one of [SQLITE_INTEGER],
** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].
** The return value of sqlite3_column_type() can be used to decide which
** of the first six interface should be used to extract the column value.
** The value returned by sqlite3_column_type() is only meaningful if no
** automatic type conversions have occurred for the value in question.
** After a type conversion, the result of calling sqlite3_column_type()
** is undefined, though harmless.  Future
** versions of SQLite may change the behavior of sqlite3_column_type()
** following a type conversion.
**
** If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes()
** or sqlite3_column_bytes16() interfaces can be used to determine the size
** of that BLOB or string.
**
** ^If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes()
** routine returns the number of bytes in that BLOB or string.
** ^If the result is a UTF-16 string, then sqlite3_column_bytes() converts
** the string to UTF-8 and then returns the number of bytes.
** ^If the result is a numeric value then sqlite3_column_bytes() uses
** [sqlite3_snprintf()] to convert that value to a UTF-8 string and returns
** the number of bytes in that string.
** ^If the result is NULL, then sqlite3_column_bytes() returns zero.
**
** ^If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16()
** routine returns the number of bytes in that BLOB or string.
** ^If the result is a UTF-8 string, then sqlite3_column_bytes16() converts
** the string to UTF-16 and then returns the number of bytes.
** ^If the result is a numeric value then sqlite3_column_bytes16() uses
** [sqlite3_snprintf()] to convert that value to a UTF-16 string and returns
** the number of bytes in that string.
** ^If the result is NULL, then sqlite3_column_bytes16() returns zero.
**
** ^The values returned by [sqlite3_column_bytes()] and
** [sqlite3_column_bytes16()] do not include the zero terminators at the end
** of the string.  ^For clarity: the values returned by
** [sqlite3_column_bytes()] and [sqlite3_column_bytes16()] are the number of
** bytes in the string, not the number of characters.
**
** ^Strings returned by sqlite3_column_text() and sqlite3_column_text16(),
** even empty strings, are always zero-terminated.  ^The return
** value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.
**
** <b>Warning:</b> ^The object returned by [sqlite3_column_value()] is an
** [unprotected sqlite3_value] object.  In a multithreaded environment,
** an unprotected sqlite3_value object may only be used safely with
** [sqlite3_bind_value()] and [sqlite3_result_value()].
** If the [unprotected sqlite3_value] object returned by
** [sqlite3_column_value()] is used in any other way, including calls
** to routines like [sqlite3_value_int()], [sqlite3_value_text()],
** or [sqlite3_value_bytes()], the behavior is not threadsafe.
** Hence, the sqlite3_column_value() interface
** is normally only useful within the implementation of
** [application-defined SQL functions] or [virtual tables], not within
** top-level application code.
**
** The these routines may attempt to convert the datatype of the result.
** ^For example, if the internal representation is FLOAT and a text result
** is requested, [sqlite3_snprintf()] is used internally to perform the
** conversion automatically.  ^(The following table details the conversions
** that are applied:
**
** <blockquote>
** <table border="1">
** <tr><th> Internal<br>Type <th> Requested<br>Type <th>  Conversion
**
** <tr><td>  NULL    <td> INTEGER   <td> Result is 0
** <tr><td>  NULL    <td>  FLOAT    <td> Result is 0.0
** <tr><td>  NULL    <td>   TEXT    <td> Result is a NULL pointer
** <tr><td>  NULL    <td>   BLOB    <td> Result is a NULL pointer
** <tr><td> INTEGER  <td>  FLOAT    <td> Convert from integer to float
** <tr><td> INTEGER  <td>   TEXT    <td> ASCII rendering of the integer
** <tr><td> INTEGER  <td>   BLOB    <td> Same as INTEGER->TEXT
** <tr><td>  FLOAT   <td> INTEGER   <td> [CAST] to INTEGER
** <tr><td>  FLOAT   <td>   TEXT    <td> ASCII rendering of the float
** <tr><td>  FLOAT   <td>   BLOB    <td> [CAST] to BLOB
** <tr><td>  TEXT    <td> INTEGER   <td> [CAST] to INTEGER
** <tr><td>  TEXT    <td>  FLOAT    <td> [CAST] to REAL
** <tr><td>  TEXT    <td>   BLOB    <td> No change
** <tr><td>  BLOB    <td> INTEGER   <td> [CAST] to INTEGER
** <tr><td>  BLOB    <td>  FLOAT    <td> [CAST] to REAL
** <tr><td>  BLOB    <td>   TEXT    <td> Add a zero terminator if needed
** </table>
** </blockquote>)^
**
** Note that when type conversions occur, pointers returned by prior
** calls to sqlite3_column_blob(), sqlite3_column_text(), and/or
** sqlite3_column_text16() may be invalidated.
** Type conversions and pointer invalidations might occur
** in the following cases:
**
** <ul>
** <li> The initial content is a BLOB and sqlite3_column_text() or
**      sqlite3_column_text16() is called.  A zero-terminator might
**      need to be added to the string.</li>
** <li> The initial content is UTF-8 text and sqlite3_column_bytes16() or
**      sqlite3_column_text16() is called.  The content must be converted
**      to UTF-16.</li>
** <li> The initial content is UTF-16 text and sqlite3_column_bytes() or
**      sqlite3_column_text() is called.  The content must be converted
**      to UTF-8.</li>
** </ul>
**
** ^Conversions between UTF-16be and UTF-16le are always done in place and do
** not invalidate a prior pointer, though of course the content of the buffer
** that the prior pointer references will have been modified.  Other kinds
** of conversion are done in place when it is possible, but sometimes they
** are not possible and in those cases prior pointers are invalidated.
**
** The safest policy is to invoke these routines
** in one of the following ways:
**
** <ul>
**  <li>sqlite3_column_text() followed by sqlite3_column_bytes()</li>
**  <li>sqlite3_column_blob() followed by sqlite3_column_bytes()</li>
**  <li>sqlite3_column_text16() followed by sqlite3_column_bytes16()</li>
** </ul>
**
** In other words, you should call sqlite3_column_text(),
** sqlite3_column_blob(), or sqlite3_column_text16() first to force the result
** into the desired format, then invoke sqlite3_column_bytes() or
** sqlite3_column_bytes16() to find the size of the result.  Do not mix calls
** to sqlite3_column_text() or sqlite3_column_blob() with calls to
** sqlite3_column_bytes16(), and do not mix calls to sqlite3_column_text16()
** with calls to sqlite3_column_bytes().
**
** ^The pointers returned are valid until a type conversion occurs as
** described above, or until [sqlite3_step()] or [sqlite3_reset()] or
** [sqlite3_finalize()] is called.  ^The memory space used to hold strings
** and BLOBs is freed automatically.  Do not pass the pointers returned
** from [sqlite3_column_blob()], [sqlite3_column_text()], etc. into
** [sqlite3_free()].
**
** ^(If a memory allocation error occurs during the evaluation of any
** of these routines, a default value is returned.  The default value
** is either the integer 0, the floating point number 0.0, or a NULL
** pointer.  Subsequent calls to [sqlite3_errcode()] will return
** [SQLITE_NOMEM].)^
*/
SQLITE_API const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
SQLITE_API double sqlite3_column_double(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_int(sqlite3_stmt*, int iCol);
SQLITE_API sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
SQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
SQLITE_API const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
SQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
SQLITE_API int sqlite3_column_type(sqlite3_stmt*, int iCol);
/*
** CAPI3REF: Destroy A Prepared Statement Object
** DESTRUCTOR: sqlite3_stmt
**
** ^The sqlite3_finalize() function is called to delete a [prepared statement].
** ^If the most recent evaluation of the statement encountered no errors
** or if the statement is never been evaluated, then sqlite3_finalize() returns
** SQLITE_OK.  ^If the most recent evaluation of statement S failed, then
** sqlite3_finalize(S) returns the appropriate [error code] or
** [extended error code].
**
** ^The sqlite3_finalize(S) routine can be called at any point during
** the life cycle of [prepared statement] S:
** before statement S is ever evaluated, after
** one or more calls to [sqlite3_reset()], or after any call
** to [sqlite3_step()] regardless of whether or not the statement has
** completed execution.
**
** ^Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.
**
** The application must finalize every [prepared statement] in order to avoid
** resource leaks.  It is a grievous error for the application to try to use
** a prepared statement after it has been finalized.  Any use of a prepared
** statement after it has been finalized can result in undefined and
** undesirable behavior such as segfaults and heap corruption.
*/
SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt);
/*
** CAPI3REF: Reset A Prepared Statement Object
** METHOD: sqlite3_stmt
**
** The sqlite3_reset() function is called to reset a [prepared statement]
** object back to its initial state, ready to be re-executed.
** ^Any SQL statement variables that had values bound to them using
** the [sqlite3_bind_blob | sqlite3_bind_*() API] retain their values.
** Use [sqlite3_clear_bindings()] to reset the bindings.
**
** ^The [sqlite3_reset(S)] interface resets the [prepared statement] S
** back to the beginning of its program.
**
** ^If the most recent call to [sqlite3_step(S)] for the
** [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],
** or if [sqlite3_step(S)] has never before been called on S,
** then [sqlite3_reset(S)] returns [SQLITE_OK].
**
** ^If the most recent call to [sqlite3_step(S)] for the
** [prepared statement] S indicated an error, then
** [sqlite3_reset(S)] returns an appropriate [error code].
**
** ^The [sqlite3_reset(S)] interface does not change the values
** of any [sqlite3_bind_blob|bindings] on the [prepared statement] S.
*/
SQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt);
/*
** CAPI3REF: Create Or Redefine SQL Functions
** KEYWORDS: {function creation routines}
** KEYWORDS: {application-defined SQL function}
** KEYWORDS: {application-defined SQL functions}
** METHOD: sqlite3
**
** ^These functions (collectively known as "function creation routines")
** are used to add SQL functions or aggregates or to redefine the behavior
** of existing SQL functions or aggregates.  The only differences between
** these routines are the text encoding expected for
** the second parameter (the name of the function being created)
** and the presence or absence of a destructor callback for
** the application data pointer.
**
** ^The first parameter is the [database connection] to which the SQL
** function is to be added.  ^If an application uses more than one database
** connection then application-defined SQL functions must be added
** to each database connection separately.
**
** ^The second parameter is the name of the SQL function to be created or
** redefined.  ^The length of the name is limited to 255 bytes in a UTF-8
** representation, exclusive of the zero-terminator.  ^Note that the name
** length limit is in UTF-8 bytes, not characters nor UTF-16 bytes.
** ^Any attempt to create a function with a longer name
** will result in [SQLITE_MISUSE] being returned.
**
** ^The third parameter (nArg)
** is the number of arguments that the SQL function or
** aggregate takes. ^If this parameter is -1, then the SQL function or
** aggregate may take any number of arguments between 0 and the limit
** set by [sqlite3_limit]([SQLITE_LIMIT_FUNCTION_ARG]).  If the third
** parameter is less than -1 or greater than 127 then the behavior is
** undefined.
**
** ^The fourth parameter, eTextRep, specifies what
** [SQLITE_UTF8 | text encoding] this SQL function prefers for
** its parameters.  The application should set this parameter to
** [SQLITE_UTF16LE] if the function implementation invokes
** [sqlite3_value_text16le()] on an input, or [SQLITE_UTF16BE] if the
** implementation invokes [sqlite3_value_text16be()] on an input, or
** [SQLITE_UTF16] if [sqlite3_value_text16()] is used, or [SQLITE_UTF8]
** otherwise.  ^The same SQL function may be registered multiple times using
** different preferred text encodings, with different implementations for
** each encoding.
** ^When multiple implementations of the same function are available, SQLite
** will pick the one that involves the least amount of data conversion.
**
** ^The fourth parameter may optionally be ORed with [SQLITE_DETERMINISTIC]
** to signal that the function will always return the same result given
** the same inputs within a single SQL statement.  Most SQL functions are
** deterministic.  The built-in [random()] SQL function is an example of a
** function that is not deterministic.  The SQLite query planner is able to
** perform additional optimizations on deterministic functions, so use
** of the [SQLITE_DETERMINISTIC] flag is recommended where possible.
**
** ^(The fifth parameter is an arbitrary pointer.  The implementation of the
** function can gain access to this pointer using [sqlite3_user_data()].)^
**
** ^The sixth, seventh and eighth parameters, xFunc, xStep and xFinal, are
** pointers to C-language functions that implement the SQL function or
** aggregate. ^A scalar SQL function requires an implementation of the xFunc
** callback only; NULL pointers must be passed as the xStep and xFinal
** parameters. ^An aggregate SQL function requires an implementation of xStep
** and xFinal and NULL pointer must be passed for xFunc. ^To delete an existing
** SQL function or aggregate, pass NULL pointers for all three function
** callbacks.
**
** ^(If the ninth parameter to sqlite3_create_function_v2() is not NULL,
** then it is destructor for the application data pointer.
** The destructor is invoked when the function is deleted, either by being
** overloaded or when the database connection closes.)^
** ^The destructor is also invoked if the call to
** sqlite3_create_function_v2() fails.
** ^When the destructor callback of the tenth parameter is invoked, it
** is passed a single argument which is a copy of the application data
** pointer which was the fifth parameter to sqlite3_create_function_v2().
**
** ^It is permitted to register multiple implementations of the same
** functions with the same name but with either differing numbers of
** arguments or differing preferred text encodings.  ^SQLite will use
** the implementation that most closely matches the way in which the
** SQL function is used.  ^A function implementation with a non-negative
** nArg parameter is a better match than a function implementation with
** a negative nArg.  ^A function where the preferred text encoding
** matches the database encoding is a better
** match than a function where the encoding is different.
** ^A function where the encoding difference is between UTF16le and UTF16be
** is a closer match than a function where the encoding difference is
** between UTF8 and UTF16.
**
** ^Built-in functions may be overloaded by new application-defined functions.
**
** ^An application-defined function is permitted to call other
** SQLite interfaces.  However, such calls must not
** close the database connection nor finalize or reset the prepared
** statement in which the function is running.
*/
SQLITE_API int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
SQLITE_API int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
SQLITE_API int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void(*xDestroy)(void*)
);
/*
** CAPI3REF: Text Encodings
**
** These constant define integer codes that represent the various
** text encodings supported by SQLite.
*/
#define SQLITE_UTF8           1
#define SQLITE_UTF16LE        2
#define SQLITE_UTF16BE        3
#define SQLITE_UTF16          4
#define SQLITE_ANY            5
#define SQLITE_UTF16_ALIGNED  8
/*
** CAPI3REF: Function Flags
**
** These constants may be ORed together with the
** [SQLITE_UTF8 | preferred text encoding] as the fourth argument
** to [sqlite3_create_function()], [sqlite3_create_function16()], or
** [sqlite3_create_function_v2()].
*/
#define SQLITE_DETERMINISTIC    0x800
/*
** CAPI3REF: Deprecated Functions
** DEPRECATED
**
** These functions are [deprecated].  In order to maintain
** backwards compatibility with older code, these functions continue
** to be supported.  However, new applications should avoid
** the use of these functions.  To encourage programmers to avoid
** these functions, we will not explain what they do.
*/
#ifndef SQLITE_OMIT_DEPRECATED
SQLITE_API SQLITE_DEPRECATED int sqlite3_aggregate_count(sqlite3_context*);
SQLITE_API SQLITE_DEPRECATED int sqlite3_expired(sqlite3_stmt*);
SQLITE_API SQLITE_DEPRECATED int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
SQLITE_API SQLITE_DEPRECATED int sqlite3_global_recover(void);
SQLITE_API SQLITE_DEPRECATED void sqlite3_thread_cleanup(void);
SQLITE_API SQLITE_DEPRECATED int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
                      void*,sqlite3_int64);
#endif
/*
** CAPI3REF: Obtaining SQL Values
** METHOD: sqlite3_value
**
** <b>Summary:</b>
** <blockquote><table border=0 cellpadding=0 cellspacing=0>
** <tr><td><b>sqlite3_value_blob</b><td>&rarr;<td>BLOB value
** <tr><td><b>sqlite3_value_double</b><td>&rarr;<td>REAL value
** <tr><td><b>sqlite3_value_int</b><td>&rarr;<td>32-bit INTEGER value
** <tr><td><b>sqlite3_value_int64</b><td>&rarr;<td>64-bit INTEGER value
** <tr><td><b>sqlite3_value_pointer</b><td>&rarr;<td>Pointer value
** <tr><td><b>sqlite3_value_text</b><td>&rarr;<td>UTF-8 TEXT value
** <tr><td><b>sqlite3_value_text16</b><td>&rarr;<td>UTF-16 TEXT value in
** the native byteorder
** <tr><td><b>sqlite3_value_text16be</b><td>&rarr;<td>UTF-16be TEXT value
** <tr><td><b>sqlite3_value_text16le</b><td>&rarr;<td>UTF-16le TEXT value
** <tr><td>&nbsp;<td>&nbsp;<td>&nbsp;
** <tr><td><b>sqlite3_value_bytes</b><td>&rarr;<td>Size of a BLOB
** or a UTF-8 TEXT in bytes
** <tr><td><b>sqlite3_value_bytes16&nbsp;&nbsp;</b>
** <td>&rarr;&nbsp;&nbsp;<td>Size of UTF-16
** TEXT in bytes
** <tr><td><b>sqlite3_value_type</b><td>&rarr;<td>Default
** datatype of the value
** <tr><td><b>sqlite3_value_numeric_type&nbsp;&nbsp;</b>
** <td>&rarr;&nbsp;&nbsp;<td>Best numeric datatype of the value
** <tr><td><b>sqlite3_value_nochange&nbsp;&nbsp;</b>
** <td>&rarr;&nbsp;&nbsp;<td>True if the column is unchanged in an UPDATE
** against a virtual table.
** </table></blockquote>
**
** <b>Details:</b>
**
** These routines extract type, size, and content information from
** [protected sqlite3_value] objects.  Protected sqlite3_value objects
** are used to pass parameter information into implementation of
** [application-defined SQL functions] and [virtual tables].
**
** These routines work only with [protected sqlite3_value] objects.
** Any attempt to use these routines on an [unprotected sqlite3_value]
** is not threadsafe.
**
** ^These routines work just like the corresponding [column access functions]
** except that these routines take a single [protected sqlite3_value] object
** pointer instead of a [sqlite3_stmt*] pointer and an integer column number.
**
** ^The sqlite3_value_text16() interface extracts a UTF-16 string
** in the native byte-order of the host machine.  ^The
** sqlite3_value_text16be() and sqlite3_value_text16le() interfaces
** extract UTF-16 strings as big-endian and little-endian respectively.
**
** ^If [sqlite3_value] object V was initialized
** using [sqlite3_bind_pointer(S,I,P,X,D)] or [sqlite3_result_pointer(C,P,X,D)]
** and if X and Y are strings that compare equal according to strcmp(X,Y),
** then sqlite3_value_pointer(V,Y) will return the pointer P.  ^Otherwise,
** sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer()
** routine is part of the [pointer passing interface] added for SQLite 3.20.0.
**
** ^(The sqlite3_value_type(V) interface returns the
** [SQLITE_INTEGER | datatype code] for the initial datatype of the
** [sqlite3_value] object V. The returned value is one of [SQLITE_INTEGER],
** [SQLITE_FLOAT], [SQLITE_TEXT], [SQLITE_BLOB], or [SQLITE_NULL].)^
** Other interfaces might change the datatype for an sqlite3_value object.
** For example, if the datatype is initially SQLITE_INTEGER and
** sqlite3_value_text(V) is called to extract a text value for that
** integer, then subsequent calls to sqlite3_value_type(V) might return
** SQLITE_TEXT.  Whether or not a persistent internal datatype conversion
** occurs is undefined and may change from one release of SQLite to the next.
**
** ^(The sqlite3_value_numeric_type() interface attempts to apply
** numeric affinity to the value.  This means that an attempt is
** made to convert the value to an integer or floating point.  If
** such a conversion is possible without loss of information (in other
** words, if the value is a string that looks like a number)
** then the conversion is performed.  Otherwise no conversion occurs.
** The [SQLITE_INTEGER | datatype] after conversion is returned.)^
**
** ^Within the [xUpdate] method of a [virtual table], the
** sqlite3_value_nochange(X) interface returns true if and only if
** the column corresponding to X is unchanged by the UPDATE operation
** that the xUpdate method call was invoked to implement and if
** and the prior [xColumn] method call that was invoked to extracted
** the value for that column returned without setting a result (probably
** because it queried [sqlite3_vtab_nochange()] and found that the column
** was unchanging).  ^Within an [xUpdate] method, any value for which
** sqlite3_value_nochange(X) is true will in all other respects appear
** to be a NULL value.  If sqlite3_value_nochange(X) is invoked anywhere other
** than within an [xUpdate] method call for an UPDATE statement, then
** the return value is arbitrary and meaningless.
**
** Please pay particular attention to the fact that the pointer returned
** from [sqlite3_value_blob()], [sqlite3_value_text()], or
** [sqlite3_value_text16()] can be invalidated by a subsequent call to
** [sqlite3_value_bytes()], [sqlite3_value_bytes16()], [sqlite3_value_text()],
** or [sqlite3_value_text16()].
**
** These routines must be called from the same thread as
** the SQL function that supplied the [sqlite3_value*] parameters.
*/
SQLITE_API const void *sqlite3_value_blob(sqlite3_value*);
SQLITE_API double sqlite3_value_double(sqlite3_value*);
SQLITE_API int sqlite3_value_int(sqlite3_value*);
SQLITE_API sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
SQLITE_API void *sqlite3_value_pointer(sqlite3_value*, const char*);
SQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value*);
SQLITE_API const void *sqlite3_value_text16(sqlite3_value*);
SQLITE_API const void *sqlite3_value_text16le(sqlite3_value*);
SQLITE_API const void *sqlite3_value_text16be(sqlite3_value*);
SQLITE_API int sqlite3_value_bytes(sqlite3_value*);
SQLITE_API int sqlite3_value_bytes16(sqlite3_value*);
SQLITE_API int sqlite3_value_type(sqlite3_value*);
SQLITE_API int sqlite3_value_numeric_type(sqlite3_value*);
SQLITE_API int sqlite3_value_nochange(sqlite3_value*);
/*
** CAPI3REF: Finding The Subtype Of SQL Values
** METHOD: sqlite3_value
**
** The sqlite3_value_subtype(V) function returns the subtype for
** an [application-defined SQL function] argument V.  The subtype
** information can be used to pass a limited amount of context from
** one SQL function to another.  Use the [sqlite3_result_subtype()]
** routine to set the subtype for the return value of an SQL function.
*/
SQLITE_API unsigned int sqlite3_value_subtype(sqlite3_value*);
/*
** CAPI3REF: Copy And Free SQL Values
** METHOD: sqlite3_value
**
** ^The sqlite3_value_dup(V) interface makes a copy of the [sqlite3_value]
** object D and returns a pointer to that copy.  ^The [sqlite3_value] returned
** is a [protected sqlite3_value] object even if the input is not.
** ^The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a
** memory allocation fails.
**
** ^The sqlite3_value_free(V) interface frees an [sqlite3_value] object
** previously obtained from [sqlite3_value_dup()].  ^If V is a NULL pointer
** then sqlite3_value_free(V) is a harmless no-op.
*/
SQLITE_API sqlite3_value *sqlite3_value_dup(const sqlite3_value*);
SQLITE_API void sqlite3_value_free(sqlite3_value*);
/*
** CAPI3REF: Obtain Aggregate Function Context
** METHOD: sqlite3_context
**
** Implementations of aggregate SQL functions use this
** routine to allocate memory for storing their state.
**
** ^The first time the sqlite3_aggregate_context(C,N) routine is called
** for a particular aggregate function, SQLite
** allocates N of memory, zeroes out that memory, and returns a pointer
** to the new memory. ^On second and subsequent calls to
** sqlite3_aggregate_context() for the same aggregate function instance,
** the same buffer is returned.  Sqlite3_aggregate_context() is normally
** called once for each invocation of the xStep callback and then one
** last time when the xFinal callback is invoked.  ^(When no rows match
** an aggregate query, the xStep() callback of the aggregate function
** implementation is never called and xFinal() is called exactly once.
** In those cases, sqlite3_aggregate_context() might be called for the
** first time from within xFinal().)^
**
** ^The sqlite3_aggregate_context(C,N) routine returns a NULL pointer
** when first called if N is less than or equal to zero or if a memory
** allocate error occurs.
**
** ^(The amount of space allocated by sqlite3_aggregate_context(C,N) is
** determined by the N parameter on first successful call.  Changing the
** value of N in subsequent call to sqlite3_aggregate_context() within
** the same aggregate function instance will not resize the memory
** allocation.)^  Within the xFinal callback, it is customary to set
** N=0 in calls to sqlite3_aggregate_context(C,N) so that no
** pointless memory allocations occur.
**
** ^SQLite automatically frees the memory allocated by
** sqlite3_aggregate_context() when the aggregate query concludes.
**
** The first parameter must be a copy of the
** [sqlite3_context | SQL function context] that is the first parameter
** to the xStep or xFinal callback routine that implements the aggregate
** function.
**
** This routine must be called from the same thread in which
** the aggregate SQL function is running.
*/
SQLITE_API void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
/*
** CAPI3REF: User Data For Functions
** METHOD: sqlite3_context
**
** ^The sqlite3_user_data() interface returns a copy of
** the pointer that was the pUserData parameter (the 5th parameter)
** of the [sqlite3_create_function()]
** and [sqlite3_create_function16()] routines that originally
** registered the application defined function.
**
** This routine must be called from the same thread in which
** the application-defined function is running.
*/
SQLITE_API void *sqlite3_user_data(sqlite3_context*);
/*
** CAPI3REF: Database Connection For Functions
** METHOD: sqlite3_context
**
** ^The sqlite3_context_db_handle() interface returns a copy of
** the pointer to the [database connection] (the 1st parameter)
** of the [sqlite3_create_function()]
** and [sqlite3_create_function16()] routines that originally
** registered the application defined function.
*/
SQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
/*
** CAPI3REF: Function Auxiliary Data
** METHOD: sqlite3_context
**
** These functions may be used by (non-aggregate) SQL functions to
** associate metadata with argument values. If the same value is passed to
** multiple invocations of the same SQL function during query execution, under
** some circumstances the associated metadata may be preserved.  An example
** of where this might be useful is in a regular-expression matching
** function. The compiled version of the regular expression can be stored as
** metadata associated with the pattern string.
** Then as long as the pattern string remains the same,
** the compiled regular expression can be reused on multiple
** invocations of the same function.
**
** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata
** associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument
** value to the application-defined function.  ^N is zero for the left-most
** function argument.  ^If there is no metadata
** associated with the function argument, the sqlite3_get_auxdata(C,N) interface
** returns a NULL pointer.
**
** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th
** argument of the application-defined function.  ^Subsequent
** calls to sqlite3_get_auxdata(C,N) return P from the most recent
** sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or
** NULL if the metadata has been discarded.
** ^After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL,
** SQLite will invoke the destructor function X with parameter P exactly
** once, when the metadata is discarded.
** SQLite is free to discard the metadata at any time, including: <ul>
** <li> ^(when the corresponding function parameter changes)^, or
** <li> ^(when [sqlite3_reset()] or [sqlite3_finalize()] is called for the
**      SQL statement)^, or
** <li> ^(when sqlite3_set_auxdata() is invoked again on the same
**       parameter)^, or
** <li> ^(during the original sqlite3_set_auxdata() call when a memory
**      allocation error occurs.)^ </ul>
**
** Note the last bullet in particular.  The destructor X in
** sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the
** sqlite3_set_auxdata() interface even returns.  Hence sqlite3_set_auxdata()
** should be called near the end of the function implementation and the
** function implementation should not make any use of P after
** sqlite3_set_auxdata() has been called.
**
** ^(In practice, metadata is preserved between function calls for
** function parameters that are compile-time constants, including literal
** values and [parameters] and expressions composed from the same.)^
**
** The value of the N parameter to these interfaces should be non-negative.
** Future enhancements may make use of negative N values to define new
** kinds of function caching behavior.
**
** These routines must be called from the same thread in which
** the SQL function is running.
*/
SQLITE_API void *sqlite3_get_auxdata(sqlite3_context*, int N);
SQLITE_API void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
/*
** CAPI3REF: Constants Defining Special Destructor Behavior
**
** These are special values for the destructor that is passed in as the
** final argument to routines like [sqlite3_result_blob()].  ^If the destructor
** argument is SQLITE_STATIC, it means that the content pointer is constant
** and will never change.  It does not need to be destroyed.  ^The
** SQLITE_TRANSIENT value means that the content will likely change in
** the near future and that SQLite should make its own private copy of
** the content before returning.
**
** The typedef is necessary to work around problems in certain
** C++ compilers.
*/
typedef void (*sqlite3_destructor_type)(void*);
#define SQLITE_STATIC      ((sqlite3_destructor_type)0)
#define SQLITE_TRANSIENT   ((sqlite3_destructor_type)-1)
/*
** CAPI3REF: Setting The Result Of An SQL Function
** METHOD: sqlite3_context
**
** These routines are used by the xFunc or xFinal callbacks that
** implement SQL functions and aggregates.  See
** [sqlite3_create_function()] and [sqlite3_create_function16()]
** for additional information.
**
** These functions work very much like the [parameter binding] family of
** functions used to bind values to host parameters in prepared statements.
** Refer to the [SQL parameter] documentation for additional information.
**
** ^The sqlite3_result_blob() interface sets the result from
** an application-defined function to be the BLOB whose content is pointed
** to by the second parameter and which is N bytes long where N is the
** third parameter.
**
** ^The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N)
** interfaces set the result of the application-defined function to be
** a BLOB containing all zero bytes and N bytes in size.
**
** ^The sqlite3_result_double() interface sets the result from
** an application-defined function to be a floating point value specified
** by its 2nd argument.
**
** ^The sqlite3_result_error() and sqlite3_result_error16() functions
** cause the implemented SQL function to throw an exception.
** ^SQLite uses the string pointed to by the
** 2nd parameter of sqlite3_result_error() or sqlite3_result_error16()
** as the text of an error message.  ^SQLite interprets the error
** message string from sqlite3_result_error() as UTF-8. ^SQLite
** interprets the string from sqlite3_result_error16() as UTF-16 in native
** byte order.  ^If the third parameter to sqlite3_result_error()
** or sqlite3_result_error16() is negative then SQLite takes as the error
** message all text up through the first zero character.
** ^If the third parameter to sqlite3_result_error() or
** sqlite3_result_error16() is non-negative then SQLite takes that many
** bytes (not characters) from the 2nd parameter as the error message.
** ^The sqlite3_result_error() and sqlite3_result_error16()
** routines make a private copy of the error message text before
** they return.  Hence, the calling function can deallocate or
** modify the text after they return without harm.
** ^The sqlite3_result_error_code() function changes the error code
** returned by SQLite as a result of an error in a function.  ^By default,
** the error code is SQLITE_ERROR.  ^A subsequent call to sqlite3_result_error()
** or sqlite3_result_error16() resets the error code to SQLITE_ERROR.
**
** ^The sqlite3_result_error_toobig() interface causes SQLite to throw an
** error indicating that a string or BLOB is too long to represent.
**
** ^The sqlite3_result_error_nomem() interface causes SQLite to throw an
** error indicating that a memory allocation failed.
**
** ^The sqlite3_result_int() interface sets the return value
** of the application-defined function to be the 32-bit signed integer
** value given in the 2nd argument.
** ^The sqlite3_result_int64() interface sets the return value
** of the application-defined function to be the 64-bit signed integer
** value given in the 2nd argument.
**
** ^The sqlite3_result_null() interface sets the return value
** of the application-defined function to be NULL.
**
** ^The sqlite3_result_text(), sqlite3_result_text16(),
** sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces
** set the return value of the application-defined function to be
** a text string which is represented as UTF-8, UTF-16 native byte order,
** UTF-16 little endian, or UTF-16 big endian, respectively.
** ^The sqlite3_result_text64() interface sets the return value of an
** application-defined function to be a text string in an encoding
** specified by the fifth (and last) parameter, which must be one
** of [SQLITE_UTF8], [SQLITE_UTF16], [SQLITE_UTF16BE], or [SQLITE_UTF16LE].
** ^SQLite takes the text result from the application from
** the 2nd parameter of the sqlite3_result_text* interfaces.
** ^If the 3rd parameter to the sqlite3_result_text* interfaces
** is negative, then SQLite takes result text from the 2nd parameter
** through the first zero character.
** ^If the 3rd parameter to the sqlite3_result_text* interfaces
** is non-negative, then as many bytes (not characters) of the text
** pointed to by the 2nd parameter are taken as the application-defined
** function result.  If the 3rd parameter is non-negative, then it
** must be the byte offset into the string where the NUL terminator would
** appear if the string where NUL terminated.  If any NUL characters occur
** in the string at a byte offset that is less than the value of the 3rd
** parameter, then the resulting string will contain embedded NULs and the
** result of expressions operating on strings with embedded NULs is undefined.
** ^If the 4th parameter to the sqlite3_result_text* interfaces
** or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that
** function as the destructor on the text or BLOB result when it has
** finished using that result.
** ^If the 4th parameter to the sqlite3_result_text* interfaces or to
** sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite
** assumes that the text or BLOB result is in constant space and does not
** copy the content of the parameter nor call a destructor on the content
** when it has finished using that result.
** ^If the 4th parameter to the sqlite3_result_text* interfaces
** or sqlite3_result_blob is the special constant SQLITE_TRANSIENT
** then SQLite makes a copy of the result into space obtained
** from [sqlite3_malloc()] before it returns.
**
** ^The sqlite3_result_value() interface sets the result of
** the application-defined function to be a copy of the
** [unprotected sqlite3_value] object specified by the 2nd parameter.  ^The
** sqlite3_result_value() interface makes a copy of the [sqlite3_value]
** so that the [sqlite3_value] specified in the parameter may change or
** be deallocated after sqlite3_result_value() returns without harm.
** ^A [protected sqlite3_value] object may always be used where an
** [unprotected sqlite3_value] object is required, so either
** kind of [sqlite3_value] object can be used with this interface.
**
** ^The sqlite3_result_pointer(C,P,T,D) interface sets the result to an
** SQL NULL value, just like [sqlite3_result_null(C)], except that it
** also associates the host-language pointer P or type T with that
** NULL value such that the pointer can be retrieved within an
** [application-defined SQL function] using [sqlite3_value_pointer()].
** ^If the D parameter is not NULL, then it is a pointer to a destructor
** for the P parameter.  ^SQLite invokes D with P as its only argument
** when SQLite is finished with P.  The T parameter should be a static
** string and preferably a string literal. The sqlite3_result_pointer()
** routine is part of the [pointer passing interface] added for SQLite 3.20.0.
**
** If these routines are called from within the different thread
** than the one containing the application-defined function that received
** the [sqlite3_context] pointer, the results are undefined.
*/
SQLITE_API void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
SQLITE_API void sqlite3_result_blob64(sqlite3_context*,const void*,
                           sqlite3_uint64,void(*)(void*));
SQLITE_API void sqlite3_result_double(sqlite3_context*, double);
SQLITE_API void sqlite3_result_error(sqlite3_context*, const char*, int);
SQLITE_API void sqlite3_result_error16(sqlite3_context*, const void*, int);
SQLITE_API void sqlite3_result_error_toobig(sqlite3_context*);
SQLITE_API void sqlite3_result_error_nomem(sqlite3_context*);
SQLITE_API void sqlite3_result_error_code(sqlite3_context*, int);
SQLITE_API void sqlite3_result_int(sqlite3_context*, int);
SQLITE_API void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
SQLITE_API void sqlite3_result_null(sqlite3_context*);
SQLITE_API void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
SQLITE_API void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
                           void(*)(void*), unsigned char encoding);
SQLITE_API void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
SQLITE_API void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
SQLITE_API void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
SQLITE_API void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
SQLITE_API void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));
SQLITE_API void sqlite3_result_zeroblob(sqlite3_context*, int n);
SQLITE_API int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
/*
** CAPI3REF: Setting The Subtype Of An SQL Function
** METHOD: sqlite3_context
**
** The sqlite3_result_subtype(C,T) function causes the subtype of
** the result from the [application-defined SQL function] with
** [sqlite3_context] C to be the value T.  Only the lower 8 bits
** of the subtype T are preserved in current versions of SQLite;
** higher order bits are discarded.
** The number of subtype bytes preserved by SQLite might increase
** in future releases of SQLite.
*/
SQLITE_API void sqlite3_result_subtype(sqlite3_context*,unsigned int);
/*
** CAPI3REF: Define New Collating Sequences
** METHOD: sqlite3
**
** ^These functions add, remove, or modify a [collation] associated
** with the [database connection] specified as the first argument.
**
** ^The name of the collation is a UTF-8 string
** for sqlite3_create_collation() and sqlite3_create_collation_v2()
** and a UTF-16 string in native byte order for sqlite3_create_collation16().
** ^Collation names that compare equal according to [sqlite3_strnicmp()] are
** considered to be the same name.
**
** ^(The third argument (eTextRep) must be one of the constants:
** <ul>
** <li> [SQLITE_UTF8],
** <li> [SQLITE_UTF16LE],
** <li> [SQLITE_UTF16BE],
** <li> [SQLITE_UTF16], or
** <li> [SQLITE_UTF16_ALIGNED].
** </ul>)^
** ^The eTextRep argument determines the encoding of strings passed
** to the collating function callback, xCallback.
** ^The [SQLITE_UTF16] and [SQLITE_UTF16_ALIGNED] values for eTextRep
** force strings to be UTF16 with native byte order.
** ^The [SQLITE_UTF16_ALIGNED] value for eTextRep forces strings to begin
** on an even byte address.
**
** ^The fourth argument, pArg, is an application data pointer that is passed
** through as the first argument to the collating function callback.
**
** ^The fifth argument, xCallback, is a pointer to the collating function.
** ^Multiple collating functions can be registered using the same name but
** with different eTextRep parameters and SQLite will use whichever
** function requires the least amount of data transformation.
** ^If the xCallback argument is NULL then the collating function is
** deleted.  ^When all collating functions having the same name are deleted,
** that collation is no longer usable.
**
** ^The collating function callback is invoked with a copy of the pArg
** application data pointer and with two strings in the encoding specified
** by the eTextRep argument.  The collating function must return an
** integer that is negative, zero, or positive
** if the first string is less than, equal to, or greater than the second,
** respectively.  A collating function must always return the same answer
** given the same inputs.  If two or more collating functions are registered
** to the same collation name (using different eTextRep values) then all
** must give an equivalent answer when invoked with equivalent strings.
** The collating function must obey the following properties for all
** strings A, B, and C:
**
** <ol>
** <li> If A==B then B==A.
** <li> If A==B and B==C then A==C.
** <li> If A&lt;B THEN B&gt;A.
** <li> If A&lt;B and B&lt;C then A&lt;C.
** </ol>
**
** If a collating function fails any of the above constraints and that
** collating function is  registered and used, then the behavior of SQLite
** is undefined.
**
** ^The sqlite3_create_collation_v2() works like sqlite3_create_collation()
** with the addition that the xDestroy callback is invoked on pArg when
** the collating function is deleted.
** ^Collating functions are deleted when they are overridden by later
** calls to the collation creation functions or when the
** [database connection] is closed using [sqlite3_close()].
**
** ^The xDestroy callback is <u>not</u> called if the
** sqlite3_create_collation_v2() function fails.  Applications that invoke
** sqlite3_create_collation_v2() with a non-NULL xDestroy argument should
** check the return code and dispose of the application data pointer
** themselves rather than expecting SQLite to deal with it for them.
** This is different from every other SQLite interface.  The inconsistency
** is unfortunate but cannot be changed without breaking backwards
** compatibility.
**
** See also:  [sqlite3_collation_needed()] and [sqlite3_collation_needed16()].
*/
SQLITE_API int sqlite3_create_collation(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
SQLITE_API int sqlite3_create_collation_v2(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDestroy)(void*)
);
SQLITE_API int sqlite3_create_collation16(
  sqlite3*,
  const void *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
/*
** CAPI3REF: Collation Needed Callbacks
** METHOD: sqlite3
**
** ^To avoid having to register all collation sequences before a database
** can be used, a single callback function may be registered with the
** [database connection] to be invoked whenever an undefined collation
** sequence is required.
**
** ^If the function is registered using the sqlite3_collation_needed() API,
** then it is passed the names of undefined collation sequences as strings
** encoded in UTF-8. ^If sqlite3_collation_needed16() is used,
** the names are passed as UTF-16 in machine native byte order.
** ^A call to either function replaces the existing collation-needed callback.
**
** ^(When the callback is invoked, the first argument passed is a copy
** of the second argument to sqlite3_collation_needed() or
** sqlite3_collation_needed16().  The second argument is the database
** connection.  The third argument is one of [SQLITE_UTF8], [SQLITE_UTF16BE],
** or [SQLITE_UTF16LE], indicating the most desirable form of the collation
** sequence function required.  The fourth parameter is the name of the
** required collation sequence.)^
**
** The callback function should register the desired collation using
** [sqlite3_create_collation()], [sqlite3_create_collation16()], or
** [sqlite3_create_collation_v2()].
*/
SQLITE_API int sqlite3_collation_needed(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
SQLITE_API int sqlite3_collation_needed16(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);
#ifdef SQLITE_HAS_CODEC
/*
** Specify the key for an encrypted database.  This routine should be
** called right after sqlite3_open().
**
** The code to implement this API is not available in the public release
** of SQLite.
*/
SQLITE_API int sqlite3_key(
  sqlite3 *db,
  const void *pKey, int nKey
);
SQLITE_API int sqlite3_key_v2(
  sqlite3 *db,
  const char *zDbName,
  const void *pKey, int nKey
);
/*
** Change the key on an open database.  If the current database is not
** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the
** database is decrypted.
**
** The code to implement this API is not available in the public release
** of SQLite.
*/
SQLITE_API int sqlite3_rekey(
  sqlite3 *db,
  const void *pKey, int nKey
);
SQLITE_API int sqlite3_rekey_v2(
  sqlite3 *db,
  const char *zDbName,
  const void *pKey, int nKey
);
/*
** Specify the activation key for a SEE database.  Unless
** activated, none of the SEE routines will work.
*/
SQLITE_API void sqlite3_activate_see(
  const char *zPassPhrase
);
#endif
#ifdef SQLITE_ENABLE_CEROD
/*
** Specify the activation key for a CEROD database.  Unless
** activated, none of the CEROD routines will work.
*/
SQLITE_API void sqlite3_activate_cerod(
  const char *zPassPhrase
);
#endif
/*
** CAPI3REF: Suspend Execution For A Short Time
**
** The sqlite3_sleep() function causes the current thread to suspend execution
** for at least a number of milliseconds specified in its parameter.
**
** If the operating system does not support sleep requests with
** millisecond time resolution, then the time will be rounded up to
** the nearest second. The number of milliseconds of sleep actually
** requested from the operating system is returned.
**
** ^SQLite implements this interface by calling the xSleep()
** method of the default [sqlite3_vfs] object.  If the xSleep() method
** of the default VFS is not implemented correctly, or not implemented at
** all, then the behavior of sqlite3_sleep() may deviate from the description
** in the previous paragraphs.
*/
SQLITE_API int sqlite3_sleep(int);
/*
** CAPI3REF: Name Of The Folder Holding Temporary Files
**
** ^(If this global variable is made to point to a string which is
** the name of a folder (a.k.a. directory), then all temporary files
** created by SQLite when using a built-in [sqlite3_vfs | VFS]
** will be placed in that directory.)^  ^If this variable
** is a NULL pointer, then SQLite performs a search for an appropriate
** temporary file directory.
**
** Applications are strongly discouraged from using this global variable.
** It is required to set a temporary folder on Windows Runtime (WinRT).
** But for all other platforms, it is highly recommended that applications
** neither read nor write this variable.  This global variable is a relic
** that exists for backwards compatibility of legacy applications and should
** be avoided in new projects.
**
** It is not safe to read or modify this variable in more than one
** thread at a time.  It is not safe to read or modify this variable
** if a [database connection] is being used at the same time in a separate
** thread.
** It is intended that this variable be set once
** as part of process initialization and before any SQLite interface
** routines have been called and that this variable remain unchanged
** thereafter.
**
** ^The [temp_store_directory pragma] may modify this variable and cause
** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,
** the [temp_store_directory pragma] always assumes that any string
** that this variable points to is held in memory obtained from
** [sqlite3_malloc] and the pragma may attempt to free that memory
** using [sqlite3_free].
** Hence, if this variable is modified directly, either it should be
** made NULL or made to point to memory obtained from [sqlite3_malloc]
** or else the use of the [temp_store_directory pragma] should be avoided.
** Except when requested by the [temp_store_directory pragma], SQLite
** does not free the memory that sqlite3_temp_directory points to.  If
** the application wants that memory to be freed, it must do
** so itself, taking care to only do so after all [database connection]
** objects have been destroyed.
**
** <b>Note to Windows Runtime users:</b>  The temporary directory must be set
** prior to calling [sqlite3_open] or [sqlite3_open_v2].  Otherwise, various
** features that require the use of temporary files may fail.  Here is an
** example of how to do this using C++ with the Windows Runtime:
**
** <blockquote><pre>
** LPCWSTR zPath = Windows::Storage::ApplicationData::Current->
** &nbsp;     TemporaryFolder->Path->Data();
** char zPathBuf&#91;MAX_PATH + 1&#93;;
** memset(zPathBuf, 0, sizeof(zPathBuf));
** WideCharToMultiByte(CP_UTF8, 0, zPath, -1, zPathBuf, sizeof(zPathBuf),
** &nbsp;     NULL, NULL);
** sqlite3_temp_directory = sqlite3_mprintf("%s", zPathBuf);
** </pre></blockquote>
*/
SQLITE_API SQLITE_EXTERN char *sqlite3_temp_directory;
/*
** CAPI3REF: Name Of The Folder Holding Database Files
**
** ^(If this global variable is made to point to a string which is
** the name of a folder (a.k.a. directory), then all database files
** specified with a relative pathname and created or accessed by
** SQLite when using a built-in windows [sqlite3_vfs | VFS] will be assumed
** to be relative to that directory.)^ ^If this variable is a NULL
** pointer, then SQLite assumes that all database files specified
** with a relative pathname are relative to the current directory
** for the process.  Only the windows VFS makes use of this global
** variable; it is ignored by the unix VFS.
**
** Changing the value of this variable while a database connection is
** open can result in a corrupt database.
**
** It is not safe to read or modify this variable in more than one
** thread at a time.  It is not safe to read or modify this variable
** if a [database connection] is being used at the same time in a separate
** thread.
** It is intended that this variable be set once
** as part of process initialization and before any SQLite interface
** routines have been called and that this variable remain unchanged
** thereafter.
**
** ^The [data_store_directory pragma] may modify this variable and cause
** it to point to memory obtained from [sqlite3_malloc].  ^Furthermore,
** the [data_store_directory pragma] always assumes that any string
** that this variable points to is held in memory obtained from
** [sqlite3_malloc] and the pragma may attempt to free that memory
** using [sqlite3_free].
** Hence, if this variable is modified directly, either it should be
** made NULL or made to point to memory obtained from [sqlite3_malloc]
** or else the use of the [data_store_directory pragma] should be avoided.
*/
SQLITE_API SQLITE_EXTERN char *sqlite3_data_directory;
/*
** CAPI3REF: Test For Auto-Commit Mode
** KEYWORDS: {autocommit mode}
** METHOD: sqlite3
**
** ^The sqlite3_get_autocommit() interface returns non-zero or
** zero if the given database connection is or is not in autocommit mode,
** respectively.  ^Autocommit mode is on by default.
** ^Autocommit mode is disabled by a [BEGIN] statement.
** ^Autocommit mode is re-enabled by a [COMMIT] or [ROLLBACK].
**
** If certain kinds of errors occur on a statement within a multi-statement
** transaction (errors including [SQLITE_FULL], [SQLITE_IOERR],
** [SQLITE_NOMEM], [SQLITE_BUSY], and [SQLITE_INTERRUPT]) then the
** transaction might be rolled back automatically.  The only way to
** find out whether SQLite automatically rolled back the transaction after
** an error is to use this function.
**
** If another thread changes the autocommit status of the database
** connection while this routine is running, then the return value
** is undefined.
*/
SQLITE_API int sqlite3_get_autocommit(sqlite3*);
/*
** CAPI3REF: Find The Database Handle Of A Prepared Statement
** METHOD: sqlite3_stmt
**
** ^The sqlite3_db_handle interface returns the [database connection] handle
** to which a [prepared statement] belongs.  ^The [database connection]
** returned by sqlite3_db_handle is the same [database connection]
** that was the first argument
** to the [sqlite3_prepare_v2()] call (or its variants) that was used to
** create the statement in the first place.
*/
SQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
/*
** CAPI3REF: Return The Filename For A Database Connection
** METHOD: sqlite3
**
** ^The sqlite3_db_filename(D,N) interface returns a pointer to a filename
** associated with database N of connection D.  ^The main database file
** has the name "main".  If there is no attached database N on the database
** connection D, or if database N is a temporary or in-memory database, then
** a NULL pointer is returned.
**
** ^The filename returned by this function is the output of the
** xFullPathname method of the [VFS].  ^In other words, the filename
** will be an absolute pathname, even if the filename used
** to open the database originally was a URI or relative pathname.
*/
SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);
/*
** CAPI3REF: Determine if a database is read-only
** METHOD: sqlite3
**
** ^The sqlite3_db_readonly(D,N) interface returns 1 if the database N
** of connection D is read-only, 0 if it is read/write, or -1 if N is not
** the name of a database on connection D.
*/
SQLITE_API int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
/*
** CAPI3REF: Find the next prepared statement
** METHOD: sqlite3
**
** ^This interface returns a pointer to the next [prepared statement] after
** pStmt associated with the [database connection] pDb.  ^If pStmt is NULL
** then this interface returns a pointer to the first prepared statement
** associated with the database connection pDb.  ^If no prepared statement
** satisfies the conditions of this routine, it returns NULL.
**
** The [database connection] pointer D in a call to
** [sqlite3_next_stmt(D,S)] must refer to an open database
** connection and in particular must not be a NULL pointer.
*/
SQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
/*
** CAPI3REF: Commit And Rollback Notification Callbacks
** METHOD: sqlite3
**
** ^The sqlite3_commit_hook() interface registers a callback
** function to be invoked whenever a transaction is [COMMIT | committed].
** ^Any callback set by a previous call to sqlite3_commit_hook()
** for the same database connection is overridden.
** ^The sqlite3_rollback_hook() interface registers a callback
** function to be invoked whenever a transaction is [ROLLBACK | rolled back].
** ^Any callback set by a previous call to sqlite3_rollback_hook()
** for the same database connection is overridden.
** ^The pArg argument is passed through to the callback.
** ^If the callback on a commit hook function returns non-zero,
** then the commit is converted into a rollback.
**
** ^The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions
** return the P argument from the previous call of the same function
** on the same [database connection] D, or NULL for
** the first call for each function on D.
**
** The commit and rollback hook callbacks are not reentrant.
** The callback implementation must not do anything that will modify
** the database connection that invoked the callback.  Any actions
** to modify the database connection must be deferred until after the
** completion of the [sqlite3_step()] call that triggered the commit
** or rollback hook in the first place.
** Note that running any other SQL statements, including SELECT statements,
** or merely calling [sqlite3_prepare_v2()] and [sqlite3_step()] will modify
** the database connections for the meaning of "modify" in this paragraph.
**
** ^Registering a NULL function disables the callback.
**
** ^When the commit hook callback routine returns zero, the [COMMIT]
** operation is allowed to continue normally.  ^If the commit hook
** returns non-zero, then the [COMMIT] is converted into a [ROLLBACK].
** ^The rollback hook is invoked on a rollback that results from a commit
** hook returning non-zero, just as it would be with any other rollback.
**
** ^For the purposes of this API, a transaction is said to have been
** rolled back if an explicit "ROLLBACK" statement is executed, or
** an error or constraint causes an implicit rollback to occur.
** ^The rollback callback is not invoked if a transaction is
** automatically rolled back because the database connection is closed.
**
** See also the [sqlite3_update_hook()] interface.
*/
SQLITE_API void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
SQLITE_API void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
/*
** CAPI3REF: Data Change Notification Callbacks
** METHOD: sqlite3
**
** ^The sqlite3_update_hook() interface registers a callback function
** with the [database connection] identified by the first argument
** to be invoked whenever a row is updated, inserted or deleted in
** a [rowid table].
** ^Any callback set by a previous call to this function
** for the same database connection is overridden.
**
** ^The second argument is a pointer to the function to invoke when a
** row is updated, inserted or deleted in a rowid table.
** ^The first argument to the callback is a copy of the third argument
** to sqlite3_update_hook().
** ^The second callback argument is one of [SQLITE_INSERT], [SQLITE_DELETE],
** or [SQLITE_UPDATE], depending on the operation that caused the callback
** to be invoked.
** ^The third and fourth arguments to the callback contain pointers to the
** database and table name containing the affected row.
** ^The final callback parameter is the [rowid] of the row.
** ^In the case of an update, this is the [rowid] after the update takes place.
**
** ^(The update hook is not invoked when internal system tables are
** modified (i.e. sqlite_master and sqlite_sequence).)^
** ^The update hook is not invoked when [WITHOUT ROWID] tables are modified.
**
** ^In the current implementation, the update hook
** is not invoked when conflicting rows are deleted because of an
** [ON CONFLICT | ON CONFLICT REPLACE] clause.  ^Nor is the update hook
** invoked when rows are deleted using the [truncate optimization].
** The exceptions defined in this paragraph might change in a future
** release of SQLite.
**
** The update hook implementation must not do anything that will modify
** the database connection that invoked the update hook.  Any actions
** to modify the database connection must be deferred until after the
** completion of the [sqlite3_step()] call that triggered the update hook.
** Note that [sqlite3_prepare_v2()] and [sqlite3_step()] both modify their
** database connections for the meaning of "modify" in this paragraph.
**
** ^The sqlite3_update_hook(D,C,P) function
** returns the P argument from the previous call
** on the same [database connection] D, or NULL for
** the first call on D.
**
** See also the [sqlite3_commit_hook()], [sqlite3_rollback_hook()],
** and [sqlite3_preupdate_hook()] interfaces.
*/
SQLITE_API void *sqlite3_update_hook(
  sqlite3*,
  void(*)(void *,int ,char const *,char const *,sqlite3_int64),
  void*
);
/*
** CAPI3REF: Enable Or Disable Shared Pager Cache
**
** ^(This routine enables or disables the sharing of the database cache
** and schema data structures between [database connection | connections]
** to the same database. Sharing is enabled if the argument is true
** and disabled if the argument is false.)^
**
** ^Cache sharing is enabled and disabled for an entire process.
** This is a change as of SQLite [version 3.5.0] ([dateof:3.5.0]).
** In prior versions of SQLite,
** sharing was enabled or disabled for each thread separately.
**
** ^(The cache sharing mode set by this interface effects all subsequent
** calls to [sqlite3_open()], [sqlite3_open_v2()], and [sqlite3_open16()].
** Existing database connections continue use the sharing mode
** that was in effect at the time they were opened.)^
**
** ^(This routine returns [SQLITE_OK] if shared cache was enabled or disabled
** successfully.  An [error code] is returned otherwise.)^
**
** ^Shared cache is disabled by default. But this might change in
** future releases of SQLite.  Applications that care about shared
** cache setting should set it explicitly.
**
** Note: This method is disabled on MacOS X 10.7 and iOS version 5.0
** and will always return SQLITE_MISUSE. On those systems,
** shared cache mode should be enabled per-database connection via
** [sqlite3_open_v2()] with [SQLITE_OPEN_SHAREDCACHE].
**
** This interface is threadsafe on processors where writing a
** 32-bit integer is atomic.
**
** See Also:  [SQLite Shared-Cache Mode]
*/
SQLITE_API int sqlite3_enable_shared_cache(int);
/*
** CAPI3REF: Attempt To Free Heap Memory
**
** ^The sqlite3_release_memory() interface attempts to free N bytes
** of heap memory by deallocating non-essential memory allocations
** held by the database library.   Memory used to cache database
** pages to improve performance is an example of non-essential memory.
** ^sqlite3_release_memory() returns the number of bytes actually freed,
** which might be more or less than the amount requested.
** ^The sqlite3_release_memory() routine is a no-op returning zero
** if SQLite is not compiled with [SQLITE_ENABLE_MEMORY_MANAGEMENT].
**
** See also: [sqlite3_db_release_memory()]
*/
SQLITE_API int sqlite3_release_memory(int);
/*
** CAPI3REF: Free Memory Used By A Database Connection
** METHOD: sqlite3
**
** ^The sqlite3_db_release_memory(D) interface attempts to free as much heap
** memory as possible from database connection D. Unlike the
** [sqlite3_release_memory()] interface, this interface is in effect even
** when the [SQLITE_ENABLE_MEMORY_MANAGEMENT] compile-time option is
** omitted.
**
** See also: [sqlite3_release_memory()]
*/
SQLITE_API int sqlite3_db_release_memory(sqlite3*);
/*
** CAPI3REF: Impose A Limit On Heap Size
**
** ^The sqlite3_soft_heap_limit64() interface sets and/or queries the
** soft limit on the amount of heap memory that may be allocated by SQLite.
** ^SQLite strives to keep heap memory utilization below the soft heap
** limit by reducing the number of pages held in the page cache
** as heap memory usages approaches the limit.
** ^The soft heap limit is "soft" because even though SQLite strives to stay
** below the limit, it will exceed the limit rather than generate
** an [SQLITE_NOMEM] error.  In other words, the soft heap limit
** is advisory only.
**
** ^The return value from sqlite3_soft_heap_limit64() is the size of
** the soft heap limit prior to the call, or negative in the case of an
** error.  ^If the argument N is negative
** then no change is made to the soft heap limit.  Hence, the current
** size of the soft heap limit can be determined by invoking
** sqlite3_soft_heap_limit64() with a negative argument.
**
** ^If the argument N is zero then the soft heap limit is disabled.
**
** ^(The soft heap limit is not enforced in the current implementation
** if one or more of following conditions are true:
**
** <ul>
** <li> The soft heap limit is set to zero.
** <li> Memory accounting is disabled using a combination of the
**      [sqlite3_config]([SQLITE_CONFIG_MEMSTATUS],...) start-time option and
**      the [SQLITE_DEFAULT_MEMSTATUS] compile-time option.
** <li> An alternative page cache implementation is specified using
**      [sqlite3_config]([SQLITE_CONFIG_PCACHE2],...).
** <li> The page cache allocates from its own memory pool supplied
**      by [sqlite3_config]([SQLITE_CONFIG_PAGECACHE],...) rather than
**      from the heap.
** </ul>)^
**
** Beginning with SQLite [version 3.7.3] ([dateof:3.7.3]),
** the soft heap limit is enforced
** regardless of whether or not the [SQLITE_ENABLE_MEMORY_MANAGEMENT]
** compile-time option is invoked.  With [SQLITE_ENABLE_MEMORY_MANAGEMENT],
** the soft heap limit is enforced on every memory allocation.  Without
** [SQLITE_ENABLE_MEMORY_MANAGEMENT], the soft heap limit is only enforced
** when memory is allocated by the page cache.  Testing suggests that because
** the page cache is the predominate memory user in SQLite, most
** applications will achieve adequate soft heap limit enforcement without
** the use of [SQLITE_ENABLE_MEMORY_MANAGEMENT].
**
** The circumstances under which SQLite will enforce the soft heap limit may
** changes in future releases of SQLite.
*/
SQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
/*
** CAPI3REF: Deprecated Soft Heap Limit Interface
** DEPRECATED
**
** This is a deprecated version of the [sqlite3_soft_heap_limit64()]
** interface.  This routine is provided for historical compatibility
** only.  All new applications should use the
** [sqlite3_soft_heap_limit64()] interface rather than this one.
*/
SQLITE_API SQLITE_DEPRECATED void sqlite3_soft_heap_limit(int N);
/*
** CAPI3REF: Extract Metadata About A Column Of A Table
** METHOD: sqlite3
**
** ^(The sqlite3_table_column_metadata(X,D,T,C,....) routine returns
** information about column C of table T in database D
** on [database connection] X.)^  ^The sqlite3_table_column_metadata()
** interface returns SQLITE_OK and fills in the non-NULL pointers in
** the final five arguments with appropriate values if the specified
** column exists.  ^The sqlite3_table_column_metadata() interface returns
** SQLITE_ERROR and if the specified column does not exist.
** ^If the column-name parameter to sqlite3_table_column_metadata() is a
** NULL pointer, then this routine simply checks for the existence of the
** table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it
** does not.  If the table name parameter T in a call to
** sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is
** undefined behavior.
**
** ^The column is identified by the second, third and fourth parameters to
** this function. ^(The second parameter is either the name of the database
** (i.e. "main", "temp", or an attached database) containing the specified
** table or NULL.)^ ^If it is NULL, then all attached databases are searched
** for the table using the same algorithm used by the database engine to
** resolve unqualified table references.
**
** ^The third and fourth parameters to this function are the table and column
** name of the desired column, respectively.
**
** ^Metadata is returned by writing to the memory locations passed as the 5th
** and subsequent parameters to this function. ^Any of these arguments may be
** NULL, in which case the corresponding element of metadata is omitted.
**
** ^(<blockquote>
** <table border="1">
** <tr><th> Parameter <th> Output<br>Type <th>  Description
**
** <tr><td> 5th <td> const char* <td> Data type
** <tr><td> 6th <td> const char* <td> Name of default collation sequence
** <tr><td> 7th <td> int         <td> True if column has a NOT NULL constraint
** <tr><td> 8th <td> int         <td> True if column is part of the PRIMARY KEY
** <tr><td> 9th <td> int         <td> True if column is [AUTOINCREMENT]
** </table>
** </blockquote>)^
**
** ^The memory pointed to by the character pointers returned for the
** declaration type and collation sequence is valid until the next
** call to any SQLite API function.
**
** ^If the specified table is actually a view, an [error code] is returned.
**
** ^If the specified column is "rowid", "oid" or "_rowid_" and the table
** is not a [WITHOUT ROWID] table and an
** [INTEGER PRIMARY KEY] column has been explicitly declared, then the output
** parameters are set for the explicitly declared column. ^(If there is no
** [INTEGER PRIMARY KEY] column, then the outputs
** for the [rowid] are set as follows:
**
** <pre>
**     data type: "INTEGER"
**     collation sequence: "BINARY"
**     not null: 0
**     primary key: 1
**     auto increment: 0
** </pre>)^
**
** ^This function causes all database schemas to be read from disk and
** parsed, if that has not already been done, and returns an error if
** any errors are encountered while loading the schema.
*/
SQLITE_API int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
);
/*
** CAPI3REF: Load An Extension
** METHOD: sqlite3
**
** ^This interface loads an SQLite extension library from the named file.
**
** ^The sqlite3_load_extension() interface attempts to load an
** [SQLite extension] library contained in the file zFile.  If
** the file cannot be loaded directly, attempts are made to load
** with various operating-system specific extensions added.
** So for example, if "samplelib" cannot be loaded, then names like
** "samplelib.so" or "samplelib.dylib" or "samplelib.dll" might
** be tried also.
**
** ^The entry point is zProc.
** ^(zProc may be 0, in which case SQLite will try to come up with an
** entry point name on its own.  It first tries "sqlite3_extension_init".
** If that does not work, it constructs a name "sqlite3_X_init" where the
** X is consists of the lower-case equivalent of all ASCII alphabetic
** characters in the filename from the last "/" to the first following
** "." and omitting any initial "lib".)^
** ^The sqlite3_load_extension() interface returns
** [SQLITE_OK] on success and [SQLITE_ERROR] if something goes wrong.
** ^If an error occurs and pzErrMsg is not 0, then the
** [sqlite3_load_extension()] interface shall attempt to
** fill *pzErrMsg with error message text stored in memory
** obtained from [sqlite3_malloc()]. The calling function
** should free this memory by calling [sqlite3_free()].
**
** ^Extension loading must be enabled using
** [sqlite3_enable_load_extension()] or
** [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],1,NULL)
** prior to calling this API,
** otherwise an error will be returned.
**
** <b>Security warning:</b> It is recommended that the
** [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method be used to enable only this
** interface.  The use of the [sqlite3_enable_load_extension()] interface
** should be avoided.  This will keep the SQL function [load_extension()]
** disabled and prevent SQL injections from giving attackers
** access to extension loading capabilities.
**
** See also the [load_extension() SQL function].
*/
SQLITE_API int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
);
/*
** CAPI3REF: Enable Or Disable Extension Loading
** METHOD: sqlite3
**
** ^So as not to open security holes in older applications that are
** unprepared to deal with [extension loading], and as a means of disabling
** [extension loading] while evaluating user-entered SQL, the following API
** is provided to turn the [sqlite3_load_extension()] mechanism on and off.
**
** ^Extension loading is off by default.
** ^Call the sqlite3_enable_load_extension() routine with onoff==1
** to turn extension loading on and call it with onoff==0 to turn
** it back off again.
**
** ^This interface enables or disables both the C-API
** [sqlite3_load_extension()] and the SQL function [load_extension()].
** ^(Use [sqlite3_db_config](db,[SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION],..)
** to enable or disable only the C-API.)^
**
** <b>Security warning:</b> It is recommended that extension loading
** be disabled using the [SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION] method
** rather than this interface, so the [load_extension()] SQL function
** remains disabled. This will prevent SQL injections from giving attackers
** access to extension loading capabilities.
*/
SQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
/*
** CAPI3REF: Automatically Load Statically Linked Extensions
**
** ^This interface causes the xEntryPoint() function to be invoked for
** each new [database connection] that is created.  The idea here is that
** xEntryPoint() is the entry point for a statically linked [SQLite extension]
** that is to be automatically loaded into all new database connections.
**
** ^(Even though the function prototype shows that xEntryPoint() takes
** no arguments and returns void, SQLite invokes xEntryPoint() with three
** arguments and expects an integer result as if the signature of the
** entry point where as follows:
**
** <blockquote><pre>
** &nbsp;  int xEntryPoint(
** &nbsp;    sqlite3 *db,
** &nbsp;    const char **pzErrMsg,
** &nbsp;    const struct sqlite3_api_routines *pThunk
** &nbsp;  );
** </pre></blockquote>)^
**
** If the xEntryPoint routine encounters an error, it should make *pzErrMsg
** point to an appropriate error message (obtained from [sqlite3_mprintf()])
** and return an appropriate [error code].  ^SQLite ensures that *pzErrMsg
** is NULL before calling the xEntryPoint().  ^SQLite will invoke
** [sqlite3_free()] on *pzErrMsg after xEntryPoint() returns.  ^If any
** xEntryPoint() returns an error, the [sqlite3_open()], [sqlite3_open16()],
** or [sqlite3_open_v2()] call that provoked the xEntryPoint() will fail.
**
** ^Calling sqlite3_auto_extension(X) with an entry point X that is already
** on the list of automatic extensions is a harmless no-op. ^No entry point
** will be called more than once for each database connection that is opened.
**
** See also: [sqlite3_reset_auto_extension()]
** and [sqlite3_cancel_auto_extension()]
*/
SQLITE_API int sqlite3_auto_extension(void(*xEntryPoint)(void));
/*
** CAPI3REF: Cancel Automatic Extension Loading
**
** ^The [sqlite3_cancel_auto_extension(X)] interface unregisters the
** initialization routine X that was registered using a prior call to
** [sqlite3_auto_extension(X)].  ^The [sqlite3_cancel_auto_extension(X)]
** routine returns 1 if initialization routine X was successfully
** unregistered and it returns 0 if X was not on the list of initialization
** routines.
*/
SQLITE_API int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));
/*
** CAPI3REF: Reset Automatic Extension Loading
**
** ^This interface disables all automatic extensions previously
** registered using [sqlite3_auto_extension()].
*/
SQLITE_API void sqlite3_reset_auto_extension(void);
/*
** The interface to the virtual-table mechanism is currently considered
** to be experimental.  The interface might change in incompatible ways.
** If this is a problem for you, do not use the interface at this time.
**
** When the virtual-table mechanism stabilizes, we will declare the
** interface fixed, support it indefinitely, and remove this comment.
*/
/*
** Structures used by the virtual table interface
*/
typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;
/*
** CAPI3REF: Virtual Table Object
** KEYWORDS: sqlite3_module {virtual table module}
**
** This structure, sometimes called a "virtual table module",
** defines the implementation of a [virtual tables].
** This structure consists mostly of methods for the module.
**
** ^A virtual table module is created by filling in a persistent
** instance of this structure and passing a pointer to that instance
** to [sqlite3_create_module()] or [sqlite3_create_module_v2()].
** ^The registration remains valid until it is replaced by a different
** module or until the [database connection] closes.  The content
** of this structure must not change while it is registered with
** any database connection.
*/
struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                       void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);
  /* The methods above are in version 1 of the sqlite_module object. Those
  ** below are for version 2 and greater. */
  int (*xSavepoint)(sqlite3_vtab *pVTab, int);
  int (*xRelease)(sqlite3_vtab *pVTab, int);
  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);
};
/*
** CAPI3REF: Virtual Table Indexing Information
** KEYWORDS: sqlite3_index_info
**
** The sqlite3_index_info structure and its substructures is used as part
** of the [virtual table] interface to
** pass information into and receive the reply from the [xBestIndex]
** method of a [virtual table module].  The fields under **Inputs** are the
** inputs to xBestIndex and are read-only.  xBestIndex inserts its
** results into the **Outputs** fields.
**
** ^(The aConstraint[] array records WHERE clause constraints of the form:
**
** <blockquote>column OP expr</blockquote>
**
** where OP is =, &lt;, &lt;=, &gt;, or &gt;=.)^  ^(The particular operator is
** stored in aConstraint[].op using one of the
** [SQLITE_INDEX_CONSTRAINT_EQ | SQLITE_INDEX_CONSTRAINT_ values].)^
** ^(The index of the column is stored in
** aConstraint[].iColumn.)^  ^(aConstraint[].usable is TRUE if the
** expr on the right-hand side can be evaluated (and thus the constraint
** is usable) and false if it cannot.)^
**
** ^The optimizer automatically inverts terms of the form "expr OP column"
** and makes other simplifications to the WHERE clause in an attempt to
** get as many WHERE clause terms into the form shown above as possible.
** ^The aConstraint[] array only reports WHERE clause terms that are
** relevant to the particular virtual table being queried.
**
** ^Information about the ORDER BY clause is stored in aOrderBy[].
** ^Each term of aOrderBy records a column of the ORDER BY clause.
**
** The colUsed field indicates which columns of the virtual table may be
** required by the current scan. Virtual table columns are numbered from
** zero in the order in which they appear within the CREATE TABLE statement
** passed to sqlite3_declare_vtab(). For the first 63 columns (columns 0-62),
** the corresponding bit is set within the colUsed mask if the column may be
** required by SQLite. If the table has at least 64 columns and any column
** to the right of the first 63 is required, then bit 63 of colUsed is also
** set. In other words, column iCol may be required if the expression
** (colUsed & ((sqlite3_uint64)1 << (iCol>=63 ? 63 : iCol))) evaluates to
** non-zero.
**
** The [xBestIndex] method must fill aConstraintUsage[] with information
** about what parameters to pass to xFilter.  ^If argvIndex>0 then
** the right-hand side of the corresponding aConstraint[] is evaluated
** and becomes the argvIndex-th entry in argv.  ^(If aConstraintUsage[].omit
** is true, then the constraint is assumed to be fully handled by the
** virtual table and is not checked again by SQLite.)^
**
** ^The idxNum and idxPtr values are recorded and passed into the
** [xFilter] method.
** ^[sqlite3_free()] is used to free idxPtr if and only if
** needToFreeIdxPtr is true.
**
** ^The orderByConsumed means that output from [xFilter]/[xNext] will occur in
** the correct order to satisfy the ORDER BY clause so that no separate
** sorting step is required.
**
** ^The estimatedCost value is an estimate of the cost of a particular
** strategy. A cost of N indicates that the cost of the strategy is similar
** to a linear scan of an SQLite table with N rows. A cost of log(N)
** indicates that the expense of the operation is similar to that of a
** binary search on a unique indexed field of an SQLite table with N rows.
**
** ^The estimatedRows value is an estimate of the number of rows that
** will be returned by the strategy.
**
** The xBestIndex method may optionally populate the idxFlags field with a
** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -
** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite
** assumes that the strategy may visit at most one row.
**
** Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then
** SQLite also assumes that if a call to the xUpdate() method is made as
** part of the same statement to delete or update a virtual table row and the
** implementation returns SQLITE_CONSTRAINT, then there is no need to rollback
** any database changes. In other words, if the xUpdate() returns
** SQLITE_CONSTRAINT, the database contents must be exactly as they were
** before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not
** set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by
** the xUpdate method are automatically rolled back by SQLite.
**
** IMPORTANT: The estimatedRows field was added to the sqlite3_index_info
** structure for SQLite [version 3.8.2] ([dateof:3.8.2]).
** If a virtual table extension is
** used with an SQLite version earlier than 3.8.2, the results of attempting
** to read or write the estimatedRows field are undefined (but are likely
** to included crashing the application). The estimatedRows field should
** therefore only be used if [sqlite3_libversion_number()] returns a
** value greater than or equal to 3008002. Similarly, the idxFlags field
** was added for [version 3.9.0] ([dateof:3.9.0]).
** It may therefore only be used if
** sqlite3_libversion_number() returns a value greater than or equal to
** 3009000.
*/
struct sqlite3_index_info {
  /* Inputs */
  int nConstraint;
  struct sqlite3_index_constraint {
     int iColumn;
     unsigned char op;
     unsigned char usable;
     int iTermOffset;
  } *aConstraint;
  int nOrderBy;
  struct sqlite3_index_orderby {
     int iColumn;
     unsigned char desc;
  } *aOrderBy;
  /* Outputs */
  struct sqlite3_index_constraint_usage {
    int argvIndex;
    unsigned char omit;
  } *aConstraintUsage;
  int idxNum;
  char *idxStr;
  int needToFreeIdxStr;
  int orderByConsumed;
  double estimatedCost;
  /* Fields below are only available in SQLite 3.8.2 and later */
  sqlite3_int64 estimatedRows;
  /* Fields below are only available in SQLite 3.9.0 and later */
  int idxFlags;
  /* Fields below are only available in SQLite 3.10.0 and later */
  sqlite3_uint64 colUsed;
};
/*
** CAPI3REF: Virtual Table Scan Flags
*/
#define SQLITE_INDEX_SCAN_UNIQUE      1
/*
** CAPI3REF: Virtual Table Constraint Operator Codes
**
** These macros defined the allowed values for the
** [sqlite3_index_info].aConstraint[].op field.  Each value represents
** an operator that is part of a constraint term in the wHERE clause of
** a query that uses a [virtual table].
*/
#define SQLITE_INDEX_CONSTRAINT_EQ         2
#define SQLITE_INDEX_CONSTRAINT_GT         4
#define SQLITE_INDEX_CONSTRAINT_LE         8
#define SQLITE_INDEX_CONSTRAINT_LT        16
#define SQLITE_INDEX_CONSTRAINT_GE        32
#define SQLITE_INDEX_CONSTRAINT_MATCH     64
#define SQLITE_INDEX_CONSTRAINT_LIKE      65
#define SQLITE_INDEX_CONSTRAINT_GLOB      66
#define SQLITE_INDEX_CONSTRAINT_REGEXP    67
#define SQLITE_INDEX_CONSTRAINT_NE        68
#define SQLITE_INDEX_CONSTRAINT_ISNOT     69
#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70
#define SQLITE_INDEX_CONSTRAINT_ISNULL    71
#define SQLITE_INDEX_CONSTRAINT_IS        72
/*
** CAPI3REF: Register A Virtual Table Implementation
** METHOD: sqlite3
**
** ^These routines are used to register a new [virtual table module] name.
** ^Module names must be registered before
** creating a new [virtual table] using the module and before using a
** preexisting [virtual table] for the module.
**
** ^The module name is registered on the [database connection] specified
** by the first parameter.  ^The name of the module is given by the
** second parameter.  ^The third parameter is a pointer to
** the implementation of the [virtual table module].   ^The fourth
** parameter is an arbitrary client data pointer that is passed through
** into the [xCreate] and [xConnect] methods of the virtual table module
** when a new virtual table is be being created or reinitialized.
**
** ^The sqlite3_create_module_v2() interface has a fifth parameter which
** is a pointer to a destructor for the pClientData.  ^SQLite will
** invoke the destructor function (if it is not NULL) when SQLite
** no longer needs the pClientData pointer.  ^The destructor will also
** be invoked if the call to sqlite3_create_module_v2() fails.
** ^The sqlite3_create_module()
** interface is equivalent to sqlite3_create_module_v2() with a NULL
** destructor.
*/
SQLITE_API int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData
);
SQLITE_API int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData,
  void(*xDestroy)(void*)
);
/*
** CAPI3REF: Virtual Table Instance Object
** KEYWORDS: sqlite3_vtab
**
** Every [virtual table module] implementation uses a subclass
** of this object to describe a particular instance
** of the [virtual table].  Each subclass will
** be tailored to the specific needs of the module implementation.
** The purpose of this superclass is to define certain fields that are
** common to all module implementations.
**
** ^Virtual tables methods can set an error message by assigning a
** string obtained from [sqlite3_mprintf()] to zErrMsg.  The method should
** take care that any prior string is freed by a call to [sqlite3_free()]
** prior to assigning a new string to zErrMsg.  ^After the error message
** is delivered up to the client application, the string will be automatically
** freed by sqlite3_free() and the zErrMsg field will be zeroed.
*/
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;
  /* Virtual table implementations will typically add additional fields */
};
/*
** CAPI3REF: Virtual Table Cursor Object
** KEYWORDS: sqlite3_vtab_cursor {virtual table cursor}
**
** Every [virtual table module] implementation uses a subclass of the
** following structure to describe cursors that point into the
** [virtual table] and are used
** to loop through the virtual table.  Cursors are created using the
** [sqlite3_module.xOpen | xOpen] method of the module and are destroyed
** by the [sqlite3_module.xClose | xClose] method.  Cursors are used
** by the [xFilter], [xNext], [xEof], [xColumn], and [xRowid] methods
** of the module.  Each module implementation will define
** the content of a cursor structure to suit its own needs.
**
** This superclass exists in order to define fields of the cursor that
** are common to all implementations.
*/
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;
  /* Virtual table implementations will typically add additional fields */
};
/*
** CAPI3REF: Declare The Schema Of A Virtual Table
**
** ^The [xCreate] and [xConnect] methods of a
** [virtual table module] call this interface
** to declare the format (the names and datatypes of the columns) of
** the virtual tables they implement.
*/
SQLITE_API int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
/*
** CAPI3REF: Overload A Function For A Virtual Table
** METHOD: sqlite3
**
** ^(Virtual tables can provide alternative implementations of functions
** using the [xFindFunction] method of the [virtual table module].
** But global versions of those functions
** must exist in order to be overloaded.)^
**
** ^(This API makes sure a global version of a function with a particular
** name and number of parameters exists.  If no such function exists
** before this API is called, a new function is created.)^  ^The implementation
** of the new function always causes an exception to be thrown.  So
** the new function is not good for anything by itself.  Its only
** purpose is to be a placeholder function that can be overloaded
** by a [virtual table].
*/
SQLITE_API int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
/*
** The interface to the virtual-table mechanism defined above (back up
** to a comment remarkably similar to this one) is currently considered
** to be experimental.  The interface might change in incompatible ways.
** If this is a problem for you, do not use the interface at this time.
**
** When the virtual-table mechanism stabilizes, we will declare the
** interface fixed, support it indefinitely, and remove this comment.
*/
/*
** CAPI3REF: A Handle To An Open BLOB
** KEYWORDS: {BLOB handle} {BLOB handles}
**
** An instance of this object represents an open BLOB on which
** [sqlite3_blob_open | incremental BLOB I/O] can be performed.
** ^Objects of this type are created by [sqlite3_blob_open()]
** and destroyed by [sqlite3_blob_close()].
** ^The [sqlite3_blob_read()] and [sqlite3_blob_write()] interfaces
** can be used to read or write small subsections of the BLOB.
** ^The [sqlite3_blob_bytes()] interface returns the size of the BLOB in bytes.
*/
typedef struct sqlite3_blob sqlite3_blob;
/*
** CAPI3REF: Open A BLOB For Incremental I/O
** METHOD: sqlite3
** CONSTRUCTOR: sqlite3_blob
**
** ^(This interfaces opens a [BLOB handle | handle] to the BLOB located
** in row iRow, column zColumn, table zTable in database zDb;
** in other words, the same BLOB that would be selected by:
**
** <pre>
**     SELECT zColumn FROM zDb.zTable WHERE [rowid] = iRow;
** </pre>)^
**
** ^(Parameter zDb is not the filename that contains the database, but
** rather the symbolic name of the database. For attached databases, this is
** the name that appears after the AS keyword in the [ATTACH] statement.
** For the main database file, the database name is "main". For TEMP
** tables, the database name is "temp".)^
**
** ^If the flags parameter is non-zero, then the BLOB is opened for read
** and write access. ^If the flags parameter is zero, the BLOB is opened for
** read-only access.
**
** ^(On success, [SQLITE_OK] is returned and the new [BLOB handle] is stored
** in *ppBlob. Otherwise an [error code] is returned and, unless the error
** code is SQLITE_MISUSE, *ppBlob is set to NULL.)^ ^This means that, provided
** the API is not misused, it is always safe to call [sqlite3_blob_close()]
** on *ppBlob after this function it returns.
**
** This function fails with SQLITE_ERROR if any of the following are true:
** <ul>
**   <li> ^(Database zDb does not exist)^,
**   <li> ^(Table zTable does not exist within database zDb)^,
**   <li> ^(Table zTable is a WITHOUT ROWID table)^,
**   <li> ^(Column zColumn does not exist)^,
**   <li> ^(Row iRow is not present in the table)^,
**   <li> ^(The specified column of row iRow contains a value that is not
**         a TEXT or BLOB value)^,
**   <li> ^(Column zColumn is part of an index, PRIMARY KEY or UNIQUE
**         constraint and the blob is being opened for read/write access)^,
**   <li> ^([foreign key constraints | Foreign key constraints] are enabled,
**         column zColumn is part of a [child key] definition and the blob is
**         being opened for read/write access)^.
** </ul>
**
** ^Unless it returns SQLITE_MISUSE, this function sets the
** [database connection] error code and message accessible via
** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions.
**
** A BLOB referenced by sqlite3_blob_open() may be read using the
** [sqlite3_blob_read()] interface and modified by using
** [sqlite3_blob_write()].  The [BLOB handle] can be moved to a
** different row of the same table using the [sqlite3_blob_reopen()]
** interface.  However, the column, table, or database of a [BLOB handle]
** cannot be changed after the [BLOB handle] is opened.
**
** ^(If the row that a BLOB handle points to is modified by an
** [UPDATE], [DELETE], or by [ON CONFLICT] side-effects
** then the BLOB handle is marked as "expired".
** This is true if any column of the row is changed, even a column
** other than the one the BLOB handle is open on.)^
** ^Calls to [sqlite3_blob_read()] and [sqlite3_blob_write()] for
** an expired BLOB handle fail with a return code of [SQLITE_ABORT].
** ^(Changes written into a BLOB prior to the BLOB expiring are not
** rolled back by the expiration of the BLOB.  Such changes will eventually
** commit if the transaction continues to completion.)^
**
** ^Use the [sqlite3_blob_bytes()] interface to determine the size of
** the opened blob.  ^The size of a blob may not be changed by this
** interface.  Use the [UPDATE] SQL command to change the size of a
** blob.
**
** ^The [sqlite3_bind_zeroblob()] and [sqlite3_result_zeroblob()] interfaces
** and the built-in [zeroblob] SQL function may be used to create a
** zero-filled blob to read or write using the incremental-blob interface.
**
** To avoid a resource leak, every open [BLOB handle] should eventually
** be released by a call to [sqlite3_blob_close()].
**
** See also: [sqlite3_blob_close()],
** [sqlite3_blob_reopen()], [sqlite3_blob_read()],
** [sqlite3_blob_bytes()], [sqlite3_blob_write()].
*/
SQLITE_API int sqlite3_blob_open(
  sqlite3*,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite3_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
);
/*
** CAPI3REF: Move a BLOB Handle to a New Row
** METHOD: sqlite3_blob
**
** ^This function is used to move an existing [BLOB handle] so that it points
** to a different row of the same database table. ^The new row is identified
** by the rowid value passed as the second argument. Only the row can be
** changed. ^The database, table and column on which the blob handle is open
** remain the same. Moving an existing [BLOB handle] to a new row is
** faster than closing the existing handle and opening a new one.
**
** ^(The new row must meet the same criteria as for [sqlite3_blob_open()] -
** it must exist and there must be either a blob or text value stored in
** the nominated column.)^ ^If the new row is not present in the table, or if
** it does not contain a blob or text value, or if another error occurs, an
** SQLite error code is returned and the blob handle is considered aborted.
** ^All subsequent calls to [sqlite3_blob_read()], [sqlite3_blob_write()] or
** [sqlite3_blob_reopen()] on an aborted blob handle immediately return
** SQLITE_ABORT. ^Calling [sqlite3_blob_bytes()] on an aborted blob handle
** always returns zero.
**
** ^This function sets the database handle error code and message.
*/
SQLITE_API int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
/*
** CAPI3REF: Close A BLOB Handle
** DESTRUCTOR: sqlite3_blob
**
** ^This function closes an open [BLOB handle]. ^(The BLOB handle is closed
** unconditionally.  Even if this routine returns an error code, the
** handle is still closed.)^
**
** ^If the blob handle being closed was opened for read-write access, and if
** the database is in auto-commit mode and there are no other open read-write
** blob handles or active write statements, the current transaction is
** committed. ^If an error occurs while committing the transaction, an error
** code is returned and the transaction rolled back.
**
** Calling this function with an argument that is not a NULL pointer or an
** open blob handle results in undefined behaviour. ^Calling this routine
** with a null pointer (such as would be returned by a failed call to
** [sqlite3_blob_open()]) is a harmless no-op. ^Otherwise, if this function
** is passed a valid open blob handle, the values returned by the
** sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.
*/
SQLITE_API int sqlite3_blob_close(sqlite3_blob *);
/*
** CAPI3REF: Return The Size Of An Open BLOB
** METHOD: sqlite3_blob
**
** ^Returns the size in bytes of the BLOB accessible via the
** successfully opened [BLOB handle] in its only argument.  ^The
** incremental blob I/O routines can only read or overwriting existing
** blob content; they cannot change the size of a blob.
**
** This routine only works on a [BLOB handle] which has been created
** by a prior successful call to [sqlite3_blob_open()] and which has not
** been closed by [sqlite3_blob_close()].  Passing any other pointer in
** to this routine results in undefined and probably undesirable behavior.
*/
SQLITE_API int sqlite3_blob_bytes(sqlite3_blob *);
/*
** CAPI3REF: Read Data From A BLOB Incrementally
** METHOD: sqlite3_blob
**
** ^(This function is used to read data from an open [BLOB handle] into a
** caller-supplied buffer. N bytes of data are copied into buffer Z
** from the open BLOB, starting at offset iOffset.)^
**
** ^If offset iOffset is less than N bytes from the end of the BLOB,
** [SQLITE_ERROR] is returned and no data is read.  ^If N or iOffset is
** less than zero, [SQLITE_ERROR] is returned and no data is read.
** ^The size of the blob (and hence the maximum value of N+iOffset)
** can be determined using the [sqlite3_blob_bytes()] interface.
**
** ^An attempt to read from an expired [BLOB handle] fails with an
** error code of [SQLITE_ABORT].
**
** ^(On success, sqlite3_blob_read() returns SQLITE_OK.
** Otherwise, an [error code] or an [extended error code] is returned.)^
**
** This routine only works on a [BLOB handle] which has been created
** by a prior successful call to [sqlite3_blob_open()] and which has not
** been closed by [sqlite3_blob_close()].  Passing any other pointer in
** to this routine results in undefined and probably undesirable behavior.
**
** See also: [sqlite3_blob_write()].
*/
SQLITE_API int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
/*
** CAPI3REF: Write Data Into A BLOB Incrementally
** METHOD: sqlite3_blob
**
** ^(This function is used to write data into an open [BLOB handle] from a
** caller-supplied buffer. N bytes of data are copied from the buffer Z
** into the open BLOB, starting at offset iOffset.)^
**
** ^(On success, sqlite3_blob_write() returns SQLITE_OK.
** Otherwise, an  [error code] or an [extended error code] is returned.)^
** ^Unless SQLITE_MISUSE is returned, this function sets the
** [database connection] error code and message accessible via
** [sqlite3_errcode()] and [sqlite3_errmsg()] and related functions.
**
** ^If the [BLOB handle] passed as the first argument was not opened for
** writing (the flags parameter to [sqlite3_blob_open()] was zero),
** this function returns [SQLITE_READONLY].
**
** This function may only modify the contents of the BLOB; it is
** not possible to increase the size of a BLOB using this API.
** ^If offset iOffset is less than N bytes from the end of the BLOB,
** [SQLITE_ERROR] is returned and no data is written. The size of the
** BLOB (and hence the maximum value of N+iOffset) can be determined
** using the [sqlite3_blob_bytes()] interface. ^If N or iOffset are less
** than zero [SQLITE_ERROR] is returned and no data is written.
**
** ^An attempt to write to an expired [BLOB handle] fails with an
** error code of [SQLITE_ABORT].  ^Writes to the BLOB that occurred
** before the [BLOB handle] expired are not rolled back by the
** expiration of the handle, though of course those changes might
** have been overwritten by the statement that expired the BLOB handle
** or by other independent statements.
**
** This routine only works on a [BLOB handle] which has been created
** by a prior successful call to [sqlite3_blob_open()] and which has not
** been closed by [sqlite3_blob_close()].  Passing any other pointer in
** to this routine results in undefined and probably undesirable behavior.
**
** See also: [sqlite3_blob_read()].
*/
SQLITE_API int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
/*
** CAPI3REF: Virtual File System Objects
**
** A virtual filesystem (VFS) is an [sqlite3_vfs] object
** that SQLite uses to interact
** with the underlying operating system.  Most SQLite builds come with a
** single default VFS that is appropriate for the host computer.
** New VFSes can be registered and existing VFSes can be unregistered.
** The following interfaces are provided.
**
** ^The sqlite3_vfs_find() interface returns a pointer to a VFS given its name.
** ^Names are case sensitive.
** ^Names are zero-terminated UTF-8 strings.
** ^If there is no match, a NULL pointer is returned.
** ^If zVfsName is NULL then the default VFS is returned.
**
** ^New VFSes are registered with sqlite3_vfs_register().
** ^Each new VFS becomes the default VFS if the makeDflt flag is set.
** ^The same VFS can be registered multiple times without injury.
** ^To make an existing VFS into the default VFS, register it again
** with the makeDflt flag set.  If two different VFSes with the
** same name are registered, the behavior is undefined.  If a
** VFS is registered with a name that is NULL or an empty string,
** then the behavior is undefined.
**
** ^Unregister a VFS with the sqlite3_vfs_unregister() interface.
** ^(If the default VFS is unregistered, another VFS is chosen as
** the default.  The choice for the new VFS is arbitrary.)^
*/
SQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
SQLITE_API int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
SQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs*);
/*
** CAPI3REF: Mutexes
**
** The SQLite core uses these routines for thread
** synchronization. Though they are intended for internal
** use by SQLite, code that links against SQLite is
** permitted to use any of these routines.
**
** The SQLite source code contains multiple implementations
** of these mutex routines.  An appropriate implementation
** is selected automatically at compile-time.  The following
** implementations are available in the SQLite core:
**
** <ul>
** <li>   SQLITE_MUTEX_PTHREADS
** <li>   SQLITE_MUTEX_W32
** <li>   SQLITE_MUTEX_NOOP
** </ul>
**
** The SQLITE_MUTEX_NOOP implementation is a set of routines
** that does no real locking and is appropriate for use in
** a single-threaded application.  The SQLITE_MUTEX_PTHREADS and
** SQLITE_MUTEX_W32 implementations are appropriate for use on Unix
** and Windows.
**
** If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor
** macro defined (with "-DSQLITE_MUTEX_APPDEF=1"), then no mutex
** implementation is included with the library. In this case the
** application must supply a custom mutex implementation using the
** [SQLITE_CONFIG_MUTEX] option of the sqlite3_config() function
** before calling sqlite3_initialize() or any other public sqlite3_
** function that calls sqlite3_initialize().
**
** ^The sqlite3_mutex_alloc() routine allocates a new
** mutex and returns a pointer to it. ^The sqlite3_mutex_alloc()
** routine returns NULL if it is unable to allocate the requested
** mutex.  The argument to sqlite3_mutex_alloc() must one of these
** integer constants:
**
** <ul>
** <li>  SQLITE_MUTEX_FAST
** <li>  SQLITE_MUTEX_RECURSIVE
** <li>  SQLITE_MUTEX_STATIC_MASTER
** <li>  SQLITE_MUTEX_STATIC_MEM
** <li>  SQLITE_MUTEX_STATIC_OPEN
** <li>  SQLITE_MUTEX_STATIC_PRNG
** <li>  SQLITE_MUTEX_STATIC_LRU
** <li>  SQLITE_MUTEX_STATIC_PMEM
** <li>  SQLITE_MUTEX_STATIC_APP1
** <li>  SQLITE_MUTEX_STATIC_APP2
** <li>  SQLITE_MUTEX_STATIC_APP3
** <li>  SQLITE_MUTEX_STATIC_VFS1
** <li>  SQLITE_MUTEX_STATIC_VFS2
** <li>  SQLITE_MUTEX_STATIC_VFS3
** </ul>
**
** ^The first two constants (SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE)
** cause sqlite3_mutex_alloc() to create
** a new mutex.  ^The new mutex is recursive when SQLITE_MUTEX_RECURSIVE
** is used but not necessarily so when SQLITE_MUTEX_FAST is used.
** The mutex implementation does not need to make a distinction
** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does
** not want to.  SQLite will only request a recursive mutex in
** cases where it really needs one.  If a faster non-recursive mutex
** implementation is available on the host platform, the mutex subsystem
** might return such a mutex in response to SQLITE_MUTEX_FAST.
**
** ^The other allowed parameters to sqlite3_mutex_alloc() (anything other
** than SQLITE_MUTEX_FAST and SQLITE_MUTEX_RECURSIVE) each return
** a pointer to a static preexisting mutex.  ^Nine static mutexes are
** used by the current version of SQLite.  Future versions of SQLite
** may add additional static mutexes.  Static mutexes are for internal
** use by SQLite only.  Applications that use SQLite mutexes should
** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or
** SQLITE_MUTEX_RECURSIVE.
**
** ^Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST
** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()
** returns a different mutex on every call.  ^For the static
** mutex types, the same mutex is returned on every call that has
** the same type number.
**
** ^The sqlite3_mutex_free() routine deallocates a previously
** allocated dynamic mutex.  Attempting to deallocate a static
** mutex results in undefined behavior.
**
** ^The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt
** to enter a mutex.  ^If another thread is already within the mutex,
** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return
** SQLITE_BUSY.  ^The sqlite3_mutex_try() interface returns [SQLITE_OK]
** upon successful entry.  ^(Mutexes created using
** SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread.
** In such cases, the
** mutex must be exited an equal number of times before another thread
** can enter.)^  If the same thread tries to enter any mutex other
** than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.
**
** ^(Some systems (for example, Windows 95) do not support the operation
** implemented by sqlite3_mutex_try().  On those systems, sqlite3_mutex_try()
** will always return SQLITE_BUSY. The SQLite core only ever uses
** sqlite3_mutex_try() as an optimization so this is acceptable
** behavior.)^
**
** ^The sqlite3_mutex_leave() routine exits a mutex that was
** previously entered by the same thread.   The behavior
** is undefined if the mutex is not currently entered by the
** calling thread or is not currently allocated.
**
** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or
** sqlite3_mutex_leave() is a NULL pointer, then all three routines
** behave as no-ops.
**
** See also: [sqlite3_mutex_held()] and [sqlite3_mutex_notheld()].
*/
SQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int);
SQLITE_API void sqlite3_mutex_free(sqlite3_mutex*);
SQLITE_API void sqlite3_mutex_enter(sqlite3_mutex*);
SQLITE_API int sqlite3_mutex_try(sqlite3_mutex*);
SQLITE_API void sqlite3_mutex_leave(sqlite3_mutex*);
/*
** CAPI3REF: Mutex Methods Object
**
** An instance of this structure defines the low-level routines
** used to allocate and use mutexes.
**
** Usually, the default mutex implementations provided by SQLite are
** sufficient, however the application has the option of substituting a custom
** implementation for specialized deployments or systems for which SQLite
** does not provide a suitable implementation. In this case, the application
** creates and populates an instance of this structure to pass
** to sqlite3_config() along with the [SQLITE_CONFIG_MUTEX] option.
** Additionally, an instance of this structure can be used as an
** output variable when querying the system for the current mutex
** implementation, using the [SQLITE_CONFIG_GETMUTEX] option.
**
** ^The xMutexInit method defined by this structure is invoked as
** part of system initialization by the sqlite3_initialize() function.
** ^The xMutexInit routine is called by SQLite exactly once for each
** effective call to [sqlite3_initialize()].
**
** ^The xMutexEnd method defined by this structure is invoked as
** part of system shutdown by the sqlite3_shutdown() function. The
** implementation of this method is expected to release all outstanding
** resources obtained by the mutex methods implementation, especially
** those obtained by the xMutexInit method.  ^The xMutexEnd()
** interface is invoked exactly once for each call to [sqlite3_shutdown()].
**
** ^(The remaining seven methods defined by this structure (xMutexAlloc,
** xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and
** xMutexNotheld) implement the following interfaces (respectively):
**
** <ul>
**   <li>  [sqlite3_mutex_alloc()] </li>
**   <li>  [sqlite3_mutex_free()] </li>
**   <li>  [sqlite3_mutex_enter()] </li>
**   <li>  [sqlite3_mutex_try()] </li>
**   <li>  [sqlite3_mutex_leave()] </li>
**   <li>  [sqlite3_mutex_held()] </li>
**   <li>  [sqlite3_mutex_notheld()] </li>
** </ul>)^
**
** The only difference is that the public sqlite3_XXX functions enumerated
** above silently ignore any invocations that pass a NULL pointer instead
** of a valid mutex handle. The implementations of the methods defined
** by this structure are not required to handle this case, the results
** of passing a NULL pointer instead of a valid mutex handle are undefined
** (i.e. it is acceptable to provide an implementation that segfaults if
** it is passed a NULL pointer).
**
** The xMutexInit() method must be threadsafe.  It must be harmless to
** invoke xMutexInit() multiple times within the same process and without
** intervening calls to xMutexEnd().  Second and subsequent calls to
** xMutexInit() must be no-ops.
**
** xMutexInit() must not use SQLite memory allocation ([sqlite3_malloc()]
** and its associates).  Similarly, xMutexAlloc() must not use SQLite memory
** allocation for a static mutex.  ^However xMutexAlloc() may use SQLite
** memory allocation for a fast or recursive mutex.
**
** ^SQLite will invoke the xMutexEnd() method when [sqlite3_shutdown()] is
** called, but only if the prior call to xMutexInit returned SQLITE_OK.
** If xMutexInit fails in any way, it is expected to clean up after itself
** prior to returning.
*/
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
  int (*xMutexInit)(void);
  int (*xMutexEnd)(void);
  sqlite3_mutex *(*xMutexAlloc)(int);
  void (*xMutexFree)(sqlite3_mutex *);
  void (*xMutexEnter)(sqlite3_mutex *);
  int (*xMutexTry)(sqlite3_mutex *);
  void (*xMutexLeave)(sqlite3_mutex *);
  int (*xMutexHeld)(sqlite3_mutex *);
  int (*xMutexNotheld)(sqlite3_mutex *);
};
/*
** CAPI3REF: Mutex Verification Routines
**
** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines
** are intended for use inside assert() statements.  The SQLite core
** never uses these routines except inside an assert() and applications
** are advised to follow the lead of the core.  The SQLite core only
** provides implementations for these routines when it is compiled
** with the SQLITE_DEBUG flag.  External mutex implementations
** are only required to provide these routines if SQLITE_DEBUG is
** defined and if NDEBUG is not defined.
**
** These routines should return true if the mutex in their argument
** is held or not held, respectively, by the calling thread.
**
** The implementation is not required to provide versions of these
** routines that actually work. If the implementation does not provide working
** versions of these routines, it should at least provide stubs that always
** return true so that one does not get spurious assertion failures.
**
** If the argument to sqlite3_mutex_held() is a NULL pointer then
** the routine should return 1.   This seems counter-intuitive since
** clearly the mutex cannot be held if it does not exist.  But
** the reason the mutex does not exist is because the build is not
** using mutexes.  And we do not want the assert() containing the
** call to sqlite3_mutex_held() to fail, so a non-zero return is
** the appropriate thing to do.  The sqlite3_mutex_notheld()
** interface should also return 1 when given a NULL pointer.
*/
#ifndef NDEBUG
SQLITE_API int sqlite3_mutex_held(sqlite3_mutex*);
SQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex*);
#endif
/*
** CAPI3REF: Mutex Types
**
** The [sqlite3_mutex_alloc()] interface takes a single argument
** which is one of these integer constants.
**
** The set of static mutexes may change from one SQLite release to the
** next.  Applications that override the built-in mutex logic must be
** prepared to accommodate additional static mutexes.
*/
#define SQLITE_MUTEX_FAST             0
#define SQLITE_MUTEX_RECURSIVE        1
#define SQLITE_MUTEX_STATIC_MASTER    2
#define SQLITE_MUTEX_STATIC_MEM       3
#define SQLITE_MUTEX_STATIC_MEM2      4
#define SQLITE_MUTEX_STATIC_OPEN      4
#define SQLITE_MUTEX_STATIC_PRNG      5
#define SQLITE_MUTEX_STATIC_LRU       6
#define SQLITE_MUTEX_STATIC_LRU2      7
#define SQLITE_MUTEX_STATIC_PMEM      7
#define SQLITE_MUTEX_STATIC_APP1      8
#define SQLITE_MUTEX_STATIC_APP2      9
#define SQLITE_MUTEX_STATIC_APP3     10
#define SQLITE_MUTEX_STATIC_VFS1     11
#define SQLITE_MUTEX_STATIC_VFS2     12
#define SQLITE_MUTEX_STATIC_VFS3     13
/*
** CAPI3REF: Retrieve the mutex for a database connection
** METHOD: sqlite3
**
** ^This interface returns a pointer the [sqlite3_mutex] object that
** serializes access to the [database connection] given in the argument
** when the [threading mode] is Serialized.
** ^If the [threading mode] is Single-thread or Multi-thread then this
** routine returns a NULL pointer.
*/
SQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
/*
** CAPI3REF: Low-Level Control Of Database Files
** METHOD: sqlite3
**
** ^The [sqlite3_file_control()] interface makes a direct call to the
** xFileControl method for the [sqlite3_io_methods] object associated
** with a particular database identified by the second argument. ^The
** name of the database is "main" for the main database or "temp" for the
** TEMP database, or the name that appears after the AS keyword for
** databases that are added using the [ATTACH] SQL command.
** ^A NULL pointer can be used in place of "main" to refer to the
** main database file.
** ^The third and fourth parameters to this routine
** are passed directly through to the second and third parameters of
** the xFileControl method.  ^The return value of the xFileControl
** method becomes the return value of this routine.
**
** ^The [SQLITE_FCNTL_FILE_POINTER] value for the op parameter causes
** a pointer to the underlying [sqlite3_file] object to be written into
** the space pointed to by the 4th parameter.  ^The [SQLITE_FCNTL_FILE_POINTER]
** case is a short-circuit path which does not actually invoke the
** underlying sqlite3_io_methods.xFileControl method.
**
** ^If the second parameter (zDbName) does not match the name of any
** open database file, then SQLITE_ERROR is returned.  ^This error
** code is not remembered and will not be recalled by [sqlite3_errcode()]
** or [sqlite3_errmsg()].  The underlying xFileControl method might
** also return SQLITE_ERROR.  There is no way to distinguish between
** an incorrect zDbName and an SQLITE_ERROR return from the underlying
** xFileControl method.
**
** See also: [file control opcodes]
*/
SQLITE_API int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
/*
** CAPI3REF: Testing Interface
**
** ^The sqlite3_test_control() interface is used to read out internal
** state of SQLite and to inject faults into SQLite for testing
** purposes.  ^The first parameter is an operation code that determines
** the number, meaning, and operation of all subsequent parameters.
**
** This interface is not for use by applications.  It exists solely
** for verifying the correct operation of the SQLite library.  Depending
** on how the SQLite library is compiled, this interface might not exist.
**
** The details of the operation codes, their meanings, the parameters
** they take, and what they do are all subject to change without notice.
** Unlike most of the SQLite API, this function is not guaranteed to
** operate consistently from one release to the next.
*/
SQLITE_API int sqlite3_test_control(int op, ...);
/*
** CAPI3REF: Testing Interface Operation Codes
**
** These constants are the valid operation code parameters used
** as the first argument to [sqlite3_test_control()].
**
** These parameters and their meanings are subject to change
** without notice.  These values are for testing purposes only.
** Applications should not use any of these parameters or the
** [sqlite3_test_control()] interface.
*/
#define SQLITE_TESTCTRL_FIRST                    5
#define SQLITE_TESTCTRL_PRNG_SAVE                5
#define SQLITE_TESTCTRL_PRNG_RESTORE             6
#define SQLITE_TESTCTRL_PRNG_RESET               7
#define SQLITE_TESTCTRL_BITVEC_TEST              8
#define SQLITE_TESTCTRL_FAULT_INSTALL            9
#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS     10
#define SQLITE_TESTCTRL_PENDING_BYTE            11
#define SQLITE_TESTCTRL_ASSERT                  12
#define SQLITE_TESTCTRL_ALWAYS                  13
#define SQLITE_TESTCTRL_RESERVE                 14
#define SQLITE_TESTCTRL_OPTIMIZATIONS           15
#define SQLITE_TESTCTRL_ISKEYWORD               16
#define SQLITE_TESTCTRL_SCRATCHMALLOC           17
#define SQLITE_TESTCTRL_LOCALTIME_FAULT         18
#define SQLITE_TESTCTRL_EXPLAIN_STMT            19
#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD    19
#define SQLITE_TESTCTRL_NEVER_CORRUPT           20
#define SQLITE_TESTCTRL_VDBE_COVERAGE           21
#define SQLITE_TESTCTRL_BYTEORDER               22
#define SQLITE_TESTCTRL_ISINIT                  23
#define SQLITE_TESTCTRL_SORTER_MMAP             24
#define SQLITE_TESTCTRL_IMPOSTER                25
#define SQLITE_TESTCTRL_PARSER_COVERAGE         26
#define SQLITE_TESTCTRL_LAST                    26
/*
** CAPI3REF: SQLite Runtime Status
**
** ^These interfaces are used to retrieve runtime status information
** about the performance of SQLite, and optionally to reset various
** highwater marks.  ^The first argument is an integer code for
** the specific parameter to measure.  ^(Recognized integer codes
** are of the form [status parameters | SQLITE_STATUS_...].)^
** ^The current value of the parameter is returned into *pCurrent.
** ^The highest recorded value is returned in *pHighwater.  ^If the
** resetFlag is true, then the highest record value is reset after
** *pHighwater is written.  ^(Some parameters do not record the highest
** value.  For those parameters
** nothing is written into *pHighwater and the resetFlag is ignored.)^
** ^(Other parameters record only the highwater mark and not the current
** value.  For these latter parameters nothing is written into *pCurrent.)^
**
** ^The sqlite3_status() and sqlite3_status64() routines return
** SQLITE_OK on success and a non-zero [error code] on failure.
**
** If either the current value or the highwater mark is too large to
** be represented by a 32-bit integer, then the values returned by
** sqlite3_status() are undefined.
**
** See also: [sqlite3_db_status()]
*/
SQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
SQLITE_API int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
);
/*
** CAPI3REF: Status Parameters
** KEYWORDS: {status parameters}
**
** These integer constants designate various run-time status parameters
** that can be returned by [sqlite3_status()].
**
** <dl>
** [[SQLITE_STATUS_MEMORY_USED]] ^(<dt>SQLITE_STATUS_MEMORY_USED</dt>
** <dd>This parameter is the current amount of memory checked out
** using [sqlite3_malloc()], either directly or indirectly.  The
** figure includes calls made to [sqlite3_malloc()] by the application
** and internal memory usage by the SQLite library.  Auxiliary page-cache
** memory controlled by [SQLITE_CONFIG_PAGECACHE] is not included in
** this parameter.  The amount returned is the sum of the allocation
** sizes as reported by the xSize method in [sqlite3_mem_methods].</dd>)^
**
** [[SQLITE_STATUS_MALLOC_SIZE]] ^(<dt>SQLITE_STATUS_MALLOC_SIZE</dt>
** <dd>This parameter records the largest memory allocation request
** handed to [sqlite3_malloc()] or [sqlite3_realloc()] (or their
** internal equivalents).  Only the value returned in the
** *pHighwater parameter to [sqlite3_status()] is of interest.
** The value written into the *pCurrent parameter is undefined.</dd>)^
**
** [[SQLITE_STATUS_MALLOC_COUNT]] ^(<dt>SQLITE_STATUS_MALLOC_COUNT</dt>
** <dd>This parameter records the number of separate memory allocations
** currently checked out.</dd>)^
**
** [[SQLITE_STATUS_PAGECACHE_USED]] ^(<dt>SQLITE_STATUS_PAGECACHE_USED</dt>
** <dd>This parameter returns the number of pages used out of the
** [pagecache memory allocator] that was configured using
** [SQLITE_CONFIG_PAGECACHE].  The
** value returned is in pages, not in bytes.</dd>)^
**
** [[SQLITE_STATUS_PAGECACHE_OVERFLOW]]
** ^(<dt>SQLITE_STATUS_PAGECACHE_OVERFLOW</dt>
** <dd>This parameter returns the number of bytes of page cache
** allocation which could not be satisfied by the [SQLITE_CONFIG_PAGECACHE]
** buffer and where forced to overflow to [sqlite3_malloc()].  The
** returned value includes allocations that overflowed because they
** where too large (they were larger than the "sz" parameter to
** [SQLITE_CONFIG_PAGECACHE]) and allocations that overflowed because
** no space was left in the page cache.</dd>)^
**
** [[SQLITE_STATUS_PAGECACHE_SIZE]] ^(<dt>SQLITE_STATUS_PAGECACHE_SIZE</dt>
** <dd>This parameter records the largest memory allocation request
** handed to [pagecache memory allocator].  Only the value returned in the
** *pHighwater parameter to [sqlite3_status()] is of interest.
** The value written into the *pCurrent parameter is undefined.</dd>)^
**
** [[SQLITE_STATUS_SCRATCH_USED]] <dt>SQLITE_STATUS_SCRATCH_USED</dt>
** <dd>No longer used.</dd>
**
** [[SQLITE_STATUS_SCRATCH_OVERFLOW]] ^(<dt>SQLITE_STATUS_SCRATCH_OVERFLOW</dt>
** <dd>No longer used.</dd>
**
** [[SQLITE_STATUS_SCRATCH_SIZE]] <dt>SQLITE_STATUS_SCRATCH_SIZE</dt>
** <dd>No longer used.</dd>
**
** [[SQLITE_STATUS_PARSER_STACK]] ^(<dt>SQLITE_STATUS_PARSER_STACK</dt>
** <dd>The *pHighwater parameter records the deepest parser stack.
** The *pCurrent value is undefined.  The *pHighwater value is only
** meaningful if SQLite is compiled with [YYTRACKMAXSTACKDEPTH].</dd>)^
** </dl>
**
** New status parameters may be added from time to time.
*/
#define SQLITE_STATUS_MEMORY_USED          0
#define SQLITE_STATUS_PAGECACHE_USED       1
#define SQLITE_STATUS_PAGECACHE_OVERFLOW   2
#define SQLITE_STATUS_SCRATCH_USED         3
#define SQLITE_STATUS_SCRATCH_OVERFLOW     4
#define SQLITE_STATUS_MALLOC_SIZE          5
#define SQLITE_STATUS_PARSER_STACK         6
#define SQLITE_STATUS_PAGECACHE_SIZE       7
#define SQLITE_STATUS_SCRATCH_SIZE         8
#define SQLITE_STATUS_MALLOC_COUNT         9
/*
** CAPI3REF: Database Connection Status
** METHOD: sqlite3
**
** ^This interface is used to retrieve runtime status information
** about a single [database connection].  ^The first argument is the
** database connection object to be interrogated.  ^The second argument
** is an integer constant, taken from the set of
** [SQLITE_DBSTATUS options], that
** determines the parameter to interrogate.  The set of
** [SQLITE_DBSTATUS options] is likely
** to grow in future releases of SQLite.
**
** ^The current value of the requested parameter is written into *pCur
** and the highest instantaneous value is written into *pHiwtr.  ^If
** the resetFlg is true, then the highest instantaneous value is
** reset back down to the current value.
**
** ^The sqlite3_db_status() routine returns SQLITE_OK on success and a
** non-zero [error code] on failure.
**
** See also: [sqlite3_status()] and [sqlite3_stmt_status()].
*/
SQLITE_API int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
/*
** CAPI3REF: Status Parameters for database connections
** KEYWORDS: {SQLITE_DBSTATUS options}
**
** These constants are the available integer "verbs" that can be passed as
** the second argument to the [sqlite3_db_status()] interface.
**
** New verbs may be added in future releases of SQLite. Existing verbs
** might be discontinued. Applications should check the return code from
** [sqlite3_db_status()] to make sure that the call worked.
** The [sqlite3_db_status()] interface will return a non-zero error code
** if a discontinued or unsupported verb is invoked.
**
** <dl>
** [[SQLITE_DBSTATUS_LOOKASIDE_USED]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_USED</dt>
** <dd>This parameter returns the number of lookaside memory slots currently
** checked out.</dd>)^
**
** [[SQLITE_DBSTATUS_LOOKASIDE_HIT]] ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_HIT</dt>
** <dd>This parameter returns the number malloc attempts that were
** satisfied using lookaside memory. Only the high-water value is meaningful;
** the current value is always zero.)^
**
** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE]]
** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE</dt>
** <dd>This parameter returns the number malloc attempts that might have
** been satisfied using lookaside memory but failed due to the amount of
** memory requested being larger than the lookaside slot size.
** Only the high-water value is meaningful;
** the current value is always zero.)^
**
** [[SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL]]
** ^(<dt>SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL</dt>
** <dd>This parameter returns the number malloc attempts that might have
** been satisfied using lookaside memory but failed due to all lookaside
** memory already being in use.
** Only the high-water value is meaningful;
** the current value is always zero.)^
**
** [[SQLITE_DBSTATUS_CACHE_USED]] ^(<dt>SQLITE_DBSTATUS_CACHE_USED</dt>
** <dd>This parameter returns the approximate number of bytes of heap
** memory used by all pager caches associated with the database connection.)^
** ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.
**
** [[SQLITE_DBSTATUS_CACHE_USED_SHARED]]
** ^(<dt>SQLITE_DBSTATUS_CACHE_USED_SHARED</dt>
** <dd>This parameter is similar to DBSTATUS_CACHE_USED, except that if a
** pager cache is shared between two or more connections the bytes of heap
** memory used by that pager cache is divided evenly between the attached
** connections.)^  In other words, if none of the pager caches associated
** with the database connection are shared, this request returns the same
** value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are
** shared, the value returned by this call will be smaller than that returned
** by DBSTATUS_CACHE_USED. ^The highwater mark associated with
** SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.
**
** [[SQLITE_DBSTATUS_SCHEMA_USED]] ^(<dt>SQLITE_DBSTATUS_SCHEMA_USED</dt>
** <dd>This parameter returns the approximate number of bytes of heap
** memory used to store the schema for all databases associated
** with the connection - main, temp, and any [ATTACH]-ed databases.)^
** ^The full amount of memory used by the schemas is reported, even if the
** schema memory is shared with other database connections due to
** [shared cache mode] being enabled.
** ^The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.
**
** [[SQLITE_DBSTATUS_STMT_USED]] ^(<dt>SQLITE_DBSTATUS_STMT_USED</dt>
** <dd>This parameter returns the approximate number of bytes of heap
** and lookaside memory used by all prepared statements associated with
** the database connection.)^
** ^The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.
** </dd>
**
** [[SQLITE_DBSTATUS_CACHE_HIT]] ^(<dt>SQLITE_DBSTATUS_CACHE_HIT</dt>
** <dd>This parameter returns the number of pager cache hits that have
** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT
** is always 0.
** </dd>
**
** [[SQLITE_DBSTATUS_CACHE_MISS]] ^(<dt>SQLITE_DBSTATUS_CACHE_MISS</dt>
** <dd>This parameter returns the number of pager cache misses that have
** occurred.)^ ^The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS
** is always 0.
** </dd>
**
** [[SQLITE_DBSTATUS_CACHE_WRITE]] ^(<dt>SQLITE_DBSTATUS_CACHE_WRITE</dt>
** <dd>This parameter returns the number of dirty cache entries that have
** been written to disk. Specifically, the number of pages written to the
** wal file in wal mode databases, or the number of pages written to the
** database file in rollback mode databases. Any pages written as part of
** transaction rollback or database recovery operations are not included.
** If an IO or other error occurs while writing a page to disk, the effect
** on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined.)^ ^The
** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.
** </dd>
**
** [[SQLITE_DBSTATUS_DEFERRED_FKS]] ^(<dt>SQLITE_DBSTATUS_DEFERRED_FKS</dt>
** <dd>This parameter returns zero for the current value if and only if
** all foreign key constraints (deferred or immediate) have been
** resolved.)^  ^The highwater mark is always 0.
** </dd>
** </dl>
*/
#define SQLITE_DBSTATUS_LOOKASIDE_USED       0
#define SQLITE_DBSTATUS_CACHE_USED           1
#define SQLITE_DBSTATUS_SCHEMA_USED          2
#define SQLITE_DBSTATUS_STMT_USED            3
#define SQLITE_DBSTATUS_LOOKASIDE_HIT        4
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE  5
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL  6
#define SQLITE_DBSTATUS_CACHE_HIT            7
#define SQLITE_DBSTATUS_CACHE_MISS           8
#define SQLITE_DBSTATUS_CACHE_WRITE          9
#define SQLITE_DBSTATUS_DEFERRED_FKS        10
#define SQLITE_DBSTATUS_CACHE_USED_SHARED   11
#define SQLITE_DBSTATUS_MAX                 11
/*
** CAPI3REF: Prepared Statement Status
** METHOD: sqlite3_stmt
**
** ^(Each prepared statement maintains various
** [SQLITE_STMTSTATUS counters] that measure the number
** of times it has performed specific operations.)^  These counters can
** be used to monitor the performance characteristics of the prepared
** statements.  For example, if the number of table steps greatly exceeds
** the number of table searches or result rows, that would tend to indicate
** that the prepared statement is using a full table scan rather than
** an index.
**
** ^(This interface is used to retrieve and reset counter values from
** a [prepared statement].  The first argument is the prepared statement
** object to be interrogated.  The second argument
** is an integer code for a specific [SQLITE_STMTSTATUS counter]
** to be interrogated.)^
** ^The current value of the requested counter is returned.
** ^If the resetFlg is true, then the counter is reset to zero after this
** interface call returns.
**
** See also: [sqlite3_status()] and [sqlite3_db_status()].
*/
SQLITE_API int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
/*
** CAPI3REF: Status Parameters for prepared statements
** KEYWORDS: {SQLITE_STMTSTATUS counter} {SQLITE_STMTSTATUS counters}
**
** These preprocessor macros define integer codes that name counter
** values associated with the [sqlite3_stmt_status()] interface.
** The meanings of the various counters are as follows:
**
** <dl>
** [[SQLITE_STMTSTATUS_FULLSCAN_STEP]] <dt>SQLITE_STMTSTATUS_FULLSCAN_STEP</dt>
** <dd>^This is the number of times that SQLite has stepped forward in
** a table as part of a full table scan.  Large numbers for this counter
** may indicate opportunities for performance improvement through
** careful use of indices.</dd>
**
** [[SQLITE_STMTSTATUS_SORT]] <dt>SQLITE_STMTSTATUS_SORT</dt>
** <dd>^This is the number of sort operations that have occurred.
** A non-zero value in this counter may indicate an opportunity to
** improvement performance through careful use of indices.</dd>
**
** [[SQLITE_STMTSTATUS_AUTOINDEX]] <dt>SQLITE_STMTSTATUS_AUTOINDEX</dt>
** <dd>^This is the number of rows inserted into transient indices that
** were created automatically in order to help joins run faster.
** A non-zero value in this counter may indicate an opportunity to
** improvement performance by adding permanent indices that do not
** need to be reinitialized each time the statement is run.</dd>
**
** [[SQLITE_STMTSTATUS_VM_STEP]] <dt>SQLITE_STMTSTATUS_VM_STEP</dt>
** <dd>^This is the number of virtual machine operations executed
** by the prepared statement if that number is less than or equal
** to 2147483647.  The number of virtual machine operations can be
** used as a proxy for the total work done by the prepared statement.
** If the number of virtual machine operations exceeds 2147483647
** then the value returned by this statement status code is undefined.
**
** [[SQLITE_STMTSTATUS_REPREPARE]] <dt>SQLITE_STMTSTATUS_REPREPARE</dt>
** <dd>^This is the number of times that the prepare statement has been
** automatically regenerated due to schema changes or change to
** [bound parameters] that might affect the query plan.
**
** [[SQLITE_STMTSTATUS_RUN]] <dt>SQLITE_STMTSTATUS_RUN</dt>
** <dd>^This is the number of times that the prepared statement has
** been run.  A single "run" for the purposes of this counter is one
** or more calls to [sqlite3_step()] followed by a call to [sqlite3_reset()].
** The counter is incremented on the first [sqlite3_step()] call of each
** cycle.
**
** [[SQLITE_STMTSTATUS_MEMUSED]] <dt>SQLITE_STMTSTATUS_MEMUSED</dt>
** <dd>^This is the approximate number of bytes of heap memory
** used to store the prepared statement.  ^This value is not actually
** a counter, and so the resetFlg parameter to sqlite3_stmt_status()
** is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.
** </dd>
** </dl>
*/
#define SQLITE_STMTSTATUS_FULLSCAN_STEP     1
#define SQLITE_STMTSTATUS_SORT              2
#define SQLITE_STMTSTATUS_AUTOINDEX         3
#define SQLITE_STMTSTATUS_VM_STEP           4
#define SQLITE_STMTSTATUS_REPREPARE         5
#define SQLITE_STMTSTATUS_RUN               6
#define SQLITE_STMTSTATUS_MEMUSED           99
/*
** CAPI3REF: Custom Page Cache Object
**
** The sqlite3_pcache type is opaque.  It is implemented by
** the pluggable module.  The SQLite core has no knowledge of
** its size or internal structure and never deals with the
** sqlite3_pcache object except by holding and passing pointers
** to the object.
**
** See [sqlite3_pcache_methods2] for additional information.
*/
typedef struct sqlite3_pcache sqlite3_pcache;
/*
** CAPI3REF: Custom Page Cache Object
**
** The sqlite3_pcache_page object represents a single page in the
** page cache.  The page cache will allocate instances of this
** object.  Various methods of the page cache use pointers to instances
** of this object as parameters or as their return value.
**
** See [sqlite3_pcache_methods2] for additional information.
*/
typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;
  void *pExtra;
};
/*
** CAPI3REF: Application Defined Page Cache.
** KEYWORDS: {page cache}
**
** ^(The [sqlite3_config]([SQLITE_CONFIG_PCACHE2], ...) interface can
** register an alternative page cache implementation by passing in an
** instance of the sqlite3_pcache_methods2 structure.)^
** In many applications, most of the heap memory allocated by
** SQLite is used for the page cache.
** By implementing a
** custom page cache using this API, an application can better control
** the amount of memory consumed by SQLite, the way in which
** that memory is allocated and released, and the policies used to
** determine exactly which parts of a database file are cached and for
** how long.
**
** The alternative page cache mechanism is an
** extreme measure that is only needed by the most demanding applications.
** The built-in page cache is recommended for most uses.
**
** ^(The contents of the sqlite3_pcache_methods2 structure are copied to an
** internal buffer by SQLite within the call to [sqlite3_config].  Hence
** the application may discard the parameter after the call to
** [sqlite3_config()] returns.)^
**
** [[the xInit() page cache method]]
** ^(The xInit() method is called once for each effective
** call to [sqlite3_initialize()])^
** (usually only once during the lifetime of the process). ^(The xInit()
** method is passed a copy of the sqlite3_pcache_methods2.pArg value.)^
** The intent of the xInit() method is to set up global data structures
** required by the custom page cache implementation.
** ^(If the xInit() method is NULL, then the
** built-in default page cache is used instead of the application defined
** page cache.)^
**
** [[the xShutdown() page cache method]]
** ^The xShutdown() method is called by [sqlite3_shutdown()].
** It can be used to clean up
** any outstanding resources before process shutdown, if required.
** ^The xShutdown() method may be NULL.
**
** ^SQLite automatically serializes calls to the xInit method,
** so the xInit method need not be threadsafe.  ^The
** xShutdown method is only called from [sqlite3_shutdown()] so it does
** not need to be threadsafe either.  All other methods must be threadsafe
** in multithreaded applications.
**
** ^SQLite will never invoke xInit() more than once without an intervening
** call to xShutdown().
**
** [[the xCreate() page cache methods]]
** ^SQLite invokes the xCreate() method to construct a new cache instance.
** SQLite will typically create one cache instance for each open database file,
** though this is not guaranteed. ^The
** first parameter, szPage, is the size in bytes of the pages that must
** be allocated by the cache.  ^szPage will always a power of two.  ^The
** second parameter szExtra is a number of bytes of extra storage
** associated with each page cache entry.  ^The szExtra parameter will
** a number less than 250.  SQLite will use the
** extra szExtra bytes on each page to store metadata about the underlying
** database page on disk.  The value passed into szExtra depends
** on the SQLite version, the target platform, and how SQLite was compiled.
** ^The third argument to xCreate(), bPurgeable, is true if the cache being
** created will be used to cache database pages of a file stored on disk, or
** false if it is used for an in-memory database. The cache implementation
** does not have to do anything special based with the value of bPurgeable;
** it is purely advisory.  ^On a cache where bPurgeable is false, SQLite will
** never invoke xUnpin() except to deliberately delete a page.
** ^In other words, calls to xUnpin() on a cache with bPurgeable set to
** false will always have the "discard" flag set to true.
** ^Hence, a cache created with bPurgeable false will
** never contain any unpinned pages.
**
** [[the xCachesize() page cache method]]
** ^(The xCachesize() method may be called at any time by SQLite to set the
** suggested maximum cache-size (number of pages stored by) the cache
** instance passed as the first argument. This is the value configured using
** the SQLite "[PRAGMA cache_size]" command.)^  As with the bPurgeable
** parameter, the implementation is not required to do anything with this
** value; it is advisory only.
**
** [[the xPagecount() page cache methods]]
** The xPagecount() method must return the number of pages currently
** stored in the cache, both pinned and unpinned.
**
** [[the xFetch() page cache methods]]
** The xFetch() method locates a page in the cache and returns a pointer to
** an sqlite3_pcache_page object associated with that page, or a NULL pointer.
** The pBuf element of the returned sqlite3_pcache_page object will be a
** pointer to a buffer of szPage bytes used to store the content of a
** single database page.  The pExtra element of sqlite3_pcache_page will be
** a pointer to the szExtra bytes of extra storage that SQLite has requested
** for each entry in the page cache.
**
** The page to be fetched is determined by the key. ^The minimum key value
** is 1.  After it has been retrieved using xFetch, the page is considered
** to be "pinned".
**
** If the requested page is already in the page cache, then the page cache
** implementation must return a pointer to the page buffer with its content
** intact.  If the requested page is not already in the cache, then the
** cache implementation should use the value of the createFlag
** parameter to help it determined what action to take:
**
** <table border=1 width=85% align=center>
** <tr><th> createFlag <th> Behavior when page is not already in cache
** <tr><td> 0 <td> Do not allocate a new page.  Return NULL.
** <tr><td> 1 <td> Allocate a new page if it easy and convenient to do so.
**                 Otherwise return NULL.
** <tr><td> 2 <td> Make every effort to allocate a new page.  Only return
**                 NULL if allocating a new page is effectively impossible.
** </table>
**
** ^(SQLite will normally invoke xFetch() with a createFlag of 0 or 1.  SQLite
** will only use a createFlag of 2 after a prior call with a createFlag of 1
** failed.)^  In between the to xFetch() calls, SQLite may
** attempt to unpin one or more cache pages by spilling the content of
** pinned pages to disk and synching the operating system disk cache.
**
** [[the xUnpin() page cache method]]
** ^xUnpin() is called by SQLite with a pointer to a currently pinned page
** as its second argument.  If the third parameter, discard, is non-zero,
** then the page must be evicted from the cache.
** ^If the discard parameter is
** zero, then the page may be discarded or retained at the discretion of
** page cache implementation. ^The page cache implementation
** may choose to evict unpinned pages at any time.
**
** The cache must not perform any reference counting. A single
** call to xUnpin() unpins the page regardless of the number of prior calls
** to xFetch().
**
** [[the xRekey() page cache methods]]
** The xRekey() method is used to change the key value associated with the
** page passed as the second argument. If the cache
** previously contains an entry associated with newKey, it must be
** discarded. ^Any prior cache entry associated with newKey is guaranteed not
** to be pinned.
**
** When SQLite calls the xTruncate() method, the cache must discard all
** existing cache entries with page numbers (keys) greater than or equal
** to the value of the iLimit parameter passed to xTruncate(). If any
** of these pages are pinned, they are implicitly unpinned, meaning that
** they can be safely discarded.
**
** [[the xDestroy() page cache method]]
** ^The xDestroy() method is used to delete a cache allocated by xCreate().
** All resources associated with the specified cache should be freed. ^After
** calling the xDestroy() method, SQLite considers the [sqlite3_pcache*]
** handle invalid, and will not use it with any other sqlite3_pcache_methods2
** functions.
**
** [[the xShrink() page cache method]]
** ^SQLite invokes the xShrink() method when it wants the page cache to
** free up as much of heap memory as possible.  The page cache implementation
** is not obligated to free any memory, but well-behaved implementations should
** do their best.
*/
typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};
/*
** This is the obsolete pcache_methods object that has now been replaced
** by sqlite3_pcache_methods2.  This object is not used by SQLite.  It is
** retained in the header file for backwards compatibility only.
*/
typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
struct sqlite3_pcache_methods {
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, void*, int discard);
  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
};
/*
** CAPI3REF: Online Backup Object
**
** The sqlite3_backup object records state information about an ongoing
** online backup operation.  ^The sqlite3_backup object is created by
** a call to [sqlite3_backup_init()] and is destroyed by a call to
** [sqlite3_backup_finish()].
**
** See Also: [Using the SQLite Online Backup API]
*/
typedef struct sqlite3_backup sqlite3_backup;
/*
** CAPI3REF: Online Backup API.
**
** The backup API copies the content of one database into another.
** It is useful either for creating backups of databases or
** for copying in-memory databases to or from persistent files.
**
** See Also: [Using the SQLite Online Backup API]
**
** ^SQLite holds a write transaction open on the destination database file
** for the duration of the backup operation.
** ^The source database is read-locked only while it is being read;
** it is not locked continuously for the entire backup operation.
** ^Thus, the backup may be performed on a live source database without
** preventing other database connections from
** reading or writing to the source database while the backup is underway.
**
** ^(To perform a backup operation:
**   <ol>
**     <li><b>sqlite3_backup_init()</b> is called once to initialize the
**         backup,
**     <li><b>sqlite3_backup_step()</b> is called one or more times to transfer
**         the data between the two databases, and finally
**     <li><b>sqlite3_backup_finish()</b> is called to release all resources
**         associated with the backup operation.
**   </ol>)^
** There should be exactly one call to sqlite3_backup_finish() for each
** successful call to sqlite3_backup_init().
**
** [[sqlite3_backup_init()]] <b>sqlite3_backup_init()</b>
**
** ^The D and N arguments to sqlite3_backup_init(D,N,S,M) are the
** [database connection] associated with the destination database
** and the database name, respectively.
** ^The database name is "main" for the main database, "temp" for the
** temporary database, or the name specified after the AS keyword in
** an [ATTACH] statement for an attached database.
** ^The S and M arguments passed to
** sqlite3_backup_init(D,N,S,M) identify the [database connection]
** and database name of the source database, respectively.
** ^The source and destination [database connections] (parameters S and D)
** must be different or else sqlite3_backup_init(D,N,S,M) will fail with
** an error.
**
** ^A call to sqlite3_backup_init() will fail, returning NULL, if
** there is already a read or read-write transaction open on the
** destination database.
**
** ^If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is
** returned and an error code and error message are stored in the
** destination [database connection] D.
** ^The error code and message for the failed call to sqlite3_backup_init()
** can be retrieved using the [sqlite3_errcode()], [sqlite3_errmsg()], and/or
** [sqlite3_errmsg16()] functions.
** ^A successful call to sqlite3_backup_init() returns a pointer to an
** [sqlite3_backup] object.
** ^The [sqlite3_backup] object may be used with the sqlite3_backup_step() and
** sqlite3_backup_finish() functions to perform the specified backup
** operation.
**
** [[sqlite3_backup_step()]] <b>sqlite3_backup_step()</b>
**
** ^Function sqlite3_backup_step(B,N) will copy up to N pages between
** the source and destination databases specified by [sqlite3_backup] object B.
** ^If N is negative, all remaining source pages are copied.
** ^If sqlite3_backup_step(B,N) successfully copies N pages and there
** are still more pages to be copied, then the function returns [SQLITE_OK].
** ^If sqlite3_backup_step(B,N) successfully finishes copying all pages
** from source to destination, then it returns [SQLITE_DONE].
** ^If an error occurs while running sqlite3_backup_step(B,N),
** then an [error code] is returned. ^As well as [SQLITE_OK] and
** [SQLITE_DONE], a call to sqlite3_backup_step() may return [SQLITE_READONLY],
** [SQLITE_NOMEM], [SQLITE_BUSY], [SQLITE_LOCKED], or an
** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX] extended error code.
**
** ^(The sqlite3_backup_step() might return [SQLITE_READONLY] if
** <ol>
** <li> the destination database was opened read-only, or
** <li> the destination database is using write-ahead-log journaling
** and the destination and source page sizes differ, or
** <li> the destination database is an in-memory database and the
** destination and source page sizes differ.
** </ol>)^
**
** ^If sqlite3_backup_step() cannot obtain a required file-system lock, then
** the [sqlite3_busy_handler | busy-handler function]
** is invoked (if one is specified). ^If the
** busy-handler returns non-zero before the lock is available, then
** [SQLITE_BUSY] is returned to the caller. ^In this case the call to
** sqlite3_backup_step() can be retried later. ^If the source
** [database connection]
** is being used to write to the source database when sqlite3_backup_step()
** is called, then [SQLITE_LOCKED] is returned immediately. ^Again, in this
** case the call to sqlite3_backup_step() can be retried later on. ^(If
** [SQLITE_IOERR_ACCESS | SQLITE_IOERR_XXX], [SQLITE_NOMEM], or
** [SQLITE_READONLY] is returned, then
** there is no point in retrying the call to sqlite3_backup_step(). These
** errors are considered fatal.)^  The application must accept
** that the backup operation has failed and pass the backup operation handle
** to the sqlite3_backup_finish() to release associated resources.
**
** ^The first call to sqlite3_backup_step() obtains an exclusive lock
** on the destination file. ^The exclusive lock is not released until either
** sqlite3_backup_finish() is called or the backup operation is complete
** and sqlite3_backup_step() returns [SQLITE_DONE].  ^Every call to
** sqlite3_backup_step() obtains a [shared lock] on the source database that
** lasts for the duration of the sqlite3_backup_step() call.
** ^Because the source database is not locked between calls to
** sqlite3_backup_step(), the source database may be modified mid-way
** through the backup process.  ^If the source database is modified by an
** external process or via a database connection other than the one being
** used by the backup operation, then the backup will be automatically
** restarted by the next call to sqlite3_backup_step(). ^If the source
** database is modified by the using the same database connection as is used
** by the backup operation, then the backup database is automatically
** updated at the same time.
**
** [[sqlite3_backup_finish()]] <b>sqlite3_backup_finish()</b>
**
** When sqlite3_backup_step() has returned [SQLITE_DONE], or when the
** application wishes to abandon the backup operation, the application
** should destroy the [sqlite3_backup] by passing it to sqlite3_backup_finish().
** ^The sqlite3_backup_finish() interfaces releases all
** resources associated with the [sqlite3_backup] object.
** ^If sqlite3_backup_step() has not yet returned [SQLITE_DONE], then any
** active write-transaction on the destination database is rolled back.
** The [sqlite3_backup] object is invalid
** and may not be used following a call to sqlite3_backup_finish().
**
** ^The value returned by sqlite3_backup_finish is [SQLITE_OK] if no
** sqlite3_backup_step() errors occurred, regardless or whether or not
** sqlite3_backup_step() completed.
** ^If an out-of-memory condition or IO error occurred during any prior
** sqlite3_backup_step() call on the same [sqlite3_backup] object, then
** sqlite3_backup_finish() returns the corresponding [error code].
**
** ^A return of [SQLITE_BUSY] or [SQLITE_LOCKED] from sqlite3_backup_step()
** is not a permanent error and does not affect the return value of
** sqlite3_backup_finish().
**
** [[sqlite3_backup_remaining()]] [[sqlite3_backup_pagecount()]]
** <b>sqlite3_backup_remaining() and sqlite3_backup_pagecount()</b>
**
** ^The sqlite3_backup_remaining() routine returns the number of pages still
** to be backed up at the conclusion of the most recent sqlite3_backup_step().
** ^The sqlite3_backup_pagecount() routine returns the total number of pages
** in the source database at the conclusion of the most recent
** sqlite3_backup_step().
** ^(The values returned by these functions are only updated by
** sqlite3_backup_step(). If the source database is modified in a way that
** changes the size of the source database or the number of pages remaining,
** those changes are not reflected in the output of sqlite3_backup_pagecount()
** and sqlite3_backup_remaining() until after the next
** sqlite3_backup_step().)^
**
** <b>Concurrent Usage of Database Handles</b>
**
** ^The source [database connection] may be used by the application for other
** purposes while a backup operation is underway or being initialized.
** ^If SQLite is compiled and configured to support threadsafe database
** connections, then the source database connection may be used concurrently
** from within other threads.
**
** However, the application must guarantee that the destination
** [database connection] is not passed to any other API (by any thread) after
** sqlite3_backup_init() is called and before the corresponding call to
** sqlite3_backup_finish().  SQLite does not currently check to see
** if the application incorrectly accesses the destination [database connection]
** and so no error code is reported, but the operations may malfunction
** nevertheless.  Use of the destination database connection while a
** backup is in progress might also also cause a mutex deadlock.
**
** If running in [shared cache mode], the application must
** guarantee that the shared cache used by the destination database
** is not accessed while the backup is running. In practice this means
** that the application must guarantee that the disk file being
** backed up to is not accessed by any connection within the process,
** not just the specific connection that was passed to sqlite3_backup_init().
**
** The [sqlite3_backup] object itself is partially threadsafe. Multiple
** threads may safely make multiple concurrent calls to sqlite3_backup_step().
** However, the sqlite3_backup_remaining() and sqlite3_backup_pagecount()
** APIs are not strictly speaking threadsafe. If they are invoked at the
** same time as another thread is invoking sqlite3_backup_step() it is
** possible that they return invalid values.
*/
SQLITE_API sqlite3_backup *sqlite3_backup_init(
  sqlite3 *pDest,
  const char *zDestName,
  sqlite3 *pSource,
  const char *zSourceName
);
SQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage);
SQLITE_API int sqlite3_backup_finish(sqlite3_backup *p);
SQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p);
SQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p);
/*
** CAPI3REF: Unlock Notification
** METHOD: sqlite3
**
** ^When running in shared-cache mode, a database operation may fail with
** an [SQLITE_LOCKED] error if the required locks on the shared-cache or
** individual tables within the shared-cache cannot be obtained. See
** [SQLite Shared-Cache Mode] for a description of shared-cache locking.
** ^This API may be used to register a callback that SQLite will invoke
** when the connection currently holding the required lock relinquishes it.
** ^This API is only available if the library was compiled with the
** [SQLITE_ENABLE_UNLOCK_NOTIFY] C-preprocessor symbol defined.
**
** See Also: [Using the SQLite Unlock Notification Feature].
**
** ^Shared-cache locks are released when a database connection concludes
** its current transaction, either by committing it or rolling it back.
**
** ^When a connection (known as the blocked connection) fails to obtain a
** shared-cache lock and SQLITE_LOCKED is returned to the caller, the
** identity of the database connection (the blocking connection) that
** has locked the required resource is stored internally. ^After an
** application receives an SQLITE_LOCKED error, it may call the
** sqlite3_unlock_notify() method with the blocked connection handle as
** the first argument to register for a callback that will be invoked
** when the blocking connections current transaction is concluded. ^The
** callback is invoked from within the [sqlite3_step] or [sqlite3_close]
** call that concludes the blocking connections transaction.
**
** ^(If sqlite3_unlock_notify() is called in a multi-threaded application,
** there is a chance that the blocking connection will have already
** concluded its transaction by the time sqlite3_unlock_notify() is invoked.
** If this happens, then the specified callback is invoked immediately,
** from within the call to sqlite3_unlock_notify().)^
**
** ^If the blocked connection is attempting to obtain a write-lock on a
** shared-cache table, and more than one other connection currently holds
** a read-lock on the same table, then SQLite arbitrarily selects one of
** the other connections to use as the blocking connection.
**
** ^(There may be at most one unlock-notify callback registered by a
** blocked connection. If sqlite3_unlock_notify() is called when the
** blocked connection already has a registered unlock-notify callback,
** then the new callback replaces the old.)^ ^If sqlite3_unlock_notify() is
** called with a NULL pointer as its second argument, then any existing
** unlock-notify callback is canceled. ^The blocked connections
** unlock-notify callback may also be canceled by closing the blocked
** connection using [sqlite3_close()].
**
** The unlock-notify callback is not reentrant. If an application invokes
** any sqlite3_xxx API functions from within an unlock-notify callback, a
** crash or deadlock may be the result.
**
** ^Unless deadlock is detected (see below), sqlite3_unlock_notify() always
** returns SQLITE_OK.
**
** <b>Callback Invocation Details</b>
**
** When an unlock-notify callback is registered, the application provides a
** single void* pointer that is passed to the callback when it is invoked.
** However, the signature of the callback function allows SQLite to pass
** it an array of void* context pointers. The first argument passed to
** an unlock-notify callback is a pointer to an array of void* pointers,
** and the second is the number of entries in the array.
**
** When a blocking connections transaction is concluded, there may be
** more than one blocked connection that has registered for an unlock-notify
** callback. ^If two or more such blocked connections have specified the
** same callback function, then instead of invoking the callback function
** multiple times, it is invoked once with the set of void* context pointers
** specified by the blocked connections bundled together into an array.
** This gives the application an opportunity to prioritize any actions
** related to the set of unblocked database connections.
**
** <b>Deadlock Detection</b>
**
** Assuming that after registering for an unlock-notify callback a
** database waits for the callback to be issued before taking any further
** action (a reasonable assumption), then using this API may cause the
** application to deadlock. For example, if connection X is waiting for
** connection Y's transaction to be concluded, and similarly connection
** Y is waiting on connection X's transaction, then neither connection
** will proceed and the system may remain deadlocked indefinitely.
**
** To avoid this scenario, the sqlite3_unlock_notify() performs deadlock
** detection. ^If a given call to sqlite3_unlock_notify() would put the
** system in a deadlocked state, then SQLITE_LOCKED is returned and no
** unlock-notify callback is registered. The system is said to be in
** a deadlocked state if connection A has registered for an unlock-notify
** callback on the conclusion of connection B's transaction, and connection
** B has itself registered for an unlock-notify callback when connection
** A's transaction is concluded. ^Indirect deadlock is also detected, so
** the system is also considered to be deadlocked if connection B has
** registered for an unlock-notify callback on the conclusion of connection
** C's transaction, where connection C is waiting on connection A. ^Any
** number of levels of indirection are allowed.
**
** <b>The "DROP TABLE" Exception</b>
**
** When a call to [sqlite3_step()] returns SQLITE_LOCKED, it is almost
** always appropriate to call sqlite3_unlock_notify(). There is however,
** one exception. When executing a "DROP TABLE" or "DROP INDEX" statement,
** SQLite checks if there are any currently executing SELECT statements
** that belong to the same connection. If there are, SQLITE_LOCKED is
** returned. In this case there is no "blocking connection", so invoking
** sqlite3_unlock_notify() results in the unlock-notify callback being
** invoked immediately. If the application then re-attempts the "DROP TABLE"
** or "DROP INDEX" query, an infinite loop might be the result.
**
** One way around this problem is to check the extended error code returned
** by an sqlite3_step() call. ^(If there is a blocking connection, then the
** extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in
** the special "DROP TABLE/INDEX" case, the extended error code is just
** SQLITE_LOCKED.)^
*/
SQLITE_API int sqlite3_unlock_notify(
  sqlite3 *pBlocked,
  void (*xNotify)(void **apArg, int nArg),
  void *pNotifyArg
);
/*
** CAPI3REF: String Comparison
**
** ^The [sqlite3_stricmp()] and [sqlite3_strnicmp()] APIs allow applications
** and extensions to compare the contents of two buffers containing UTF-8
** strings in a case-independent fashion, using the same definition of "case
** independence" that SQLite uses internally when comparing identifiers.
*/
SQLITE_API int sqlite3_stricmp(const char *, const char *);
SQLITE_API int sqlite3_strnicmp(const char *, const char *, int);
/*
** CAPI3REF: String Globbing
*
** ^The [sqlite3_strglob(P,X)] interface returns zero if and only if
** string X matches the [GLOB] pattern P.
** ^The definition of [GLOB] pattern matching used in
** [sqlite3_strglob(P,X)] is the same as for the "X GLOB P" operator in the
** SQL dialect understood by SQLite.  ^The [sqlite3_strglob(P,X)] function
** is case sensitive.
**
** Note that this routine returns zero on a match and non-zero if the strings
** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].
**
** See also: [sqlite3_strlike()].
*/
SQLITE_API int sqlite3_strglob(const char *zGlob, const char *zStr);
/*
** CAPI3REF: String LIKE Matching
*
** ^The [sqlite3_strlike(P,X,E)] interface returns zero if and only if
** string X matches the [LIKE] pattern P with escape character E.
** ^The definition of [LIKE] pattern matching used in
** [sqlite3_strlike(P,X,E)] is the same as for the "X LIKE P ESCAPE E"
** operator in the SQL dialect understood by SQLite.  ^For "X LIKE P" without
** the ESCAPE clause, set the E parameter of [sqlite3_strlike(P,X,E)] to 0.
** ^As with the LIKE operator, the [sqlite3_strlike(P,X,E)] function is case
** insensitive - equivalent upper and lower case ASCII characters match
** one another.
**
** ^The [sqlite3_strlike(P,X,E)] function matches Unicode characters, though
** only ASCII characters are case folded.
**
** Note that this routine returns zero on a match and non-zero if the strings
** do not match, the same as [sqlite3_stricmp()] and [sqlite3_strnicmp()].
**
** See also: [sqlite3_strglob()].
*/
SQLITE_API int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);
/*
** CAPI3REF: Error Logging Interface
**
** ^The [sqlite3_log()] interface writes a message into the [error log]
** established by the [SQLITE_CONFIG_LOG] option to [sqlite3_config()].
** ^If logging is enabled, the zFormat string and subsequent arguments are
** used with [sqlite3_snprintf()] to generate the final output string.
**
** The sqlite3_log() interface is intended for use by extensions such as
** virtual tables, collating functions, and SQL functions.  While there is
** nothing to prevent an application from calling sqlite3_log(), doing so
** is considered bad form.
**
** The zFormat string must not be NULL.
**
** To avoid deadlocks and other threading problems, the sqlite3_log() routine
** will not use dynamically allocated memory.  The log message is stored in
** a fixed-length buffer on the stack.  If the log message is longer than
** a few hundred characters, it will be truncated to the length of the
** buffer.
*/
SQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...);
/*
** CAPI3REF: Write-Ahead Log Commit Hook
** METHOD: sqlite3
**
** ^The [sqlite3_wal_hook()] function is used to register a callback that
** is invoked each time data is committed to a database in wal mode.
**
** ^(The callback is invoked by SQLite after the commit has taken place and
** the associated write-lock on the database released)^, so the implementation
** may read, write or [checkpoint] the database as required.
**
** ^The first parameter passed to the callback function when it is invoked
** is a copy of the third parameter passed to sqlite3_wal_hook() when
** registering the callback. ^The second is a copy of the database handle.
** ^The third parameter is the name of the database that was written to -
** either "main" or the name of an [ATTACH]-ed database. ^The fourth parameter
** is the number of pages currently in the write-ahead log file,
** including those that were just committed.
**
** The callback function should normally return [SQLITE_OK].  ^If an error
** code is returned, that error will propagate back up through the
** SQLite code base to cause the statement that provoked the callback
** to report an error, though the commit will have still occurred. If the
** callback returns [SQLITE_ROW] or [SQLITE_DONE], or if it returns a value
** that does not correspond to any valid SQLite error code, the results
** are undefined.
**
** A single database handle may have at most a single write-ahead log callback
** registered at one time. ^Calling [sqlite3_wal_hook()] replaces any
** previously registered write-ahead log callback. ^Note that the
** [sqlite3_wal_autocheckpoint()] interface and the
** [wal_autocheckpoint pragma] both invoke [sqlite3_wal_hook()] and will
** overwrite any prior [sqlite3_wal_hook()] settings.
*/
SQLITE_API void *sqlite3_wal_hook(
  sqlite3*,
  int(*)(void *,sqlite3*,const char*,int),
  void*
);
/*
** CAPI3REF: Configure an auto-checkpoint
** METHOD: sqlite3
**
** ^The [sqlite3_wal_autocheckpoint(D,N)] is a wrapper around
** [sqlite3_wal_hook()] that causes any database on [database connection] D
** to automatically [checkpoint]
** after committing a transaction if there are N or
** more frames in the [write-ahead log] file.  ^Passing zero or
** a negative value as the nFrame parameter disables automatic
** checkpoints entirely.
**
** ^The callback registered by this function replaces any existing callback
** registered using [sqlite3_wal_hook()].  ^Likewise, registering a callback
** using [sqlite3_wal_hook()] disables the automatic checkpoint mechanism
** configured by this function.
**
** ^The [wal_autocheckpoint pragma] can be used to invoke this interface
** from SQL.
**
** ^Checkpoints initiated by this mechanism are
** [sqlite3_wal_checkpoint_v2|PASSIVE].
**
** ^Every new [database connection] defaults to having the auto-checkpoint
** enabled with a threshold of 1000 or [SQLITE_DEFAULT_WAL_AUTOCHECKPOINT]
** pages.  The use of this interface
** is only necessary if the default setting is found to be suboptimal
** for a particular application.
*/
SQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
/*
** CAPI3REF: Checkpoint a database
** METHOD: sqlite3
**
** ^(The sqlite3_wal_checkpoint(D,X) is equivalent to
** [sqlite3_wal_checkpoint_v2](D,X,[SQLITE_CHECKPOINT_PASSIVE],0,0).)^
**
** In brief, sqlite3_wal_checkpoint(D,X) causes the content in the
** [write-ahead log] for database X on [database connection] D to be
** transferred into the database file and for the write-ahead log to
** be reset.  See the [checkpointing] documentation for addition
** information.
**
** This interface used to be the only way to cause a checkpoint to
** occur.  But then the newer and more powerful [sqlite3_wal_checkpoint_v2()]
** interface was added.  This interface is retained for backwards
** compatibility and as a convenience for applications that need to manually
** start a callback but which do not need the full power (and corresponding
** complication) of [sqlite3_wal_checkpoint_v2()].
*/
SQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
/*
** CAPI3REF: Checkpoint a database
** METHOD: sqlite3
**
** ^(The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint
** operation on database X of [database connection] D in mode M.  Status
** information is written back into integers pointed to by L and C.)^
** ^(The M parameter must be a valid [checkpoint mode]:)^
**
** <dl>
** <dt>SQLITE_CHECKPOINT_PASSIVE<dd>
**   ^Checkpoint as many frames as possible without waiting for any database
**   readers or writers to finish, then sync the database file if all frames
**   in the log were checkpointed. ^The [busy-handler callback]
**   is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode.
**   ^On the other hand, passive mode might leave the checkpoint unfinished
**   if there are concurrent readers or writers.
**
** <dt>SQLITE_CHECKPOINT_FULL<dd>
**   ^This mode blocks (it invokes the
**   [sqlite3_busy_handler|busy-handler callback]) until there is no
**   database writer and all readers are reading from the most recent database
**   snapshot. ^It then checkpoints all frames in the log file and syncs the
**   database file. ^This mode blocks new database writers while it is pending,
**   but new database readers are allowed to continue unimpeded.
**
** <dt>SQLITE_CHECKPOINT_RESTART<dd>
**   ^This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition
**   that after checkpointing the log file it blocks (calls the
**   [busy-handler callback])
**   until all readers are reading from the database file only. ^This ensures
**   that the next writer will restart the log file from the beginning.
**   ^Like SQLITE_CHECKPOINT_FULL, this mode blocks new
**   database writer attempts while it is pending, but does not impede readers.
**
** <dt>SQLITE_CHECKPOINT_TRUNCATE<dd>
**   ^This mode works the same way as SQLITE_CHECKPOINT_RESTART with the
**   addition that it also truncates the log file to zero bytes just prior
**   to a successful return.
** </dl>
**
** ^If pnLog is not NULL, then *pnLog is set to the total number of frames in
** the log file or to -1 if the checkpoint could not run because
** of an error or because the database is not in [WAL mode]. ^If pnCkpt is not
** NULL,then *pnCkpt is set to the total number of checkpointed frames in the
** log file (including any that were already checkpointed before the function
** was called) or to -1 if the checkpoint could not run due to an error or
** because the database is not in WAL mode. ^Note that upon successful
** completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been
** truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.
**
** ^All calls obtain an exclusive "checkpoint" lock on the database file. ^If
** any other process is running a checkpoint operation at the same time, the
** lock cannot be obtained and SQLITE_BUSY is returned. ^Even if there is a
** busy-handler configured, it will not be invoked in this case.
**
** ^The SQLITE_CHECKPOINT_FULL, RESTART and TRUNCATE modes also obtain the
** exclusive "writer" lock on the database file. ^If the writer lock cannot be
** obtained immediately, and a busy-handler is configured, it is invoked and
** the writer lock retried until either the busy-handler returns 0 or the lock
** is successfully obtained. ^The busy-handler is also invoked while waiting for
** database readers as described above. ^If the busy-handler returns 0 before
** the writer lock is obtained or while waiting for database readers, the
** checkpoint operation proceeds from that point in the same way as
** SQLITE_CHECKPOINT_PASSIVE - checkpointing as many frames as possible
** without blocking any further. ^SQLITE_BUSY is returned in this case.
**
** ^If parameter zDb is NULL or points to a zero length string, then the
** specified operation is attempted on all WAL databases [attached] to
** [database connection] db.  In this case the
** values written to output parameters *pnLog and *pnCkpt are undefined. ^If
** an SQLITE_BUSY error is encountered when processing one or more of the
** attached WAL databases, the operation is still attempted on any remaining
** attached databases and SQLITE_BUSY is returned at the end. ^If any other
** error occurs while processing an attached database, processing is abandoned
** and the error code is returned to the caller immediately. ^If no error
** (SQLITE_BUSY or otherwise) is encountered while processing the attached
** databases, SQLITE_OK is returned.
**
** ^If database zDb is the name of an attached database that is not in WAL
** mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. ^If
** zDb is not NULL (or a zero length string) and is not the name of any
** attached database, SQLITE_ERROR is returned to the caller.
**
** ^Unless it returns SQLITE_MISUSE,
** the sqlite3_wal_checkpoint_v2() interface
** sets the error information that is queried by
** [sqlite3_errcode()] and [sqlite3_errmsg()].
**
** ^The [PRAGMA wal_checkpoint] command can be used to invoke this interface
** from SQL.
*/
SQLITE_API int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
);
/*
** CAPI3REF: Checkpoint Mode Values
** KEYWORDS: {checkpoint mode}
**
** These constants define all valid values for the "checkpoint mode" passed
** as the third parameter to the [sqlite3_wal_checkpoint_v2()] interface.
** See the [sqlite3_wal_checkpoint_v2()] documentation for details on the
** meaning of each of these checkpoint modes.
*/
#define SQLITE_CHECKPOINT_PASSIVE  0
#define SQLITE_CHECKPOINT_FULL     1
#define SQLITE_CHECKPOINT_RESTART  2
#define SQLITE_CHECKPOINT_TRUNCATE 3
/*
** CAPI3REF: Virtual Table Interface Configuration
**
** This function may be called by either the [xConnect] or [xCreate] method
** of a [virtual table] implementation to configure
** various facets of the virtual table interface.
**
** If this interface is invoked outside the context of an xConnect or
** xCreate virtual table method then the behavior is undefined.
**
** At present, there is only one option that may be configured using
** this function. (See [SQLITE_VTAB_CONSTRAINT_SUPPORT].)  Further options
** may be added in the future.
*/
SQLITE_API int sqlite3_vtab_config(sqlite3*, int op, ...);
/*
** CAPI3REF: Virtual Table Configuration Options
**
** These macros define the various options to the
** [sqlite3_vtab_config()] interface that [virtual table] implementations
** can use to customize and optimize their behavior.
**
** <dl>
** <dt>SQLITE_VTAB_CONSTRAINT_SUPPORT
** <dd>Calls of the form
** [sqlite3_vtab_config](db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported,
** where X is an integer.  If X is zero, then the [virtual table] whose
** [xCreate] or [xConnect] method invoked [sqlite3_vtab_config()] does not
** support constraints.  In this configuration (which is the default) if
** a call to the [xUpdate] method returns [SQLITE_CONSTRAINT], then the entire
** statement is rolled back as if [ON CONFLICT | OR ABORT] had been
** specified as part of the users SQL statement, regardless of the actual
** ON CONFLICT mode specified.
**
** If X is non-zero, then the virtual table implementation guarantees
** that if [xUpdate] returns [SQLITE_CONSTRAINT], it will do so before
** any modifications to internal or persistent data structures have been made.
** If the [ON CONFLICT] mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite
** is able to roll back a statement or database transaction, and abandon
** or continue processing the current SQL statement as appropriate.
** If the ON CONFLICT mode is REPLACE and the [xUpdate] method returns
** [SQLITE_CONSTRAINT], SQLite handles this as if the ON CONFLICT mode
** had been ABORT.
**
** Virtual table implementations that are required to handle OR REPLACE
** must do so within the [xUpdate] method. If a call to the
** [sqlite3_vtab_on_conflict()] function indicates that the current ON
** CONFLICT policy is REPLACE, the virtual table implementation should
** silently replace the appropriate rows within the xUpdate callback and
** return SQLITE_OK. Or, if this is not possible, it may return
** SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT
** constraint handling.
** </dl>
*/
#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1
/*
** CAPI3REF: Determine The Virtual Table Conflict Policy
**
** This function may only be called from within a call to the [xUpdate] method
** of a [virtual table] implementation for an INSERT or UPDATE operation. ^The
** value returned is one of [SQLITE_ROLLBACK], [SQLITE_IGNORE], [SQLITE_FAIL],
** [SQLITE_ABORT], or [SQLITE_REPLACE], according to the [ON CONFLICT] mode
** of the SQL statement that triggered the call to the [xUpdate] method of the
** [virtual table].
*/
SQLITE_API int sqlite3_vtab_on_conflict(sqlite3 *);
/*
** CAPI3REF: Determine If Virtual Table Column Access Is For UPDATE
**
** If the sqlite3_vtab_nochange(X) routine is called within the [xColumn]
** method of a [virtual table], then it returns true if and only if the
** column is being fetched as part of an UPDATE operation during which the
** column value will not change.  Applications might use this to substitute
** a lighter-weight value to return that the corresponding [xUpdate] method
** understands as a "no-change" value.
**
** If the [xColumn] method calls sqlite3_vtab_nochange() and finds that
** the column is not changed by the UPDATE statement, they the xColumn
** method can optionally return without setting a result, without calling
** any of the [sqlite3_result_int|sqlite3_result_xxxxx() interfaces].
** In that case, [sqlite3_value_nochange(X)] will return true for the
** same column in the [xUpdate] method.
*/
SQLITE_API int sqlite3_vtab_nochange(sqlite3_context*);
/*
** CAPI3REF: Determine The Collation For a Virtual Table Constraint
**
** This function may only be called from within a call to the [xBestIndex]
** method of a [virtual table].
**
** The first argument must be the sqlite3_index_info object that is the
** first parameter to the xBestIndex() method. The second argument must be
** an index into the aConstraint[] array belonging to the sqlite3_index_info
** structure passed to xBestIndex. This function returns a pointer to a buffer
** containing the name of the collation sequence for the corresponding
** constraint.
*/
SQLITE_API SQLITE_EXPERIMENTAL const char *sqlite3_vtab_collation(sqlite3_index_info*,int);
/*
** CAPI3REF: Conflict resolution modes
** KEYWORDS: {conflict resolution mode}
**
** These constants are returned by [sqlite3_vtab_on_conflict()] to
** inform a [virtual table] implementation what the [ON CONFLICT] mode
** is for the SQL statement being evaluated.
**
** Note that the [SQLITE_IGNORE] constant is also used as a potential
** return value from the [sqlite3_set_authorizer()] callback and that
** [SQLITE_ABORT] is also a [result code].
*/
#define SQLITE_ROLLBACK 1
/* #define SQLITE_IGNORE 2 // Also used by sqlite3_authorizer() callback */
#define SQLITE_FAIL     3
/* #define SQLITE_ABORT 4  // Also an error code */
#define SQLITE_REPLACE  5
/*
** CAPI3REF: Prepared Statement Scan Status Opcodes
** KEYWORDS: {scanstatus options}
**
** The following constants can be used for the T parameter to the
** [sqlite3_stmt_scanstatus(S,X,T,V)] interface.  Each constant designates a
** different metric for sqlite3_stmt_scanstatus() to return.
**
** When the value returned to V is a string, space to hold that string is
** managed by the prepared statement S and will be automatically freed when
** S is finalized.
**
** <dl>
** [[SQLITE_SCANSTAT_NLOOP]] <dt>SQLITE_SCANSTAT_NLOOP</dt>
** <dd>^The [sqlite3_int64] variable pointed to by the T parameter will be
** set to the total number of times that the X-th loop has run.</dd>
**
** [[SQLITE_SCANSTAT_NVISIT]] <dt>SQLITE_SCANSTAT_NVISIT</dt>
** <dd>^The [sqlite3_int64] variable pointed to by the T parameter will be set
** to the total number of rows examined by all iterations of the X-th loop.</dd>
**
** [[SQLITE_SCANSTAT_EST]] <dt>SQLITE_SCANSTAT_EST</dt>
** <dd>^The "double" variable pointed to by the T parameter will be set to the
** query planner's estimate for the average number of rows output from each
** iteration of the X-th loop.  If the query planner's estimates was accurate,
** then this value will approximate the quotient NVISIT/NLOOP and the
** product of this value for all prior loops with the same SELECTID will
** be the NLOOP value for the current loop.
**
** [[SQLITE_SCANSTAT_NAME]] <dt>SQLITE_SCANSTAT_NAME</dt>
** <dd>^The "const char *" variable pointed to by the T parameter will be set
** to a zero-terminated UTF-8 string containing the name of the index or table
** used for the X-th loop.
**
** [[SQLITE_SCANSTAT_EXPLAIN]] <dt>SQLITE_SCANSTAT_EXPLAIN</dt>
** <dd>^The "const char *" variable pointed to by the T parameter will be set
** to a zero-terminated UTF-8 string containing the [EXPLAIN QUERY PLAN]
** description for the X-th loop.
**
** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECT</dt>
** <dd>^The "int" variable pointed to by the T parameter will be set to the
** "select-id" for the X-th loop.  The select-id identifies which query or
** subquery the loop is part of.  The main query has a select-id of zero.
** The select-id is the same value as is output in the first column
** of an [EXPLAIN QUERY PLAN] query.
** </dl>
*/
#define SQLITE_SCANSTAT_NLOOP    0
#define SQLITE_SCANSTAT_NVISIT   1
#define SQLITE_SCANSTAT_EST      2
#define SQLITE_SCANSTAT_NAME     3
#define SQLITE_SCANSTAT_EXPLAIN  4
#define SQLITE_SCANSTAT_SELECTID 5
/*
** CAPI3REF: Prepared Statement Scan Status
** METHOD: sqlite3_stmt
**
** This interface returns information about the predicted and measured
** performance for pStmt.  Advanced applications can use this
** interface to compare the predicted and the measured performance and
** issue warnings and/or rerun [ANALYZE] if discrepancies are found.
**
** Since this interface is expected to be rarely used, it is only
** available if SQLite is compiled using the [SQLITE_ENABLE_STMT_SCANSTATUS]
** compile-time option.
**
** The "iScanStatusOp" parameter determines which status information to return.
** The "iScanStatusOp" must be one of the [scanstatus options] or the behavior
** of this interface is undefined.
** ^The requested measurement is written into a variable pointed to by
** the "pOut" parameter.
** Parameter "idx" identifies the specific loop to retrieve statistics for.
** Loops are numbered starting from zero. ^If idx is out of range - less than
** zero or greater than or equal to the total number of loops used to implement
** the statement - a non-zero value is returned and the variable that pOut
** points to is unchanged.
**
** ^Statistics might not be available for all loops in all statements. ^In cases
** where there exist loops with no available statistics, this function behaves
** as if the loop did not exist - it returns non-zero and leave the variable
** that pOut points to unchanged.
**
** See also: [sqlite3_stmt_scanstatus_reset()]
*/
SQLITE_API int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,
  int idx,
  int iScanStatusOp,
  void *pOut
);
/*
** CAPI3REF: Zero Scan-Status Counters
** METHOD: sqlite3_stmt
**
** ^Zero all [sqlite3_stmt_scanstatus()] related event counters.
**
** This API is only available if the library is built with pre-processor
** symbol [SQLITE_ENABLE_STMT_SCANSTATUS] defined.
*/
SQLITE_API void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
/*
** CAPI3REF: Flush caches to disk mid-transaction
**
** ^If a write-transaction is open on [database connection] D when the
** [sqlite3_db_cacheflush(D)] interface invoked, any dirty
** pages in the pager-cache that are not currently in use are written out
** to disk. A dirty page may be in use if a database cursor created by an
** active SQL statement is reading from it, or if it is page 1 of a database
** file (page 1 is always "in use").  ^The [sqlite3_db_cacheflush(D)]
** interface flushes caches for all schemas - "main", "temp", and
** any [attached] databases.
**
** ^If this function needs to obtain extra database locks before dirty pages
** can be flushed to disk, it does so. ^If those locks cannot be obtained
** immediately and there is a busy-handler callback configured, it is invoked
** in the usual manner. ^If the required lock still cannot be obtained, then
** the database is skipped and an attempt made to flush any dirty pages
** belonging to the next (if any) database. ^If any databases are skipped
** because locks cannot be obtained, but no other error occurs, this
** function returns SQLITE_BUSY.
**
** ^If any other error occurs while flushing dirty pages to disk (for
** example an IO error or out-of-memory condition), then processing is
** abandoned and an SQLite [error code] is returned to the caller immediately.
**
** ^Otherwise, if no error occurs, [sqlite3_db_cacheflush()] returns SQLITE_OK.
**
** ^This function does not set the database handle error code or message
** returned by the [sqlite3_errcode()] and [sqlite3_errmsg()] functions.
*/
SQLITE_API int sqlite3_db_cacheflush(sqlite3*);
/*
** CAPI3REF: The pre-update hook.
**
** ^These interfaces are only available if SQLite is compiled using the
** [SQLITE_ENABLE_PREUPDATE_HOOK] compile-time option.
**
** ^The [sqlite3_preupdate_hook()] interface registers a callback function
** that is invoked prior to each [INSERT], [UPDATE], and [DELETE] operation
** on a database table.
** ^At most one preupdate hook may be registered at a time on a single
** [database connection]; each call to [sqlite3_preupdate_hook()] overrides
** the previous setting.
** ^The preupdate hook is disabled by invoking [sqlite3_preupdate_hook()]
** with a NULL pointer as the second parameter.
** ^The third parameter to [sqlite3_preupdate_hook()] is passed through as
** the first parameter to callbacks.
**
** ^The preupdate hook only fires for changes to real database tables; the
** preupdate hook is not invoked for changes to [virtual tables] or to
** system tables like sqlite_master or sqlite_stat1.
**
** ^The second parameter to the preupdate callback is a pointer to
** the [database connection] that registered the preupdate hook.
** ^The third parameter to the preupdate callback is one of the constants
** [SQLITE_INSERT], [SQLITE_DELETE], or [SQLITE_UPDATE] to identify the
** kind of update operation that is about to occur.
** ^(The fourth parameter to the preupdate callback is the name of the
** database within the database connection that is being modified.  This
** will be "main" for the main database or "temp" for TEMP tables or
** the name given after the AS keyword in the [ATTACH] statement for attached
** databases.)^
** ^The fifth parameter to the preupdate callback is the name of the
** table that is being modified.
**
** For an UPDATE or DELETE operation on a [rowid table], the sixth
** parameter passed to the preupdate callback is the initial [rowid] of the
** row being modified or deleted. For an INSERT operation on a rowid table,
** or any operation on a WITHOUT ROWID table, the value of the sixth
** parameter is undefined. For an INSERT or UPDATE on a rowid table the
** seventh parameter is the final rowid value of the row being inserted
** or updated. The value of the seventh parameter passed to the callback
** function is not defined for operations on WITHOUT ROWID tables, or for
** INSERT operations on rowid tables.
**
** The [sqlite3_preupdate_old()], [sqlite3_preupdate_new()],
** [sqlite3_preupdate_count()], and [sqlite3_preupdate_depth()] interfaces
** provide additional information about a preupdate event. These routines
** may only be called from within a preupdate callback.  Invoking any of
** these routines from outside of a preupdate callback or with a
** [database connection] pointer that is different from the one supplied
** to the preupdate callback results in undefined and probably undesirable
** behavior.
**
** ^The [sqlite3_preupdate_count(D)] interface returns the number of columns
** in the row that is being inserted, updated, or deleted.
**
** ^The [sqlite3_preupdate_old(D,N,P)] interface writes into P a pointer to
** a [protected sqlite3_value] that contains the value of the Nth column of
** the table row before it is updated.  The N parameter must be between 0
** and one less than the number of columns or the behavior will be
** undefined. This must only be used within SQLITE_UPDATE and SQLITE_DELETE
** preupdate callbacks; if it is used by an SQLITE_INSERT callback then the
** behavior is undefined.  The [sqlite3_value] that P points to
** will be destroyed when the preupdate callback returns.
**
** ^The [sqlite3_preupdate_new(D,N,P)] interface writes into P a pointer to
** a [protected sqlite3_value] that contains the value of the Nth column of
** the table row after it is updated.  The N parameter must be between 0
** and one less than the number of columns or the behavior will be
** undefined. This must only be used within SQLITE_INSERT and SQLITE_UPDATE
** preupdate callbacks; if it is used by an SQLITE_DELETE callback then the
** behavior is undefined.  The [sqlite3_value] that P points to
** will be destroyed when the preupdate callback returns.
**
** ^The [sqlite3_preupdate_depth(D)] interface returns 0 if the preupdate
** callback was invoked as a result of a direct insert, update, or delete
** operation; or 1 for inserts, updates, or deletes invoked by top-level
** triggers; or 2 for changes resulting from triggers called by top-level
** triggers; and so forth.
**
** See also:  [sqlite3_update_hook()]
*/
#if defined(SQLITE_ENABLE_PREUPDATE_HOOK)
SQLITE_API void *sqlite3_preupdate_hook(
  sqlite3 *db,
  void(*xPreUpdate)(
    void *pCtx,
    sqlite3 *db,
    int op,
    char const *zDb,
    char const *zName,
    sqlite3_int64 iKey1,
    sqlite3_int64 iKey2
  ),
  void*
);
SQLITE_API int sqlite3_preupdate_old(sqlite3 *, int, sqlite3_value **);
SQLITE_API int sqlite3_preupdate_count(sqlite3 *);
SQLITE_API int sqlite3_preupdate_depth(sqlite3 *);
SQLITE_API int sqlite3_preupdate_new(sqlite3 *, int, sqlite3_value **);
#endif
/*
** CAPI3REF: Low-level system error code
**
** ^Attempt to return the underlying operating system error code or error
** number that caused the most recent I/O error or failure to open a file.
** The return value is OS-dependent.  For example, on unix systems, after
** [sqlite3_open_v2()] returns [SQLITE_CANTOPEN], this interface could be
** called to get back the underlying "errno" that caused the problem, such
** as ENOSPC, EAUTH, EISDIR, and so forth.
*/
SQLITE_API int sqlite3_system_errno(sqlite3*);
/*
** CAPI3REF: Database Snapshot
** KEYWORDS: {snapshot} {sqlite3_snapshot}
** EXPERIMENTAL
**
** An instance of the snapshot object records the state of a [WAL mode]
** database for some specific point in history.
**
** In [WAL mode], multiple [database connections] that are open on the
** same database file can each be reading a different historical version
** of the database file.  When a [database connection] begins a read
** transaction, that connection sees an unchanging copy of the database
** as it existed for the point in time when the transaction first started.
** Subsequent changes to the database from other connections are not seen
** by the reader until a new read transaction is started.
**
** The sqlite3_snapshot object records state information about an historical
** version of the database file so that it is possible to later open a new read
** transaction that sees that historical version of the database rather than
** the most recent version.
**
** The constructor for this object is [sqlite3_snapshot_get()].  The
** [sqlite3_snapshot_open()] method causes a fresh read transaction to refer
** to an historical snapshot (if possible).  The destructor for
** sqlite3_snapshot objects is [sqlite3_snapshot_free()].
*/
typedef struct sqlite3_snapshot {
  unsigned char hidden[48];
} sqlite3_snapshot;
/*
** CAPI3REF: Record A Database Snapshot
** EXPERIMENTAL
**
** ^The [sqlite3_snapshot_get(D,S,P)] interface attempts to make a
** new [sqlite3_snapshot] object that records the current state of
** schema S in database connection D.  ^On success, the
** [sqlite3_snapshot_get(D,S,P)] interface writes a pointer to the newly
** created [sqlite3_snapshot] object into *P and returns SQLITE_OK.
** If there is not already a read-transaction open on schema S when
** this function is called, one is opened automatically.
**
** The following must be true for this function to succeed. If any of
** the following statements are false when sqlite3_snapshot_get() is
** called, SQLITE_ERROR is returned. The final value of *P is undefined
** in this case.
**
** <ul>
**   <li> The database handle must be in [autocommit mode].
**
**   <li> Schema S of [database connection] D must be a [WAL mode] database.
**
**   <li> There must not be a write transaction open on schema S of database
**        connection D.
**
**   <li> One or more transactions must have been written to the current wal
**        file since it was created on disk (by any connection). This means
**        that a snapshot cannot be taken on a wal mode database with no wal
**        file immediately after it is first opened. At least one transaction
**        must be written to it first.
** </ul>
**
** This function may also return SQLITE_NOMEM.  If it is called with the
** database handle in autocommit mode but fails for some other reason,
** whether or not a read transaction is opened on schema S is undefined.
**
** The [sqlite3_snapshot] object returned from a successful call to
** [sqlite3_snapshot_get()] must be freed using [sqlite3_snapshot_free()]
** to avoid a memory leak.
**
** The [sqlite3_snapshot_get()] interface is only available when the
** SQLITE_ENABLE_SNAPSHOT compile-time option is used.
*/
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_get(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot **ppSnapshot
);
/*
** CAPI3REF: Start a read transaction on an historical snapshot
** EXPERIMENTAL
**
** ^The [sqlite3_snapshot_open(D,S,P)] interface starts a
** read transaction for schema S of
** [database connection] D such that the read transaction
** refers to historical [snapshot] P, rather than the most
** recent change to the database.
** ^The [sqlite3_snapshot_open()] interface returns SQLITE_OK on success
** or an appropriate [error code] if it fails.
**
** ^In order to succeed, a call to [sqlite3_snapshot_open(D,S,P)] must be
** the first operation following the [BEGIN] that takes the schema S
** out of [autocommit mode].
** ^In other words, schema S must not currently be in
** a transaction for [sqlite3_snapshot_open(D,S,P)] to work, but the
** database connection D must be out of [autocommit mode].
** ^A [snapshot] will fail to open if it has been overwritten by a
** [checkpoint].
** ^(A call to [sqlite3_snapshot_open(D,S,P)] will fail if the
** database connection D does not know that the database file for
** schema S is in [WAL mode].  A database connection might not know
** that the database file is in [WAL mode] if there has been no prior
** I/O on that database connection, or if the database entered [WAL mode]
** after the most recent I/O on the database connection.)^
** (Hint: Run "[PRAGMA application_id]" against a newly opened
** database connection in order to make it ready to use snapshots.)
**
** The [sqlite3_snapshot_open()] interface is only available when the
** SQLITE_ENABLE_SNAPSHOT compile-time option is used.
*/
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_open(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot *pSnapshot
);
/*
** CAPI3REF: Destroy a snapshot
** EXPERIMENTAL
**
** ^The [sqlite3_snapshot_free(P)] interface destroys [sqlite3_snapshot] P.
** The application must eventually free every [sqlite3_snapshot] object
** using this routine to avoid a memory leak.
**
** The [sqlite3_snapshot_free()] interface is only available when the
** SQLITE_ENABLE_SNAPSHOT compile-time option is used.
*/
SQLITE_API SQLITE_EXPERIMENTAL void sqlite3_snapshot_free(sqlite3_snapshot*);
/*
** CAPI3REF: Compare the ages of two snapshot handles.
** EXPERIMENTAL
**
** The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages
** of two valid snapshot handles.
**
** If the two snapshot handles are not associated with the same database
** file, the result of the comparison is undefined.
**
** Additionally, the result of the comparison is only valid if both of the
** snapshot handles were obtained by calling sqlite3_snapshot_get() since the
** last time the wal file was deleted. The wal file is deleted when the
** database is changed back to rollback mode or when the number of database
** clients drops to zero. If either snapshot handle was obtained before the
** wal file was last deleted, the value returned by this function
** is undefined.
**
** Otherwise, this API returns a negative value if P1 refers to an older
** snapshot than P2, zero if the two handles refer to the same database
** snapshot, and a positive value if P1 is a newer snapshot than P2.
*/
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_cmp(
  sqlite3_snapshot *p1,
  sqlite3_snapshot *p2
);
/*
** CAPI3REF: Recover snapshots from a wal file
** EXPERIMENTAL
**
** If all connections disconnect from a database file but do not perform
** a checkpoint, the existing wal file is opened along with the database
** file the next time the database is opened. At this point it is only
** possible to successfully call sqlite3_snapshot_open() to open the most
** recent snapshot of the database (the one at the head of the wal file),
** even though the wal file may contain other valid snapshots for which
** clients have sqlite3_snapshot handles.
**
** This function attempts to scan the wal file associated with database zDb
** of database handle db and make all valid snapshots available to
** sqlite3_snapshot_open(). It is an error if there is already a read
** transaction open on the database, or if the database is not a wal mode
** database.
**
** SQLITE_OK is returned if successful, or an SQLite error code otherwise.
*/
SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);
/*
** Undo the hack that converts floating point types to integer for
** builds on processors without floating point support.
*/
#ifdef SQLITE_OMIT_FLOATING_POINT
# undef double
#endif
#ifdef __cplusplus
}
#endif
#endif
/******** Begin file sqlite3rtree.h *********/
/*
** 2010 August 30
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
*/
#ifndef _SQLITE3RTREE_H_
#define _SQLITE3RTREE_H_
#ifdef __cplusplus
extern "C" {
#endif
typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;
typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;
/* The double-precision datatype used by RTree depends on the
** SQLITE_RTREE_INT_ONLY compile-time option.
*/
#ifdef SQLITE_RTREE_INT_ONLY
  typedef sqlite3_int64 sqlite3_rtree_dbl;
#else
  typedef double sqlite3_rtree_dbl;
#endif
/*
** Register a geometry callback named zGeom that can be used as part of an
** R-Tree geometry query as follows:
**
**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zGeom(... params ...)
*/
SQLITE_API int sqlite3_rtree_geometry_callback(
  sqlite3 *db,
  const char *zGeom,
  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),
  void *pContext
);
/*
** A pointer to a structure of the following type is passed as the first
** argument to callbacks registered using rtree_geometry_callback().
*/
struct sqlite3_rtree_geometry {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void *);
};
/*
** Register a 2nd-generation geometry callback named zScore that can be
** used as part of an R-Tree geometry query as follows:
**
**   SELECT ... FROM <rtree> WHERE <rtree col> MATCH $zQueryFunc(... params ...)
*/
SQLITE_API int sqlite3_rtree_query_callback(
  sqlite3 *db,
  const char *zQueryFunc,
  int (*xQueryFunc)(sqlite3_rtree_query_info*),
  void *pContext,
  void (*xDestructor)(void*)
);
/*
** A pointer to a structure of the following type is passed as the
** argument to scored geometry callback registered using
** sqlite3_rtree_query_callback().
**
** Note that the first 5 fields of this structure are identical to
** sqlite3_rtree_geometry.  This structure is a subclass of
** sqlite3_rtree_geometry.
*/
struct sqlite3_rtree_query_info {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void*);
  sqlite3_rtree_dbl *aCoord;
  unsigned int *anQueue;
  int nCoord;
  int iLevel;
  int mxLevel;
  sqlite3_int64 iRowid;
  sqlite3_rtree_dbl rParentScore;
  int eParentWithin;
  int eWithin;
  sqlite3_rtree_dbl rScore;
  /* The following fields are only available in 3.8.11 and later */
  sqlite3_value **apSqlParam;
};
/*
** Allowed values for sqlite3_rtree_query.eWithin and .eParentWithin.
*/
#define NOT_WITHIN       0
#define PARTLY_WITHIN    1
#define FULLY_WITHIN     2
#ifdef __cplusplus
}
#endif
#endif
/******** End of sqlite3rtree.h *********/
/******** Begin file sqlite3session.h *********/
#if !defined(__SQLITESESSION_H_) && defined(SQLITE_ENABLE_SESSION)
#define __SQLITESESSION_H_ 1
/*
** Make sure we can call this stuff from C++.
*/
#ifdef __cplusplus
extern "C" {
#endif
/*
** CAPI3REF: Session Object Handle
*/
typedef struct sqlite3_session sqlite3_session;
/*
** CAPI3REF: Changeset Iterator Handle
*/
typedef struct sqlite3_changeset_iter sqlite3_changeset_iter;
/*
** CAPI3REF: Create A New Session Object
**
** Create a new session object attached to database handle db. If successful,
** a pointer to the new object is written to *ppSession and SQLITE_OK is
** returned. If an error occurs, *ppSession is set to NULL and an SQLite
** error code (e.g. SQLITE_NOMEM) is returned.
**
** It is possible to create multiple session objects attached to a single
** database handle.
**
** Session objects created using this function should be deleted using the
** [sqlite3session_delete()] function before the database handle that they
** are attached to is itself closed. If the database handle is closed before
** the session object is deleted, then the results of calling any session
** module function, including [sqlite3session_delete()] on the session object
** are undefined.
**
** Because the session module uses the [sqlite3_preupdate_hook()] API, it
** is not possible for an application to register a pre-update hook on a
** database handle that has one or more session objects attached. Nor is
** it possible to create a session object attached to a database handle for
** which a pre-update hook is already defined. The results of attempting
** either of these things are undefined.
**
** The session object will be used to create changesets for tables in
** database zDb, where zDb is either "main", or "temp", or the name of an
** attached database. It is not an error if database zDb is not attached
** to the database when the session object is created.
*/
SQLITE_API int sqlite3session_create(
  sqlite3 *db,
  const char *zDb,
  sqlite3_session **ppSession
);
/*
** CAPI3REF: Delete A Session Object
**
** Delete a session object previously allocated using
** [sqlite3session_create()]. Once a session object has been deleted, the
** results of attempting to use pSession with any other session module
** function are undefined.
**
** Session objects must be deleted before the database handle to which they
** are attached is closed. Refer to the documentation for
** [sqlite3session_create()] for details.
*/
SQLITE_API void sqlite3session_delete(sqlite3_session *pSession);
/*
** CAPI3REF: Enable Or Disable A Session Object
**
** Enable or disable the recording of changes by a session object. When
** enabled, a session object records changes made to the database. When
** disabled - it does not. A newly created session object is enabled.
** Refer to the documentation for [sqlite3session_changeset()] for further
** details regarding how enabling and disabling a session object affects
** the eventual changesets.
**
** Passing zero to this function disables the session. Passing a value
** greater than zero enables it. Passing a value less than zero is a
** no-op, and may be used to query the current state of the session.
**
** The return value indicates the final state of the session object: 0 if
** the session is disabled, or 1 if it is enabled.
*/
SQLITE_API int sqlite3session_enable(sqlite3_session *pSession, int bEnable);
/*
** CAPI3REF: Set Or Clear the Indirect Change Flag
**
** Each change recorded by a session object is marked as either direct or
** indirect. A change is marked as indirect if either:
**
** <ul>
**   <li> The session object "indirect" flag is set when the change is
**        made, or
**   <li> The change is made by an SQL trigger or foreign key action
**        instead of directly as a result of a users SQL statement.
** </ul>
**
** If a single row is affected by more than one operation within a session,
** then the change is considered indirect if all operations meet the criteria
** for an indirect change above, or direct otherwise.
**
** This function is used to set, clear or query the session object indirect
** flag.  If the second argument passed to this function is zero, then the
** indirect flag is cleared. If it is greater than zero, the indirect flag
** is set. Passing a value less than zero does not modify the current value
** of the indirect flag, and may be used to query the current state of the
** indirect flag for the specified session object.
**
** The return value indicates the final state of the indirect flag: 0 if
** it is clear, or 1 if it is set.
*/
SQLITE_API int sqlite3session_indirect(sqlite3_session *pSession, int bIndirect);
/*
** CAPI3REF: Attach A Table To A Session Object
**
** If argument zTab is not NULL, then it is the name of a table to attach
** to the session object passed as the first argument. All subsequent changes
** made to the table while the session object is enabled will be recorded. See
** documentation for [sqlite3session_changeset()] for further details.
**
** Or, if argument zTab is NULL, then changes are recorded for all tables
** in the database. If additional tables are added to the database (by
** executing "CREATE TABLE" statements) after this call is made, changes for
** the new tables are also recorded.
**
** Changes can only be recorded for tables that have a PRIMARY KEY explicitly
** defined as part of their CREATE TABLE statement. It does not matter if the
** PRIMARY KEY is an "INTEGER PRIMARY KEY" (rowid alias) or not. The PRIMARY
** KEY may consist of a single column, or may be a composite key.
**
** It is not an error if the named table does not exist in the database. Nor
** is it an error if the named table does not have a PRIMARY KEY. However,
** no changes will be recorded in either of these scenarios.
**
** Changes are not recorded for individual rows that have NULL values stored
** in one or more of their PRIMARY KEY columns.
**
** SQLITE_OK is returned if the call completes without error. Or, if an error
** occurs, an SQLite error code (e.g. SQLITE_NOMEM) is returned.
**
** <h3>Special sqlite_stat1 Handling</h3>
**
** As of SQLite version 3.22.0, the "sqlite_stat1" table is an exception to
** some of the rules above. In SQLite, the schema of sqlite_stat1 is:
**  <pre>
**  &nbsp;     CREATE TABLE sqlite_stat1(tbl,idx,stat)
**  </pre>
**
** Even though sqlite_stat1 does not have a PRIMARY KEY, changes are
** recorded for it as if the PRIMARY KEY is (tbl,idx). Additionally, changes
** are recorded for rows for which (idx IS NULL) is true. However, for such
** rows a zero-length blob (SQL value X'') is stored in the changeset or
** patchset instead of a NULL value. This allows such changesets to be
** manipulated by legacy implementations of sqlite3changeset_invert(),
** concat() and similar.
**
** The sqlite3changeset_apply() function automatically converts the
** zero-length blob back to a NULL value when updating the sqlite_stat1
** table. However, if the application calls sqlite3changeset_new(),
** sqlite3changeset_old() or sqlite3changeset_conflict on a changeset
** iterator directly (including on a changeset iterator passed to a
** conflict-handler callback) then the X'' value is returned. The application
** must translate X'' to NULL itself if required.
**
** Legacy (older than 3.22.0) versions of the sessions module cannot capture
** changes made to the sqlite_stat1 table. Legacy versions of the
** sqlite3changeset_apply() function silently ignore any modifications to the
** sqlite_stat1 table that are part of a changeset or patchset.
*/
SQLITE_API int sqlite3session_attach(
  sqlite3_session *pSession,
  const char *zTab
);
/*
** CAPI3REF: Set a table filter on a Session Object.
**
** The second argument (xFilter) is the "filter callback". For changes to rows
** in tables that are not attached to the Session object, the filter is called
** to determine whether changes to the table's rows should be tracked or not.
** If xFilter returns 0, changes is not tracked. Note that once a table is
** attached, xFilter will not be called again.
*/
SQLITE_API void sqlite3session_table_filter(
  sqlite3_session *pSession,
  int(*xFilter)(
    void *pCtx,
    const char *zTab
  ),
  void *pCtx
);
/*
** CAPI3REF: Generate A Changeset From A Session Object
**
** Obtain a changeset containing changes to the tables attached to the
** session object passed as the first argument. If successful,
** set *ppChangeset to point to a buffer containing the changeset
** and *pnChangeset to the size of the changeset in bytes before returning
** SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to
** zero and return an SQLite error code.
**
** A changeset consists of zero or more INSERT, UPDATE and/or DELETE changes,
** each representing a change to a single row of an attached table. An INSERT
** change contains the values of each field of a new database row. A DELETE
** contains the original values of each field of a deleted database row. An
** UPDATE change contains the original values of each field of an updated
** database row along with the updated values for each updated non-primary-key
** column. It is not possible for an UPDATE change to represent a change that
** modifies the values of primary key columns. If such a change is made, it
** is represented in a changeset as a DELETE followed by an INSERT.
**
** Changes are not recorded for rows that have NULL values stored in one or
** more of their PRIMARY KEY columns. If such a row is inserted or deleted,
** no corresponding change is present in the changesets returned by this
** function. If an existing row with one or more NULL values stored in
** PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL,
** only an INSERT is appears in the changeset. Similarly, if an existing row
** with non-NULL PRIMARY KEY values is updated so that one or more of its
** PRIMARY KEY columns are set to NULL, the resulting changeset contains a
** DELETE change only.
**
** The contents of a changeset may be traversed using an iterator created
** using the [sqlite3changeset_start()] API. A changeset may be applied to
** a database with a compatible schema using the [sqlite3changeset_apply()]
** API.
**
** Within a changeset generated by this function, all changes related to a
** single table are grouped together. In other words, when iterating through
** a changeset or when applying a changeset to a database, all changes related
** to a single table are processed before moving on to the next table. Tables
** are sorted in the same order in which they were attached (or auto-attached)
** to the sqlite3_session object. The order in which the changes related to
** a single table are stored is undefined.
**
** Following a successful call to this function, it is the responsibility of
** the caller to eventually free the buffer that *ppChangeset points to using
** [sqlite3_free()].
**
** <h3>Changeset Generation</h3>
**
** Once a table has been attached to a session object, the session object
** records the primary key values of all new rows inserted into the table.
** It also records the original primary key and other column values of any
** deleted or updated rows. For each unique primary key value, data is only
** recorded once - the first time a row with said primary key is inserted,
** updated or deleted in the lifetime of the session.
**
** There is one exception to the previous paragraph: when a row is inserted,
** updated or deleted, if one or more of its primary key columns contain a
** NULL value, no record of the change is made.
**
** The session object therefore accumulates two types of records - those
** that consist of primary key values only (created when the user inserts
** a new record) and those that consist of the primary key values and the
** original values of other table columns (created when the users deletes
** or updates a record).
**
** When this function is called, the requested changeset is created using
** both the accumulated records and the current contents of the database
** file. Specifically:
**
** <ul>
**   <li> For each record generated by an insert, the database is queried
**        for a row with a matching primary key. If one is found, an INSERT
**        change is added to the changeset. If no such row is found, no change
**        is added to the changeset.
**
**   <li> For each record generated by an update or delete, the database is
**        queried for a row with a matching primary key. If such a row is
**        found and one or more of the non-primary key fields have been
**        modified from their original values, an UPDATE change is added to
**        the changeset. Or, if no such row is found in the table, a DELETE
**        change is added to the changeset. If there is a row with a matching
**        primary key in the database, but all fields contain their original
**        values, no change is added to the changeset.
** </ul>
**
** This means, amongst other things, that if a row is inserted and then later
** deleted while a session object is active, neither the insert nor the delete
** will be present in the changeset. Or if a row is deleted and then later a
** row with the same primary key values inserted while a session object is
** active, the resulting changeset will contain an UPDATE change instead of
** a DELETE and an INSERT.
**
** When a session object is disabled (see the [sqlite3session_enable()] API),
** it does not accumulate records when rows are inserted, updated or deleted.
** This may appear to have some counter-intuitive effects if a single row
** is written to more than once during a session. For example, if a row
** is inserted while a session object is enabled, then later deleted while
** the same session object is disabled, no INSERT record will appear in the
** changeset, even though the delete took place while the session was disabled.
** Or, if one field of a row is updated while a session is disabled, and
** another field of the same row is updated while the session is enabled, the
** resulting changeset will contain an UPDATE change that updates both fields.
*/
SQLITE_API int sqlite3session_changeset(
  sqlite3_session *pSession,
  int *pnChangeset,
  void **ppChangeset
);
/*
** CAPI3REF: Load The Difference Between Tables Into A Session
**
** If it is not already attached to the session object passed as the first
** argument, this function attaches table zTbl in the same manner as the
** [sqlite3session_attach()] function. If zTbl does not exist, or if it
** does not have a primary key, this function is a no-op (but does not return
** an error).
**
** Argument zFromDb must be the name of a database ("main", "temp" etc.)
** attached to the same database handle as the session object that contains
** a table compatible with the table attached to the session by this function.
** A table is considered compatible if it:
**
** <ul>
**   <li> Has the same name,
**   <li> Has the same set of columns declared in the same order, and
**   <li> Has the same PRIMARY KEY definition.
** </ul>
**
** If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables
** are compatible but do not have any PRIMARY KEY columns, it is not an error
** but no changes are added to the session object. As with other session
** APIs, tables without PRIMARY KEYs are simply ignored.
**
** This function adds a set of changes to the session object that could be
** used to update the table in database zFrom (call this the "from-table")
** so that its content is the same as the table attached to the session
** object (call this the "to-table"). Specifically:
**
** <ul>
**   <li> For each row (primary key) that exists in the to-table but not in
**     the from-table, an INSERT record is added to the session object.
**
**   <li> For each row (primary key) that exists in the to-table but not in
**     the from-table, a DELETE record is added to the session object.
**
**   <li> For each row (primary key) that exists in both tables, but features
**     different non-PK values in each, an UPDATE record is added to the
**     session.
** </ul>
**
** To clarify, if this function is called and then a changeset constructed
** using [sqlite3session_changeset()], then after applying that changeset to
** database zFrom the contents of the two compatible tables would be
** identical.
**
** It an error if database zFrom does not exist or does not contain the
** required compatible table.
**
** If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite
** error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg
** may be set to point to a buffer containing an English language error
** message. It is the responsibility of the caller to free this buffer using
** sqlite3_free().
*/
SQLITE_API int sqlite3session_diff(
  sqlite3_session *pSession,
  const char *zFromDb,
  const char *zTbl,
  char **pzErrMsg
);
/*
** CAPI3REF: Generate A Patchset From A Session Object
**
** The differences between a patchset and a changeset are that:
**
** <ul>
**   <li> DELETE records consist of the primary key fields only. The
**        original values of other fields are omitted.
**   <li> The original values of any modified fields are omitted from
**        UPDATE records.
** </ul>
**
** A patchset blob may be used with up to date versions of all
** sqlite3changeset_xxx API functions except for sqlite3changeset_invert(),
** which returns SQLITE_CORRUPT if it is passed a patchset. Similarly,
** attempting to use a patchset blob with old versions of the
** sqlite3changeset_xxx APIs also provokes an SQLITE_CORRUPT error.
**
** Because the non-primary key "old.*" fields are omitted, no
** SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset
** is passed to the sqlite3changeset_apply() API. Other conflict types work
** in the same way as for changesets.
**
** Changes within a patchset are ordered in the same way as for changesets
** generated by the sqlite3session_changeset() function (i.e. all changes for
** a single table are grouped together, tables appear in the order in which
** they were attached to the session object).
*/
SQLITE_API int sqlite3session_patchset(
  sqlite3_session *pSession,
  int *pnPatchset,
  void **ppPatchset
);
/*
** CAPI3REF: Test if a changeset has recorded any changes.
**
** Return non-zero if no changes to attached tables have been recorded by
** the session object passed as the first argument. Otherwise, if one or
** more changes have been recorded, return zero.
**
** Even if this function returns zero, it is possible that calling
** [sqlite3session_changeset()] on the session handle may still return a
** changeset that contains no changes. This can happen when a row in
** an attached table is modified and then later on the original values
** are restored. However, if this function returns non-zero, then it is
** guaranteed that a call to sqlite3session_changeset() will return a
** changeset containing zero changes.
*/
SQLITE_API int sqlite3session_isempty(sqlite3_session *pSession);
/*
** CAPI3REF: Create An Iterator To Traverse A Changeset
**
** Create an iterator used to iterate through the contents of a changeset.
** If successful, *pp is set to point to the iterator handle and SQLITE_OK
** is returned. Otherwise, if an error occurs, *pp is set to zero and an
** SQLite error code is returned.
**
** The following functions can be used to advance and query a changeset
** iterator created by this function:
**
** <ul>
**   <li> [sqlite3changeset_next()]
**   <li> [sqlite3changeset_op()]
**   <li> [sqlite3changeset_new()]
**   <li> [sqlite3changeset_old()]
** </ul>
**
** It is the responsibility of the caller to eventually destroy the iterator
** by passing it to [sqlite3changeset_finalize()]. The buffer containing the
** changeset (pChangeset) must remain valid until after the iterator is
** destroyed.
**
** Assuming the changeset blob was created by one of the
** [sqlite3session_changeset()], [sqlite3changeset_concat()] or
** [sqlite3changeset_invert()] functions, all changes within the changeset
** that apply to a single table are grouped together. This means that when
** an application iterates through a changeset using an iterator created by
** this function, all changes that relate to a single table are visited
** consecutively. There is no chance that the iterator will visit a change
** the applies to table X, then one for table Y, and then later on visit
** another change for table X.
*/
SQLITE_API int sqlite3changeset_start(
  sqlite3_changeset_iter **pp,
  int nChangeset,
  void *pChangeset
);
/*
** CAPI3REF: Advance A Changeset Iterator
**
** This function may only be used with iterators created by function
** [sqlite3changeset_start()]. If it is called on an iterator passed to
** a conflict-handler callback by [sqlite3changeset_apply()], SQLITE_MISUSE
** is returned and the call has no effect.
**
** Immediately after an iterator is created by sqlite3changeset_start(), it
** does not point to any change in the changeset. Assuming the changeset
** is not empty, the first call to this function advances the iterator to
** point to the first change in the changeset. Each subsequent call advances
** the iterator to point to the next change in the changeset (if any). If
** no error occurs and the iterator points to a valid change after a call
** to sqlite3changeset_next() has advanced it, SQLITE_ROW is returned.
** Otherwise, if all changes in the changeset have already been visited,
** SQLITE_DONE is returned.
**
** If an error occurs, an SQLite error code is returned. Possible error
** codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or
** SQLITE_NOMEM.
*/
SQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *pIter);
/*
** CAPI3REF: Obtain The Current Operation From A Changeset Iterator
**
** The pIter argument passed to this function may either be an iterator
** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
** created by [sqlite3changeset_start()]. In the latter case, the most recent
** call to [sqlite3changeset_next()] must have returned [SQLITE_ROW]. If this
** is not the case, this function returns [SQLITE_MISUSE].
**
** If argument pzTab is not NULL, then *pzTab is set to point to a
** nul-terminated utf-8 encoded string containing the name of the table
** affected by the current change. The buffer remains valid until either
** sqlite3changeset_next() is called on the iterator or until the
** conflict-handler function returns. If pnCol is not NULL, then *pnCol is
** set to the number of columns in the table affected by the change. If
** pbIncorrect is not NULL, then *pbIndirect is set to true (1) if the change
** is an indirect change, or false (0) otherwise. See the documentation for
** [sqlite3session_indirect()] for a description of direct and indirect
** changes. Finally, if pOp is not NULL, then *pOp is set to one of
** [SQLITE_INSERT], [SQLITE_DELETE] or [SQLITE_UPDATE], depending on the
** type of change that the iterator currently points to.
**
** If no error occurs, SQLITE_OK is returned. If an error does occur, an
** SQLite error code is returned. The values of the output variables may not
** be trusted in this case.
*/
SQLITE_API int sqlite3changeset_op(
  sqlite3_changeset_iter *pIter,
  const char **pzTab,
  int *pnCol,
  int *pOp,
  int *pbIndirect
);
/*
** CAPI3REF: Obtain The Primary Key Definition Of A Table
**
** For each modified table, a changeset includes the following:
**
** <ul>
**   <li> The number of columns in the table, and
**   <li> Which of those columns make up the tables PRIMARY KEY.
** </ul>
**
** This function is used to find which columns comprise the PRIMARY KEY of
** the table modified by the change that iterator pIter currently points to.
** If successful, *pabPK is set to point to an array of nCol entries, where
** nCol is the number of columns in the table. Elements of *pabPK are set to
** 0x01 if the corresponding column is part of the tables primary key, or
** 0x00 if it is not.
**
** If argument pnCol is not NULL, then *pnCol is set to the number of columns
** in the table.
**
** If this function is called when the iterator does not point to a valid
** entry, SQLITE_MISUSE is returned and the output variables zeroed. Otherwise,
** SQLITE_OK is returned and the output variables populated as described
** above.
*/
SQLITE_API int sqlite3changeset_pk(
  sqlite3_changeset_iter *pIter,
  unsigned char **pabPK,
  int *pnCol
);
/*
** CAPI3REF: Obtain old.* Values From A Changeset Iterator
**
** The pIter argument passed to this function may either be an iterator
** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
** created by [sqlite3changeset_start()]. In the latter case, the most recent
** call to [sqlite3changeset_next()] must have returned SQLITE_ROW.
** Furthermore, it may only be called if the type of change that the iterator
** currently points to is either [SQLITE_DELETE] or [SQLITE_UPDATE]. Otherwise,
** this function returns [SQLITE_MISUSE] and sets *ppValue to NULL.
**
** Argument iVal must be greater than or equal to 0, and less than the number
** of columns in the table affected by the current change. Otherwise,
** [SQLITE_RANGE] is returned and *ppValue is set to NULL.
**
** If successful, this function sets *ppValue to point to a protected
** sqlite3_value object containing the iVal'th value from the vector of
** original row values stored as part of the UPDATE or DELETE change and
** returns SQLITE_OK. The name of the function comes from the fact that this
** is similar to the "old.*" columns available to update or delete triggers.
**
** If some other error occurs (e.g. an OOM condition), an SQLite error code
** is returned and *ppValue is set to NULL.
*/
SQLITE_API int sqlite3changeset_old(
  sqlite3_changeset_iter *pIter,
  int iVal,
  sqlite3_value **ppValue
);
/*
** CAPI3REF: Obtain new.* Values From A Changeset Iterator
**
** The pIter argument passed to this function may either be an iterator
** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
** created by [sqlite3changeset_start()]. In the latter case, the most recent
** call to [sqlite3changeset_next()] must have returned SQLITE_ROW.
** Furthermore, it may only be called if the type of change that the iterator
** currently points to is either [SQLITE_UPDATE] or [SQLITE_INSERT]. Otherwise,
** this function returns [SQLITE_MISUSE] and sets *ppValue to NULL.
**
** Argument iVal must be greater than or equal to 0, and less than the number
** of columns in the table affected by the current change. Otherwise,
** [SQLITE_RANGE] is returned and *ppValue is set to NULL.
**
** If successful, this function sets *ppValue to point to a protected
** sqlite3_value object containing the iVal'th value from the vector of
** new row values stored as part of the UPDATE or INSERT change and
** returns SQLITE_OK. If the change is an UPDATE and does not include
** a new value for the requested column, *ppValue is set to NULL and
** SQLITE_OK returned. The name of the function comes from the fact that
** this is similar to the "new.*" columns available to update or delete
** triggers.
**
** If some other error occurs (e.g. an OOM condition), an SQLite error code
** is returned and *ppValue is set to NULL.
*/
SQLITE_API int sqlite3changeset_new(
  sqlite3_changeset_iter *pIter,
  int iVal,
  sqlite3_value **ppValue
);
/*
** CAPI3REF: Obtain Conflicting Row Values From A Changeset Iterator
**
** This function should only be used with iterator objects passed to a
** conflict-handler callback by [sqlite3changeset_apply()] with either
** [SQLITE_CHANGESET_DATA] or [SQLITE_CHANGESET_CONFLICT]. If this function
** is called on any other iterator, [SQLITE_MISUSE] is returned and *ppValue
** is set to NULL.
**
** Argument iVal must be greater than or equal to 0, and less than the number
** of columns in the table affected by the current change. Otherwise,
** [SQLITE_RANGE] is returned and *ppValue is set to NULL.
**
** If successful, this function sets *ppValue to point to a protected
** sqlite3_value object containing the iVal'th value from the
** "conflicting row" associated with the current conflict-handler callback
** and returns SQLITE_OK.
**
** If some other error occurs (e.g. an OOM condition), an SQLite error code
** is returned and *ppValue is set to NULL.
*/
SQLITE_API int sqlite3changeset_conflict(
  sqlite3_changeset_iter *pIter,
  int iVal,
  sqlite3_value **ppValue
);
/*
** CAPI3REF: Determine The Number Of Foreign Key Constraint Violations
**
** This function may only be called with an iterator passed to an
** SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case
** it sets the output variable to the total number of known foreign key
** violations in the destination database and returns SQLITE_OK.
**
** In all other cases this function returns SQLITE_MISUSE.
*/
SQLITE_API int sqlite3changeset_fk_conflicts(
  sqlite3_changeset_iter *pIter,
  int *pnOut
);
/*
** CAPI3REF: Finalize A Changeset Iterator
**
** This function is used to finalize an iterator allocated with
** [sqlite3changeset_start()].
**
** This function should only be called on iterators created using the
** [sqlite3changeset_start()] function. If an application calls this
** function with an iterator passed to a conflict-handler by
** [sqlite3changeset_apply()], [SQLITE_MISUSE] is immediately returned and the
** call has no effect.
**
** If an error was encountered within a call to an sqlite3changeset_xxx()
** function (for example an [SQLITE_CORRUPT] in [sqlite3changeset_next()] or an
** [SQLITE_NOMEM] in [sqlite3changeset_new()]) then an error code corresponding
** to that error is returned by this function. Otherwise, SQLITE_OK is
** returned. This is to allow the following pattern (pseudo-code):
**
**   sqlite3changeset_start();
**   while( SQLITE_ROW==sqlite3changeset_next() ){
**     // Do something with change.
**   }
**   rc = sqlite3changeset_finalize();
**   if( rc!=SQLITE_OK ){
**     // An error has occurred
**   }
*/
SQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter);
/*
** CAPI3REF: Invert A Changeset
**
** This function is used to "invert" a changeset object. Applying an inverted
** changeset to a database reverses the effects of applying the uninverted
** changeset. Specifically:
**
** <ul>
**   <li> Each DELETE change is changed to an INSERT, and
**   <li> Each INSERT change is changed to a DELETE, and
**   <li> For each UPDATE change, the old.* and new.* values are exchanged.
** </ul>
**
** This function does not change the order in which changes appear within
** the changeset. It merely reverses the sense of each individual change.
**
** If successful, a pointer to a buffer containing the inverted changeset
** is stored in *ppOut, the size of the same buffer is stored in *pnOut, and
** SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are
** zeroed and an SQLite error code returned.
**
** It is the responsibility of the caller to eventually call sqlite3_free()
** on the *ppOut pointer to free the buffer allocation following a successful
** call to this function.
**
** WARNING/TODO: This function currently assumes that the input is a valid
** changeset. If it is not, the results are undefined.
*/
SQLITE_API int sqlite3changeset_invert(
  int nIn, const void *pIn,
  int *pnOut, void **ppOut
);
/*
** CAPI3REF: Concatenate Two Changeset Objects
**
** This function is used to concatenate two changesets, A and B, into a
** single changeset. The result is a changeset equivalent to applying
** changeset A followed by changeset B.
**
** This function combines the two input changesets using an
** sqlite3_changegroup object. Calling it produces similar results as the
** following code fragment:
**
**   sqlite3_changegroup *pGrp;
**   rc = sqlite3_changegroup_new(&pGrp);
**   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nA, pA);
**   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nB, pB);
**   if( rc==SQLITE_OK ){
**     rc = sqlite3changegroup_output(pGrp, pnOut, ppOut);
**   }else{
**     *ppOut = 0;
**     *pnOut = 0;
**   }
**
** Refer to the sqlite3_changegroup documentation below for details.
*/
SQLITE_API int sqlite3changeset_concat(
  int nA,
  void *pA,
  int nB,
  void *pB,
  int *pnOut,
  void **ppOut
);
/*
** CAPI3REF: Changegroup Handle
*/
typedef struct sqlite3_changegroup sqlite3_changegroup;
/*
** CAPI3REF: Create A New Changegroup Object
**
** An sqlite3_changegroup object is used to combine two or more changesets
** (or patchsets) into a single changeset (or patchset). A single changegroup
** object may combine changesets or patchsets, but not both. The output is
** always in the same format as the input.
**
** If successful, this function returns SQLITE_OK and populates (*pp) with
** a pointer to a new sqlite3_changegroup object before returning. The caller
** should eventually free the returned object using a call to
** sqlite3changegroup_delete(). If an error occurs, an SQLite error code
** (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.
**
** The usual usage pattern for an sqlite3_changegroup object is as follows:
**
** <ul>
**   <li> It is created using a call to sqlite3changegroup_new().
**
**   <li> Zero or more changesets (or patchsets) are added to the object
**        by calling sqlite3changegroup_add().
**
**   <li> The result of combining all input changesets together is obtained
**        by the application via a call to sqlite3changegroup_output().
**
**   <li> The object is deleted using a call to sqlite3changegroup_delete().
** </ul>
**
** Any number of calls to add() and output() may be made between the calls to
** new() and delete(), and in any order.
**
** As well as the regular sqlite3changegroup_add() and
** sqlite3changegroup_output() functions, also available are the streaming
** versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().
*/
SQLITE_API int sqlite3changegroup_new(sqlite3_changegroup **pp);
/*
** CAPI3REF: Add A Changeset To A Changegroup
**
** Add all changes within the changeset (or patchset) in buffer pData (size
** nData bytes) to the changegroup.
**
** If the buffer contains a patchset, then all prior calls to this function
** on the same changegroup object must also have specified patchsets. Or, if
** the buffer contains a changeset, so must have the earlier calls to this
** function. Otherwise, SQLITE_ERROR is returned and no changes are added
** to the changegroup.
**
** Rows within the changeset and changegroup are identified by the values in
** their PRIMARY KEY columns. A change in the changeset is considered to
** apply to the same row as a change already present in the changegroup if
** the two rows have the same primary key.
**
** Changes to rows that do not already appear in the changegroup are
** simply copied into it. Or, if both the new changeset and the changegroup
** contain changes that apply to a single row, the final contents of the
** changegroup depends on the type of each change, as follows:
**
** <table border=1 style="margin-left:8ex;margin-right:8ex">
**   <tr><th style="white-space:pre">Existing Change  </th>
**       <th style="white-space:pre">New Change       </th>
**       <th>Output Change
**   <tr><td>INSERT <td>INSERT <td>
**       The new change is ignored. This case does not occur if the new
**       changeset was recorded immediately after the changesets already
**       added to the changegroup.
**   <tr><td>INSERT <td>UPDATE <td>
**       The INSERT change remains in the changegroup. The values in the
**       INSERT change are modified as if the row was inserted by the
**       existing change and then updated according to the new change.
**   <tr><td>INSERT <td>DELETE <td>
**       The existing INSERT is removed from the changegroup. The DELETE is
**       not added.
**   <tr><td>UPDATE <td>INSERT <td>
**       The new change is ignored. This case does not occur if the new
**       changeset was recorded immediately after the changesets already
**       added to the changegroup.
**   <tr><td>UPDATE <td>UPDATE <td>
**       The existing UPDATE remains within the changegroup. It is amended
**       so that the accompanying values are as if the row was updated once
**       by the existing change and then again by the new change.
**   <tr><td>UPDATE <td>DELETE <td>
**       The existing UPDATE is replaced by the new DELETE within the
**       changegroup.
**   <tr><td>DELETE <td>INSERT <td>
**       If one or more of the column values in the row inserted by the
**       new change differ from those in the row deleted by the existing
**       change, the existing DELETE is replaced by an UPDATE within the
**       changegroup. Otherwise, if the inserted row is exactly the same
**       as the deleted row, the existing DELETE is simply discarded.
**   <tr><td>DELETE <td>UPDATE <td>
**       The new change is ignored. This case does not occur if the new
**       changeset was recorded immediately after the changesets already
**       added to the changegroup.
**   <tr><td>DELETE <td>DELETE <td>
**       The new change is ignored. This case does not occur if the new
**       changeset was recorded immediately after the changesets already
**       added to the changegroup.
** </table>
**
** If the new changeset contains changes to a table that is already present
** in the changegroup, then the number of columns and the position of the
** primary key columns for the table must be consistent. If this is not the
** case, this function fails with SQLITE_SCHEMA. If the input changeset
** appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is
** returned. Or, if an out-of-memory condition occurs during processing, this
** function returns SQLITE_NOMEM. In all cases, if an error occurs the
** final contents of the changegroup is undefined.
**
** If no error occurs, SQLITE_OK is returned.
*/
SQLITE_API int sqlite3changegroup_add(sqlite3_changegroup*, int nData, void *pData);
/*
** CAPI3REF: Obtain A Composite Changeset From A Changegroup
**
** Obtain a buffer containing a changeset (or patchset) representing the
** current contents of the changegroup. If the inputs to the changegroup
** were themselves changesets, the output is a changeset. Or, if the
** inputs were patchsets, the output is also a patchset.
**
** As with the output of the sqlite3session_changeset() and
** sqlite3session_patchset() functions, all changes related to a single
** table are grouped together in the output of this function. Tables appear
** in the same order as for the very first changeset added to the changegroup.
** If the second or subsequent changesets added to the changegroup contain
** changes for tables that do not appear in the first changeset, they are
** appended onto the end of the output changeset, again in the order in
** which they are first encountered.
**
** If an error occurs, an SQLite error code is returned and the output
** variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK
** is returned and the output variables are set to the size of and a
** pointer to the output buffer, respectively. In this case it is the
** responsibility of the caller to eventually free the buffer using a
** call to sqlite3_free().
*/
SQLITE_API int sqlite3changegroup_output(
  sqlite3_changegroup*,
  int *pnData,
  void **ppData
);
/*
** CAPI3REF: Delete A Changegroup Object
*/
SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*);
/*
** CAPI3REF: Apply A Changeset To A Database
**
** Apply a changeset to a database. This function attempts to update the
** "main" database attached to handle db with the changes found in the
** changeset passed via the second and third arguments.
**
** The fourth argument (xFilter) passed to this function is the "filter
** callback". If it is not NULL, then for each table affected by at least one
** change in the changeset, the filter callback is invoked with
** the table name as the second argument, and a copy of the context pointer
** passed as the sixth argument to this function as the first. If the "filter
** callback" returns zero, then no attempt is made to apply any changes to
** the table. Otherwise, if the return value is non-zero or the xFilter
** argument to this function is NULL, all changes related to the table are
** attempted.
**
** For each table that is not excluded by the filter callback, this function
** tests that the target database contains a compatible table. A table is
** considered compatible if all of the following are true:
**
** <ul>
**   <li> The table has the same name as the name recorded in the
**        changeset, and
**   <li> The table has at least as many columns as recorded in the
**        changeset, and
**   <li> The table has primary key columns in the same position as
**        recorded in the changeset.
** </ul>
**
** If there is no compatible table, it is not an error, but none of the
** changes associated with the table are applied. A warning message is issued
** via the sqlite3_log() mechanism with the error code SQLITE_SCHEMA. At most
** one such warning is issued for each table in the changeset.
**
** For each change for which there is a compatible table, an attempt is made
** to modify the table contents according to the UPDATE, INSERT or DELETE
** change. If a change cannot be applied cleanly, the conflict handler
** function passed as the fifth argument to sqlite3changeset_apply() may be
** invoked. A description of exactly when the conflict handler is invoked for
** each type of change is below.
**
** Unlike the xFilter argument, xConflict may not be passed NULL. The results
** of passing anything other than a valid function pointer as the xConflict
** argument are undefined.
**
** Each time the conflict handler function is invoked, it must return one
** of [SQLITE_CHANGESET_OMIT], [SQLITE_CHANGESET_ABORT] or
** [SQLITE_CHANGESET_REPLACE]. SQLITE_CHANGESET_REPLACE may only be returned
** if the second argument passed to the conflict handler is either
** SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If the conflict-handler
** returns an illegal value, any changes already made are rolled back and
** the call to sqlite3changeset_apply() returns SQLITE_MISUSE. Different
** actions are taken by sqlite3changeset_apply() depending on the value
** returned by each invocation of the conflict-handler function. Refer to
** the documentation for the three
** [SQLITE_CHANGESET_OMIT|available return values] for details.
**
** <dl>
** <dt>DELETE Changes<dd>
**   For each DELETE change, this function checks if the target database
**   contains a row with the same primary key value (or values) as the
**   original row values stored in the changeset. If it does, and the values
**   stored in all non-primary key columns also match the values stored in
**   the changeset the row is deleted from the target database.
**
**   If a row with matching primary key values is found, but one or more of
**   the non-primary key fields contains a value different from the original
**   row value stored in the changeset, the conflict-handler function is
**   invoked with [SQLITE_CHANGESET_DATA] as the second argument. If the
**   database table has more columns than are recorded in the changeset,
**   only the values of those non-primary key fields are compared against
**   the current database contents - any trailing database table columns
**   are ignored.
**
**   If no row with matching primary key values is found in the database,
**   the conflict-handler function is invoked with [SQLITE_CHANGESET_NOTFOUND]
**   passed as the second argument.
**
**   If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT
**   (which can only happen if a foreign key constraint is violated), the
**   conflict-handler function is invoked with [SQLITE_CHANGESET_CONSTRAINT]
**   passed as the second argument. This includes the case where the DELETE
**   operation is attempted because an earlier call to the conflict handler
**   function returned [SQLITE_CHANGESET_REPLACE].
**
** <dt>INSERT Changes<dd>
**   For each INSERT change, an attempt is made to insert the new row into
**   the database. If the changeset row contains fewer fields than the
**   database table, the trailing fields are populated with their default
**   values.
**
**   If the attempt to insert the row fails because the database already
**   contains a row with the same primary key values, the conflict handler
**   function is invoked with the second argument set to
**   [SQLITE_CHANGESET_CONFLICT].
**
**   If the attempt to insert the row fails because of some other constraint
**   violation (e.g. NOT NULL or UNIQUE), the conflict handler function is
**   invoked with the second argument set to [SQLITE_CHANGESET_CONSTRAINT].
**   This includes the case where the INSERT operation is re-attempted because
**   an earlier call to the conflict handler function returned
**   [SQLITE_CHANGESET_REPLACE].
**
** <dt>UPDATE Changes<dd>
**   For each UPDATE change, this function checks if the target database
**   contains a row with the same primary key value (or values) as the
**   original row values stored in the changeset. If it does, and the values
**   stored in all modified non-primary key columns also match the values
**   stored in the changeset the row is updated within the target database.
**
**   If a row with matching primary key values is found, but one or more of
**   the modified non-primary key fields contains a value different from an
**   original row value stored in the changeset, the conflict-handler function
**   is invoked with [SQLITE_CHANGESET_DATA] as the second argument. Since
**   UPDATE changes only contain values for non-primary key fields that are
**   to be modified, only those fields need to match the original values to
**   avoid the SQLITE_CHANGESET_DATA conflict-handler callback.
**
**   If no row with matching primary key values is found in the database,
**   the conflict-handler function is invoked with [SQLITE_CHANGESET_NOTFOUND]
**   passed as the second argument.
**
**   If the UPDATE operation is attempted, but SQLite returns
**   SQLITE_CONSTRAINT, the conflict-handler function is invoked with
**   [SQLITE_CHANGESET_CONSTRAINT] passed as the second argument.
**   This includes the case where the UPDATE operation is attempted after
**   an earlier call to the conflict handler function returned
**   [SQLITE_CHANGESET_REPLACE].
** </dl>
**
** It is safe to execute SQL statements, including those that write to the
** table that the callback related to, from within the xConflict callback.
** This can be used to further customize the applications conflict
** resolution strategy.
**
** All changes made by this function are enclosed in a savepoint transaction.
** If any other error (aside from a constraint failure when attempting to
** write to the target database) occurs, then the savepoint transaction is
** rolled back, restoring the target database to its original state, and an
** SQLite error code returned.
*/
SQLITE_API int sqlite3changeset_apply(
  sqlite3 *db,
  int nChangeset,
  void *pChangeset,
  int(*xFilter)(
    void *pCtx,
    const char *zTab
  ),
  int(*xConflict)(
    void *pCtx,
    int eConflict,
    sqlite3_changeset_iter *p
  ),
  void *pCtx
);
/*
** CAPI3REF: Constants Passed To The Conflict Handler
**
** Values that may be passed as the second argument to a conflict-handler.
**
** <dl>
** <dt>SQLITE_CHANGESET_DATA<dd>
**   The conflict handler is invoked with CHANGESET_DATA as the second argument
**   when processing a DELETE or UPDATE change if a row with the required
**   PRIMARY KEY fields is present in the database, but one or more other
**   (non primary-key) fields modified by the update do not contain the
**   expected "before" values.
**
**   The conflicting row, in this case, is the database row with the matching
**   primary key.
**
** <dt>SQLITE_CHANGESET_NOTFOUND<dd>
**   The conflict handler is invoked with CHANGESET_NOTFOUND as the second
**   argument when processing a DELETE or UPDATE change if a row with the
**   required PRIMARY KEY fields is not present in the database.
**
**   There is no conflicting row in this case. The results of invoking the
**   sqlite3changeset_conflict() API are undefined.
**
** <dt>SQLITE_CHANGESET_CONFLICT<dd>
**   CHANGESET_CONFLICT is passed as the second argument to the conflict
**   handler while processing an INSERT change if the operation would result
**   in duplicate primary key values.
**
**   The conflicting row in this case is the database row with the matching
**   primary key.
**
** <dt>SQLITE_CHANGESET_FOREIGN_KEY<dd>
**   If foreign key handling is enabled, and applying a changeset leaves the
**   database in a state containing foreign key violations, the conflict
**   handler is invoked with CHANGESET_FOREIGN_KEY as the second argument
**   exactly once before the changeset is committed. If the conflict handler
**   returns CHANGESET_OMIT, the changes, including those that caused the
**   foreign key constraint violation, are committed. Or, if it returns
**   CHANGESET_ABORT, the changeset is rolled back.
**
**   No current or conflicting row information is provided. The only function
**   it is possible to call on the supplied sqlite3_changeset_iter handle
**   is sqlite3changeset_fk_conflicts().
**
** <dt>SQLITE_CHANGESET_CONSTRAINT<dd>
**   If any other constraint violation occurs while applying a change (i.e.
**   a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is
**   invoked with CHANGESET_CONSTRAINT as the second argument.
**
**   There is no conflicting row in this case. The results of invoking the
**   sqlite3changeset_conflict() API are undefined.
**
** </dl>
*/
#define SQLITE_CHANGESET_DATA        1
#define SQLITE_CHANGESET_NOTFOUND    2
#define SQLITE_CHANGESET_CONFLICT    3
#define SQLITE_CHANGESET_CONSTRAINT  4
#define SQLITE_CHANGESET_FOREIGN_KEY 5
/*
** CAPI3REF: Constants Returned By The Conflict Handler
**
** A conflict handler callback must return one of the following three values.
**
** <dl>
** <dt>SQLITE_CHANGESET_OMIT<dd>
**   If a conflict handler returns this value no special action is taken. The
**   change that caused the conflict is not applied. The session module
**   continues to the next change in the changeset.
**
** <dt>SQLITE_CHANGESET_REPLACE<dd>
**   This value may only be returned if the second argument to the conflict
**   handler was SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If this
**   is not the case, any changes applied so far are rolled back and the
**   call to sqlite3changeset_apply() returns SQLITE_MISUSE.
**
**   If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict
**   handler, then the conflicting row is either updated or deleted, depending
**   on the type of change.
**
**   If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict
**   handler, then the conflicting row is removed from the database and a
**   second attempt to apply the change is made. If this second attempt fails,
**   the original row is restored to the database before continuing.
**
** <dt>SQLITE_CHANGESET_ABORT<dd>
**   If this value is returned, any changes applied so far are rolled back
**   and the call to sqlite3changeset_apply() returns SQLITE_ABORT.
** </dl>
*/
#define SQLITE_CHANGESET_OMIT       0
#define SQLITE_CHANGESET_REPLACE    1
#define SQLITE_CHANGESET_ABORT      2
/*
** CAPI3REF: Streaming Versions of API functions.
**
** The six streaming API xxx_strm() functions serve similar purposes to the
** corresponding non-streaming API functions:
**
** <table border=1 style="margin-left:8ex;margin-right:8ex">
**   <tr><th>Streaming function<th>Non-streaming equivalent</th>
**   <tr><td>sqlite3changeset_apply_strm<td>[sqlite3changeset_apply]
**   <tr><td>sqlite3changeset_concat_strm<td>[sqlite3changeset_concat]
**   <tr><td>sqlite3changeset_invert_strm<td>[sqlite3changeset_invert]
**   <tr><td>sqlite3changeset_start_strm<td>[sqlite3changeset_start]
**   <tr><td>sqlite3session_changeset_strm<td>[sqlite3session_changeset]
**   <tr><td>sqlite3session_patchset_strm<td>[sqlite3session_patchset]
** </table>
**
** Non-streaming functions that accept changesets (or patchsets) as input
** require that the entire changeset be stored in a single buffer in memory.
** Similarly, those that return a changeset or patchset do so by returning
** a pointer to a single large buffer allocated using sqlite3_malloc().
** Normally this is convenient. However, if an application running in a
** low-memory environment is required to handle very large changesets, the
** large contiguous memory allocations required can become onerous.
**
** In order to avoid this problem, instead of a single large buffer, input
** is passed to a streaming API functions by way of a callback function that
** the sessions module invokes to incrementally request input data as it is
** required. In all cases, a pair of API function parameters such as
**
**  <pre>
**  &nbsp;     int nChangeset,
**  &nbsp;     void *pChangeset,
**  </pre>
**
** Is replaced by:
**
**  <pre>
**  &nbsp;     int (*xInput)(void *pIn, void *pData, int *pnData),
**  &nbsp;     void *pIn,
**  </pre>
**
** Each time the xInput callback is invoked by the sessions module, the first
** argument passed is a copy of the supplied pIn context pointer. The second
** argument, pData, points to a buffer (*pnData) bytes in size. Assuming no
** error occurs the xInput method should copy up to (*pnData) bytes of data
** into the buffer and set (*pnData) to the actual number of bytes copied
** before returning SQLITE_OK. If the input is completely exhausted, (*pnData)
** should be set to zero to indicate this. Or, if an error occurs, an SQLite
** error code should be returned. In all cases, if an xInput callback returns
** an error, all processing is abandoned and the streaming API function
** returns a copy of the error code to the caller.
**
** In the case of sqlite3changeset_start_strm(), the xInput callback may be
** invoked by the sessions module at any point during the lifetime of the
** iterator. If such an xInput callback returns an error, the iterator enters
** an error state, whereby all subsequent calls to iterator functions
** immediately fail with the same error code as returned by xInput.
**
** Similarly, streaming API functions that return changesets (or patchsets)
** return them in chunks by way of a callback function instead of via a
** pointer to a single large buffer. In this case, a pair of parameters such
** as:
**
**  <pre>
**  &nbsp;     int *pnChangeset,
**  &nbsp;     void **ppChangeset,
**  </pre>
**
** Is replaced by:
**
**  <pre>
**  &nbsp;     int (*xOutput)(void *pOut, const void *pData, int nData),
**  &nbsp;     void *pOut
**  </pre>
**
** The xOutput callback is invoked zero or more times to return data to
** the application. The first parameter passed to each call is a copy of the
** pOut pointer supplied by the application. The second parameter, pData,
** points to a buffer nData bytes in size containing the chunk of output
** data being returned. If the xOutput callback successfully processes the
** supplied data, it should return SQLITE_OK to indicate success. Otherwise,
** it should return some other SQLite error code. In this case processing
** is immediately abandoned and the streaming API function returns a copy
** of the xOutput error code to the application.
**
** The sessions module never invokes an xOutput callback with the third
** parameter set to a value less than or equal to zero. Other than this,
** no guarantees are made as to the size of the chunks of data returned.
*/
SQLITE_API int sqlite3changeset_apply_strm(
  sqlite3 *db,
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn,
  int(*xFilter)(
    void *pCtx,
    const char *zTab
  ),
  int(*xConflict)(
    void *pCtx,
    int eConflict,
    sqlite3_changeset_iter *p
  ),
  void *pCtx
);
SQLITE_API int sqlite3changeset_concat_strm(
  int (*xInputA)(void *pIn, void *pData, int *pnData),
  void *pInA,
  int (*xInputB)(void *pIn, void *pData, int *pnData),
  void *pInB,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
);
SQLITE_API int sqlite3changeset_invert_strm(
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
);
SQLITE_API int sqlite3changeset_start_strm(
  sqlite3_changeset_iter **pp,
  int (*xInput)(void *pIn, void *pData, int *pnData),
  void *pIn
);
SQLITE_API int sqlite3session_changeset_strm(
  sqlite3_session *pSession,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
);
SQLITE_API int sqlite3session_patchset_strm(
  sqlite3_session *pSession,
  int (*xOutput)(void *pOut, const void *pData, int nData),
  void *pOut
);
SQLITE_API int sqlite3changegroup_add_strm(sqlite3_changegroup*,
    int (*xInput)(void *pIn, void *pData, int *pnData),
    void *pIn
);
SQLITE_API int sqlite3changegroup_output_strm(sqlite3_changegroup*,
    int (*xOutput)(void *pOut, const void *pData, int nData),
    void *pOut
);
/*
** Make sure we can call this stuff from C++.
*/
#ifdef __cplusplus
}
#endif
#endif
/******** End of sqlite3session.h *********/
/******** Begin file fts5.h *********/
/*
** 2014 May 31
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** Interfaces to extend FTS5. Using the interfaces defined in this file,
** FTS5 may be extended with:
**
**     * custom tokenizers, and
**     * custom auxiliary functions.
*/
#ifndef _FTS5_H
#define _FTS5_H
#ifdef __cplusplus
extern "C" {
#endif
/*************************************************************************
** CUSTOM AUXILIARY FUNCTIONS
**
** Virtual table implementations may overload SQL functions by implementing
** the sqlite3_module.xFindFunction() method.
*/
typedef struct Fts5ExtensionApi Fts5ExtensionApi;
typedef struct Fts5Context Fts5Context;
typedef struct Fts5PhraseIter Fts5PhraseIter;
typedef void (*fts5_extension_function)(
  const Fts5ExtensionApi *pApi,
  Fts5Context *pFts,
  sqlite3_context *pCtx,
  int nVal,
  sqlite3_value **apVal
);
struct Fts5PhraseIter {
  const unsigned char *a;
  const unsigned char *b;
};
/*
** EXTENSION API FUNCTIONS
**
** xUserData(pFts):
**   Return a copy of the context pointer the extension function was
**   registered with.
**
** xColumnTotalSize(pFts, iCol, pnToken):
**   If parameter iCol is less than zero, set output variable *pnToken
**   to the total number of tokens in the FTS5 table. Or, if iCol is
**   non-negative but less than the number of columns in the table, return
**   the total number of tokens in column iCol, considering all rows in
**   the FTS5 table.
**
**   If parameter iCol is greater than or equal to the number of columns
**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
**   an OOM condition or IO error), an appropriate SQLite error code is
**   returned.
**
** xColumnCount(pFts):
**   Return the number of columns in the table.
**
** xColumnSize(pFts, iCol, pnToken):
**   If parameter iCol is less than zero, set output variable *pnToken
**   to the total number of tokens in the current row. Or, if iCol is
**   non-negative but less than the number of columns in the table, set
**   *pnToken to the number of tokens in column iCol of the current row.
**
**   If parameter iCol is greater than or equal to the number of columns
**   in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g.
**   an OOM condition or IO error), an appropriate SQLite error code is
**   returned.
**
**   This function may be quite inefficient if used with an FTS5 table
**   created with the "columnsize=0" option.
**
** xColumnText:
**   This function attempts to retrieve the text of column iCol of the
**   current document. If successful, (*pz) is set to point to a buffer
**   containing the text in utf-8 encoding, (*pn) is set to the size in bytes
**   (not characters) of the buffer and SQLITE_OK is returned. Otherwise,
**   if an error occurs, an SQLite error code is returned and the final values
**   of (*pz) and (*pn) are undefined.
**
** xPhraseCount:
**   Returns the number of phrases in the current query expression.
**
** xPhraseSize:
**   Returns the number of tokens in phrase iPhrase of the query. Phrases
**   are numbered starting from zero.
**
** xInstCount:
**   Set *pnInst to the total number of occurrences of all phrases within
**   the query within the current row. Return SQLITE_OK if successful, or
**   an error code (i.e. SQLITE_NOMEM) if an error occurs.
**
**   This API can be quite slow if used with an FTS5 table created with the
**   "detail=none" or "detail=column" option. If the FTS5 table is created
**   with either "detail=none" or "detail=column" and "content=" option
**   (i.e. if it is a contentless table), then this API always returns 0.
**
** xInst:
**   Query for the details of phrase match iIdx within the current row.
**   Phrase matches are numbered starting from zero, so the iIdx argument
**   should be greater than or equal to zero and smaller than the value
**   output by xInstCount().
**
**   Usually, output parameter *piPhrase is set to the phrase number, *piCol
**   to the column in which it occurs and *piOff the token offset of the
**   first token of the phrase. The exception is if the table was created
**   with the offsets=0 option specified. In this case *piOff is always
**   set to -1.
**
**   Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM)
**   if an error occurs.
**
**   This API can be quite slow if used with an FTS5 table created with the
**   "detail=none" or "detail=column" option.
**
** xRowid:
**   Returns the rowid of the current row.
**
** xTokenize:
**   Tokenize text using the tokenizer belonging to the FTS5 table.
**
** xQueryPhrase(pFts5, iPhrase, pUserData, xCallback):
**   This API function is used to query the FTS table for phrase iPhrase
**   of the current query. Specifically, a query equivalent to:
**
**       ... FROM ftstable WHERE ftstable MATCH $p ORDER BY rowid
**
**   with $p set to a phrase equivalent to the phrase iPhrase of the
**   current query is executed. Any column filter that applies to
**   phrase iPhrase of the current query is included in $p. For each
**   row visited, the callback function passed as the fourth argument
**   is invoked. The context and API objects passed to the callback
**   function may be used to access the properties of each matched row.
**   Invoking Api.xUserData() returns a copy of the pointer passed as
**   the third argument to pUserData.
**
**   If the callback function returns any value other than SQLITE_OK, the
**   query is abandoned and the xQueryPhrase function returns immediately.
**   If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK.
**   Otherwise, the error code is propagated upwards.
**
**   If the query runs to completion without incident, SQLITE_OK is returned.
**   Or, if some error occurs before the query completes or is aborted by
**   the callback, an SQLite error code is returned.
**
**
** xSetAuxdata(pFts5, pAux, xDelete)
**
**   Save the pointer passed as the second argument as the extension functions
**   "auxiliary data". The pointer may then be retrieved by the current or any
**   future invocation of the same fts5 extension function made as part of
**   of the same MATCH query using the xGetAuxdata() API.
**
**   Each extension function is allocated a single auxiliary data slot for
**   each FTS query (MATCH expression). If the extension function is invoked
**   more than once for a single FTS query, then all invocations share a
**   single auxiliary data context.
**
**   If there is already an auxiliary data pointer when this function is
**   invoked, then it is replaced by the new pointer. If an xDelete callback
**   was specified along with the original pointer, it is invoked at this
**   point.
**
**   The xDelete callback, if one is specified, is also invoked on the
**   auxiliary data pointer after the FTS5 query has finished.
**
**   If an error (e.g. an OOM condition) occurs within this function, an
**   the auxiliary data is set to NULL and an error code returned. If the
**   xDelete parameter was not NULL, it is invoked on the auxiliary data
**   pointer before returning.
**
**
** xGetAuxdata(pFts5, bClear)
**
**   Returns the current auxiliary data pointer for the fts5 extension
**   function. See the xSetAuxdata() method for details.
**
**   If the bClear argument is non-zero, then the auxiliary data is cleared
**   (set to NULL) before this function returns. In this case the xDelete,
**   if any, is not invoked.
**
**
** xRowCount(pFts5, pnRow)
**
**   This function is used to retrieve the total number of rows in the table.
**   In other words, the same value that would be returned by:
**
**        SELECT count(*) FROM ftstable;
**
** xPhraseFirst()
**   This function is used, along with type Fts5PhraseIter and the xPhraseNext
**   method, to iterate through all instances of a single query phrase within
**   the current row. This is the same information as is accessible via the
**   xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient
**   to use, this API may be faster under some circumstances. To iterate
**   through instances of phrase iPhrase, use the following code:
**
**       Fts5PhraseIter iter;
**       int iCol, iOff;
**       for(pApi->xPhraseFirst(pFts, iPhrase, &iter, &iCol, &iOff);
**           iCol>=0;
**           pApi->xPhraseNext(pFts, &iter, &iCol, &iOff)
**       ){
**         // An instance of phrase iPhrase at offset iOff of column iCol
**       }
**
**   The Fts5PhraseIter structure is defined above. Applications should not
**   modify this structure directly - it should only be used as shown above
**   with the xPhraseFirst() and xPhraseNext() API methods (and by
**   xPhraseFirstColumn() and xPhraseNextColumn() as illustrated below).
**
**   This API can be quite slow if used with an FTS5 table created with the
**   "detail=none" or "detail=column" option. If the FTS5 table is created
**   with either "detail=none" or "detail=column" and "content=" option
**   (i.e. if it is a contentless table), then this API always iterates
**   through an empty set (all calls to xPhraseFirst() set iCol to -1).
**
** xPhraseNext()
**   See xPhraseFirst above.
**
** xPhraseFirstColumn()
**   This function and xPhraseNextColumn() are similar to the xPhraseFirst()
**   and xPhraseNext() APIs described above. The difference is that instead
**   of iterating through all instances of a phrase in the current row, these
**   APIs are used to iterate through the set of columns in the current row
**   that contain one or more instances of a specified phrase. For example:
**
**       Fts5PhraseIter iter;
**       int iCol;
**       for(pApi->xPhraseFirstColumn(pFts, iPhrase, &iter, &iCol);
**           iCol>=0;
**           pApi->xPhraseNextColumn(pFts, &iter, &iCol)
**       ){
**         // Column iCol contains at least one instance of phrase iPhrase
**       }
**
**   This API can be quite slow if used with an FTS5 table created with the
**   "detail=none" option. If the FTS5 table is created with either
**   "detail=none" "content=" option (i.e. if it is a contentless table),
**   then this API always iterates through an empty set (all calls to
**   xPhraseFirstColumn() set iCol to -1).
**
**   The information accessed using this API and its companion
**   xPhraseFirstColumn() may also be obtained using xPhraseFirst/xPhraseNext
**   (or xInst/xInstCount). The chief advantage of this API is that it is
**   significantly more efficient than those alternatives when used with
**   "detail=column" tables.
**
** xPhraseNextColumn()
**   See xPhraseFirstColumn above.
*/
struct Fts5ExtensionApi {
  int iVersion;
  void *(*xUserData)(Fts5Context*);
  int (*xColumnCount)(Fts5Context*);
  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);
  int (*xTokenize)(Fts5Context*,
    const char *pText, int nText,
    void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int)
  );
  int (*xPhraseCount)(Fts5Context*);
  int (*xPhraseSize)(Fts5Context*, int iPhrase);
  int (*xInstCount)(Fts5Context*, int *pnInst);
  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);
  sqlite3_int64 (*xRowid)(Fts5Context*);
  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);
  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  );
  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
  void *(*xGetAuxdata)(Fts5Context*, int bClear);
  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);
  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);
};
/*
** CUSTOM AUXILIARY FUNCTIONS
*************************************************************************/
/*************************************************************************
** CUSTOM TOKENIZERS
**
** Applications may also register custom tokenizer types. A tokenizer
** is registered by providing fts5 with a populated instance of the
** following structure. All structure methods must be defined, setting
** any member of the fts5_tokenizer struct to NULL leads to undefined
** behaviour. The structure methods are expected to function as follows:
**
** xCreate:
**   This function is used to allocate and initialize a tokenizer instance.
**   A tokenizer instance is required to actually tokenize text.
**
**   The first argument passed to this function is a copy of the (void*)
**   pointer provided by the application when the fts5_tokenizer object
**   was registered with FTS5 (the third argument to xCreateTokenizer()).
**   The second and third arguments are an array of nul-terminated strings
**   containing the tokenizer arguments, if any, specified following the
**   tokenizer name as part of the CREATE VIRTUAL TABLE statement used
**   to create the FTS5 table.
**
**   The final argument is an output variable. If successful, (*ppOut)
**   should be set to point to the new tokenizer handle and SQLITE_OK
**   returned. If an error occurs, some value other than SQLITE_OK should
**   be returned. In this case, fts5 assumes that the final value of *ppOut
**   is undefined.
**
** xDelete:
**   This function is invoked to delete a tokenizer handle previously
**   allocated using xCreate(). Fts5 guarantees that this function will
**   be invoked exactly once for each successful call to xCreate().
**
** xTokenize:
**   This function is expected to tokenize the nText byte string indicated
**   by argument pText. pText may or may not be nul-terminated. The first
**   argument passed to this function is a pointer to an Fts5Tokenizer object
**   returned by an earlier call to xCreate().
**
**   The second argument indicates the reason that FTS5 is requesting
**   tokenization of the supplied text. This is always one of the following
**   four values:
**
**   <ul><li> <b>FTS5_TOKENIZE_DOCUMENT</b> - A document is being inserted into
**            or removed from the FTS table. The tokenizer is being invoked to
**            determine the set of tokens to add to (or delete from) the
**            FTS index.
**
**       <li> <b>FTS5_TOKENIZE_QUERY</b> - A MATCH query is being executed
**            against the FTS index. The tokenizer is being called to tokenize
**            a bareword or quoted string specified as part of the query.
**
**       <li> <b>(FTS5_TOKENIZE_QUERY | FTS5_TOKENIZE_PREFIX)</b> - Same as
**            FTS5_TOKENIZE_QUERY, except that the bareword or quoted string is
**            followed by a "*" character, indicating that the last token
**            returned by the tokenizer will be treated as a token prefix.
**
**       <li> <b>FTS5_TOKENIZE_AUX</b> - The tokenizer is being invoked to
**            satisfy an fts5_api.xTokenize() request made by an auxiliary
**            function. Or an fts5_api.xColumnSize() request made by the same
**            on a columnsize=0 database.
**   </ul>
**
**   For each token in the input string, the supplied callback xToken() must
**   be invoked. The first argument to it should be a copy of the pointer
**   passed as the second argument to xTokenize(). The third and fourth
**   arguments are a pointer to a buffer containing the token text, and the
**   size of the token in bytes. The 4th and 5th arguments are the byte offsets
**   of the first byte of and first byte immediately following the text from
**   which the token is derived within the input.
**
**   The second argument passed to the xToken() callback ("tflags") should
**   normally be set to 0. The exception is if the tokenizer supports
**   synonyms. In this case see the discussion below for details.
**
**   FTS5 assumes the xToken() callback is invoked for each token in the
**   order that they occur within the input text.
**
**   If an xToken() callback returns any value other than SQLITE_OK, then
**   the tokenization should be abandoned and the xTokenize() method should
**   immediately return a copy of the xToken() return value. Or, if the
**   input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally,
**   if an error occurs with the xTokenize() implementation itself, it
**   may abandon the tokenization and return any error code other than
**   SQLITE_OK or SQLITE_DONE.
**
** SYNONYM SUPPORT
**
**   Custom tokenizers may also support synonyms. Consider a case in which a
**   user wishes to query for a phrase such as "first place". Using the
**   built-in tokenizers, the FTS5 query 'first + place' will match instances
**   of "first place" within the document set, but not alternative forms
**   such as "1st place". In some applications, it would be better to match
**   all instances of "first place" or "1st place" regardless of which form
**   the user specified in the MATCH query text.
**
**   There are several ways to approach this in FTS5:
**
**   <ol><li> By mapping all synonyms to a single token. In this case, the
**            In the above example, this means that the tokenizer returns the
**            same token for inputs "first" and "1st". Say that token is in
**            fact "first", so that when the user inserts the document "I won
**            1st place" entries are added to the index for tokens "i", "won",
**            "first" and "place". If the user then queries for '1st + place',
**            the tokenizer substitutes "first" for "1st" and the query works
**            as expected.
**
**       <li> By adding multiple synonyms for a single term to the FTS index.
**            In this case, when tokenizing query text, the tokenizer may
**            provide multiple synonyms for a single term within the document.
**            FTS5 then queries the index for each synonym individually. For
**            example, faced with the query:
**
**   <codeblock>
**     ... MATCH 'first place'</codeblock>
**
**            the tokenizer offers both "1st" and "first" as synonyms for the
**            first token in the MATCH query and FTS5 effectively runs a query
**            similar to:
**
**   <codeblock>
**     ... MATCH '(first OR 1st) place'</codeblock>
**
**            except that, for the purposes of auxiliary functions, the query
**            still appears to contain just two phrases - "(first OR 1st)"
**            being treated as a single phrase.
**
**       <li> By adding multiple synonyms for a single term to the FTS index.
**            Using this method, when tokenizing document text, the tokenizer
**            provides multiple synonyms for each token. So that when a
**            document such as "I won first place" is tokenized, entries are
**            added to the FTS index for "i", "won", "first", "1st" and
**            "place".
**
**            This way, even if the tokenizer does not provide synonyms
**            when tokenizing query text (it should not - to do would be
**            inefficient), it doesn't matter if the user queries for
**            'first + place' or '1st + place', as there are entires in the
**            FTS index corresponding to both forms of the first token.
**   </ol>
**
**   Whether it is parsing document or query text, any call to xToken that
**   specifies a <i>tflags</i> argument with the FTS5_TOKEN_COLOCATED bit
**   is considered to supply a synonym for the previous token. For example,
**   when parsing the document "I won first place", a tokenizer that supports
**   synonyms would call xToken() 5 times, as follows:
**
**   <codeblock>
**       xToken(pCtx, 0, "i",                      1,  0,  1);
**       xToken(pCtx, 0, "won",                    3,  2,  5);
**       xToken(pCtx, 0, "first",                  5,  6, 11);
**       xToken(pCtx, FTS5_TOKEN_COLOCATED, "1st", 3,  6, 11);
**       xToken(pCtx, 0, "place",                  5, 12, 17);
**</codeblock>
**
**   It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time
**   xToken() is called. Multiple synonyms may be specified for a single token
**   by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence.
**   There is no limit to the number of synonyms that may be provided for a
**   single token.
**
**   In many cases, method (1) above is the best approach. It does not add
**   extra data to the FTS index or require FTS5 to query for multiple terms,
**   so it is efficient in terms of disk space and query speed. However, it
**   does not support prefix queries very well. If, as suggested above, the
**   token "first" is subsituted for "1st" by the tokenizer, then the query:
**
**   <codeblock>
**     ... MATCH '1s*'</codeblock>
**
**   will not match documents that contain the token "1st" (as the tokenizer
**   will probably not map "1s" to any prefix of "first").
**
**   For full prefix support, method (3) may be preferred. In this case,
**   because the index contains entries for both "first" and "1st", prefix
**   queries such as 'fi*' or '1s*' will match correctly. However, because
**   extra entries are added to the FTS index, this method uses more space
**   within the database.
**
**   Method (2) offers a midpoint between (1) and (3). Using this method,
**   a query such as '1s*' will match documents that contain the literal
**   token "1st", but not "first" (assuming the tokenizer is not able to
**   provide synonyms for prefixes). However, a non-prefix query like '1st'
**   will match against "1st" and "first". This method does not require
**   extra disk space, as no extra entries are added to the FTS index.
**   On the other hand, it may require more CPU cycles to run MATCH queries,
**   as separate queries of the FTS index are required for each synonym.
**
**   When using methods (2) or (3), it is important that the tokenizer only
**   provide synonyms when tokenizing document text (method (2)) or query
**   text (method (3)), not both. Doing so will not cause any errors, but is
**   inefficient.
*/
typedef struct Fts5Tokenizer Fts5Tokenizer;
typedef struct fts5_tokenizer fts5_tokenizer;
struct fts5_tokenizer {
  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
  void (*xDelete)(Fts5Tokenizer*);
  int (*xTokenize)(Fts5Tokenizer*,
      void *pCtx,
      int flags,
      const char *pText, int nText,
      int (*xToken)(
        void *pCtx,
        int tflags,
        const char *pToken,
        int nToken,
        int iStart,
        int iEnd
      )
  );
};
/* Flags that may be passed as the third argument to xTokenize() */
#define FTS5_TOKENIZE_QUERY     0x0001
#define FTS5_TOKENIZE_PREFIX    0x0002
#define FTS5_TOKENIZE_DOCUMENT  0x0004
#define FTS5_TOKENIZE_AUX       0x0008
/* Flags that may be passed by the tokenizer implementation back to FTS5
** as the third argument to the supplied xToken callback. */
#define FTS5_TOKEN_COLOCATED    0x0001
/*
** END OF CUSTOM TOKENIZERS
*************************************************************************/
/*************************************************************************
** FTS5 EXTENSION REGISTRATION API
*/
typedef struct fts5_api fts5_api;
struct fts5_api {
  int iVersion;
  /* Create a new tokenizer */
  int (*xCreateTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_tokenizer *pTokenizer,
    void (*xDestroy)(void*)
  );
  /* Find an existing tokenizer */
  int (*xFindTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void **ppContext,
    fts5_tokenizer *pTokenizer
  );
  /* Create a new auxiliary function */
  int (*xCreateFunction)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_extension_function xFunction,
    void (*xDestroy)(void*)
  );
};
/*
** END OF REGISTRATION API
*************************************************************************/
#ifdef __cplusplus
}
#endif
#endif
/******** End of fts5.h *********/
# endif
#if defined( __NO_ODBC__ )
// if not using odbc, need these
// otherwise they will be defined in sql.h
 // sqllite uses a generic int type for result codes
typedef int RETCODE;
typedef int SQLSMALLINT;
typedef unsigned int SQLULEN;
typedef int SQLINTEGER;
enum {
	SQL_HANDLE_DBC
      , SQL_HANDLE_STMT
};
#else
#  define USE_ODBC 1
#  include <sql.h>
#  include <sqlext.h>
#endif
#ifndef CLIENT_MESSAGE_INTERFACE
#define CLIENT_MESSAGE_INTERFACE
#  ifdef CLIENTMSG_SOURCE
#   define CLIENTMSG_PROC(type,name) EXPORT_METHOD type CPROC name
#  else
#   define CLIENTMSG_PROC(type,name) IMPORT_METHOD type CPROC name
#  endif
#ifdef __cplusplus
#define _CLIENT_NAMESPACE namespace client {
#define MSGCLIENT_NAMESPACE SACK_NAMESPACE namespace msg { namespace client {
#define MSGCLIENT_NAMESPACE_END }} SACK_NAMESPACE_END
#else
#define _CLIENT_NAMESPACE
#define MSGCLIENT_NAMESPACE
#define MSGCLIENT_NAMESPACE_END
#endif
SACK_NAMESPACE
   _MSG_NAMESPACE
	/* Defines methods and macros for use as a client of a service. */
	_CLIENT_NAMESPACE
#define MSG_DEFAULT_RESULT_BUFFER_MAX (sizeof( uint32_t ) * 16384)
	// not realy sure where this doc goes
   //
// result is TRUE/FALSE.  Successful registration will result TRUE.
// a timeout to the master message service
// only [functions, entries] or [event_handler]
// need to be specified.  If both are specified....
// then both methods for invoking functions will be used.
// Also if event_handler is used, then the result of this is MsgBase
//  and needs to be subtracted from the MsgID to...
//  --- above comments are somewhat invalid --- events have bee biased
//   to have event 0 be the first user event... system events have the
// MSB (most sig bit) set.
// Use this to make sure message subsystem is active
CLIENTMSG_PROC( int, InitMessageService )( void );
// allow messaage service opportunity to shutdown.?
CLIENTMSG_PROC( void, CloseMessageService )( void );
// the result is a RouteID.  (ie. or MsgBase)...
CLIENTMSG_PROC( LOGICAL, RegisterServiceExx )( CTEXTSTR name
																	 , server_function_table functions
																	 , int entries
																	 , server_message_handler event_handler
																	 , server_message_handler_ex handler_ex
																	 , uintptr_t psv
																	 );
#define RegisterServiceEx( n,f,psv ) RegisterServiceExx( n,NULL,65535,NULL,f,psv)
#define RegisterService(n,f,e)        RegisterServiceExx(n,f,e,NULL,NULL,0)
#define RegisterServiceHandler(n,f)   RegisterServiceExx(n,NULL,65535,f,NULL,0)
#define RegisterServiceHandlerEx(n,f,psv)   RegisterServiceExx(n,NULL,65535,NULL,f,psv)
CLIENTMSG_PROC( void, UnregisterService )( CTEXTSTR name );
CLIENTMSG_PROC( int, ProcessClientMessages )( uintptr_t unused );
// returns INVALID_INDEX on failure - else is message base to servic.
// the core message services may be opened with ID 0 - which serves
// to dispatch local event queue messages... transactions between client
// and server hrm - suppose someone could send to this service ID...
// LoadService( NULL ) will return 0 on success
#define INVALID_MESSAGE_BASE ((uint32_t)-1)
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadService )( CTEXTSTR service, EventHandlerFunction );
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceEx )( CTEXTSTR service, EventHandlerFunctionEx );
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceExx )( CTEXTSTR service, EventHandlerFunctionExx, uintptr_t psv );
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceAsServer )( CTEXTSTR service, EventHandlerFunction, server_message_handler );
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceAsServerEx )( CTEXTSTR service, EventHandlerFunctionEx, server_message_handler );
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceAsServerExx )( CTEXTSTR service, EventHandlerFunctionExx, server_message_handler_ex, uintptr_t psv );
CLIENTMSG_PROC( void, UnloadService )( CTEXTSTR service );
/*
 When a service connects, this registered callback is called.
 static LOGICAL OnServiceConnect( "RegisterService_name" )( PSERVICE_ROUTE route_to_client );
 */
#define OnServiceConnect(name)	  __DefineRegistryMethodP(DEFAULT_PRELOAD_PRIORITY	  ,"SACK/Message Service",_OnServiceConnect,WIDE("server"),name,WIDE("on_connect")	  ,LOGICAL,(PSERVICE_ROUTE), __LINE__)
// this extended feature does not look up the routing ID
// from the message ID, and if you happen to somehow know
// the destionation process, you can send any message directed to it
// with this.
CLIENTMSG_PROC( int, TransactRoutedServerMultiMessageEx )( PSERVICE_ROUTE RouteID
																			, MSGIDTYPE MsgOut, uint32_t buffers
																			, MSGIDTYPE *MsgIn
																			, POINTER BufferIn, size_t *LengthIn
 // non zero overrides default timeout
																			, uint32_t timeout
																			// buffer starts arg list, length is
																			// not used, but is here for demonstration
																	, ... );
// again if you happen to know something special, you can use the routeID
// to probe if a client is alive - it's a 10ms check.
CLIENTMSG_PROC( int, ProbeClientAlive )( PSERVICE_ENDPOINT RouteID );
// this is the message which should NORMALLY be used.
// timeout willreturn FALSE else a reponce (or non-responce) will result
// in non-zero.
										 // buffer starts arg list, length is
                               // not used, but is here for demonstration
typedef  int (CPROC *TSMMProto)(PSERVICE_ROUTE,MSGIDTYPE, uint32_t, MSGIDTYPE *, POINTER , size_t *,...);
CLIENTMSG_PROC( TSMMProto, TransactServerMultiMessageExEx )( DBG_VOIDPASS );
CLIENTMSG_PROC( int, TransactServerMultiMessage )( PSERVICE_ROUTE RouteID
																 , MSGIDTYPE MsgOut, uint32_t buffers
																 , MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn
																  // buffer starts arg list, length is
																  // not used, but is here for demonstration
																 , ... );
//#define TransactServerMultiMessage TransactServerMultiMessageExEx(DBG_VOIDSRC)
CLIENTMSG_PROC( int, TransactServerMessageExx)( PSERVICE_ROUTE RouteID
															 , MSGIDTYPE MsgOut, CPOINTER BufferOut, size_t LengthOut
															 , MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn
															  , uint32_t timeout DBG_PASS );
CLIENTMSG_PROC( int, TransactServerMessageEx )( PSERVICE_ROUTE RouteID
															 , MSGIDTYPE MsgOut, CPOINTER BufferOut, size_t LengthOut
															 , MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn DBG_PASS);
CLIENTMSG_PROC( int, TransactServerMultiMessageEx )( PSERVICE_ROUTE RouteID
																	, MSGIDTYPE MsgOut, uint32_t buffers
																	, MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn
                                                   , uint32_t timeout
																	 // buffer starts arg list, length is
																	 // not used, but is here for demonstration
																	, ... );
//#define TransactServerMessageEx(mo,bo,lo,mi,bi,li DBG_RELAY) TransactServer
#define TransactServerMessage(rid,mo,bo,lo,mi,bi,li) TransactServerMessageEx(rid,mo,bo,lo,mi,bi,li DBG_SRC )
#define TransactRoutedServerMessage(ro,mo,bo,lo,mi,bi,li) TransactRoutedServerMultiMessageEx(ro,mo,1,mi,bi,li,0,bo,lo DBG_SRC )
//#define TransactRoutedMessage(ro,mo,bo,lo,mi,bi,li) TransactMultiServerMessageEx(ro,mo,bi,li,1,&bo DBG_SRC )
// these are provided but are storngly discouraged from use.
CLIENTMSG_PROC( int, SendRoutedServerMultiMessage )( PSERVICE_ROUTE RouteID, uint32_t MessageID, uint32_t buffers, ... );
CLIENTMSG_PROC( int, SendRoutedServerMessage )( PSERVICE_ROUTE RouteID, uint32_t MessageID, POINTER msg, size_t len );
CLIENTMSG_PROC( int, SendServerMultiMessage )( PSERVICE_ROUTE RouteID
															, uint32_t MessageID, uint32_t buffers, ... );
CLIENTMSG_PROC( int, SendServerMessage )( PSERVICE_ROUTE RouteID
													 , uint32_t MessageID, POINTER msg, size_t len );
// really I guess the integeration of all message handles [as a msg_base_id] allows some unique opportunities....
// this message is one of those that does not take a base message ID...
#define TellClientTardy( client_source_id, new_responce_timeout )  { uint32_t timeout = new_responce_timeout; lprintf( WIDE("TELL TARDY") ); SendInMessage( (client_source_id), IM_TARDY, &timeout, sizeof( timeout ) ); }
// TellClientTardy( 5000000 ); // tell client to wait a LONG time.
// TellClientTardy( 3000 ); // reset timeout to 3 seconds
// this may result FALSE if it satisfied no message
// otherwise it will return true...
// the waiter then check his PEVENTHANDLER to see if ti was complete.
//CLIENTMSG_PROC( int, ReceiveServerMessageEx )( uint32_t *MessageID, POINTER msg, uint32_t *len DBG_PASS);
//#define ReceiveServerMessage(mid,m,l) ReceiveServerMessageEx( mid,m,l DBG_SRC )
CLIENTMSG_PROC( void, DumpServiceList )( void );
CLIENTMSG_PROC( void, GetServiceList )( PLIST *ppList );
CLIENTMSG_PROC( int, SendInMultiMessage )( PSERVICE_ROUTE routeID, uint32_t MsgID, uint32_t parts, BUFFER_LENGTH_PAIR *pairs );
CLIENTMSG_PROC( int, SendInMessage )( PSERVICE_ROUTE routeID, uint32_t MsgID, POINTER buffer, size_t length );
// now - is there some magic to allow libraries to link to
// the core application?? - this is in the server's core
// and is access by the services it loads.
// add event base - determines which loaded service this
// event is destined to...
typedef int (CPROC* SendMultiServiceEventProto)( PSERVICE_ROUTE pid, uint32_t event
															  , uint32_t parts
															  ,... );
CLIENTMSG_PROC(int, SendMultiServiceEventPairs)( PSERVICE_ROUTE pid, uint32_t event
															  , uint32_t parts
															  , BUFFER_LENGTH_PAIR *pairs );
// SendMultiServiceEvent calls ...Pairs with all information and the address
// of the var-args...
CLIENTMSG_PROC(int, SendMultiServiceEvent)( PSERVICE_ROUTE pid, uint32_t event
								 , uint32_t parts
								 , ... );
CLIENTMSG_PROC(SendMultiServiceEventProto, SendMultiServiceEventEx)( DBG_VOIDPASS );
#define SendMultiServiceEvent SendMultiServiceEventEx(DBG_VOIDSRC)
#define SendServiceEvent(pid,event,data,len) SendMultiServiceEvent(pid,event,1,data,len)
//void SendServiceEvent( uint32_t pid, uint32_t event, uint32_t *data, uint32_t len );
// sends a message on the out queue.  Normally one should use SendServerMessage et al.
typedef struct message_header_tag *PMSGHDR;
typedef struct full_message_header_tag *PQMSG;
CLIENTMSG_PROC( int, SendOutMessage )( PQMSG buffer, size_t len );
CLIENTMSG_PROC( LOGICAL, IsSameMsgEndPoint )( PSERVICE_ENDPOINT a, PSERVICE_ENDPOINT b );
CLIENTMSG_PROC( LOGICAL, IsSameMsgSource )( PSERVICE_ROUTE a, PSERVICE_ROUTE b );
CLIENTMSG_PROC( LOGICAL, IsSameMsgDest )( PSERVICE_ROUTE a, PSERVICE_ROUTE b );
CLIENTMSG_PROC( LOGICAL, IsMsgSourceSameAsMsgDest )( PSERVICE_ROUTE a, PSERVICE_ROUTE b );
MSGCLIENT_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::msg::client;
#endif
#endif
// $Log: msgclient.h,v $
// Revision 1.26  2005/06/30 18:31:32  jim
// Deifne extended methods for communication.
//
// Revision 1.22  2005/06/30 13:22:44  d3x0r
// Attempt to define preload, atexit methods for msvc.  Fix deadstart loading to be more protected.
//
// Revision 1.21  2005/05/30 11:56:20  d3x0r
// various fixes... working on psilib update optimization... various stabilitizations... also extending msgsvr functionality.
//
// Revision 1.20  2005/05/25 16:50:09  d3x0r
// Synch with working repository.
//
// Revision 1.23  2005/05/23 19:32:03  jim
// Remove extra definition of eventhandlerfunction typedef
//
// Revision 1.22  2005/05/23 19:26:07  jim
// Improved registeration of services to allow a specification of a message-proc style handler.... Also worked on straightening out MSG_ and CLIENT_ message IDs...
//
// Revision 1.21  2005/05/13 00:32:06  jim
// Added some missing functions for clean windows build
//
// Revision 1.19.2.3  2005/05/12 21:02:30  jim
// Add extended transaction method that takes a RoutingID
//
// Revision 1.19.2.2  2005/05/06 21:38:51  jim
// Fix sendservice event definition.
//
// Revision 1.19.2.1  2005/05/02 17:01:08  jim
// Nearly works... time to move over to linux... still need some cleanup on exits... and dead clients.
//
// Revision 1.19  2004/12/19 15:44:57  panther
// Extended set methods to interact with raw index numbers
//
// Revision 1.18  2004/09/30 01:14:42  d3x0r
// Cleaned up consistancy of PID and thread ID... extended message service a bit to supply event PID both ways.
//
// Revision 1.17  2004/09/29 00:49:47  d3x0r
// Added fancy wait for PSI frames which allows non-polling sleeping... Extended Idle() to result in meaningful information.
//
// Revision 1.16  2004/09/22 20:26:13  d3x0r
// Begin implementation of message queues to handle events from video to application
//
// Revision 1.15  2003/10/28 01:14:34  panther
// many changes to implement msgsvr on windows.  Even to get displaylib service to build, there's all sorts of errors in inconsistant definitions...
//
// Revision 1.14  2003/09/19 14:52:40  panther
// Added new procedure name registry
//
// Revision 1.13  2003/03/27 15:36:38  panther
// Changes were done to limit client messages to server - but all SERVER-CLIENT messages were filtered too... Define LOWEST_BASE_MESSAGE
//
// Revision 1.12  2003/03/25 08:38:11  panther
// Add logging
//
 // critical section
SQL_NAMESPACE
enum {
	WM_SQL_COMMAND = MSG_UserServiceMessages
	  , WM_SQL_QUERY
	  , WM_SQL_DATA_START
	  , WM_SQL_DATA_MORE
	  , WM_SQL_RESULT_ERROR
	  , WM_SQL_RESULT_SUCCESS
     , WM_SQL_RESULT_DATA
     , WM_SQL_RESULT_MORE
	  , WM_SQL_MORE
	  , WM_SQL_GET_ERROR
 // no error, but no lines result
	  , WM_SQL_RESULT_NO_DATA
	  // which is not the same as no error, but an empty line resulted...
	  , WM_SQL_QUERY_RECORD
     , WM_SQL_RESULT_RECORD
     , WM_SQL_NUM_MESSAGES
};
typedef struct data_collection_tag
{
	struct {
 // sql commands during queries are given temporary status.
		BIT_FIELD  bTemporary  : 1;
 // not a static member
		BIT_FIELD  bDynamic : 1;
		BIT_FIELD  bBuildResultArray  : 1;
		BIT_FIELD bEndOfFile : 1;
 // pop should work up to this point.
		BIT_FIELD bPushed : 1;
	} flags;
 // the last SQL command for this...
	PVARTEXT pvt_out;
 // the last result for this...
	PVARTEXT pvt_result;
 // the last error info for this...
	PVARTEXT pvt_errorinfo;
	PSERVICE_ROUTE SourceID;
	struct odbc_handle_tag *odbc;
	uint32_t      responce;
	uint32_t      lastop;
   int    *column_types;
	size_t *result_len;
	TEXTSTR *results;
	//uint32_t nResults; // this is columns
	TEXTSTR *fields;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	sqlite3_stmt *stmt;
#endif
#if !defined( __NO_ODBC__ )
	SQLHSTMT    hstmt;
#endif
	SQLSMALLINT columns;
	PTEXT result_text;
	SQLULEN  *colsizes;
	SQLSMALLINT *coltypes;
	DeclareLink( struct data_collection_tag );
#ifdef WINDOWS_PROXY_EXTENSION
	uint32_t MyID;
	HWND     hLastWnd;
	HWND     hWnd;
#endif
} COLLECT, *PCOLLECT;
typedef struct database_info_tag
{
	struct {
		BIT_FIELD  bAutoUser  : 1;
	} flags;
	CTEXTSTR pDSN;
	TEXTCHAR pID[64];
	TEXTCHAR pPASSWORD[64];
	TEXTCHAR pConnString[256];
} DB_INFO, *PDB_INFO;
struct odbc_handle_tag{
	DB_INFO info;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	sqlite3 *db;
#endif
#if !defined( __NO_ODBC__ )
  // odbc database access handle...
	SQLHENV    env;
 // handle to database connection
	SQLHDBC    hdbc;
#endif
	struct {
		BIT_FIELD  bConnected  : 1;
 // operate as if talking to an access MDB
		BIT_FIELD  bAccess  : 1;
 // sqllite via sqlite odbc driver...
		BIT_FIELD  bSQLite  : 1;
  // for selecting how transactions are done.
		BIT_FIELD  bMySQL : 1;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		BIT_FIELD  bSQLite_native  : 1;
#endif
#if USE_ODBC
 // odbc is actually an odbc
		BIT_FIELD  bODBC  : 1;
#endif
 // set to skip ODBC connection (if dsn has a '.' in it)
		BIT_FIELD bSkipODBC  : 1;
 // do NOT log to SQL.log
		BIT_FIELD bNoLogging  : 1;
 // pop should work up to this point. just did a push... next collector should be marked.
		BIT_FIELD bPushed : 1;
 // same sort of thing as the global flag... but that should just apply to default connection?
		BIT_FIELD bForceConnection : 1;
		BIT_FIELD bFailEnvOnDbcFail : 1;
		// generate begintransaction and commit automatically.
		BIT_FIELD bAutoTransact : 1;
 // use enter/leave critical section on this connector (auto transact protector)
		BIT_FIELD bThreadProtect : 1;
 // don't leave the connection open 100%; open when required and close when idle
		BIT_FIELD bAutoClose : 1;
 // sqlite; alternative to closing; generate wal_checkpoints automatically on idle.
		BIT_FIELD bAutoCheckpoint : 1;
		BIT_FIELD bClosed : 1;
	} flags;
 // this one tracks auto commit state; it is cleared when a commit happens
	uint32_t last_command_tick;
 // this one tracks truly the last operation on a connection
	uint32_t last_command_tick_;
	uint32_t commit_timer;
	PCOLLECT collection;
 // saved for resulting with native error code...
	int native;
 // allow user to associate some data with this.
	uintptr_t psvUser;
	CRITICALSECTION cs;
 // critical section is currently owned
	int nProtect;
	PTHREAD auto_commit_thread;
	PTHREAD auto_close_thread;
	PTHREAD auto_checkpoint_thread;
	struct odbc_queue *queue;
	void (CPROC*auto_commit_callback)(uintptr_t,PODBC);
	uintptr_t auto_commit_callback_psv;
	void (CPROC*pCorruptionHandler)(uintptr_t psv, PODBC odbc);
	uintptr_t psvCorruptionHandler;
};
struct odbc_queue
{
	CTEXTSTR name;
   PLINKQUEUE connections;
};
#ifdef SQLLIB_SOURCE
struct pssql_global
{
	CRITICALSECTION Init;
	//POPTION_INTERFACE pOptionInterface;
	uint32_t PrimaryLastConnect, BackupLastConnect;
	ODBC Primary, Backup;
 // current connection
	PODBC odbc;
#ifdef __cplusplus
//	sack::containers::list::
#endif
 // list of PODBC objects which are open.
	PLIST pOpenODBC;
 // collections which were created for g.odbc while it was NULL
	PCOLLECT collections;
 // this is used for fatal errors when neither primary or backup are set in g.odbc
	COLLECT LocalCollect;
 // used when checking status... as a static element it's more reliable.
	COLLECT TimerCollect;
	struct {
		BIT_FIELD  bInited  : 1;
		// when this happens, something
		// needs to be done to update information from the
		// backup to the primary
		// and from the primary to the backup
		// if BOTH have failed - we're how shall I say... fucked.
		BIT_FIELD  bPrimaryRestored  : 1;
		BIT_FIELD  bNoBackup  : 1;
		BIT_FIELD  bPrimaryUp  : 1;
		BIT_FIELD  bBackupUp  : 1;
		BIT_FIELD  bNoLog  : 1;
		BIT_FIELD  bOpening  : 1;
		BIT_FIELD  bMySQL  : 1;
		BIT_FIELD  bPostgresql  : 1;
		BIT_FIELD  bBadODBC  : 1;
 // do log to SQL.log
		BIT_FIELD  bLogging  : 1;
		BIT_FIELD  bFallback : 1;
		BIT_FIELD  bRequireConnection : 1;
		BIT_FIELD bLogData : 1;
		BIT_FIELD  bLogOptionConnection : 1;
		BIT_FIELD bCriticalSectionInited : 1;
		BIT_FIELD bDeadstartCompleted : 1;
		BIT_FIELD bAutoCheckpoint : 1;
		BIT_FIELD bAutoCheckpointRecover : 1;
	} flags;
	struct update_task_def *UpdateTasks;
	PSERVICE_ROUTE SQLMsgBase;
	FILE *pSQLLog;
	void (CPROC*feedback_handler)(CTEXTSTR message);
 // a third, well-known DSN used for option library by default.  May be SQLite.
	ODBC OptionDb;
	PLIST date_offsets;
	PLIST odbc_queues;
	PLIST option_database_init;
	PLIST database_init;
	// ----- shared with option code; these need to be shared between instances.
  // some
	PTREEROOT tables;
};
#endif
INDEX GetIndexOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name);
PTREEROOT GetTableCache( PODBC odbc, CTEXTSTR tablename );
CTEXTSTR GetKeyOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name);
int OpenSQL( DBG_VOIDPASS );
void CloseDatabaseEx( PODBC odbc, LOGICAL ReleaseConnection );
#ifdef USE_SQLITE_INTERFACE
#  if defined( __WATCOMC__ ) && !defined( BUILDS_INTERFACE ) && ( __WATCOMC__ < 1300 )
#    define FIXREF
#    define FIXDEREF
#    define FIXREF2 *
#    define FIXDEREF2 *
#  else
#    define FIXREF
#    define FIXDEREF
#    define FIXREF2
#    define FIXDEREF2
#  endif
struct sqlite_interface
{
	void(FIXREF2 *sqlite3_result_text)(sqlite3_context*, const char*, int, void(*)(void*));
	void*(FIXREF*sqlite3_user_data)(sqlite3_context*);
	sqlite3_int64 (FIXREF2*sqlite3_last_insert_rowid)(sqlite3*);
	int (FIXREF*sqlite3_create_function)(  sqlite3 *db,
	  const char *zFunctionName,
	  int nArg,
	  int eTextRep,
	  void *pApp,
	  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
	  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
	  void (*xFinal)(sqlite3_context*)
	);
	int (FIXREF2*sqlite3_get_autocommit)(sqlite3*);
	int (FIXREF2*sqlite3_open)(  const char *filename,
	  sqlite3 **ppDb
	);
	int (FIXREF2*sqlite3_open_v2)(
	  const char *filename,
	  sqlite3 **ppDb,
	  int flags,
	  const char *zVfs
	);
	const char* (FIXREF2*sqlite3_errmsg)(sqlite3*);
	int (FIXREF2*sqlite3_finalize)(sqlite3_stmt *);
	int (FIXREF2*sqlite3_close)(sqlite3*);
#  if ( SQLITE_VERSION_NUMBER > 3007013 )
	int (FIXREF2*sqlite3_close_v2)(sqlite3*);
#  endif
	int (FIXREF2*sqlite3_prepare_v2)(
	  sqlite3 *db,
	  const char *zSql,
	  int nByte,
	  sqlite3_stmt **ppStmt,
	  const char **pzTail     );
	int (FIXREF2*sqlite3_prepare16_v2)(
		  sqlite3 *db,
		  const void *zSql,
		  int nByte,
		  sqlite3_stmt **ppStmt,
		  const void **pzTail
		);
	int (FIXREF2*sqlite3_step)(sqlite3_stmt *);
	const char* (FIXREF2*sqlite3_column_name)(sqlite3_stmt *pStmt, int col);
	const unsigned char* (FIXREF*sqlite3_column_text)(sqlite3_stmt *pStmt, int col);
	int (FIXREF2*sqlite3_column_bytes)(sqlite3_stmt *pStmt, int col);
	int (FIXREF*sqlite3_column_type )(sqlite3_stmt *pStmt, int col);
	int (FIXREF2*sqlite3_column_count)(sqlite3_stmt *pStmt);
	int (FIXREF2*sqlite3_config)(int,...);
	int (FIXREF2*sqlite3_db_config)(sqlite3*, int op, ...);
	// allow full definition of a VFS including the FS interface
	void (*InitVFS)( CTEXTSTR name, struct file_system_mounted_interface *fsi );
	sqlite3_backup *( FIXREF2*sqlite3_backup_init)(
			  sqlite3 *pDest,
			  const char *zDestName,
			  sqlite3 *pSource,
			  const char *zSourceName
				);
	int ( FIXREF2*sqlite3_backup_step)(sqlite3_backup *p, int nPage);
	int ( FIXREF2*sqlite3_backup_remaining)(sqlite3_backup *p);
	//int ( FIXREF2*sqlite3_backup_pagecount)(sqlite3_backup *p);
	int ( FIXREF2*sqlite3_backup_finish)(sqlite3_backup *p);
	int ( FIXREF2*sqlite3_extended_errcode)(sqlite3 *db);
	int ( FIXREF2*sqlite3_stmt_readonly)(sqlite3_stmt *pStmt);
	const char *( FIXREF2*sqlite3_column_table_name )( sqlite3_stmt *odbc, int col );
	const char *( FIXREF2*sqlite3_column_table_alias )( sqlite3_stmt *odbc, int col );
};
#  ifndef DEFINES_SQLITE_INTERFACE
extern
#  endif
        struct sqlite_interface *sqlite_iface;
#  ifdef DEFINES_SQLITE_INTERFACE
PRIORITY_PRELOAD( LoadSQLiteInterface, SQL_PRELOAD_PRIORITY-1 )
{
   sqlite_iface = (struct sqlite_interface*)GetInterface( WIDE("sqlite3") );
}
#  endif
#  ifndef BUILDS_INTERFACE
#    define sqlite3_result_text          (FIXDEREF2 (sqlite_iface->sqlite3_result_text))
#    define sqlite3_user_data            (FIXDEREF (sqlite_iface->sqlite3_user_data))
#    define sqlite3_last_insert_rowid    (FIXDEREF2 (sqlite_iface->sqlite3_last_insert_rowid))
#    define sqlite3_create_function      (FIXDEREF (sqlite_iface->sqlite3_create_function))
#    define sqlite3_get_autocommit       (FIXDEREF2 (sqlite_iface->sqlite3_get_autocommit))
#    define sqlite3_open(a,b)            (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_open))(a,b):SQLITE_ERROR
#    define sqlite3_open_v2(a,b,c,d)     (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_open_v2))(a,b,c,d):SQLITE_ERROR
#    define sqlite3_errmsg(db)           (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_errmsg))(db):"No Sqlite3 Interface"
#    define sqlite3_finalize             (FIXDEREF2 (sqlite_iface->sqlite3_finalize))
#    define sqlite3_close                (FIXDEREF2 (sqlite_iface->sqlite3_close))
#    define sqlite3_close_v2             (FIXDEREF2 (sqlite_iface->sqlite3_close_v2))
#    define sqlite3_prepare_v2           (FIXDEREF2 (sqlite_iface->sqlite3_prepare_v2))
#    define sqlite3_prepare16_v2         (FIXDEREF2 (sqlite_iface->sqlite3_prepare16_v2))
#    define sqlite3_step                 (FIXDEREF2 (sqlite_iface->sqlite3_step))
#    define sqlite3_column_name          (FIXDEREF2 (sqlite_iface->sqlite3_column_name))
#    define sqlite3_column_text          (FIXDEREF (sqlite_iface->sqlite3_column_text))
#    define sqlite3_column_bytes         (FIXDEREF2 (sqlite_iface->sqlite3_column_bytes))
#    define sqlite3_column_type          (FIXDEREF (sqlite_iface->sqlite3_column_type))
#    define sqlite3_column_count         (FIXDEREF2 (sqlite_iface->sqlite3_column_count))
#    define sqlite3_config               (FIXDEREF2 (sqlite_iface->sqlite3_config))
#    define sqlite3_db_config            (FIXDEREF2 (sqlite_iface->sqlite3_db_config))
#    define sqlite3_backup_init          (FIXDEREF2 (sqlite_iface->sqlite3_backup_init))
#    define sqlite3_backup_step          (FIXDEREF2 (sqlite_iface->sqlite3_backup_step))
#    define sqlite3_backup_finish        (FIXDEREF2 (sqlite_iface->sqlite3_backup_finish))
#    define sqlite3_backup_remaining     (FIXDEREF2 (sqlite_iface->sqlite3_backup_remaining))
#    define sqlite3_extended_errcode     (FIXDEREF2 (sqlite_iface->sqlite3_extended_errcode))
#    define sqlite3_stmt_readonly        (FIXDEREF2 (sqlite_iface->sqlite3_stmt_readonly))
#    define sqlite3_column_table_name    (FIXDEREF2 (sqlite_iface->sqlite3_column_table_name))
#    define sqlite3_column_table_alias (FIXDEREF2 (sqlite_iface->sqlite3_column_table_alias))
#  endif
#endif
SQL_NAMESPACE_END
#endif
//#define LOG_OPERATIONS
#ifdef USE_SQLITE_INTERFACE
SQL_NAMESPACE
static void InitVFS( CTEXTSTR name, struct file_system_mounted_interface *fsi );
struct sqlite_interface my_sqlite_interface = {
	sqlite3_result_text
	 , sqlite3_user_data
	 , sqlite3_last_insert_rowid
	 , sqlite3_create_function
	 , sqlite3_get_autocommit
	 , sqlite3_open
	 , sqlite3_open_v2
	 , sqlite3_errmsg
	 , sqlite3_finalize
	 , sqlite3_close
#if ( SQLITE_VERSION_NUMBER > 3007013 )
         , sqlite3_close_v2
#endif
         , sqlite3_prepare_v2
#ifdef _UNICODE
         , sqlite3_prepare16_v2
#else
         , NULL
#endif
                                           , sqlite3_step
                                           , sqlite3_column_name
                                           , sqlite3_column_text
                                           , sqlite3_column_bytes
                                           , sqlite3_column_type
                                           , sqlite3_column_count
                                           , sqlite3_config
															 , sqlite3_db_config
															 , InitVFS
															 , sqlite3_backup_init
															 , sqlite3_backup_step
															 , sqlite3_backup_remaining
															 , sqlite3_backup_finish
															 , sqlite3_extended_errcode
                                           , sqlite3_stmt_readonly
                                           , sqlite3_column_table_name
                                           , sqlite3_column_table_alias
};
struct my_file_data
{
 // must be first member to be file subclass...
	struct sqlite3_io_methods *pMethods;
	FILE *file;
	CRITICALSECTION cs;
	TEXTSTR filename;
	int locktype;
	struct file_system_mounted_interface *mount;
	LOGICAL temp;
};
struct my_sqlite3_vfs
{
	sqlite3_vfs vfs;
	struct file_system_mounted_interface *mount;
};
#ifdef l
#  undef l
#endif
#define l (*local_sqlite_interface)
struct local_data {
	PLIST registered_vfs;
} *local_sqlite_interface;
//typedef struct sqlite3_io_methods sqlite3_io_methods;
int xClose(sqlite3_file*file)
{
	struct my_file_data *my_file = (struct my_file_data*)file;
	if( my_file->file )
	{
		sack_fclose( my_file->file );
#ifdef LOG_OPERATIONS
		lprintf( "Close %p %s", my_file->file, my_file->filename );
#endif
		my_file->file = NULL;
	}
	if( my_file->temp )
	{
		sack_unlinkEx( 0, my_file->filename, my_file->mount );
#ifdef LOG_OPERATIONS
		lprintf( "unlink temp file : %s", my_file->filename );
#endif
	}
	return SQLITE_OK;
}
int xRead(sqlite3_file*file, void*buffer, int iAmt, sqlite3_int64 iOfst)
{
	struct my_file_data *my_file = (struct my_file_data*)file;
	size_t actual;
#ifdef LOG_OPERATIONS
	lprintf( "read %p %s %d  %d", my_file->file, my_file->filename, iAmt, iOfst );
#endif
	sack_fseek( my_file->file, (size_t)iOfst, SEEK_SET );
	if( ( actual = sack_fread( buffer, 1, iAmt, my_file->file ) ) == (size_t)iAmt )
	{
#ifdef LOG_OPERATIONS
		//LogBinary( buffer, iAmt );
#endif
		return SQLITE_OK;
	}
#ifdef LOG_OPERATIONS
	lprintf( "Errno : %d", errno );
#endif
	MemSet( ((char*)buffer)+actual, 0, iAmt - actual );
	return SQLITE_IOERR_SHORT_READ;
}
int xWrite(sqlite3_file*file, const void*buffer, int iAmt, sqlite3_int64 iOfst)
{
	struct my_file_data *my_file = (struct my_file_data*)file;
	size_t actual;
#ifdef LOG_OPERATIONS
	lprintf( "Write %p %s %d at %d", my_file->file, my_file->filename, iAmt, iOfst );
	//LogBinary( buffer, iAmt );
#endif
	{
		size_t filesize = sack_fsize( my_file->file );
		if( USS_LT( filesize, size_t, iOfst, sqlite3_int64 ) )
		{
			static unsigned char *filler;
			if( !filler )
			{
				filler = NewArray( unsigned char, 512 );
				MemSet( filler, 0, 512 );
			}
			sack_fseek( my_file->file, 0, SEEK_END );
			while( USS_LT( filesize, size_t, iOfst, sqlite3_int64 ) )
			{
				if( ( iOfst - filesize ) >= 512 )
				{
					sack_fwrite( filler, 1, 512, my_file->file );
					filesize += 512;
				}
				else
				{
					sack_fwrite( filler, 1, (int)( iOfst - filesize ), my_file->file );
					filesize += ( (size_t)iOfst - filesize );
				}
			}
		}
	}
	sack_fseek( my_file->file, (size_t)iOfst, SEEK_SET );
	if( (size_t)iAmt == ( actual = sack_fwrite( buffer, 1, iAmt, my_file->file ) ) )
	{
#ifdef LOG_OPERATIONS
		lprintf( "file  %s is now %d", my_file->filename, sack_fsize( my_file->file ) );
#endif
		return SQLITE_OK;
	}
	return SQLITE_IOERR_WRITE;
}
int xTruncate(sqlite3_file*file, sqlite3_int64 size)
{
	struct my_file_data *my_file = (struct my_file_data*)file;
	sack_fseek( my_file->file, (size_t)size, SEEK_SET );
 // works through file system interface...
	sack_ftruncate( my_file->file );
	//SetFileLength( my_file->filename, (size_t)size );
	return SQLITE_OK;
}
int xSync(sqlite3_file*file, int flags)
{
	struct my_file_data *my_file = (struct my_file_data*)file;
	if( !my_file->file )
		return SQLITE_OK;
#ifdef LOG_OPERATIONS
	lprintf( "Sync on %s", my_file->filename );
#endif
	sack_fflush( my_file->file );
	/* noop */
	return SQLITE_OK;
}
int xFileSize(sqlite3_file*file, sqlite3_int64 *pSize)
{
	struct my_file_data *my_file = (struct my_file_data*)file;
	if( my_file->file )
		(*pSize) = sack_fsize( my_file->file );
	else {
		(*pSize) = 0;
		return SQLITE_OK;
		//return SQLITE_IOERR_FSTAT;
	}
#ifdef LOG_OPERATIONS
	lprintf( "Get File size result of %s %d", my_file->filename, (*pSize) );
#endif
	return SQLITE_OK;
}
int xLock(sqlite3_file*file, int locktype)
{
	return SQLITE_OK;
#if 0
	struct my_file_data *my_file = (struct my_file_data*)file;
	switch( locktype )
	{
	case SQLITE_LOCK_NONE:
		//return SQLITE_OK;
	case SQLITE_LOCK_SHARED:
	case SQLITE_LOCK_RESERVED:
	case SQLITE_LOCK_PENDING:
	case SQLITE_LOCK_EXCLUSIVE:
		EnterCriticalSec( &my_file->cs );
		my_file->locktype = locktype;
		return SQLITE_OK;
		break;
	}
#endif
}
int xUnlock(sqlite3_file*file, int locktype)
{
	return SQLITE_OK;
#if 0
	struct my_file_data *my_file = (struct my_file_data*)file;
	switch( locktype )
	{
	case SQLITE_LOCK_NONE:
		//break;
	case SQLITE_LOCK_SHARED:
	case SQLITE_LOCK_RESERVED:
	case SQLITE_LOCK_PENDING:
	case SQLITE_LOCK_EXCLUSIVE:
		//my_file->error = SQLITE_LOCK_EXCLUSIVE;
		LeaveCriticalSec( &my_file->cs );
		my_file->locktype = SQLITE_LOCK_NONE;
		break;
	}
	return SQLITE_OK;
#endif
}
int xCheckReservedLock(sqlite3_file*file, int *pResOut)
{
	*pResOut = 0;
	return SQLITE_OK;
#if 0
	struct my_file_data *my_file = (struct my_file_data*)file;
	if( EnterCriticalSecNoWait( &my_file->cs, NULL ) )
	{
		LeaveCriticalSec( &my_file->cs );
		return SQLITE_LOCK_NONE;
	}
	return my_file->locktype;
#endif
}
int xFileControl(sqlite3_file*file, int op, void *pArg)
{
#ifdef LOG_OPERATIONS
	struct my_file_data *my_file = (struct my_file_data*)file;
	lprintf( WIDE("file %s control op: %d %p"), my_file->filename, op, pArg );
#endif
	switch( op )
	{
#if ( SQLITE_VERSION_NUMBER > 3007013 )
	case SQLITE_FCNTL_BUSYHANDLER:
	case SQLITE_FCNTL_TEMPFILENAME:
		break;
	case SQLITE_FCNTL_HAS_MOVED:
		{
			int *val = (int*)pArg;
			(*val)= 0;
		}
		break;
#endif
	case SQLITE_FCNTL_LOCKSTATE:
	case SQLITE_GET_LOCKPROXYFILE:
	case SQLITE_SET_LOCKPROXYFILE:
	case SQLITE_LAST_ERRNO:
		break;
	case SQLITE_FCNTL_SIZE_HINT:
		//lprintf( "hint is %d", *(int*)pArg );
		// might preallocate the file here...
		break;
	case SQLITE_FCNTL_CHUNK_SIZE:
	case SQLITE_FCNTL_FILE_POINTER:
	case SQLITE_FCNTL_SYNC_OMITTED:
	case SQLITE_FCNTL_WIN32_AV_RETRY:
	case SQLITE_FCNTL_PERSIST_WAL:
	case SQLITE_FCNTL_OVERWRITE:
	case SQLITE_FCNTL_VFSNAME:
	case SQLITE_FCNTL_POWERSAFE_OVERWRITE:
		break;
	case SQLITE_FCNTL_PRAGMA:
		{
			char **files = (char**)pArg;
			//char *name = files[3];
			//lprintf( "pragma... (%s)", files[1] );
			//files[0] = sqlite3_mprintf( "%s", files[2] );
			return SQLITE_NOTFOUND;
			//xOpen( my_file->
		}
		break;
	}
	return SQLITE_OK;
}
int xSectorSize(sqlite3_file*file)
{
	//struct my_file_data *my_file = (struct my_file_data*)file;
	return 512;
}
int xDeviceCharacteristics(sqlite3_file*file)
{
	//struct my_file_data *my_file = (struct my_file_data*)file;
	return SQLITE_IOCAP_ATOMIC|SQLITE_IOCAP_SAFE_APPEND|SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN|SQLITE_IOCAP_POWERSAFE_OVERWRITE;
}
  int xShmMap(sqlite3_file*file, int iPg, int pgsz, int a, void volatile**b)
  {
	  return 0;
  }
  int xShmLock(sqlite3_file*file, int offset, int n, int flags)
  {
	  return 0;
  }
  void xShmBarrier(sqlite3_file*file)
  {
  }
  int xShmUnmap(sqlite3_file*file, int deleteFlag)
  {
	  return 0;
  }
/* Methods above are valid for version 1 */
//int xShmMap(sqlite3_file*file, int iPg, int pgsz, int, void volatile**);
//int xShmLock(sqlite3_file*file, int offset, int n, int flags);
//void xShmBarrier(sqlite3_file*file);
//int xShmUnmap(sqlite3_file*file, int deleteFlag);
//{
// }
/* Methods above are valid for version 2 */
  /* Additional methods may be added in future releases */
struct sqlite3_io_methods my_methods = { 1
													/*, sizeof( struct my_file_data )*/
													, xClose
													, xRead
													, xWrite
													, xTruncate
													, xSync
													, xFileSize
													, xLock
													, xUnlock
													, xCheckReservedLock
													, xFileControl
													, xSectorSize
													, xDeviceCharacteristics
 //, xShmMap
                                       , NULL
 //, xShmLock
                                       , NULL
 //, xShmBarrier
                                       , NULL
 //, xShmUnmap
                                       , NULL
  // xfetch
                                       , NULL
 // xunfetch
                                       , NULL
};
int xOpen(sqlite3_vfs* vfs, const char *zName, sqlite3_file*file,
			 int flags, int *pOutFlags)
{
	struct my_sqlite3_vfs *my_vfs = (struct my_sqlite3_vfs *)vfs;
	struct my_file_data *my_file = (struct my_file_data*)file;
	static int temp_id;
	char buf[32];
	file->pMethods = &my_methods;
	my_file->mount = my_vfs->mount;
	if( zName == NULL )
	{
		snprintf( buf, 32, "sql-%d.tmp", temp_id++ );
		my_file->temp = TRUE;
		zName = buf;
	}
	else
		my_file->temp = FALSE;
#ifdef LOG_OPERATIONS
	lprintf( "Open file: %s (vfs:%s) (already)%p", zName, vfs->zName, my_file->file );
#endif
	my_file->filename = DupCStr( zName );
#if defined( __GNUC__ )
	//__ANDROID__
#define sack_fsopen(a,b,c,d) sack_fopen(a,b,c)
#define sack_fsopenEx(a,b,c,d,fsi) sack_fopenEx(a,b,c, fsi)
#endif
	if( my_vfs->mount )
	{
		//lprintf( "try on mount..%s .%p", my_file->filename, my_vfs->mount );
		if( (flags & (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE)) == (SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE) ) {
			if( !(my_file->file = sack_fsopenEx( 0, my_file->filename, WIDE("rb+"), _SH_DENYNO, my_vfs->mount ) ) )
				my_file->file = sack_fsopenEx( 0, my_file->filename, WIDE("wb+"), _SH_DENYNO, my_vfs->mount );
		} else if( flags & (SQLITE_OPEN_READWRITE) )
			my_file->file = sack_fsopenEx( 0, my_file->filename, WIDE( "rb+" ), _SH_DENYNO, my_vfs->mount );
		else if( flags & SQLITE_OPEN_CREATE )
			my_file->file = sack_fsopenEx( 0, my_file->filename, WIDE( "wb" ), _SH_DENYNO, my_vfs->mount );
		if( my_file->file )
		{
#ifdef LOG_OPERATIONS
			lprintf( "Opened file: %s (vfs:%s) %p", zName, vfs->zName, my_file->file );
#endif
			InitializeCriticalSec( &my_file->cs );
			return SQLITE_OK;
		}
		//lprintf( "failed..." );
	}
	else
	{
		my_file->file = sack_fsopen( 0, my_file->filename, WIDE("rb+"), _SH_DENYNO );
		if( !my_file->file )
			my_file->file = sack_fsopen( 0, my_file->filename, WIDE("wb+"), _SH_DENYNO );
		if( my_file->file )
		{
#ifdef LOG_OPERATIONS
			lprintf( "Opened file: %s (vfs:%s) %p", zName, vfs->zName, my_file->file );
#endif
			InitializeCriticalSec( &my_file->cs );
			return SQLITE_OK;
		}
	}
#if defined( __GNUC__ )
	//__ANDROID__
#undef sack_fsopen
#undef sack_fsopenEx
#endif
	return SQLITE_CANTOPEN;
}
int xDelete(sqlite3_vfs*vfs, const char *zName, int syncDir)
{
	struct my_sqlite3_vfs *my_vfs = (struct my_sqlite3_vfs *)vfs;
#ifdef LOG_OPERATIONS
	lprintf( "delete on %s (%s:%p)", zName, vfs->zName, my_vfs->mount );
#endif
#ifdef UNICODE
		sack_unlinkEx( 0, (TEXTSTR)zName, my_vfs->mount );
#else
		sack_unlinkEx( 0, zName, my_vfs->mount );
#endif
	return SQLITE_OK;
}
#ifndef F_OK
# define F_OK 0
#endif
#ifndef R_OK
# define R_OK 4
#endif
#ifndef W_OK
# define W_OK 2
#endif
/*
** Query the file-system to see if the named file exists, is readable or
** is both readable and writable.
*/
static int xAccess(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int flags,
  int *pResOut
){
	struct my_sqlite3_vfs *my_vfs = (struct my_sqlite3_vfs *)pVfs;
	int rc = 0;
	//int eAccess = F_OK;             /* Second argument to access() */
#if 0
	assert( flags==SQLITE_ACCESS_EXISTS
       || flags==SQLITE_ACCESS_READ
       || flags==SQLITE_ACCESS_READWRITE
  );
#endif
#ifdef LOG_OPERATIONS
	//lprintf( "Open file: %s (vfs:%s)", zName, vfs->zName );
	//lprintf( "Access on %s %s", zPath, pVfs->zName );
#endif
	//if( flags==SQLITE_ACCESS_READWRITE ) eAccess = R_OK|W_OK;
	//if( flags==SQLITE_ACCESS_READ )			eAccess = R_OK;
	//if( flags & SQLITE_ACCESS_EXISTS )
	{
#ifdef UNICODE
		CTEXTSTR _zPath = DupCStr(zPath);
#       define zPath _zPath
#endif
		if( sack_existsEx( zPath, my_vfs->mount ) )
		{
#ifdef LOG_OPERATIONS
			//lprintf( "Open file: %s (vfs:%s)", zName, vfs->zName );
			lprintf( "Access on %s %s = file exists path", zPath, pVfs->zName );
#endif
			rc = 0;
		}
		else
		{
#ifdef LOG_OPERATIONS
			//lprintf( "Open file: %s (vfs:%s)", zName, vfs->zName );
			lprintf( "Access on %s %s = no path", zPath, pVfs->zName );
#endif
			rc = -1;
		}
	}
	//rc = sack_access(zPath, eAccess);
	*pResOut = (rc==0);
	return SQLITE_OK;
}
/*
** Argument zPath points to a nul-terminated string containing a file path.
** If zPath is an absolute path, then it is copied as is into the output
** buffer. Otherwise, if it is a relative path, then the equivalent full
** path is written to the output buffer.
**
** This function assumes that paths are UNIX style. Specifically, that:
**
**   1. Path components are separated by a '/'. and
**   2. Full paths begin with a '/' character.
*/
static int xFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nPathOut,
  char *zPathOut
){
#ifdef UNICODE
	TEXTSTR tmp = DupCStr( zPath );
	TEXTSTR path = ExpandPath( tmp );
	char *tmp2 = CStrDup( path );
	strncpy( zPathOut, tmp2, nPathOut );
	Release( tmp );
	Release( tmp2 );
#else
	TEXTSTR path = ExpandPath( zPath );
	StrCpyEx( zPathOut, path, nPathOut );
#endif
	//lprintf( "Expand %s = %s", zPath, path );
	Release( path );
	return SQLITE_OK;
}
void InitVFS( CTEXTSTR name, struct file_system_mounted_interface *mount )
{
	struct my_sqlite3_vfs *vfs;
	INDEX idx;
	LIST_FORALL( l.registered_vfs, idx, struct my_sqlite3_vfs *, vfs )
	{
#ifdef UNICODE
		char *tmp = CStrDup( name );
		if( stricmp( vfs->vfs.zName, tmp ) == 0 )
			return;
#else
		if( StrCaseCmp( vfs->vfs.zName, name ) == 0 )
			return;
#endif
	}
	//lprintf( WIDE("getting interface...") );
	{
		sqlite3_vfs *default_vfs = sqlite3_vfs_find(NULL);
		struct my_sqlite3_vfs *new_vfs;
		//lprintf( "Register sqlite vfs called %s", name );
		new_vfs = New( struct my_sqlite3_vfs );
		MemCpy( &new_vfs->vfs, default_vfs, sizeof( sqlite3_vfs ) );
		new_vfs->vfs.pAppData = 0;
		new_vfs->vfs.szOsFile = sizeof( struct my_file_data );
		new_vfs->vfs.zName = CStrDup( name );
		new_vfs->vfs.xOpen = xOpen;
		new_vfs->vfs.xDelete = xDelete;
		new_vfs->vfs.xAccess = xAccess;
		new_vfs->vfs.xFullPathname = xFullPathname;
		new_vfs->mount = mount;
		if( sqlite3_vfs_register( &new_vfs->vfs, 0 ) )
		{
			//lprintf( WIDE("error registering my interface") );
		}
		AddLink( &l.registered_vfs, new_vfs );
		//int sqlite3_vfs_unregister(sqlite3_vfs*);
	}
}
void errorLogCallback(void *pArg, int iErrCode, const char *zMsg){
	if( iErrCode == SQLITE_NOTICE_RECOVER_WAL ) {
		extern struct pssql_global *global_sqlstub_data;
		lprintf( "Sqlite3 Notice: wal recovered: generating checkpoint:%s", zMsg);
		// after open returns, generate an automatic wal_checkpoint.
		global_sqlstub_data->flags.bAutoCheckpointRecover = 1;
	}
	else if( iErrCode == SQLITE_NOTICE_RECOVER_ROLLBACK ) {
		lprintf( "Sqlite3 Notice: journal rollback:%s", zMsg );
	}
	else if( iErrCode == SQLITE_ERROR )
 // these will generally be logged by other error handling.
		;
	else
		lprintf( "Sqlite3 Err: (%d) %s", iErrCode, zMsg);
}
static POINTER SimpleAllocate( int size )
{
	return HeapAllocateAligned( 0, size, 8 );
}
static POINTER SimpleReallocate( POINTER p, int size )
{
	return Reallocate( p, size );
}
static void SimpleFree( POINTER size )
{
	Release( size );
}
// this routine must return 'int' which is what sqlite expects for its interface
static int SimpleSize( POINTER p )
{
	return (int)SizeOfMemBlock( p );
}
static int SimpleRound( int size )
{
	return size;
}
static int SimpleInit( POINTER p )
{
	return TRUE;
}
static void SimpleShutdown( POINTER p )
{
}
static void DoInitVFS( void )
{
	if( l.registered_vfs )
		return;
	sqlite3_config( SQLITE_CONFIG_LOG, errorLogCallback, 0);
	{
#if SQLITE_VERSION_NUMBER >= 3006011
		static sqlite3_mem_methods mem_routines;
		if( mem_routines.pAppData == NULL )
		{
			sqlite3_config( SQLITE_CONFIG_GETMALLOC, &mem_routines );
			mem_routines.xMalloc = SimpleAllocate;
			mem_routines.xFree = SimpleFree;
			mem_routines.xRealloc = SimpleReallocate;
			mem_routines.xSize = SimpleSize;
			//mem_routines.xRoundUp = SimpleRound;
			//mem_routines.xInit = SimpleInit;
			//mem_routines.xShutdown = SimpleShutdown;
			mem_routines.pAppData = &mem_routines;
//#if SQLITE_VERSION_NUMBER >= 3006023
//			sqlite3_db_config( odbc->db, SQLITE_CONFIG_MALLOC, &mem_routines );
//#else
			sqlite3_config( SQLITE_CONFIG_MALLOC, &mem_routines );
//#endif
		}
#endif
	}
	InitVFS( WIDE("sack"), NULL );
}
static POINTER CPROC GetSQLiteInterface( void )
{
	//sqlite3_enable_shared_cache( 1 );
	DoInitVFS();
	return &my_sqlite_interface;
}
static void CPROC DropSQLiteInterface( POINTER p )
{
}
PRIORITY_PRELOAD( RegisterSQLiteInterface, SQL_PRELOAD_PRIORITY-2 )
{
	SimpleRegisterAndCreateGlobal( local_sqlite_interface );
	if( !GetInterface( "sqlite3" ) )
		RegisterInterface( WIDE("sqlite3"), GetSQLiteInterface, DropSQLiteInterface );
}
#undef l
SQL_NAMESPACE_END
#endif
#ifndef SQL_STRUCT_DEFINED
#define SQL_STRUCT_DEFINED
# if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
# endif
#if defined( __NO_ODBC__ )
// if not using odbc, need these
// otherwise they will be defined in sql.h
 // sqllite uses a generic int type for result codes
typedef int RETCODE;
typedef int SQLSMALLINT;
typedef unsigned int SQLULEN;
typedef int SQLINTEGER;
enum {
	SQL_HANDLE_DBC
      , SQL_HANDLE_STMT
};
#else
#  define USE_ODBC 1
#endif
 // critical section
SQL_NAMESPACE
enum {
	WM_SQL_COMMAND = MSG_UserServiceMessages
	  , WM_SQL_QUERY
	  , WM_SQL_DATA_START
	  , WM_SQL_DATA_MORE
	  , WM_SQL_RESULT_ERROR
	  , WM_SQL_RESULT_SUCCESS
     , WM_SQL_RESULT_DATA
     , WM_SQL_RESULT_MORE
	  , WM_SQL_MORE
	  , WM_SQL_GET_ERROR
 // no error, but no lines result
	  , WM_SQL_RESULT_NO_DATA
	  // which is not the same as no error, but an empty line resulted...
	  , WM_SQL_QUERY_RECORD
     , WM_SQL_RESULT_RECORD
     , WM_SQL_NUM_MESSAGES
};
typedef struct data_collection_tag
{
	struct {
 // sql commands during queries are given temporary status.
		BIT_FIELD  bTemporary  : 1;
 // not a static member
		BIT_FIELD  bDynamic : 1;
		BIT_FIELD  bBuildResultArray  : 1;
		BIT_FIELD bEndOfFile : 1;
 // pop should work up to this point.
		BIT_FIELD bPushed : 1;
	} flags;
 // the last SQL command for this...
	PVARTEXT pvt_out;
 // the last result for this...
	PVARTEXT pvt_result;
 // the last error info for this...
	PVARTEXT pvt_errorinfo;
	PSERVICE_ROUTE SourceID;
	struct odbc_handle_tag *odbc;
	uint32_t      responce;
	uint32_t      lastop;
   int    *column_types;
	size_t *result_len;
	TEXTSTR *results;
	//uint32_t nResults; // this is columns
	TEXTSTR *fields;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	sqlite3_stmt *stmt;
#endif
#if !defined( __NO_ODBC__ )
	SQLHSTMT    hstmt;
#endif
	SQLSMALLINT columns;
	PTEXT result_text;
	SQLULEN  *colsizes;
	SQLSMALLINT *coltypes;
	DeclareLink( struct data_collection_tag );
#ifdef WINDOWS_PROXY_EXTENSION
	uint32_t MyID;
	HWND     hLastWnd;
	HWND     hWnd;
#endif
} COLLECT, *PCOLLECT;
typedef struct database_info_tag
{
	struct {
		BIT_FIELD  bAutoUser  : 1;
	} flags;
	CTEXTSTR pDSN;
	TEXTCHAR pID[64];
	TEXTCHAR pPASSWORD[64];
	TEXTCHAR pConnString[256];
} DB_INFO, *PDB_INFO;
struct odbc_handle_tag{
	DB_INFO info;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	sqlite3 *db;
#endif
#if !defined( __NO_ODBC__ )
  // odbc database access handle...
	SQLHENV    env;
 // handle to database connection
	SQLHDBC    hdbc;
#endif
	struct {
		BIT_FIELD  bConnected  : 1;
 // operate as if talking to an access MDB
		BIT_FIELD  bAccess  : 1;
 // sqllite via sqlite odbc driver...
		BIT_FIELD  bSQLite  : 1;
  // for selecting how transactions are done.
		BIT_FIELD  bMySQL : 1;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		BIT_FIELD  bSQLite_native  : 1;
#endif
#if USE_ODBC
 // odbc is actually an odbc
		BIT_FIELD  bODBC  : 1;
#endif
 // set to skip ODBC connection (if dsn has a '.' in it)
		BIT_FIELD bSkipODBC  : 1;
 // do NOT log to SQL.log
		BIT_FIELD bNoLogging  : 1;
 // pop should work up to this point. just did a push... next collector should be marked.
		BIT_FIELD bPushed : 1;
 // same sort of thing as the global flag... but that should just apply to default connection?
		BIT_FIELD bForceConnection : 1;
		BIT_FIELD bFailEnvOnDbcFail : 1;
		// generate begintransaction and commit automatically.
		BIT_FIELD bAutoTransact : 1;
 // use enter/leave critical section on this connector (auto transact protector)
		BIT_FIELD bThreadProtect : 1;
 // don't leave the connection open 100%; open when required and close when idle
		BIT_FIELD bAutoClose : 1;
 // sqlite; alternative to closing; generate wal_checkpoints automatically on idle.
		BIT_FIELD bAutoCheckpoint : 1;
		BIT_FIELD bClosed : 1;
	} flags;
 // this one tracks auto commit state; it is cleared when a commit happens
	uint32_t last_command_tick;
 // this one tracks truly the last operation on a connection
	uint32_t last_command_tick_;
	uint32_t commit_timer;
	PCOLLECT collection;
 // saved for resulting with native error code...
	int native;
 // allow user to associate some data with this.
	uintptr_t psvUser;
	CRITICALSECTION cs;
 // critical section is currently owned
	int nProtect;
	PTHREAD auto_commit_thread;
	PTHREAD auto_close_thread;
	PTHREAD auto_checkpoint_thread;
	struct odbc_queue *queue;
	void (CPROC*auto_commit_callback)(uintptr_t,PODBC);
	uintptr_t auto_commit_callback_psv;
	void (CPROC*pCorruptionHandler)(uintptr_t psv, PODBC odbc);
	uintptr_t psvCorruptionHandler;
};
struct odbc_queue
{
	CTEXTSTR name;
   PLINKQUEUE connections;
};
#ifdef SQLLIB_SOURCE
struct pssql_global
{
	CRITICALSECTION Init;
	//POPTION_INTERFACE pOptionInterface;
	uint32_t PrimaryLastConnect, BackupLastConnect;
	ODBC Primary, Backup;
 // current connection
	PODBC odbc;
#ifdef __cplusplus
//	sack::containers::list::
#endif
 // list of PODBC objects which are open.
	PLIST pOpenODBC;
 // collections which were created for g.odbc while it was NULL
	PCOLLECT collections;
 // this is used for fatal errors when neither primary or backup are set in g.odbc
	COLLECT LocalCollect;
 // used when checking status... as a static element it's more reliable.
	COLLECT TimerCollect;
	struct {
		BIT_FIELD  bInited  : 1;
		// when this happens, something
		// needs to be done to update information from the
		// backup to the primary
		// and from the primary to the backup
		// if BOTH have failed - we're how shall I say... fucked.
		BIT_FIELD  bPrimaryRestored  : 1;
		BIT_FIELD  bNoBackup  : 1;
		BIT_FIELD  bPrimaryUp  : 1;
		BIT_FIELD  bBackupUp  : 1;
		BIT_FIELD  bNoLog  : 1;
		BIT_FIELD  bOpening  : 1;
		BIT_FIELD  bMySQL  : 1;
		BIT_FIELD  bPostgresql  : 1;
		BIT_FIELD  bBadODBC  : 1;
 // do log to SQL.log
		BIT_FIELD  bLogging  : 1;
		BIT_FIELD  bFallback : 1;
		BIT_FIELD  bRequireConnection : 1;
		BIT_FIELD bLogData : 1;
		BIT_FIELD  bLogOptionConnection : 1;
		BIT_FIELD bCriticalSectionInited : 1;
		BIT_FIELD bDeadstartCompleted : 1;
		BIT_FIELD bAutoCheckpoint : 1;
		BIT_FIELD bAutoCheckpointRecover : 1;
	} flags;
	struct update_task_def *UpdateTasks;
	PSERVICE_ROUTE SQLMsgBase;
	FILE *pSQLLog;
	void (CPROC*feedback_handler)(CTEXTSTR message);
 // a third, well-known DSN used for option library by default.  May be SQLite.
	ODBC OptionDb;
	PLIST date_offsets;
	PLIST odbc_queues;
	PLIST option_database_init;
	PLIST database_init;
	// ----- shared with option code; these need to be shared between instances.
  // some
	PTREEROOT tables;
};
#endif
INDEX GetIndexOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name);
PTREEROOT GetTableCache( PODBC odbc, CTEXTSTR tablename );
CTEXTSTR GetKeyOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name);
int OpenSQL( DBG_VOIDPASS );
void CloseDatabaseEx( PODBC odbc, LOGICAL ReleaseConnection );
#ifdef USE_SQLITE_INTERFACE
#  if defined( __WATCOMC__ ) && !defined( BUILDS_INTERFACE ) && ( __WATCOMC__ < 1300 )
#    define FIXREF
#    define FIXDEREF
#    define FIXREF2 *
#    define FIXDEREF2 *
#  else
#    define FIXREF
#    define FIXDEREF
#    define FIXREF2
#    define FIXDEREF2
#  endif
struct sqlite_interface
{
	void(FIXREF2 *sqlite3_result_text)(sqlite3_context*, const char*, int, void(*)(void*));
	void*(FIXREF*sqlite3_user_data)(sqlite3_context*);
	sqlite3_int64 (FIXREF2*sqlite3_last_insert_rowid)(sqlite3*);
	int (FIXREF*sqlite3_create_function)(  sqlite3 *db,
	  const char *zFunctionName,
	  int nArg,
	  int eTextRep,
	  void *pApp,
	  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
	  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
	  void (*xFinal)(sqlite3_context*)
	);
	int (FIXREF2*sqlite3_get_autocommit)(sqlite3*);
	int (FIXREF2*sqlite3_open)(  const char *filename,
	  sqlite3 **ppDb
	);
	int (FIXREF2*sqlite3_open_v2)(
	  const char *filename,
	  sqlite3 **ppDb,
	  int flags,
	  const char *zVfs
	);
	const char* (FIXREF2*sqlite3_errmsg)(sqlite3*);
	int (FIXREF2*sqlite3_finalize)(sqlite3_stmt *);
	int (FIXREF2*sqlite3_close)(sqlite3*);
#  if ( SQLITE_VERSION_NUMBER > 3007013 )
	int (FIXREF2*sqlite3_close_v2)(sqlite3*);
#  endif
	int (FIXREF2*sqlite3_prepare_v2)(
	  sqlite3 *db,
	  const char *zSql,
	  int nByte,
	  sqlite3_stmt **ppStmt,
	  const char **pzTail     );
	int (FIXREF2*sqlite3_prepare16_v2)(
		  sqlite3 *db,
		  const void *zSql,
		  int nByte,
		  sqlite3_stmt **ppStmt,
		  const void **pzTail
		);
	int (FIXREF2*sqlite3_step)(sqlite3_stmt *);
	const char* (FIXREF2*sqlite3_column_name)(sqlite3_stmt *pStmt, int col);
	const unsigned char* (FIXREF*sqlite3_column_text)(sqlite3_stmt *pStmt, int col);
	int (FIXREF2*sqlite3_column_bytes)(sqlite3_stmt *pStmt, int col);
	int (FIXREF*sqlite3_column_type )(sqlite3_stmt *pStmt, int col);
	int (FIXREF2*sqlite3_column_count)(sqlite3_stmt *pStmt);
	int (FIXREF2*sqlite3_config)(int,...);
	int (FIXREF2*sqlite3_db_config)(sqlite3*, int op, ...);
	// allow full definition of a VFS including the FS interface
	void (*InitVFS)( CTEXTSTR name, struct file_system_mounted_interface *fsi );
	sqlite3_backup *( FIXREF2*sqlite3_backup_init)(
			  sqlite3 *pDest,
			  const char *zDestName,
			  sqlite3 *pSource,
			  const char *zSourceName
				);
	int ( FIXREF2*sqlite3_backup_step)(sqlite3_backup *p, int nPage);
	int ( FIXREF2*sqlite3_backup_remaining)(sqlite3_backup *p);
	//int ( FIXREF2*sqlite3_backup_pagecount)(sqlite3_backup *p);
	int ( FIXREF2*sqlite3_backup_finish)(sqlite3_backup *p);
	int ( FIXREF2*sqlite3_extended_errcode)(sqlite3 *db);
	int ( FIXREF2*sqlite3_stmt_readonly)(sqlite3_stmt *pStmt);
	const char *( FIXREF2*sqlite3_column_table_name )( sqlite3_stmt *odbc, int col );
	const char *( FIXREF2*sqlite3_column_table_alias )( sqlite3_stmt *odbc, int col );
};
#  ifndef DEFINES_SQLITE_INTERFACE
extern
#  endif
        struct sqlite_interface *sqlite_iface;
#  ifdef DEFINES_SQLITE_INTERFACE
PRIORITY_PRELOAD( LoadSQLiteInterface, SQL_PRELOAD_PRIORITY-1 )
{
   sqlite_iface = (struct sqlite_interface*)GetInterface( WIDE("sqlite3") );
}
#  endif
#  ifndef BUILDS_INTERFACE
#    define sqlite3_result_text          (FIXDEREF2 (sqlite_iface->sqlite3_result_text))
#    define sqlite3_user_data            (FIXDEREF (sqlite_iface->sqlite3_user_data))
#    define sqlite3_last_insert_rowid    (FIXDEREF2 (sqlite_iface->sqlite3_last_insert_rowid))
#    define sqlite3_create_function      (FIXDEREF (sqlite_iface->sqlite3_create_function))
#    define sqlite3_get_autocommit       (FIXDEREF2 (sqlite_iface->sqlite3_get_autocommit))
#    define sqlite3_open(a,b)            (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_open))(a,b):SQLITE_ERROR
#    define sqlite3_open_v2(a,b,c,d)     (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_open_v2))(a,b,c,d):SQLITE_ERROR
#    define sqlite3_errmsg(db)           (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_errmsg))(db):"No Sqlite3 Interface"
#    define sqlite3_finalize             (FIXDEREF2 (sqlite_iface->sqlite3_finalize))
#    define sqlite3_close                (FIXDEREF2 (sqlite_iface->sqlite3_close))
#    define sqlite3_close_v2             (FIXDEREF2 (sqlite_iface->sqlite3_close_v2))
#    define sqlite3_prepare_v2           (FIXDEREF2 (sqlite_iface->sqlite3_prepare_v2))
#    define sqlite3_prepare16_v2         (FIXDEREF2 (sqlite_iface->sqlite3_prepare16_v2))
#    define sqlite3_step                 (FIXDEREF2 (sqlite_iface->sqlite3_step))
#    define sqlite3_column_name          (FIXDEREF2 (sqlite_iface->sqlite3_column_name))
#    define sqlite3_column_text          (FIXDEREF (sqlite_iface->sqlite3_column_text))
#    define sqlite3_column_bytes         (FIXDEREF2 (sqlite_iface->sqlite3_column_bytes))
#    define sqlite3_column_type          (FIXDEREF (sqlite_iface->sqlite3_column_type))
#    define sqlite3_column_count         (FIXDEREF2 (sqlite_iface->sqlite3_column_count))
#    define sqlite3_config               (FIXDEREF2 (sqlite_iface->sqlite3_config))
#    define sqlite3_db_config            (FIXDEREF2 (sqlite_iface->sqlite3_db_config))
#    define sqlite3_backup_init          (FIXDEREF2 (sqlite_iface->sqlite3_backup_init))
#    define sqlite3_backup_step          (FIXDEREF2 (sqlite_iface->sqlite3_backup_step))
#    define sqlite3_backup_finish        (FIXDEREF2 (sqlite_iface->sqlite3_backup_finish))
#    define sqlite3_backup_remaining     (FIXDEREF2 (sqlite_iface->sqlite3_backup_remaining))
#    define sqlite3_extended_errcode     (FIXDEREF2 (sqlite_iface->sqlite3_extended_errcode))
#    define sqlite3_stmt_readonly        (FIXDEREF2 (sqlite_iface->sqlite3_stmt_readonly))
#    define sqlite3_column_table_name    (FIXDEREF2 (sqlite_iface->sqlite3_column_table_name))
#    define sqlite3_column_table_alias (FIXDEREF2 (sqlite_iface->sqlite3_column_table_alias))
#  endif
#endif
SQL_NAMESPACE_END
#endif
#define NO_UNICODE_C
#ifdef _MSC_VER
//#define NO_CRT_SECURE_WARNINGS
#endif
#define DEFINE_DEFAULT_IMAGE_INTERFACE
 // sockaddr, createaddress(str,defport)
#define FULL_TRACE
#define LOG_LINES_READ
////#define DEBUG_SLOWNESS
//#define DEBUG_SAVE_CONFIG
//#if defined( GCC ) && !defined( __arm__ )
//#define NEED_ASSEMBLY_CALLER
//#endif
#define DO_LOGGING
#ifdef __cplusplus
namespace sack { namespace config {
using namespace sack::math::fraction;
#endif
#ifdef __LINUX__
#define stricmp strcasecmp
#define strnicmp strncasecmp
#endif
#define CompareText(l1,l2)	( StrCaseCmp( GetText(l1), GetText(l2) ) )
// all matches to content are done case insensitive.
// consider vector/array declarations
enum config_types {
	CONFIG_UNKNOWN
	// must match case-insensative exact length.
	// literal text
	, CONFIG_TEXT
	// a yes/no field may be 0/1, y[es]/n[o], on/off
	//
	, CONFIG_YESNO
	, CONFIG_TRUEFALSE = CONFIG_YESNO
	, CONFIG_ONOFF = CONFIG_YESNO
	, CONFIG_OPENCLOSE = CONFIG_YESNO
	, CONFIG_BOOLEAN = CONFIG_YESNO
	// may not have a . point - therefore the . is a terminator and needs
	// to match the next word.
	, CONFIG_INTEGER
	// has to be a floating point number (perhaps integral ie. no decimal)
	, CONFIG_FLOAT
	// binary data storage - stored as base64 encoded passed as PDATA
	, CONFIG_BINARY
	// formated number [+/-][[ ]## ]##[/##]
	, CONFIG_FRACTION
	// matches any single word.
	, CONFIG_SINGLE_WORD
	// protocol://[user[:password]](ip/name)[:port][/filepath][?cgi]
	// by convention this will not contain spaces... but perhaps
	// &20; (?)
	, CONFIG_URL
	// matches several words in a row - the end word to match is supplied.
	, CONFIG_MULTI_WORD
	// file name - does not have any path part.
	// the following are all treated like multi_word since file names/paths
	// may contain spaces
	, CONFIG_FILE
	// ends in a / or \,
	, CONFIG_PATH
	// may have path and filename
	, CONFIG_FILEPATH
	// (IP/name)[:port]
	, CONFIG_ADDRESS
	// end of configuration line (match assumed)
	, CONFIG_PROCEDURE
	, CONFIG_PROCEDURE_EX
	, CONFIG_COLOR
 // to save as an option after variables
	, CONFIG_NOTHING
};
typedef struct config_element_tag CONFIG_ELEMENT, *PCONFIG_ELEMENT;
struct config_element_tag
{
	enum config_types type;
// if a match is found, follow this to next.
	struct config_test_tag *next;
	struct config_element_tag *prior;
 // this is where we came from
	struct config_element_tag **ppMe;
	struct {
		BIT_FIELD vector : 1;
 // prior == actual segment...
		BIT_FIELD multiword_terminator : 1;
 // prior == actual segment...
		BIT_FIELD singleword_terminator : 1;
		// careful - assembly here requires absolute known
		// posisitioning - -fpack-struct will short-change
		// this structure to the minimal number of bits.
		BIT_FIELD filler:29;
	} flags;
 // used with vector fields.
	uint32_t element_count;
	union {
		PTEXT pText;
		struct {
				LOGICAL bTrue;
		} truefalse;
		uint64_t integer_number;
		double float_number;
 // also pFilename, pPath, pURL
		TEXTSTR pWord;
		struct {
 // also pFilename, pPath, pURL
			TEXTSTR pWord;
 // also this ends single word...
			PLIST pEnds;
			struct config_element_tag *pWhichEnd;
		} singleword;
		// maybe pURL should be burst into
		//	( address, user, password, path, page, params )
		SOCKADDR *psaSockaddr;
		struct {
			TEXTSTR pWords;
				 // next thing to match...
				 // this is probably a constant text thing, but
				 // may be say an integer, filename, or some known
				 // format thing...
//struct config_element_tag *pEnd;
			PLIST pEnds;
			struct config_element_tag *pWhichEnd;
		} multiword;
		FRACTION fraction;
		USER_CONFIG_HANDLER Process;
		struct {
			USER_CONFIG_HANDLER_EX Process;
			uintptr_t arg;
		} ProcessEx;
		CDATA Color;
		struct {
			size_t length;
			POINTER data;
		} binary;
 // these are value holders... if there is a vector field,
	} data[1];
				// either the count will be specified, or this will have to
				// be auto expanded....
};
typedef struct config_test_tag
{
	// this constant list could be a more optimized structure like
	// a tree...
  // list of words which are constant to be checked.
	PLIST pConstElementList;
	// list of fields which are variables.
	PLIST pVarElementList;
} CONFIG_TEST, *PCONFIG_TEST;
#define MAXCONFIG_TESTSPERSET 128
DeclareSet( CONFIG_TEST );
#define MAXCONFIG_ELEMENTSPERSET 128
DeclareSet( CONFIG_ELEMENT );
typedef struct config_file_tag CONFIG_HANDLER;
struct config_file_tag
{
	// this needs to be the first element -
	// address of this IS the address of main structure
	CONFIG_TEST ConfigTestRoot;
	PDATASTACK ConfigStateStack;
	FILE *file;
	//gcroot<System::IO::StreamReader^> sr;
	//gcroot<System::IO::FileStream^> fs;
	PTEXT blocks;
	// this should be more than one...
	// and each will be called in order that it was
	// added, very importatn first in first process
	PLIST filters;
 // a scratch pointer addrss passd to each filter ... (per config handler)
	PLIST filter_data;
	//uintptr_t (CPROC *filter)(uintptr_t,int *,char**);
	uintptr_t psvUser;
	uintptr_t (CPROC *EndProcess)( uintptr_t );
	uintptr_t (CPROC *Unhandled)( uintptr_t, CTEXTSTR );
	PCONFIG_ELEMENTSET elements;
	PCONFIG_TESTSET test_elements;
	LOGICAL config_recovered;
	CTEXTSTR save_config_as;
 // history of saved coniguration states...
	PLIST states;
	struct config_file_flags {
 // if used, don't release
		BIT_FIELD bConfigSaveNameUsed : 1;
		BIT_FIELD bUnicode : 1;
		BIT_FIELD bUnicode8 : 1;
	} flags;
};
typedef struct configuation_state *PCONFIG_STATE;
typedef struct configuation_state {
	LOGICAL recovered;
	CTEXTSTR name;
	CONFIG_TEST ConfigTestRoot;
	uintptr_t psvUser;
	uintptr_t (CPROC *EndProcess)( uintptr_t );
	uintptr_t (CPROC *Unhandled)( uintptr_t, CTEXTSTR );
} CONFIG_STATE;
struct configscript_global {
	//LOGICAL bSaveMemDebug;
	int _last_allocate_logging;
	int _disabled_allocate_logging;
	struct {
		BIT_FIELD bInitialized : 1;
		BIT_FIELD bDisableMemoryLogging : 1;
		BIT_FIELD bLogUnhandled : 1;
		BIT_FIELD bLogTrace : 1;
		BIT_FIELD bLogLines : 1;
	} flags;
};
#ifdef g
#  undef g
#endif
#ifndef __STATIC_GLOBALS__
static struct configscript_global *global_config_data;
PRIORITY_PRELOAD( InitGlobalConfigScript, CONFIG_SCRIPT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( global_config_data );
}
#else
static struct configscript_global _global_config_data;
static struct configscript_global *global_config_data = &_global_config_data;
#endif
#define g (*global_config_data)
void DoInit( void )
{
#ifndef __STATIC_GLOBALS__
	if( !global_config_data )
		SimpleRegisterAndCreateGlobal( global_config_data );
#endif
	if( !g.flags.bInitialized )
	{
		g.flags.bDisableMemoryLogging = 1;
		g.flags.bLogUnhandled = 0;
		g.flags.bInitialized = 1;
	}
}
PRELOAD( InitGlobalConfig2 )
{
	DoInit();
#if !defined( __NO_OPTIONS__ )
	// later, set options - core startup configs like sql.config cannot read options.
	g.flags.bDisableMemoryLogging = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Disable Memory Logging" ), g.flags.bDisableMemoryLogging, TRUE );
	g.flags.bLogUnhandled = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Log Unhandled if no application handler" ), g.flags.bLogUnhandled, TRUE );
	g.flags.bLogTrace = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Log configuration processing(trace)" ), g.flags.bLogTrace, TRUE );
	g.flags.bLogLines = SACK_GetProfileIntEx( WIDE( "SACK/Config Script" ), WIDE( "Log configuration line input" ), g.flags.bLogLines, TRUE );
#endif
}
//#else
//#define g global_config_data
//static GLOBAL g;
//#endif
//---------------------------------------------------------------------
void LogElementEx( CTEXTSTR leader, PCONFIG_ELEMENT pce DBG_PASS)
#define LogElement(leader,pc) LogElementEx(leader,pc DBG_SRC )
{
	if( !pce )
	{
		_lprintf(DBG_RELAY)( WIDE("Nothing.") );
		return;
	}
	switch( pce->type )
	{
	case CONFIG_UNKNOWN:
		_lprintf(DBG_RELAY)( WIDE("This thing was never configured?") );
		break;
	case CONFIG_TEXT:
		_lprintf(DBG_RELAY)( WIDE("%s text constant: %s"), leader, GetText( pce->data[0].pText ) );
		break;
	case CONFIG_BOOLEAN:
		_lprintf(DBG_RELAY)( WIDE("%s a boolean"), leader );
		break;
	case CONFIG_INTEGER:
		_lprintf(DBG_RELAY)( WIDE("%s integer"), leader );
		break;
	case CONFIG_COLOR:
		_lprintf(DBG_RELAY)( WIDE("%s color"), leader );
		break;
	case CONFIG_BINARY:
		_lprintf(DBG_RELAY)( WIDE("%s binary"), leader );
		break;
	case CONFIG_FLOAT:
		_lprintf(DBG_RELAY)( WIDE("%s Floating"), leader );
		break;
	case CONFIG_FRACTION:
		_lprintf(DBG_RELAY)( WIDE("%s fraction"), leader );
		break;
	case CONFIG_SINGLE_WORD:
		_lprintf(DBG_RELAY)( WIDE("%s a single word:%p"), leader, pce->data[0].pWord );
		break;
	case CONFIG_MULTI_WORD:
		_lprintf(DBG_RELAY)( WIDE("%s a multi word"), leader );
		break;
	case CONFIG_PROCEDURE:
		_lprintf(DBG_RELAY)( WIDE("%s a procedure to call."), leader );
		break;
	case CONFIG_PROCEDURE_EX:
		_lprintf( DBG_RELAY )(WIDE( "%s a procedure to call." ), leader);
		break;
	case CONFIG_URL:
	_lprintf(DBG_RELAY)( WIDE("%s a url?"), leader );
	break;
	case CONFIG_FILE:
	_lprintf(DBG_RELAY)( WIDE("%s a filename"), leader );
	break;
	case CONFIG_PATH:
	_lprintf(DBG_RELAY)( WIDE("%s a path name"), leader );
	break;
	case CONFIG_FILEPATH:
	_lprintf(DBG_RELAY)( WIDE("%s a full path and file name"), leader );
	break;
	case CONFIG_ADDRESS:
	_lprintf(DBG_RELAY)( WIDE("%s an address"), leader );
	break;
	default:
		_lprintf(DBG_RELAY)( WIDE("Do not know what this is.") );
		break;
	}
}
//---------------------------------------------------------------------
void DumpConfigurationEvaluator( PCONFIG_HANDLER pch )
{
	INDEX idx;
	PCONFIG_ELEMENT pce;
	LIST_FORALL( pch->ConfigTestRoot.pConstElementList, idx, PCONFIG_ELEMENT, pce )
	{
		LogElement( WIDE("const"), pce );
	}
	LIST_FORALL( pch->ConfigTestRoot.pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
		LogElement( WIDE( "var" ), pce );
	}
}
//---------------------------------------------------------------------
// man what a friggin mess just to deal with ANY
// kind of mangled input and spit out some kinda lines
// uhmm...
static PTEXT CPROC FilterLines( POINTER *scratch, PTEXT buffer )
{
	struct my_scratch_data {
		size_t skip;
		int lastread;
		PTEXT linebuf;
	} *data = (struct my_scratch_data*)scratch[0];
	size_t total_length;
	size_t n;
	size_t thisskip;
	if( !data && buffer )
	{
		scratch[0] = data = New( struct my_scratch_data );
		data[0].skip = 0;
		data[0].linebuf = 0;
		data[0].lastread = 0;
	}
	else if( !data )
		return NULL;
 // skip N characters in first buffer.
	thisskip = data->skip;
	if( buffer )
	{
		data->lastread = FALSE;
		data->linebuf = SegAppend( data->linebuf, buffer );
	}
#if 0
	// this routine is a low level raw data input, line result routine.
	// it would be the sort of thing that produces zerosegs.
	// this will NEVER run - the above condition catches it.
	else if( buffer && !GetTextSize( buffer ) )
	{
		// if the buffer is a zeroseg, then it's a end of line marker.
		// assuming other things filter before this.... in reality
		// burst returns newlines I think?
		PTEXT text = data->linebuf;
		data->lastread = FALSE;
		Release( scratch[0] );
		scratch[0] = NULL;
		if( text )
		{
			LineRelease( buffer );
			lprintf( WIDE( "Returning buffer [%s]" ), GetText( text ) );
			return text;
		}
		else
		{
			lprintf( WIDE( "Returning buffer [%s]" ), GetText( buffer ) );
 // pass it on to others - end of stream..
			return buffer;
		}
	}
#endif
	else if( !buffer )
	{
		if( data->lastread )
		{
			PTEXT final = NULL;
			if( data->linebuf )
				final = SegCreateFromText( GetText( data->linebuf ) + data->skip );
			LineRelease( data->linebuf );
			Release( scratch[0] );
			scratch[0] = NULL;
			if( g.flags.bLogLines )
				lprintf( WIDE( "Returning buffer [%s]" ), GetText( final ) );
			return final;
		}
	}
	buffer = data->linebuf;
	total_length = 0;
	while( buffer )
	{
		// full new buffer, which may or may not add to prior segments...
		int end = 0;
		size_t length = GetTextSize( buffer );
		CTEXTSTR chardata = GetText( buffer );
		//lprintf( WIDE( "Considering buffer %s" ), GetText( buffer ) + data->skip );
		if( !length )
			LineRelease( SegGrab( buffer ) );
		for( n = thisskip; n < length; n++ )
		{
			if( chardata[n] == '\n' ||
				chardata[n] == '\r' )
			{
				if( chardata[n] == '\n' )
				{
					end = 1;
 // include this character.
					n++;
					//lprintf( WIDE("BLANK LINE - CONSUMED") );
					break;
				}
 // \r\r is two lines too
				if( end )
				{
					break;
				}
				end = 1;
			}
			else if( end )
			{
				// any other character... after a \r.. don't include the character.
				break;
			}
		}
		total_length += n - thisskip;
		if( end )
		{
			// new character, trim at -1 from here...
			PTEXT result = SegCreate( (int32_t)total_length );
			size_t ofs;
			buffer = data->linebuf;
			thisskip = data->skip;
			n = thisskip;
			ofs = 0;
			while( ofs < total_length )
			{
				size_t len = GetTextSize( buffer );
				if( len > ( len - thisskip ) )
					len = len - thisskip;
				if( len > ( total_length - ofs ) )
					len = total_length - ofs;
				MemCpy( GetText( result ) + ofs
					, GetText( buffer ) + thisskip
					, sizeof( TEXTCHAR)*len );
				ofs += len;
				n += len;
				if( ofs < total_length )
				{
					n = 0;
					thisskip = 0;
					buffer = NEXTLINE( buffer );
				}
			}
			if( buffer )
			{
				data->skip = n;
				LineRelease( SegBreak( buffer ) );
				data->linebuf = buffer;
			}
			else
				data->skip = 0;
			GetText(result)[total_length] = 0;
			//lprintf( "Considering buffer %s", GetText( result ) );
			if( g.flags.bLogLines )
				lprintf( WIDE( "Returning buffer [%s]" ), GetText( result ) );
			return result;
		}
		else
		{
			//lprintf( WIDE("Had no end within the buffer, waiting for another...") );
		}
 // no more skips.
		thisskip = 0;
		buffer = NEXTLINE( buffer );
	}
	data->lastread = TRUE;
	return NULL;
}
//---------------------------------------------------------------------
static PTEXT CPROC FilterTerminators( POINTER *scratch, PTEXT buffer )
{
	struct my_scratch_data {
		PTEXT newline;
	} *data = (struct my_scratch_data*)scratch[0];
	if( !data && buffer )
	{
		scratch[0] = data = New( struct my_scratch_data );
		data[0].newline = NULL;
	}
	else if( !data )
		return NULL;
	if( !buffer )
	{
		if( data[0].newline )
		{
			PTEXT tmp = data[0].newline;
			data[0].newline = NULL;
			return tmp;
		}
		else
			return NULL;
	}
	{
		int modified;
		int end = TRUE;
		// filter \r\n\\ just cause...
		data[0].newline = SegAppend( data[0].newline, buffer );
		while( buffer )
		{
			TEXTSTR chardata = GetText( buffer );
			size_t length = GetTextSize( buffer );
			//LogBinary( chardata, length );
			do
			{
				modified = 0;
				if( length && chardata[length-1] == '\n' )
				{
					//Log( WIDE("Removing newline...") );
					end = TRUE;
					length--;
					modified = 1;
				}
				if( length && chardata[length-1] == '\r' )
				{
					//lprintf( WIDE("Removing cr...") );
					end = TRUE;
					length--;
					modified = 1;
				}
				if( length && chardata[length-1] == '\\' )
				{
					if( ( length > 1 ) && ( chardata[length-2] != '\\' ) )
					{
						//lprintf( WIDE("Removing continue slash...") );
						end = FALSE;
						length--;
						modified = 1;
					}
				}
			} while( modified );
			if( !length )
			{
				LineRelease( SegGrab( buffer ) );
				data[0].newline = NULL;
				return NULL;
			}
			chardata[length] = 0;
			//lprintf( WIDE("Resulting line: %s"), chardata );
			SetTextSize( buffer, length );
			buffer = NEXTLINE( buffer );
		}
		if( end )
		{
			PTEXT result = data[0].newline;
			data[0].newline = NULL;
			return result;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
/* does not need scratch buffer... */
static PTEXT CPROC FilterEscapesAndComments( POINTER *scratch, PTEXT pText )
{
	CTEXTSTR text = GetText( pText );
	PTEXT pNewText;
 /*&& strchr( text, '\\' )*/
	if( text )
	{
		PTEXT tmp;
		tmp = pNewText = TextDuplicate( pText, FALSE );
		while( tmp )
		{
			int dest = 0, src = 0;
			TEXTSTR text = GetText( tmp );
			while( text && text[src] )
			{
				if( text[src] == '\\' )
				{
					src++;
					switch( text[src] )
					{
					case 0:
						lprintf( WIDE( "Continuation at end of line... save this and append next line please." ) );
						break;
					default:
						text[dest++] = text[src];
						break;
					}
				}
				else
				{
					if( text[src] == '#' )
						break;
					text[dest++] = text[src];
				}
				src++;
			}
			text[dest] = 0;
			SetTextSize( tmp, dest );
			tmp = NEXTLINE( tmp );
		}
		LineRelease( pText );
	}
	else
		pNewText = pText;
	return pNewText;
}
//---------------------------------------------------------------------
static PTEXT get_line(PCONFIG_HANDLER pch
							, int bReturnBlank )
{
  // character for workspace
#define WORKSPACE 1024
	FILE *source = pch->file;
	PLIST *filters = &pch->filters;
	PLIST *filter_data = &pch->filter_data;
	PTEXT newline = NULL;
	int one_more_read = 0;
	//if( !source && !pch->blocks )
	//	return NULL;
	// create a workspace to read input from the file.
	// read a line of input from the file.
	// can't use fgets with encrypted data, but have to use something
	// more like read(), pass to decrypt, then decode lines.
	{
		INDEX idx;
		PTEXT (CPROC *filter)(POINTER*,PTEXT);
		size_t readlen;
		do
		{
			int didone;
		do_filters:
			do
			{
				didone = FALSE;
				LIST_FORALL( filters[0], idx, PTEXT (CPROC *)(POINTER*,PTEXT), filter )
				{
					// request any existing data without adding more...
					newline = filter( GetLinkAddress( filter_data, idx ), newline );
					//lprintf( WIDE( "Process line: %s" ), GetText( newline ) );
					//lprintf( WIDE("after filter %d line = %s"), idx, GetText( newline ) );
					if( newline )
					{
						one_more_read = 0;
						didone = TRUE;
					}
					else
					{
						//lprintf( WIDE("no more newline... it's been deleted...") );
 // had one, lost it, try for another from the top of blank...
						if( didone )
						{
							if( bReturnBlank )
								return SegCreate(0);
							didone = 0;
							break;
						}
					}
				}
			}
			while( !newline && didone );
			if( !newline )
			{
				if( source )
				{
					char buffer[WORKSPACE];
					wchar_t wbuffer[WORKSPACE];
					newline = NULL;
					if( pch->flags.bUnicode )
					{
						if( !one_more_read )
						{
							if( ( readlen = sack_fread( wbuffer, sizeof( wchar_t ), WORKSPACE-1, source ) ) )
							{
								wbuffer[readlen] = 0;
								newline = SegCreateFromWideLen( wbuffer, readlen );
							}
							else
							{
								newline = NULL;
								one_more_read = 1;
							}
						}
						else
							one_more_read = 0;
					}
					else
					{
						if( !one_more_read )
						{
							if( ( readlen = sack_fread( buffer, sizeof( char ), WORKSPACE-1, source ) ) )
							{
								buffer[readlen] = 0;
								newline = SegCreateFromCharLen( buffer, readlen );
							}
							else
							{
								newline = NULL;
								one_more_read = 1;
							}
						}
						else
							one_more_read = 0;
					}
				}
				else
				{
					if( !one_more_read )
					{
						newline = pch->blocks;
 // received block.
						pch->blocks = NULL;
						one_more_read = 1;
					}
					else if( !newline )
					{
						readlen = 0;
						one_more_read = 0;
					}
				}
				if( newline || one_more_read )
					goto do_filters;
				/*
				LIST_FORALL( filters[0], idx, PTEXT (CPROC *)(POINTER*,PTEXT), filter )
				{
					newline = filter( GetLinkAddress( filter_data, idx ), newline );
					//lprintf( WIDE( "Process line: %s" ), GetText( newline ) );
					if( !newline )
						break; // get next bit of data ....
				}
				*/
			}
		}
		while( !newline && readlen );
	}
		// return the line read from the file.
	return newline;
}
//---------------------------------------------------------------------
static PTEXT GetConfigurationLine( PCONFIG_HANDLER pConfigHandler )
{
	PTEXT line, p;
	while( ( line = get_line( pConfigHandler
									, pConfigHandler->Unhandled?TRUE:FALSE ) ) )
	{
		if( g.flags.bLogLines )
			lprintf( WIDE( "Process line: %s" ), GetText( line ) );
		p = burst( line );
		LineRelease( line );
		if( g.flags.bLogTrace || g.flags.bLogLines )
		{
			{
				PTEXT x = p;
				while( x )
				{
					lprintf( WIDE("Word is: %s (%")_size_f WIDE(",%d)"), GetText( x ), GetTextSize( x ), x->format.position.offset.spaces );
					x = NEXTLINE( x );
				}
			}
			{
				PTEXT tmp = BuildLine( p );
				lprintf( WIDE("input: %s"), GetText( tmp ) );
				LineRelease( tmp );
			}
		}
		if( p &&
			GetTextSize( p ) )
		{
			return p;
		}
 // drop and consume blank lines.
		else
		{
			//lprintf( WIDE("Okay got a blank line... might handle it with 'unhandled'") );
			if( pConfigHandler->Unhandled )
				pConfigHandler->Unhandled( pConfigHandler->psvUser, NULL );
			LineRelease(p);
		}
	}
	return NULL;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
// Is____Var results in true/false, plus the config element is filled
// with the current value.  start will also be updated to the current
// location to process.  Otherwise, false will be returned, the element
// will remain uninitialized, and start will not be updated.
//---------------------------------------------------------------------
int IsAnyVarEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS );
int IsAnyVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	return IsAnyVarEx( pce, start DBG_SRC );
}
#define IsAnyVar(a,b) IsAnyVarEx(a,b DBG_SRC )
//---------------------------------------------------------------------
int IsConstTextEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS )
#define IsConstText(a,b) IsConstTextEx(a,b DBG_SRC )
{
	if( pce->type != CONFIG_TEXT )
	{
		return FALSE;
	}
	if( g.flags.bLogTrace )
		_lprintf(DBG_RELAY)( WIDE("Testing %s vs %s"), GetText( *start ), GetText( pce->data[0].pText ) );
	if( CompareText( *start, pce->data[0].pText ) == 0 )
	{
		if( g.flags.bLogTrace )
			lprintf( WIDE("%s matched %s"), GetText( *start ), GetText( pce->data[0].pText ) );
		*start = NEXTLINE( *start );
		return TRUE;
	}
	if( g.flags.bLogTrace )
		lprintf( WIDE("isn't constant...") );
	return FALSE;
}
//---------------------------------------------------------------------
static CTEXTSTR charset1 = WIDE("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ.-+");
static CTEXTSTR charset2 = WIDE("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY.-Z+");
typedef union bintobase{
	struct {
		uint8_t bytes[3];
	} bin;
	// these need to be unsigned.
	// the warning is 'nonstandard extension used : bit field types other than int'
	// but 'int' will NOT work, because it's signed.
	struct {
		uint32_t data1 : 6;
		uint32_t data2 : 6;
		uint32_t data3 : 6;
		uint32_t data4 : 6;
	} base;
} BINBASE;
void EncodeBinaryConfig( TEXTSTR *encode, POINTER data, size_t length )
{
	BINBASE convert;
	CTEXTSTR charset = charset2;
	unsigned char *p;
	TEXTCHAR *q;
	uint32_t l;
	int bExtraBytes;
	q = (TEXTCHAR*)((*encode) = NewArray( TEXTCHAR, ( ( ( 1 + (length + 2) / 3 ) * 4 ) + 3 ) * 2 ));
	(q++)[0]= '[';
	p = (unsigned char*)&length;
	convert.bin.bytes[0] = (p++)[0];
	convert.bin.bytes[1] = (p++)[0];
	convert.bin.bytes[2] = (p++)[0];
#define EXPLOIT_BURST_FEATURE()	if( ((q[-1] == '+')?(q[0]='0'),1:0 ) ||	 ((q[-1] == '.')?(q[0]='1'),1:0 ) ||											((q[-1] == '-')?(q[0]='2'),1:0 ) )												{																	q[-1] = '.';											q++;														}
	(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
	(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	p = (unsigned char*)data;
	for( l = 0; l < length - 2; l += 3 )
	{
		convert.bin.bytes[0] = (p++)[0];
		convert.bin.bytes[1] = (p++)[0];
		convert.bin.bytes[2] = (p++)[0];
		(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	}
	bExtraBytes = 0;
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[0] = (p++)[0];
		l++;
	}
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[1] = (p++)[0];
		l++;
	}
	else if( bExtraBytes )
		convert.bin.bytes[1] = 0;
	if( l < length )
	{
		bExtraBytes = 1;
		convert.bin.bytes[2] = (p++)[0];
		l++;
	}
	else if( bExtraBytes )
		convert.bin.bytes[2] = 0;
	if( bExtraBytes )
	{
		(q++)[0] = charset[convert.base.data1];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data2];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data3];
	EXPLOIT_BURST_FEATURE();
		(q++)[0] = charset[convert.base.data4];
	EXPLOIT_BURST_FEATURE();
	}
	(q++)[0]= '}';
	(q++)[0] = 0;
}
//---------------------------------------------------------------------
int DoDecodeBinary( PTEXT *start, POINTER *binary_buffer, size_t *buflen )
{
	static int *reverse;
	static int reverse1[256];
	static int reverse2[256];
	size_t failsafe_len;
	CTEXTSTR charset;
	POINTER failsafe_buffer;
	if( reverse1['B'] == 0 )
	{
		int c;
		for( c = 0; charset2[c]; c++ )
		{
			reverse1[(int)charset1[c]] = c;
			reverse2[(int)charset2[c]] = c;
		}
	}
	if( !buflen )
		buflen = &failsafe_len;
	if( !binary_buffer )
		binary_buffer = &failsafe_buffer;
	(*buflen) = 0;
	(*binary_buffer) = NULL;
	if( GetText( *start )[0] == '{' )
	{
		reverse = reverse1;
		charset = charset1;
	}
	else if( GetText( *start )[0] == '[' )
	{
		reverse = reverse2;
		charset = charset2;
	}
	else
		charset = NULL;
	if( charset )
	{
		BINBASE convert;
		size_t len;
		CTEXTSTR p = GetText( NEXTLINE( *start ) );
		// looks like a good chance this is a binary blob
		char *q;
		TEXTCHAR ch;
#define HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION()	  if( (ch=(p++)[0]) == '.' ) {	if( p[0] == '0' ) {p++;ch='+';}								else if ( p[0] == '1' ) {p++;ch = '.';}					else if ( p[0] == '2' ) {p++;ch = '-';}					}
		// if it is empty data... null, and 0
		if( NEXTLINE( *start ) &&
			( ( charset == charset1 && GetText( NEXTLINE( *start  ) )[0] == '}' )
			|| ( charset == charset2 && GetText( NEXTLINE( *start  ) )[0] == ']' ) ) )
		{
			(*binary_buffer) = NULL;
			(*buflen) = 0;
 // step from { onto }
			(*start) = NEXTLINE( *start );
 // step from } onto next token
			(*start) = NEXTLINE( *start );
			return TRUE;
		}
		if( !GetText( NEXTLINE( NEXTLINE( *start  ) ) ) ||
			( GetText( NEXTLINE( NEXTLINE( *start  ) ) )[0] != '}'
			&& GetText( NEXTLINE( NEXTLINE( *start  ) ) )[0] != ']' )
		)
		{
			return FALSE;
		}
		// HANLDE_BURST_EXPLOIT converts .0, .1, .2 into .-+ characters... and sets 'ch'
		// to the character to find.
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data1 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data2 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data3 = reverse[(int)ch];
		HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
		convert.base.data4 = reverse[(int)ch];
		q = (char*)buflen;
		q[0] = convert.bin.bytes[0];
		q[1] = convert.bin.bytes[1];
		q[2] = convert.bin.bytes[2];
		// may be as much as 2 extra bytes (expressed as 3)
		(*binary_buffer) = Allocate( len = (*buflen) );
		q = (char*)(*binary_buffer);
		while( p[0] && len )
		{
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data1 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data2 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data3 = reverse[(int)ch];
			HANDLE_BURST_PECULIARITY_WITH_DECIMALS_AND_NUMBER_COLLATION();
			convert.base.data4 = reverse[(int)ch];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[0];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[1];
			if( len && len-- )
				(q++)[0] = convert.bin.bytes[2];
		}
 // step from { onto 0235
		(*start) = NEXTLINE( *start );
 // step from 25234 onto }
		(*start) = NEXTLINE( *start );
 // step from } onto next token
		(*start) = NEXTLINE( *start );
		return TRUE;
	}
	else
	{
		(*binary_buffer) = NULL;
		(*buflen) = 0;
	}
	return FALSE;
}
int DecodeBinaryConfig( CTEXTSTR string, POINTER *binary_buffer, size_t *buflen )
{
	int status;
	PTEXT tmp1 = SegCreateFromText( string );
	PTEXT start = burst( tmp1 );
 // save this decode updates position...
	PTEXT delete_string = start;
	LineRelease( tmp1 );
	status = DoDecodeBinary( &start, binary_buffer, buflen );
	LineRelease( delete_string );
	return status;
}
int IsBinaryVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_BINARY )
		return FALSE;
	if( pce->data[0].binary.data )
	{
		Release( pce->data[0].binary.data );
		//pce->data[0].binary.data = NULL; // decode binary should do this?!
	}
	return DoDecodeBinary( start, &pce->data[0].binary.data, &pce->data[0].binary.length );
}
//---------------------------------------------------------------------
int IsBooleanVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	size_t len = GetTextSize( *start );
	int bOkay = FALSE;
	if( pce && pce->type != CONFIG_BOOLEAN )
		return FALSE;
	//lprintf( WIDE("Is %s boolean?"), GetText( *start ) );
#define CmpMin(constlen)  ((len <= (constlen))?(len):0)
#define NearText(text,const)	( CmpMin( sizeof( const ) - 1 ) &&							( StrCaseCmpEx( GetText( text ), const, len ) == 0 ) )
	if( NearText( *start, WIDE("yes") ) ||
		NearText( *start, WIDE("1") ) ||
		NearText( *start, WIDE("on") ) ||
		NearText( *start, WIDE("true") ) ||
		NearText( *start, WIDE("open") )
		)
	{
		if(pce)pce->data[0].truefalse.bTrue = 1;
		bOkay = TRUE;
	}
	else if( NearText( *start, WIDE("no") ) ||
			NearText( *start, WIDE("0") ) ||
			NearText( *start, WIDE("off") ) ||
		NearText( *start, WIDE("false") ) ||
		NearText( *start, WIDE("close") )
		)
	{
		if(pce)pce->data[0].truefalse.bTrue = 0;
		bOkay = TRUE;
	}
	else if( NearText( *start, WIDE("are") ) ||
			NearText( *start, WIDE("is") ) )
	{
		PTEXT word;
		bOkay = TRUE;
		if(pce)pce->data[0].truefalse.bTrue = 1;
		if( ( word = NEXTLINE( *start ) ) )
		{
		if( NearText( *start, WIDE("not") ) )
		{
				if(pce)pce->data[0].truefalse.bTrue = 0;
				*start = word;
		}
		}
	}
	if( bOkay )
	{
		*start = NEXTLINE( *start );
		return bOkay;
	}
	return FALSE;
}
int GetBooleanVar( PTEXT *start, LOGICAL *data )
{
	CONFIG_ELEMENT element = { CONFIG_BOOLEAN };
	if( IsBooleanVar( &element, start ) )
	{
		if( data )
			(*data) = element.data[0].truefalse.bTrue;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
static TEXTCHAR maxbase1[] = WIDE("0123456789abcdefghijklmnopqrstuvwxyz");
static TEXTCHAR maxbase2[] = WIDE("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ");
int TextToInt( CTEXTSTR text, int64_t* out )
{
	struct {
		uint32_t neg : 1;
		uint32_t success : 1;
	} flags;
	uint32_t base;
	int64_t accum;
	flags.neg = 0;
	flags.success = 1;
	if( text[0] == '-' )
	{
		flags.neg = 1;
		text++;
	}
	else if( text[0] == '+' )
	{
		text++;
	}
	base = 10;
	if( text[0] == '0' )
	{
		base = 8;
		text++;
		if( text[0] == 'x' )
		{
				base = 16;
				text++;
		}
		else if( text[0] == 'b' )
		{
				base = 2;
				text++;
		}
	}
	accum = 0;
	while( text[0] )
	{
		CTEXTSTR c;
		uint32_t val;
		if( ( c = StrChr( maxbase1, text[0] ) ) ) val = (uint32_t)(c - maxbase1);
		if( !c ) if( ( c = StrChr( maxbase2, text[0] ) ) ) val = (uint32_t)(c - maxbase2);
		if( !c ) { flags.success = 0; break; }
		if( val < base )
		{
				accum *= base;
				accum += val;
		}
		else
		{
			// yeah this works... there are times when badly behaved programs generate
			// output that should not match...
			// launch at screenX by ScreenY	"launch at %i by %i" fails
			// launch at 50 by 59						"					works
			// another rule that took launchat %w by %w could also work... in case
			// there is some variadric thing .. but a different config proc will probably be
			// called for such a case.
				//Log3( WIDE("Base Error : [%c]%s is not within base %d"), text[0], text+1, base );
				flags.success = 0;
				break;
		}
		text++;
	}
	if( flags.success )
	{
		if( out )
		{
			if( flags.neg )
				*out = -accum;
			else
				*out = accum;
		}
		return TRUE;
	}
	return FALSE;
}
int IsIntegerVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	CTEXTSTR text;
	int64_t accum;
	if( pce->type != CONFIG_INTEGER )
		return FALSE;
	text = GetText( *start );
	if( TextToInt( text, &accum ) )
	{
		pce->data[0].integer_number = accum;
		*start = NEXTLINE( *start );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsColorVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_COLOR )
		return FALSE;
	// might consider color names also, (of course that table
	// would have to be configurable)
	//lprintf( WIDE("COlor testing: %s"), GetText( *start ) );
	if( GetText( *start )[0] == '$' )
	{
		int ofs = 0;
		PTEXT val = NEXTLINE( *start );
		if( GetTextSize( *start ) == 1 )
			val = NEXTLINE( *start );
		else
		{
			val = *start;
			ofs = 1;
		}
		// potentially a hex variation...
		if( val )
		{
			uint32_t accum = 0;
			CTEXTSTR digit;
			digit = GetText( val ) + ofs;
			//lprintf( WIDE("COlor testing: %s"), digit );
			while( digit && digit[0] )
			{
				int n;
				CTEXTSTR p;
				n = 16;
				p = StrChr( maxbase1, digit[0] );
				if( p )
					n = (uint32_t)(p-maxbase1);
				else
				{
					p = StrChr( maxbase2, digit[0] );
					if( p )
						n = (uint32_t)(p-maxbase2);
				}
				if( n < 16 )
				{
					accum *= 16;
					accum += n;
				}
				else
					break;
				digit++;
			}
			if( ( digit - GetText( val ) ) < 6 )
			{
				lprintf( WIDE("Perhaps an error in color variable...") );
				pce->data[0].Color = accum | 0xFF000000;
			}
			else
			{
				if( ( digit - GetText( val ) ) == 6 )
					pce->data[0].Color = accum | 0xFF000000;
				else
					pce->data[0].Color = accum;
			}
			{
				uint32_t file_color = pce->data[0].Color;
				COLOR_CHANNEL a = (COLOR_CHANNEL)( file_color >> 24 ) & 0xFF;
				COLOR_CHANNEL r = (COLOR_CHANNEL)( file_color >> 16 ) & 0xFF;
				COLOR_CHANNEL grn = (COLOR_CHANNEL)( file_color >> 8 ) & 0xFF;
				COLOR_CHANNEL b = (COLOR_CHANNEL)( file_color >> 0 ) & 0xFF;
				pce->data[0].Color = AColor( r,grn,b,a );
			}
			//Log4( WIDE("Color is: $%08X/(%d,%d,%d)")
			//		, pce->data[0].Color
			//		, RedVal( pce->data[0].Color ), GreenVal(pce->data[0].Color), BlueVal(pce->data[0].Color) );
			*start = NEXTLINE( val );
		}
		return TRUE;
	}
	else if( GetText( *start )[0] == '(' )
	{
		// potentially a parenthetical variation.
		PTEXT val;
		int components = 0;
		uint32_t color = 0;
		for( val = *start;
			val && GetText( val )[0] != ')';
			val = NEXTLINE( val ) )
		{
			int64_t accum = 0;
			//lprintf( WIDE("Test : %s"), GetText( val ) );
			if( GetText(val)[0] == ',' )
				continue;
			if( TextToInt( GetText( val ), &accum ) )
			{
				components++;
				color <<= 8;
				color |= ( accum & 0xFF );
			}
		}
		if( val )
		{
			pce->data[0].Color = color;
			if( components < 4 )
				pce->data[0].Color |= 0xFF000000;
			//Log4( WIDE("Color is: $%08X/(%d,%d,%d)")
			//		, pce->data[0].Color
			//		, RedVal( pce->data[0].Color ), GreenVal(pce->data[0].Color), BlueVal(pce->data[0].Color) );
			*start = NEXTLINE( val );
			return TRUE;
		}
	}
	return FALSE;
}
int GetColorVar( PTEXT *start, CDATA *data )
{
	CONFIG_ELEMENT element = { CONFIG_COLOR };
	if( IsColorVar( &element, start ) )
	{
		if( data )
			(*data) = element.data[0].Color;
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFloatVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	//char *text;
	if( pce->type != CONFIG_FLOAT )
		return FALSE;
	//text = GetText( *start );
	lprintf( WIDE("Floating values are not processed yet.") );
	return FALSE;
}
//---------------------------------------------------------------------
int IsFractionVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	int32_t accum1, accum2, accum3;
	int neg1, neg2, neg3;
	PTEXT current;
	CTEXTSTR text;
	if( pce->type != CONFIG_FRACTION )
		return FALSE;
	// this may consume multiple segments (4?)  (+/-)##(1) ##(2)/(3)##(4)
	current = *start;
	text = GetText( current );
	accum1 = 0;
	neg1 = 1;
	if( text[0] == '-' )
	{
		neg1 = -1;
		text++;
	}
	else if( text[0] == '+' )
	{
		text++;
	}
	while( text[0] && text[0] >= '0' && text[0] <= '9' )
	{
		accum1 *= 10;
		accum1 += text[0] - '0';
		text++;
	}
	if( text[0] )
	{
		lprintf( WIDE("Error in first argument of format of fraction.") );
		return FALSE;
	}
// collect numerator after whole number.
	current = NEXTLINE( current );
	if( current )
	{
	text = GetText( current );
	accum2 = 0;
		neg2 = 1;
	if( text[0] == '/' )
	{
		//lprintf( WIDE("Promoting whole to numerator, getting denominaotr") );
		neg2	= neg1;
		accum2 = accum1;
		neg1	= 1;
		accum1 = 0;
		goto collect_denominator;
	}
	if( text[0] == '-' )
	{
		neg2 = -1;
		text++;
		}
		else if( text[0] == '+' )
		{
		text++;
		}
		while( text[0] && text[0] >= '0' && text[0] <= '9' )
		{
		accum2 *= 10;
		accum2 += text[0] - '0';
		text++;
		}
		if( text[0] )
		lprintf( WIDE("Error in format of numerator") );
	}
	else
	{
	//lprintf( WIDE("End of line before numerator") );
		pce->data[0].fraction.numerator = accum1;
		pce->data[0].fraction.denominator = neg1;
		*start = NEXTLINE( current );
	return TRUE;
	}
	current = NEXTLINE( current );
	if( current )
	{
	text = GetText( current );
	if( text[0] != '/' )
	{
		lprintf( WIDE("No denominator specified - error in fraction.") );
		return FALSE;
	}
	}
	else
	{
	lprintf( WIDE("End of line before '/'") );
	}
collect_denominator:
	current = NEXTLINE( current );
	if( current )
	{
		text = GetText( current );
		accum3 = 0;
		neg3 = 1;
		if( text[0] == '-' )
		{
		neg3 = -1;
		text++;
		}
		else if( text[0] == '+' )
		{
		text++;
		}
		while( text[0] && text[0] >= '0' && text[0] <= '9' )
		{
		accum3 *= 10;
		accum3 += text[0] - '0';
		text++;
		}
		if( text[0] )
		{
		lprintf( WIDE("Error in format of denominator.") );
		return FALSE;
		}
		//Log7( WIDE("%d*%d+%d / %d*%d*%d*%d"), accum1, accum3, accum2, neg1, neg2, neg3, accum3 );
		pce->data[0].fraction.numerator = accum1 * accum3 + accum2;
		pce->data[0].fraction.denominator = neg1 * neg2 * neg3 * accum3;
		*start = NEXTLINE( current );
	}
	else
	{
		lprintf( WIDE("End of line before denominator.") );
		return FALSE;
	}
	return TRUE;
}
//---------------------------------------------------------------------
int IsSingleWordVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	int matched = 1;
	struct config_element_tag *default_EOL = NULL;
	//PTEXT __start = *start;
	if( pce->type != CONFIG_SINGLE_WORD )
		return FALSE;
	if( pce->data[0].singleword.pWord )
	{
		Release( pce->data[0].singleword.pWord );
		pce->data[0].singleword.pWord = NULL;
	}
	while( *start )
	{
		if( pWords )
		{
			INDEX idx;
			if( (*start)->format.position.offset.spaces )
			{
				//if( pWords )
				//	LineRelease( pWords );
				// so at a space, stop appending.
				if( g.flags.bLogTrace )
					lprintf( WIDE( "next word has spaces... [%s](%d)" ), GetText( *start ), (*start)->format.position.offset.spaces );
				break;
			}
			LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
				PTEXT _start = *start;
				if( matched = IsAnyVar( pEnd, start ) )
				{
					pce->data[0].singleword.pWhichEnd = pEnd;
					pce->next = pEnd->next;
					if( g.flags.bLogTrace )
						lprintf( WIDE("Failed check for var check..") );
 // restore start..
					*start = _start;
					break;
				}
				else if( pEnd->type == CONFIG_NOTHING ) {
					if( !default_EOL )
						default_EOL = pce;
				}
				//*start = _start;
				//return TRUE;
			}
		}
		// was more than one word.
		if( pWords && ( (*start)->format.position.offset.spaces || (*start)->format.position.offset.tabs ) ) {
			LineRelease( pWords );
			pWords = NULL;
			return FALSE;
		}
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		if( g.flags.bLogTrace )
			lprintf( WIDE("Appending more to single word...[%s]"), GetText( (*start) ) );
		*start = NEXTLINE( *start );
	}
	if( (!*start) )
	{
		if( !matched && !default_EOL )
		{
			LineRelease( pWords );
			pWords = NULL;
			// multiword ended - end of line, and no match on the next tag...
			return FALSE;
		}
		else if( g.flags.bLogTrace )
			lprintf( WIDE( "is alright - gathered to end of line ok." ) );
	}
	if( pWords )
	{
		PTEXT pText;
		pWords->format.position.offset.spaces= 0;
		pText = BuildLine( pWords );
		LineRelease( pWords );
		if( g.flags.bLogTrace )
			lprintf( WIDE("Setting text word...") );
		pce->data[0].singleword.pWord = StrDup( GetText( pText ) );
		LineRelease( pText );
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsMultiWordVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	int matched = 1;
	PTEXT pWords = NULL;
	struct config_element_tag *default_EOL = NULL;
	if( pce->type != CONFIG_MULTI_WORD )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( matched = IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				if( g.flags.bLogTrace )
					lprintf( "Matched one of several?  set next to %p", pEnd, pEnd->next );
				pce->next = pEnd->next;
				break;
			}
			else if( !default_EOL && pEnd->type == CONFIG_NOTHING ) {
				default_EOL = pEnd;
			}
		}
		if( pEnd )
			break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( (!*start) )
	{
		if( !matched && !default_EOL )
		{
			LineRelease( pWords );
			pWords = NULL;
			// multiword ended - end of line, and no match on the next tag...
			return FALSE;
		}
		else {
			if( default_EOL )
				pce->next = default_EOL->next;
			if( g.flags.bLogTrace )
				lprintf( WIDE( "is alright - gathered to end of line ok. (or matched)" ) );
		}
	}
	//if( !pWords )
	//	pWords = SegCreate(0);
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			TEXTSTR buf = StrDup( GetText( out ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	/* can have empty space for multiword, but was an OK result anyway...*/
	return matched;
}
//---------------------------------------------------------------------
int IsPathVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_PATH )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start  )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				if( g.flags.bLogTrace )
					lprintf( "Matched one of several?  set next to %p", pEnd->next );
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
         break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFileVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_FILE )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				lprintf( "Matched one of several?  set next to %p", pEnd->next );
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
			break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
int IsFilePathVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	struct config_element_tag *pEnd;
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_FILEPATH )
		return FALSE;
	if( pce->data[0].multiword.pWords )
	{
		Release( pce->data[0].multiword.pWords );
		pce->data[0].multiword.pWords = NULL;
	}
	while( *start )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				pce->next = pEnd->next;
				break;
			}
		}
		if( pEnd )
         break;
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		INDEX idx;
		LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
		{
			if( IsAnyVar( pEnd, start ) ) {
				pce->data[0].multiword.pWhichEnd = pEnd;
				pce->next = pEnd->next;
				break;
			}
		}
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT out = BuildLine( pWords );
			size_t length;
			TEXTSTR buf = NewArray( TEXTCHAR, length = GetTextSize( out ) + 1 );
			StrCpyEx( buf, GetText( out ), length * sizeof( TEXTCHAR ) );
			LineRelease( out );
			LineRelease( pWords );
			pce->data[0].multiword.pWords = buf;
		}
		return TRUE;
	}
	return FALSE;
}
//---------------------------------------------------------------------
#if !defined( __NO_NETWORK__ ) && 0
int IsAddressVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	PTEXT pWords = NULL;
	if( pce->type != CONFIG_ADDRESS )
		return FALSE;
	if( pce->data[0].psaSockaddr )
	{
		ReleaseAddress( pce->data[0].psaSockaddr );
		pce->data[0].psaSockaddr = NULL;
	}
	while( *start && !(*start)->format.position.offset.spaces )
	{
		pWords = SegAppend( pWords, SegDuplicate( *start ) );
		*start = NEXTLINE( *start );
	}
	if( pWords )
	{
		pWords->format.position.offset.spaces = 0;
		{
			PTEXT pText = BuildLine( pWords );
			LineRelease( pWords );
			pce->data[0].psaSockaddr = CreateSockAddress( (CTEXTSTR)GetText( pText ), 0 );
			LineRelease( pText );
		}
		return TRUE;
	}
	return FALSE;
}
#endif
//---------------------------------------------------------------------
int IsURLVar( PCONFIG_ELEMENT pce, PTEXT *start )
{
	if( pce->type != CONFIG_URL )
		return FALSE;
	return FALSE;
}
//---------------------------------------------------------------------
int IsAnyVarEx( PCONFIG_ELEMENT pce, PTEXT *start DBG_PASS )
{
	if( !pce || !start )
	{
		//lprintf( WIDE("No pce or no start") );
		return FALSE;
	}
	if( g.flags.bLogTrace )
		_lprintf(DBG_RELAY)( WIDE("IsAnyVar") );
	if( pce->type == CONFIG_NOTHING && !(*start) )
		return TRUE;
	return( ( IsConstText( pce, start ) ) ||
			( IsBooleanVar( pce, start ) ) ||
			( IsBinaryVar( pce, start ) ) ||
			( IsIntegerVar( pce, start ) ) ||
			( IsFloatVar( pce, start ) ) ||
			( IsFractionVar( pce, start ) ) ||
			( IsSingleWordVar( pce, start ) ) ||
			( IsMultiWordVar( pce, start ) ) ||
			( IsPathVar( pce, start ) ) ||
			( IsFileVar( pce, start ) ) ||
			( IsFilePathVar( pce, start ) ) ||
			( IsURLVar( pce, start ) ) ||
			( IsColorVar( pce, start ) ) );
}
//---------------------------------------------------------------------
//#define PushArgument( type, arg ) ( (parampack = Preallocate( parampack, argsize += sizeof( arg )) )?(*(type*)(parampack) = (arg)),0:0)
//#define PopArguments( sz ) Release( parampack )
//---------------------------------------------------------------------
void DoProcedure( uintptr_t *ppsvUser, PCONFIG_TEST Check )
{
	INDEX idx;
	PCONFIG_ELEMENT pce = NULL;
	va_args parampack;
#ifdef __WATCOMC__
	va_args save_parampack;
#endif
	init_args( parampack );
	LIST_FORALL( Check->pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
		if( pce->type == CONFIG_PROCEDURE || pce->type == CONFIG_PROCEDURE_EX )
		{
			if( pce->data[0].Process)
			{
#ifdef NEED_ASSEMBLY_CALLER
				CallProcedure( ppsvUser, pce );
#else
				PCONFIG_ELEMENT pcePush = pce->prior;
				// push arguments in reverse order...
				//lprintf( WIDE("Calling process... ") );
				while( pcePush )
				{
					if( g.flags.bLogTrace )
						LogElement( WIDE("pushing"), pcePush );
					switch( pcePush->type )
					{
					case CONFIG_TEXT:
						break;
					case CONFIG_BINARY:
						PushArgument( parampack, CONFIG_ARG_DATA, POINTER, pcePush->data[0].binary.data );
						PushArgument( parampack, CONFIG_ARG_DATA_SIZE, size_t, pcePush->data[0].binary.length );
						break;
					case CONFIG_BOOLEAN:
						{
							LOGICAL val = pcePush->data[0].truefalse.bTrue;
							PushArgument( parampack, CONFIG_ARG_LOGICAL, LOGICAL, val );
						}
						break;
					case CONFIG_INTEGER:
						PushArgument( parampack, CONFIG_ARG_INT64, int64_t, pcePush->data[0].integer_number );
						break;
					case CONFIG_FLOAT:
						PushArgument( parampack, CONFIG_ARG_FLOAT, float, (float)pcePush->data[0].float_number );
						break;
					case CONFIG_FRACTION:
						PushArgument( parampack, CONFIG_ARG_FRACTION, FRACTION, pcePush->data[0].fraction );
						break;
					case CONFIG_SINGLE_WORD:
						PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, pcePush->data[0].pWord );
						break;
					case CONFIG_COLOR:
						PushArgument( parampack, CONFIG_ARG_COLOR, CDATA, pcePush->data[0].Color );
						break;
					case CONFIG_MULTI_WORD:
					case CONFIG_FILEPATH:
						PushArgument( parampack, CONFIG_ARG_STRING, CTEXTSTR, pcePush->data[0].multiword.pWords );
						break;
					default:
						break;
					}
					//lprintf( WIDE("Total args are now: %d"), argsize );
					pcePush = pcePush->prior;
				}
				if( pce->type == CONFIG_PROCEDURE_EX )
					(*ppsvUser) = pce->data[0].ProcessEx.Process( *ppsvUser, pce->data[0].ProcessEx.arg, pass_args( parampack ) );
				else
					(*ppsvUser) = pce->data[0].Process( *ppsvUser, pass_args(parampack) );
				PopArguments( parampack );
#endif
 // done, end of list, please leave and do not iterate further!
				break;
			}
		}
		else
		{
			switch( pce->type )
			{
			case CONFIG_MULTI_WORD:
			case CONFIG_SINGLE_WORD:
				// null content ?
				break;
			default:
				// actually this probably means that there was no content to complete
				// the match, and NULL is not a valid responce to data...
				lprintf( WIDE("Multiple options here for what to do at end of line?") );
			}
		}
	}
}
void ProcessConfigurationLine( PCONFIG_HANDLER pch, PTEXT line )
		{
			PCONFIG_TEST Check = &pch->ConfigTestRoot;
			PTEXT word = line;
			while( word && Check )
			{
					INDEX idx;
					PCONFIG_ELEMENT pce = NULL;
					if( g.flags.bLogTrace )
						lprintf( WIDE("Test word (%s) vs constant elements"), GetText( word ) );
					LIST_FORALL( Check->pConstElementList, idx, PCONFIG_ELEMENT, pce )
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Is %s == %s?"), GetText( word ), GetText( pce->data[0].pText ) );
						if( IsConstText( pce, &word ) )
						{
							Check = pce->next;
							break;
						}
					}
					if( g.flags.bLogTrace )
						lprintf( WIDE("Test word (%s) vs variable elements"), GetText( word ) );
					{
						if( !pce )
						{
							int found = 0;
							LIST_FORALL( Check->pVarElementList, idx, PCONFIG_ELEMENT, pce )
							{
								// end of the line, match should be the process...
								if( g.flags.bLogTrace )
								{
									lprintf( WIDE("Is %s a Thing"), GetText( word ) );
									LogElement( WIDE("Thing is"), pce );
								}
								if( IsAnyVar( pce, &word ) )
								{
									if( g.flags.bLogTrace )
										lprintf( WIDE("Yes, it is any var.") );
									found = 1;
									if( g.flags.bLogTrace )
										lprintf( "pce->next is %p  word is %p(%s)", pce->next, word, GetText( word ) );
									Check = pce->next;
									break;
								}
								else if( g.flags.bLogTrace )
								{
									lprintf( WIDE("But it's not anything I know.") );
								}
							}
							if( g.flags.bLogTrace )
								lprintf( WIDE("is %s"), found?WIDE("found"):WIDE("Not found") );
							if( !found )
							{
								PTEXT pLine = BuildLine( line );
								if( g.flags.bLogTrace )
									lprintf( WIDE("Line not matched[%s]"), GetText( pLine ) );
								if( pch->Unhandled )
									pch->Unhandled( pch->psvUser, GetText( pLine ) );
								else
								{
									if( g.flags.bLogUnhandled )
										xlprintf(LOG_NOISE)( WIDE("Unknown Configuration Line(No unhandled proc): %s"), GetText( pLine ) );
								}
								break;
							}
						}
					}
			}
			if( !Check )
			{
				lprintf( WIDE("Fell off the end the line processor, still have data...") );
				{
					PTEXT pLine = BuildLine( line );
					if( pch->Unhandled )
						pch->Unhandled( pch->psvUser, GetText( pLine ) );
					else
					{
						// I didn't want to get rid of this...
						// but ahh well, it's noisy and it works.
						//lprintf( WIDE("Unknown Configuration Line: %s"), GetText( pLine ) );
					}
				}
			}
	// otherwise we may have bailed early.
			else if( !word )
			{
				// check here for Procedure at end of line (word == NULL)
				DoProcedure( &pch->psvUser, Check );
			}
#if 0
			else
			{
				if( g.flags.bLogTrace )
					lprintf( WIDE("line partially matched... need to recover and re-evaluate..") );
				{
					PTEXT pLine = BuildLine( line );
					if( pch->Unhandled )
						pch->Unhandled( pch->psvUser, GetText( pLine ) );
					else
					{
						// I didn't want to get rid of this...
						// but ahh well, it's noisy and it works.
						//lprintf( WIDE("Unknown Configuration Line: %s"), GetText( pLine ) );
					}
				}
			}
#endif
		}
static void TestUnicode( PCONFIG_HANDLER pch )
{
	int return_pos = 0;
	pch->flags.bUnicode	= 0;
	{
		char charbuf[64];
 // could be really short
		size_t len_read;
		size_t char_check;
		int ascii_unicode = 1;
		len_read = sack_fread( charbuf, 1, 64, pch->file );
		if( ( ((uint16_t*)charbuf)[0] == 0xFEFF )
			|| ( ((uint16_t*)charbuf)[0] == 0xFFFE )
			|| ( ((uint16_t*)charbuf)[0] == 0xFDEF ) )
		{
			return_pos = 2;
			pch->flags.bUnicode = 1;
		}
		else if( ( charbuf[0] == (char)0xef ) && ( charbuf[1] == (char)0xbb ) && ( charbuf[0] == (char)0xbf ) )
		{
			return_pos = 1;
			pch->flags.bUnicode8 = 1;
		}
		else for( char_check = 0; char_check < len_read; char_check++ )
		{
		// every other byte is a 0 for flat unicode text...
			if( ( char_check & 1 ) && ( charbuf[char_check] != 0 ) )
			{
				ascii_unicode = 0;
				break;
			}
		}
		if( ascii_unicode )
		{
			pch->flags.bUnicode = 1;
		}
		else
		{
			int ascii = 1;
			for( char_check = 0; char_check < len_read; char_check++ )
				if( charbuf[char_check] & 0x80 )
				{
					ascii = 0;
					break;
				}
			if( ascii )
			{
				// hmm this is probably a binary thing?
			}
		}
	}
	sack_fseek( pch->file, return_pos, SEEK_SET );
	// rewind
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( int, ProcessConfigurationFile )( PCONFIG_HANDLER pch, CTEXTSTR name, uintptr_t psv )
{
	PTEXT line;
#ifndef __ANDROID__
 // don't prefix with anything.
	int absolute_path = IsAbsolutePath( name );
#endif
	pch->file = sack_fopen( 0, name, WIDE("rb") );
#ifndef __ANDROID__
#  ifndef UNDER_CE
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("./%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("@/%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
#  endif
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("*/%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("#/%s"), name );
#	ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#	endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
	if( !pch->file && !absolute_path )
	{
		TEXTCHAR pathname[255];
		tnprintf( pathname, sizeof( pathname ), WIDE("/etc/%s"), name );
#  ifdef _MSC_VER
		pathname[sizeof(pathname)/sizeof(pathname[0])-1]=0;
#  endif
		pch->file = sack_fopen( 0, pathname, WIDE("rb") );
	}
#endif
	pch->psvUser = psv;
	if( pch->file )
	{
		TestUnicode( pch );
		while( ( line = GetConfigurationLine( pch ) ) )
		{
			ProcessConfigurationLine( pch, line );
			LineRelease( line );
		}
		sack_fclose( pch->file );
		if( pch->EndProcess )
			pch->EndProcess( pch->psvUser );
		pch->file = NULL;
		return TRUE;
	}
	else
	{
		//lprintf( WIDE("Failed to open config file: %s"), name );
		return FALSE;
	}
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( uintptr_t, ProcessConfigurationInput )( PCONFIG_HANDLER pch, CTEXTSTR data, size_t size, uintptr_t psv )
{
	pch->psvUser = psv;
	{
		PTEXT line;
		PTEXT block = SegCreate( size + 1 );
		MemCpy( GetText( block ), data, size );
		GetText( block )[size] = 0;
		SetTextSize( block, size );
		pch->blocks = block;
		while( ( line = GetConfigurationLine( pch ) ) )
		{
			ProcessConfigurationLine( pch, line );
			LineRelease( line );
		}
		// this block will have been moved into internal accumulators.
		//LineRelease( block );
	}
	return pch->psvUser;
}
//---------------------------------------------------------------------
static PCONFIG_ELEMENT NewConfigTestElement( PCONFIG_HANDLER pch )
{
 //&(PCONFIG_ELEMENT)Allocate( sizeof( CONFIG_ELEMENT ) );
	PCONFIG_ELEMENT pceNew = GetFromSet( CONFIG_ELEMENT, &pch->elements );
	MemSet( pceNew, 0, sizeof( CONFIG_ELEMENT ) );
	return pceNew;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
static PCONFIG_TEST NewConfigTest( PCONFIG_HANDLER pch )
{
 //(PCONFIG_TEST)AllocateEx( sizeof( CONFIG_TEST ) DBG_RELAY );
	PCONFIG_TEST pctNew = GetFromSet( CONFIG_TEST, &pch->test_elements );
	MemSet( pctNew, 0, sizeof( CONFIG_TEST ) );
	// I don't actually have to create list...
	// they will be filled in and allocated on demand.
//CreateListEx( DBG_VOIDRELAY );
	pctNew->pConstElementList = NULL;
//CreateListEx( DBG_VOIDRELAY );
	pctNew->pVarElementList = NULL;
	return pctNew;
}
//---------------------------------------------------------------------
void DestroyConfigElement( PCONFIG_HANDLER pch, PCONFIG_ELEMENT pct );
//---------------------------------------------------------------------
void BeginConfiguration( PCONFIG_HANDLER pch )
{
	// pushes the config file handler state...
	if( pch )
	{
		CONFIG_STATE save_state;
		if( !pch->ConfigStateStack )
			pch->ConfigStateStack = CreateDataStack( sizeof( CONFIG_STATE ) );
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Saving config and psvUser is %08x", pch->psvUser );
		DumpConfigurationEvaluator( pch );
#endif
		save_state.recovered = pch->config_recovered;
		save_state.ConfigTestRoot = pch->ConfigTestRoot;
		save_state.psvUser = pch->psvUser;
		save_state.EndProcess = pch->EndProcess;
		save_state.Unhandled = pch->Unhandled;
		save_state.name = pch->save_config_as;
		pch->flags.bConfigSaveNameUsed = 1;
		PushData( &pch->ConfigStateStack, &save_state );
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "<BEGIN>" );
#endif
		pch->ConfigTestRoot.pConstElementList = NULL;
		pch->ConfigTestRoot.pVarElementList = NULL;
		pch->EndProcess = NULL;
		pch->Unhandled = NULL;
		pch->config_recovered = FALSE;
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Setting config as not savable." );
#endif
		pch->save_config_as = NULL;
	}
}
LOGICAL BeginNamedConfiguration( PCONFIG_HANDLER pch, CTEXTSTR name )
{
	// returns true if the configuration previously exists...
	// returns false if it needs to be built.
	INDEX idx;
	PCONFIG_STATE state;
	LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
	{
		if( StrCmp( state->name, name ) == 0 )
		{
#ifdef DEBUG_SAVE_CONFIG
			lprintf( "found previous config, setting this up, and resulting." );
#endif
			BeginConfiguration( pch );
			pch->ConfigTestRoot = state->ConfigTestRoot;
			pch->EndProcess = state->EndProcess;
			pch->Unhandled = state->Unhandled;
			pch->config_recovered = TRUE;
#ifdef DEBUG_SAVE_CONFIG
			lprintf( "Beginning a named configuration..." );
#endif
			pch->save_config_as = state->name;
#ifdef DEBUG_SAVE_CONFIG
			DumpConfigurationEvaluator( pch );
#endif
			return TRUE;
		}
	}
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "No previous found, setting this up to save at end config..." );
#endif
	BeginConfiguration( pch );
	pch->config_recovered = FALSE;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Setting named configuration." );
#endif
	pch->flags.bConfigSaveNameUsed = 0;
	pch->save_config_as = StrDup( name );
	return FALSE;
}
void DestroyConfigTest( PCONFIG_HANDLER pch, PCONFIG_TEST pct, int dealloc );
// this is more like a pop configuration.
void EndConfiguration( PCONFIG_HANDLER pch )
{
	PCONFIG_STATE prior_state;
	//PCONFIG_TEST prior;
	if( pch->EndProcess )
		pch->EndProcess( pch->psvUser );
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "<END>" );
#endif
	prior_state = (PCONFIG_STATE)PopData( &pch->ConfigStateStack );
	if( prior_state )
	{
		if( pch->save_config_as )
		{
			if( !pch->config_recovered )
			{
				CONFIG_STATE *state = New( CONFIG_STATE );
				state->ConfigTestRoot = pch->ConfigTestRoot;
				state->EndProcess = pch->EndProcess;
				state->Unhandled = pch->Unhandled;
				pch->flags.bConfigSaveNameUsed = 1;
				state->name = pch->save_config_as;
				AddLink( &pch->states, state );
			}
			// otherwise there's no action to do... already have it saved.
		}
		else
		{
			//lprintf( WIDE("Config was not saved, destroying.") );
			DestroyConfigTest( pch, &pch->ConfigTestRoot, FALSE );
		}
		// didn't recover from states list.
		pch->config_recovered = prior_state->recovered;
		pch->ConfigTestRoot = prior_state->ConfigTestRoot;
		pch->EndProcess = prior_state->EndProcess;
		pch->Unhandled = prior_state->Unhandled;
		pch->psvUser = prior_state->psvUser;
		pch->save_config_as = prior_state->name;
	}
}
PCONFIG_ELEMENT _AddConfigurationEx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process DBG_PASS )
{
	PTEXT pTemp = SegCreateFromText( format );
	PTEXT pLine;
	PTEXT pWord;
	struct {
		uint32_t vartag : 1;
		uint32_t vector : 1;
		uint32_t ignore_new : 1;
		uint32_t store_next_as_end : 1;
		uint32_t also_store_next_as_end : 1;
		uint32_t store_as_end : 1;
		uint32_t also_store_as_end : 1;
	}flags;
	PCONFIG_TEST pct;
	PCONFIG_ELEMENT pceNew, pcePrior;
	((uint32_t*)&flags)[0] = 0;
	//flags.dw = 0;
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
	if( g.flags.bLogTrace )
		lprintf( WIDE( "Burst..." ) );
//#endif
	pLine = burst( pTemp );
	LineRelease( pTemp );
	pct = &pch->ConfigTestRoot;
	pceNew = NewConfigTestElement( pch );
	pcePrior = NULL;
	pWord = pLine;
	while( pWord )
	{
		if( g.flags.bLogTrace )
			lprintf( WIDE("Evaluating %s ... "), GetText( pWord ) );
		if( flags.vartag )
		{
			CTEXTSTR pWordText = GetText( pWord );
			if( pWordText[0] == 'v' )
			{
				flags.vector = 1;
				pWordText++;
				if( !pWordText[0] )
				{
					lprintf( WIDE("Format: %s"), format );
					lprintf( WIDE("Configuration error %%v[no type]") );
				}
				LineRelease( pLine );
				lprintf( WIDE( "Destroy config element %p" ), pceNew );
				DestroyConfigElement( pch, pceNew );
				return NULL;
			}
			switch( pWordText[0] )
			{
			case 'b':
				//lprintf( WIDE("is a boolean...") );
				pceNew->type = CONFIG_BOOLEAN;
				pceNew->flags.vector = flags.vector;
				break;
			case 'B':
				//lprintf( WIDE("is a binary...") );
				pceNew->type = CONFIG_BINARY;
				pceNew->flags.vector = flags.vector;
				break;
			case 'i':
				//lprintf( WIDE("Is an integer... ")) ;
				pceNew->type = CONFIG_INTEGER;
				pceNew->flags.vector = flags.vector;
				break;
			case 'c':
				pceNew->type = CONFIG_COLOR;
				pceNew->flags.vector = flags.vector;
				break;
			case 'f':
				pceNew->type = CONFIG_FLOAT;
				pceNew->flags.vector = flags.vector;
				break;
			case 'q':
				pceNew->type = CONFIG_FRACTION;
				pceNew->flags.vector = flags.vector;
				break;
			case 'w':
				if( g.flags.bLogTrace )
					lprintf( WIDE("Setting new as type SINGLE_WORD") );
				pceNew->type = CONFIG_SINGLE_WORD;
				pceNew->flags.vector = flags.vector;
				flags.also_store_next_as_end = 1;
				break;
			case 'm':
				if( g.flags.bLogTrace )
					lprintf( WIDE("Setting new as type MULTI_WORD") );
				pceNew->type = CONFIG_MULTI_WORD;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'u':
				pceNew->type = CONFIG_URL;
				pceNew->flags.vector = flags.vector;
				break;
			case 'd':
				pceNew->type = CONFIG_PATH;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'n':
				pceNew->type = CONFIG_FILE;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'p':
				pceNew->type = CONFIG_FILEPATH;
				pceNew->flags.vector = flags.vector;
				flags.store_next_as_end = 1;
				break;
			case 'a':
				pceNew->type = CONFIG_ADDRESS;
				pceNew->flags.vector = flags.vector;
				break;
			default:
				lprintf( WIDE("Format: %s"), format );
				lprintf( WIDE("Unknown format character: %c"), pWordText[0] );
				flags.ignore_new = 1;
				break;
			}
			if( !flags.ignore_new )
			{
				if( g.flags.bLogTrace )
					lprintf( WIDE("Not ignoring the new thing...") );
				if( flags.store_as_end )
				{
					if( g.flags.bLogTrace )
						lprintf( WIDE("Storing as end...") );
					{
						INDEX idx;
						struct config_element_tag *pEnd;
						LIST_FORALL( pcePrior->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
							if( pceNew->type == pEnd->type ) {
								break;
							}
						}
						if( !pEnd ){
							AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
							pceNew->flags.multiword_terminator = 1;
							pceNew->prior = pcePrior;
							pct = pceNew->next = NewConfigTest( pch );
							if( g.flags.bLogTrace )
								lprintf( "%p pceNew next is %p", pceNew, pct );
						}
						else{
							if( g.flags.bLogTrace )
								lprintf( "Need to do something with original to chain?" );
							DestroyConfigElement( pch, pceNew );
							pceNew = pEnd;
							pct = pEnd->next;
						}
					}
					pcePrior = pceNew;
					pceNew = NewConfigTestElement( pch );
					flags.store_as_end = 0;
				}
				else
				{
					if( flags.store_next_as_end )
					{
 // flag to store next thing as end condition.
						flags.store_as_end = 1;
						flags.store_next_as_end = 0;
					}
					if( flags.also_store_as_end )
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Also Storing as end...") );
						AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
						pceNew->flags.singleword_terminator = 1;
						flags.also_store_as_end = 0;
					}
					if( flags.also_store_next_as_end )
					{
 // flag to store next thing as end condition.
						flags.also_store_as_end = 1;
						flags.also_store_next_as_end = 0;
					}
					{
						INDEX idx;
						PCONFIG_ELEMENT pceCheck;
						LIST_FORALL( pct->pVarElementList, idx, PCONFIG_ELEMENT, pceCheck )
						{
							if( pceCheck->type == pceNew->type )
							{
								// any data set will be overwritten...
								// uhmm should probably update to new links.
								if( !pceCheck->next )
								{
									lprintf( WIDE("Something fishy here... second instance of same type...") );
								}
								pcePrior = pceCheck;
								pct = pceCheck->next;
								break;
							}
						}
						if( !pceCheck )
						{
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
							if( g.flags.bLogTrace )
								lprintf( WIDE("Adding into a new config test") );
//#endif
							AddLink( &pct->pVarElementList, pceNew );
							pct = pceNew->next = NewConfigTest( pch );
							pceNew->prior = pcePrior;
							pcePrior = pceNew;
							pceNew = NewConfigTestElement( pch );
//#if defined( FULL_TRACE ) || defined( DEBUG_SLOWNESS )
							if( g.flags.bLogTrace )
								lprintf( WIDE( "Added." ) );
//#endif
						}
					}
				}
			}
			else
			{
				lprintf( WIDE("ignoreing NEW!?") );
			}
			flags.vartag = 0;
			flags.vector = 0;
			flags.ignore_new = 0;
		}
		else
		{
			if( TextIs( pWord, WIDE("%") ) )
			{
				if( g.flags.bLogTrace )
					lprintf( WIDE("next thing is a format character") );
				flags.vartag = 1;
			}
 // is static text - literal match.
			else
			{
				INDEX idx;
				PCONFIG_ELEMENT pConst = NULL;
				if( g.flags.bLogTrace )
					lprintf( WIDE("Storing %s as a constant text"), GetText( pWord ) );
				if( flags.store_as_end )
				{
					pceNew->type = CONFIG_TEXT;
					if( g.flags.bLogTrace )
						lprintf( WIDE("Adding %s as the terminator"), GetText( pWord ) );
					pceNew->data[0].pText = SegDuplicate( pWord );
					{
						INDEX idx;
						struct config_element_tag *pEnd;
						LIST_FORALL( pcePrior->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd ){
							if( pceNew->type == pEnd->type ) {
								if( pceNew->type == CONFIG_TEXT ) {
									if( SameText( pceNew->data[0].pText, pEnd->data[0].pText ) == 0 )
										break;
								}
							}
						}
						if( !pEnd ){
							if( g.flags.bLogTrace )
								lprintf( "Added new terminator branch... pce needs a pct" );
							AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
							pceNew->flags.multiword_terminator = 1;
							pceNew->prior = pcePrior;
                     pct = pceNew->next = NewConfigTest( pch );
						}
						else{
                     // use existing one, so delete this one.
                     DestroyConfigElement( pch, pceNew );
							pceNew = pEnd;
                     pct = pEnd->next;
							if( g.flags.bLogTrace )
								lprintf( "Recovered an old pce to resume from...%p", pEnd );
						}
					}
					pcePrior = pceNew;
					pceNew = NewConfigTestElement( pch );
					flags.store_as_end = 0;
				}
				else
				{
					LIST_FORALL( pct->pConstElementList, idx, PCONFIG_ELEMENT, pConst )
					{
						if( IsConstText( pConst, &pWord ) )
						{
							pct = pConst->next;
							break;
						}
 // this is not always cleared...
						pConst = NULL;
					}
 // continue outer loop (while word)
					if( pConst )
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Found constant already in tree") );
						if( flags.also_store_as_end )
						{
							if( g.flags.bLogTrace )
								lprintf( WIDE("Also Storing as end... %s"), GetText( pceNew->data[0].pText ) );
							AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
							pceNew->flags.singleword_terminator = 1;
							flags.also_store_as_end = 0;
						}
						continue;
					}
					else
					{
						if( g.flags.bLogTrace )
							lprintf( WIDE("Adding new constant to tree:%s"), GetText( pWord ) );
						if( flags.also_store_as_end )
						{
							if( g.flags.bLogTrace )
								lprintf( WIDE("Also Storing as end... %s"), GetText( pceNew->data[0].pText ) );
							AddLink( &pcePrior->data[0].singleword.pEnds, pceNew );
							pceNew->flags.singleword_terminator = 1;
							flags.also_store_as_end = 0;
						}
						pceNew->type = CONFIG_TEXT;
						pceNew->data[0].pText = SegDuplicate( pWord );
						AddLink( &pct->pConstElementList, pceNew );
						pct = pceNew->next = NewConfigTest( pch);
						pceNew->prior = pcePrior;
						pcePrior = pceNew;
						pceNew = NewConfigTestElement(pch );
					}
				}
			}
		}
		pWord = NEXTLINE( pWord );
	}
	if( flags.store_as_end ) {
		pceNew->type = CONFIG_NOTHING;
		AddLink( &pcePrior->data[0].multiword.pEnds, pceNew );
		pceNew->flags.multiword_terminator = 1;
		pceNew->prior = pcePrior;
		pct = pceNew->next = NewConfigTest( pch );
		if( g.flags.bLogTrace )
			lprintf( "%p pceNew next is %p", pceNew, pct );
		pcePrior = pceNew;
		pceNew = NewConfigTestElement( pch );
		flags.store_as_end = 0;
	}
	LineRelease( pLine );
	// end of the format line - add the procedure.
	pceNew->prior = pcePrior;
	// no need to update pcePrior - we're done.
	pceNew->type = CONFIG_PROCEDURE;
	pceNew->data[0].Process = Process;
	AddLink( &pct->pVarElementList, pceNew );
	return pceNew;
}
void AddConfigurationExx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER_EX Process, uintptr_t arg DBG_PASS ) {
	PCONFIG_ELEMENT element = _AddConfigurationEx( pch, format, (USER_CONFIG_HANDLER)Process DBG_RELAY );
	if( !element )
		return;
	element->type = CONFIG_PROCEDURE_EX;
	element->data[0].ProcessEx.Process = Process;
	element->data[0].ProcessEx.arg = arg;
}
void AddConfigurationEx( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process DBG_PASS ) {
	_AddConfigurationEx( pch, format, Process DBG_RELAY );
}
//---------------------------------------------------------------------
#undef AddConfiguration
CONFIGSCR_PROC( void, AddConfiguration )( PCONFIG_HANDLER pch, CTEXTSTR format, USER_CONFIG_HANDLER Process )
{
	AddConfigurationEx( pch, format, Process DBG_SRC );
}
//---------------------------------------------------------------------
	CONFIGSCR_PROC( void, SetConfigurationEndProc )( PCONFIG_HANDLER pch
													, uintptr_t (CPROC *Process)( uintptr_t ) )
{
	pch->EndProcess = Process;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, SetConfigurationUnhandled )( PCONFIG_HANDLER pch
																, uintptr_t (CPROC *Process)( uintptr_t, CTEXTSTR ) )
{
	pch->Unhandled = Process;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( PCONFIG_HANDLER, CreateConfigurationEvaluator )( void )
{
	PCONFIG_HANDLER pch;
	DoInit();
	if( g.flags.bDisableMemoryLogging )
	{
		if( !(g._disabled_allocate_logging++) )
		{
			g._last_allocate_logging = SetAllocateLogging( FALSE );
		}
	}
	pch = (PCONFIG_HANDLER)Allocate( sizeof( CONFIG_HANDLER ) );
	MemSet( pch, 0, sizeof( *pch ) );
	// break input chunks into lines....
	AddLink( &pch->filters, FilterLines );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterLines ), 0 );
	// end the lines at # (also remove \r, \n)
	AddLink( &pch->filters, FilterTerminators );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterTerminators ), 0 );
	// get rid of \\ and \# to replace with appropriate things
	// since \# might be escaped, this is the only place I can handle the '#' character
	// to terminate lines at comment points.
	AddLink( &pch->filters, FilterEscapesAndComments );
	SetLink( &pch->filter_data, FindLink( &pch->filters, (POINTER)FilterEscapesAndComments ), 0 );
	//pch->ConfigTestRoot.pConstElementList = NULL; //CreateList();
	//pch->ConfigTestRoot.pVarElementList = NULL;//CreateList();
	return pch;
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, ClearDefaultFilters )( PCONFIG_HANDLER pch )
{
	EmptyList( &pch->filters );
}
CONFIGSCR_PROC( void, AddConfigurationFilter )( PCONFIG_HANDLER pch, USER_FILTER filter )
{
	AddLink( &pch->filters, filter );
}
//---------------------------------------------------------------------
void DestroyConfigElement( PCONFIG_HANDLER pch, PCONFIG_ELEMENT pce )
{
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy element %p %p", pch, pce );
#endif
	DestroyConfigTest( pch, pce->next, TRUE );
	switch( pce->type )
	{
	case CONFIG_BINARY:
		if( pce->data[0].binary.data )
			Release( pce->data[0].binary.data );
		break;
	case CONFIG_TEXT:
		if( pce->data[0].pText )
			LineRelease( pce->data[0].pText );
		break;
	case CONFIG_SINGLE_WORD:
		if( pce->data[0].pWord )
			Release( pce->data[0].pWord );
		DeleteList( &pce->data[0].singleword.pEnds );
		break;
	case CONFIG_MULTI_WORD:
		if( pce->data[0].multiword.pWords )
			Release( pce->data[0].multiword.pWords );
		if( pce->data[0].multiword.pEnds )
		{
			struct config_element_tag *pEnd;
			INDEX idx;
			LIST_FORALL( pce->data[0].multiword.pEnds, idx, struct config_element_tag *, pEnd )
			{
#ifdef DEBUG_SAVE_CONFIG
				lprintf( "Destroy config element %p", pEnd );
#endif
				DestroyConfigElement( pch, pEnd );
			}
		}
		DeleteList( &pce->data[0].multiword.pEnds );
		break;
	case CONFIG_URL:
	case CONFIG_PATH:
	case CONFIG_FILE:
	case CONFIG_FILEPATH:
	case CONFIG_ADDRESS:
		break;
	case CONFIG_COLOR:
	case CONFIG_PROCEDURE:
	case CONFIG_PROCEDURE_EX:
	case CONFIG_UNKNOWN:
	case CONFIG_BOOLEAN:
	case CONFIG_INTEGER:
	case CONFIG_FRACTION:
	case CONFIG_FLOAT:
	case CONFIG_NOTHING:
		break;
	}
	DeleteFromSet( CONFIG_ELEMENT, pch->elements, pce );
	//Release( pce );
}
void DestroyConfigTest( PCONFIG_HANDLER pch, PCONFIG_TEST pct, int deallocate )
{
	PCONFIG_ELEMENT pce;
	INDEX idx;
	if( !pct )
		return;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy Config %p %p", pch, pct );
#endif
	LIST_FORALL( pct->pConstElementList, idx, PCONFIG_ELEMENT, pce )
	{
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Delete const element" );
#endif
		DestroyConfigElement( pch, pce );
	}
	DeleteList( &pct->pConstElementList );
	LIST_FORALL( pct->pVarElementList, idx, PCONFIG_ELEMENT, pce )
	{
#ifdef DEBUG_SAVE_CONFIG
		lprintf( "Delete var element" );
#endif
		DestroyConfigElement( pch, pce );
	}
	DeleteList( &pct->pVarElementList );
	// a pconfig_handler has one static root - guaranteed root.
	// if this pct IS the root, don't attempt to delete from set
	if( deallocate )
		//if( pct != &pch->ConfigTestRoot )
		DeleteFromSet( CONFIG_TEST, pch->test_elements, pct );
	//Release( pct );
}
//---------------------------------------------------------------------
CONFIGSCR_PROC( void, DestroyConfigurationEvaluator )( PCONFIG_HANDLER pch )
{
	// since as noted in the structure
	//	// address of this IS the address of main structure
	// the configtest Release() will quickly free this .
	PLIST save_list_pConstElementList = pch->ConfigTestRoot.pConstElementList;
	PLIST save_list_pVarElementList = pch->ConfigTestRoot.pVarElementList;
#ifdef DEBUG_SAVE_CONFIG
	lprintf( "Destroy evaluator %p", pch );
#endif
	DestroyConfigTest( pch, &pch->ConfigTestRoot, FALSE );
	{
		INDEX idx;
		PCONFIG_STATE state;
		LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
		{
			if( ( save_list_pConstElementList
				&& (state->ConfigTestRoot.pConstElementList == save_list_pConstElementList ))
				|| ( save_list_pVarElementList
					&& (state->ConfigTestRoot.pVarElementList == save_list_pVarElementList ) )
			)
			{
				//probably this was the error I found in the field... there were
				// probably macros or something that caused excessive layering.
				// or - it was the old bug of not saving the state quite correctly.
				continue;
			}
			DestroyConfigTest( pch, &state->ConfigTestRoot, FALSE );
		}
		LIST_FORALL( pch->states, idx, PCONFIG_STATE, state )
		{
			Release( (POINTER)state->name );
			Release( state );
		}
	}
	if( pch->save_config_as && !pch->flags.bConfigSaveNameUsed )
		Release( (POINTER)pch->save_config_as );
	//lprintf( WIDE("Setting memory logging to %d"), _last_allocate_logging );
	if( g.flags.bDisableMemoryLogging )
		if( g._disabled_allocate_logging )
		{
			g._disabled_allocate_logging--;
			if( !g._disabled_allocate_logging )
			{
				SetAllocateLogging( g._last_allocate_logging );
			}
		}
	DeleteList( &pch->states );
	DeleteList( &pch->filters );
	DeleteList( &pch->filter_data );
	DeleteSet( (PGENERICSET*)&(pch->elements) );
	DeleteSet( (PGENERICSET*)&(pch->test_elements) );
	Release( pch );
}
void StripConfigString( TEXTSTR out, CTEXTSTR in )
{
	// convert \r\n to literal characters...
	if( !in )
	{
		out[0] = 0;
		return;
	}
	for( ; in[0]; in++,out++ )
	{
		if( in[0] == '\\' )
		{
			switch( in[1] )
			{
			case 'n':
				in++;
				out[0] = '\n';
				break;
			default:
				out[0] = in[1];
				in++;
				break;
			}
		}
		else
			out[0] = in[0];
	}
	out[0] = in[0];
}
void ExpandConfigString( TEXTSTR out, CTEXTSTR in )
{
	// convert \r\n to literal characters...
	if( !in )
	{
		out[0] = 0;
		return;
	}
	for( ; in[0]; in++,out++ )
	{
		if( in[0] == '\n' )
		{
			out[0] = '\\';
			out++;
			out[0] = 'n';
		}
		else if( in[0] == '\\' )
		{
			out[0] = '\\';
			out++;
			out[0] = '\\';
		}
		else if( in[0] == '#' )
		{
			out[0] = '\\';
			out++;
			out[0] = '#';
		}
		else
			out[0] = in[0];
	}
	out[0] = in[0];
}
CTEXTSTR FormatColor( CDATA color )
{
	static TEXTCHAR color_buf[14];
	tnprintf( color_buf, sizeof( color_buf ), WIDE("$%02X%02X%02X%02X")
			, (int)AlphaVal( color )
			, (int)RedVal( color )
			, (int)GreenVal( color )
			, (int)BlueVal( color )
			);
	return color_buf;
}
#ifdef __cplusplus
 //namespace sack { namespace config {
}}
#endif
//-----------------------------------------------------------------------
// SQLSTUB.C - core sql abstractin library
//   Provides, essentially, 2 functions...
//     SQLQuery
//     SQLCommand
//
//-----------------------------------------------------------------------
/* this is a logging around the ODBC open itself... may be used for timing... */
//#define LOG_ACTUAL_CONNECTION
//#define LOG_COLLECTOR_STATES
//#define LOG_EVERYTHING
#define SQLLIB_SOURCE
#define DO_LOGGING
#ifdef USE_SQLITE_INTERFACE
#define USES_SQLITE_INTERFACE
//#define DEFINES_SQLITE_INTERFACE
#endif
// please remove this reference ASAP
//#include <controls.h> // temp graphic interface for debugging....
#ifdef SYSTRAY_LIBRARAY
#define SYSTRAY_PROC EXPORT_METHOD
#else
#define SYSTRAY_PROC IMPORT_METHOD
#endif
#define ICONFROMIMAGE 1
#define ICONFROMTEXT 2
SYSTRAY_PROC int RegisterIconEx( CTEXTSTR icon DBG_PASS);
#define RegisterIcon(icon) RegisterIconEx( icon DBG_SRC )
SYSTRAY_PROC void ChangeIconEx( CTEXTSTR icon DBG_PASS );
#define ChangeIcon(icon) ChangeIconEx( icon DBG_SRC )
SYSTRAY_PROC void UnregisterIcon( void );
SYSTRAY_PROC void SetIconDoubleClick( void (*DoubleClick)(void ) );
SYSTRAY_PROC void TerminateIcon( void );
SYSTRAY_PROC void AddSystrayMenuFunction( CTEXTSTR text, void (CPROC*function)(void) );
// this may be important one day!
//void SetIconMenu( HMENU menu );
// $Log: systray.h,v $
// Revision 1.3  2003/03/25 08:38:11  panther
// Add logging
//
#ifdef SQL_PROXY_SERVER
#endif
#ifdef __cplusplus
using namespace sack::logging;
using namespace sack::memory;
using namespace sack::timers;
using namespace sack::config;
#endif
// undef if USE=0
#ifdef USE_ODBC
#  if !USE_ODBC
#    undef USE_ODBC
#  endif
#endif
SQL_NAMESPACE
#ifdef _cplusplus_cli
using namespace CORE::Database;
public ref class export_this_class_PLEASE
{
 // implements/overrides the IDisposable::Dispose method
	~export_this_class_PLEASE()
    {
        // free managed and unmanaged resources
    }
 // implements/overrides the Object::Finalize method
    !export_this_class_PLEASE()
    {
        // free unmanaged resources only
    }
};
//It also works on generics:
#if 0
generic <typename T>
ref class MyGeneric
{
public:
   void PrintTypes()
   {
      Type^ tType = T::typeid;
      Console::WriteLine(tType->FullName);
   }
};
#endif
/*
PRELOAD( test1 )
//void f( void )
{
CORE::Database::SingleService^ ss = gcnew CORE::Database::SingleService();
DECLTEXT( cmd, WIDE("Select 1+1") );
System::Data::Common::DbDataReader^ db = ss->RunQuery( gcnew System::String( GetText( (PTEXT)&cmd ) ) );
for( int n = db->FieldCount; n; n-- )
{
	lprintf( WIDE("field %d is %s"), n, db->GetString(n-1) );
}
delete db;
delete ss;
	//for( db.Read();
	//CORE::Database::SingleService::
	}
*/
#endif
#define PROXY_FULL     WIDE( "PROXY_FULL" )
#define PROXY_PRIMARY  WIDE( "PROXY_PRIMARY" )
#define PROXY_BACKUP   WIDE( "PROXY_BACKUP" )
#define PROXY_DOWN     WIDE( "PROXY_DOWN" )
#define SQL_INI WIDE( "SQLPROXY.INI" )
static uintptr_t CPROC AutoCloseThread( PTHREAD thread );
static uintptr_t CPROC AutoCheckpointThread( PTHREAD thread );
void CloseDatabaseEx( PODBC odbc, LOGICAL ReleaseConnection );
static int __DoSQLQueryEx(  PODBC odbc, PCOLLECT collection, CTEXTSTR query DBG_PASS );
#define __DoSQLQuery( o,c,q ) __DoSQLQueryEx(o,c,q DBG_SRC )
/*, uint32_t MyID*/
static int __DoSQLCommandEx( PODBC odbc, PCOLLECT collection DBG_PASS );
#define __DoSQLCommand(o,c) __DoSQLCommandEx(o,c DBG_SRC )
/*, uint32_t MyID*/
static int __GetSQLResult( PODBC odbc, PCOLLECT collection, int bMore );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
static int DumpInfo2( PVARTEXT pvt, SQLSMALLINT type, struct odbc_handle_tag *odbc, LOGICAL bNoLog );
#endif
#ifdef USE_ODBC
static int DumpInfoEx( PODBC odbc, PVARTEXT pvt, SQLSMALLINT type, SQLHANDLE *handle, LOGICAL bNoLog DBG_PASS );
#define DumpInfo(o,a,b,c,d) DumpInfoEx(o,a,b,c,d DBG_SRC )
//int DumpInfo( PVARTEXT pvt, SQLSMALLINT type, SQLHANDLE *handle );
#endif
enum SQL_DelayOperations {
   LAST_NONE
     , LAST_COMMAND
     , LAST_QUERY
     , LAST_RESULT
 // LastOperations;
};
//#include <sqlstub.h>
typedef struct update_task_def UPDATE_TASK, *PUPDATE_TASK;
struct update_task_def
{
	TEXTCHAR name[256];
	// perhaps this should be PODBC primary PODBC backup
	// so we know where we're copying to/from on the update task.
	void (CPROC *PrimaryRecovered)( PODBC,PODBC );
	void (CPROC *CheckTables)( PODBC );
	DeclareLink( struct update_task_def );
};
struct pssql_global *global_sqlstub_data;
#ifdef g
#  undef g
#endif
#define g (*global_sqlstub_data)
//----------------------------------------------------------------------
static void SqlStubInitLibrary( void );
PRIORITY_PRELOAD( InitGlobalData, SQL_PRELOAD_PRIORITY )
{
	// is null initialized.
	SimpleRegisterAndCreateGlobal( global_sqlstub_data );
	SqlStubInitLibrary();
}
ATEXIT_PRIORITY( CloseConnections, ATEXIT_PRIORITY_SYSLOG - 3 )
{
	PODBC odbc;
	INDEX idx;
	if( global_sqlstub_data )
		LIST_FORALL( global_sqlstub_data->pOpenODBC, idx, PODBC, odbc  )
		{
			CloseDatabaseEx( odbc, FALSE );
		}
}
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
static void GetColumnSize(sqlite3_context*onwhat,int n,sqlite3_value**something) {
	switch( sqlite3_value_type( something[0] ) ) {
	case SQLITE_TEXT :
	case SQLITE_BLOB :
		sqlite3_result_int( onwhat, sqlite3_value_bytes(something[0] ) );
		break;
	default :
		// do a text conversion on it.
		sqlite3_value_text( something[0] );
		sqlite3_result_int( onwhat, sqlite3_value_bytes(something[0] ) );
		break;
	}
}
static void GetNowFunc(sqlite3_context*onwhat,int n,sqlite3_value**something)
{
	CTEXTSTR str = GetPackedTime();
#ifdef _UNICODE
	char *tmp_str = WcharConvert( str );
	sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
	Deallocate( char *, tmp_str );
#else
	sqlite3_result_text( onwhat, str, (int)(sizeof( str[0] ) * StrLen( str )), 0 );
#endif
}
static void GetCurUser(sqlite3_context*onwhat,int n,sqlite3_value**something)
{
	CTEXTSTR str = OSALOT_GetEnvironmentVariable( WIDE("USERNAME") );
	static TEXTCHAR tmp[256];
	tnprintf( tmp, 256, WIDE("%s@127.0.0.1"), str );
#ifdef _UNICODE
	{
		char *tmp_str = WcharConvert( tmp );
		sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
		Deallocate( char *, tmp_str );
	}
#else
	sqlite3_result_text( onwhat, tmp, (int)(sizeof( tmp[0] ) * StrLen( tmp )), 0 );
#endif
}
static void GetCurDateFunc(sqlite3_context*onwhat,int n,sqlite3_value**something)
{
	CTEXTSTR str = GetPackedTime();
	static TEXTSTR tmp;
	if( !tmp )
		tmp = StrDup( str );
	else
		StrCpyEx( tmp, str, 8 );
	tmp[8] = 0;
#ifdef _UNICODE
	{
		char *tmp_str = WcharConvert( tmp );
		sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
		Deallocate( char *, tmp_str );
	}
#else
	sqlite3_result_text( onwhat, tmp, (int)(sizeof( tmp[0] ) * StrLen( tmp )), 0 );
#endif
}
static void SQLiteGetLastInsertID(sqlite3_context*onwhat,int n,sqlite3_value**something)
{
	static TEXTCHAR str[20];
	PODBC odbc = (PODBC)sqlite3_user_data(onwhat);
	tnprintf( str, sizeof( str ), WIDE( "%") _64fs, sqlite3_last_insert_rowid( odbc->db ) );
#ifdef _UNICODE
	{
		char *tmp_str = WcharConvert( str );
		sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
		Deallocate( char *, tmp_str );
	}
#else
	sqlite3_result_text( onwhat, str, (int)(sizeof( str[0] ) * StrLen( str )), 0 );
#endif
}
#ifndef NO_CRYPT
static void computeSha1(sqlite3_context*onwhat,int argc,sqlite3_value**argv)
{
	PVARTEXT pvt = VarTextCreate();
	PODBC odbc = (PODBC)sqlite3_user_data(onwhat);
	const unsigned char *val = sqlite3_value_text( argv[0] );
	SHA1Context sha;
	uint8_t digest[SHA1HashSize];
	int n;
	static PTEXT result;
   if( result ) LineRelease( result );
	SHA1Reset( &sha );
	SHA1Input( &sha, val, strlen( (CTEXTSTR)val ) );
	SHA1Result( &sha, digest );
	for( n = 0; n < SHA1HashSize; n++ )
		vtprintf( pvt, "%02X", digest[n] );
	result = VarTextGet( pvt );
#ifdef _UNICODE
	{
		char *tmp_str = WcharConvert( GetText( result ) );
		sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
		Deallocate( char *, tmp_str );
	}
#else
	sqlite3_result_text( onwhat, GetText( result ), (int)GetTextSize( result ), 0 );
#endif
}
static void computePassword(sqlite3_context*onwhat,int argc,sqlite3_value**argv)
{
   const unsigned char *val = sqlite3_value_text( argv[0] );
	static TEXTCHAR *result;
	if( result ) Release( result );
	result = SRG_EncryptString( (CTEXTSTR)val );
#ifdef _UNICODE
	{
		char *tmp_str = WcharConvert( result );
		sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
		Deallocate( char *, tmp_str );
	}
#else
	sqlite3_result_text( onwhat, result, (int)StrLen( result ), 0 );
#endif
	//Release( result );
}
static void decomputePassword(sqlite3_context*onwhat,int n,sqlite3_value**argv)
{
	const unsigned char *val = sqlite3_value_text( argv[0] );
	static TEXTCHAR *result;
	if( result ) Release( result );
	result = SRG_DecryptString( (CTEXTSTR)val );
#ifdef _UNICODE
	{
		char *tmp_str = WcharConvert( result );
		sqlite3_result_text( onwhat, tmp_str, (int)(sizeof( tmp_str[0] ) * StrLen( str )), 0 );
		Deallocate( char *, tmp_str );
	}
#else
	sqlite3_result_text( onwhat, result, (int)StrLen( result ), 0 );
#endif
	//Release( result );
}
#endif
int PSSQL_AddSqliteFunction( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callDestroy )( void* )
	, int args
	, void *userData ) {
	return sqlite3_create_function_v2(
 //sqlite3 *,
	    odbc->db
  //const char *zFunctionName,
	    , name
 //int nArg,
	    , args
 //int eTextRep,
	    , SQLITE_UTF8
 //void*,
	    , userData
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
	    , callUserFunction
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
	    , NULL
 //void (*xFinal)(sqlite3_context*)
	    , NULL
	    , callDestroy
	);
}
int PSSQL_AddSqliteProcedure( PODBC odbc
	, const char *name
	, void( *callUserFunction )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callDestroy )( void* )
	, int args
	, void *userData ) {
	return sqlite3_create_function_v2(
 //sqlite3 *,
	    odbc->db
  //const char *zFunctionName,
	    , name
 //int nArg,
	    , args
 //int eTextRep,
	    , SQLITE_UTF8|SQLITE_DETERMINISTIC
 //void*,
	    , userData
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
	    , callUserFunction
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
	    , NULL
 //void (*xFinal)(sqlite3_context*)
	    , NULL
	    , callDestroy
	);
}
int PSSQL_AddSqliteAggregate( PODBC odbc
	, const char *name
	, void( *callStep )( struct sqlite3_context*onwhat, int argc, struct sqlite3_value**argv )
	, void( *callFinal )( struct sqlite3_context*onwhat )
	, void( *callDestroy )( void* )
	, int args
	, void *userData ) {
	return sqlite3_create_function_v2(
 //sqlite3 *,
	    odbc->db
  //const char *zFunctionName,
	    , name
 //int nArg,
	    , args
 //int eTextRep,
	    , SQLITE_UTF8
 //void*,
	    , userData
 //callUserFunction //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
	    , NULL
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
	    , callStep
 //void (*xFinal)(sqlite3_context*)
	    , callFinal
	    , callDestroy
	);
}
POINTER PSSQL_GetSqliteFunctionData( struct sqlite3_context*context ) {
	return sqlite3_user_data( context );
}
void PSSQL_ResultSqliteText( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) ) {
	sqlite3_result_text( context, data, dataLen, done );
}
void PSSQL_ResultSqliteBlob( struct sqlite3_context*context, const char *data, int dataLen, void (*done)(void*) ) {
	sqlite3_result_blob( context, data, dataLen, done );
}
void PSSQL_ResultSqliteDouble( struct sqlite3_context*context, double val ) {
	sqlite3_result_double( context, val );
}
void PSSQL_ResultSqliteInt( struct sqlite3_context*context, int val ) {
	sqlite3_result_int( context, val );
}
void PSSQL_ResultSqliteInt64( struct sqlite3_context*context, int64_t val ) {
	sqlite3_result_int64( context, val );
}
void PSSQL_ResultSqliteNull( struct sqlite3_context*context ) {
	sqlite3_result_null( context );
}
void PSSQL_GetSqliteValueText( struct sqlite3_value *val, const char **text, int *textLen ) {
 // sqlite function is 'unsigned' result
	(*text) = (const char *)sqlite3_value_text( val );
	(*textLen) = sqlite3_value_bytes( val );
}
enum sqlite_data_types PSSQL_GetSqliteValueType( struct sqlite3_value *val ){
	return (enum sqlite_data_types)sqlite3_value_type( val );
}
void PSSQL_GetSqliteValueBlob( struct sqlite3_value *val, const char **text, int *textLen ){
 // sqlite function is 'unsigned' result
	(*text) = (const char *)sqlite3_value_text( val );
	(*textLen) = sqlite3_value_bytes( val );
}
void PSSQL_GetSqliteValueDouble( struct sqlite3_value *val, double *result ){
 // sqlite function is 'unsigned' result
	(*result) = sqlite3_value_double( val );
}
void PSSQL_GetSqliteValueInt( struct sqlite3_value *val, int *result ){
 // sqlite function is 'unsigned' result
	(*result) = sqlite3_value_int( val );
}
void PSSQL_GetSqliteValueInt64( struct sqlite3_value *val, int64_t *result ){
 // sqlite function is 'unsigned' result
	(*result) = sqlite3_value_int64( val );
}
const char * PSSQL_GetColumnTableName( PODBC odbc, int col) {
	PCOLLECT pCollect;
	pCollect = odbc ? odbc->collection : NULL;
	if( pCollect ) {
		const char *tmp;
		//tmp = sqlite3_column_table_name( pCollect->stmt, col ); // sqlite function is 'unsigned' result
		//tmp = sqlite3_column_origin_name( pCollect->stmt, col ); // sqlite function is 'unsigned' result
 // sqlite function is 'unsigned' result
		tmp = sqlite3_column_table_name( pCollect->stmt, col );
		return tmp;
	}
	return NULL;
}
const char * PSSQL_GetColumnTableAliasName( PODBC odbc, int col ) {
	PCOLLECT pCollect;
	pCollect = odbc ? odbc->collection : NULL;
	if( pCollect ) {
		const char *tmp;
		//tmp = sqlite3_column_table_name( pCollect->stmt, col ); // sqlite function is 'unsigned' result
		//tmp = sqlite3_column_origin_name( pCollect->stmt, col ); // sqlite function is 'unsigned' result
 // sqlite function is 'unsigned' result
		tmp = sqlite3_column_table_alias( pCollect->stmt, col );
		return tmp;
	}
	return NULL;
}
void ExtendConnection( PODBC odbc )
{
	int rc;
	if( odbc->flags.bAutoClose )
	{
		lprintf( "Extned found autoclose" );
		if( !odbc->auto_close_thread )
			odbc->auto_close_thread = ThreadTo( AutoCloseThread, (uintptr_t)odbc );
	}
	rc = sqlite3_create_function(
 //sqlite3 *,
												odbc->db
  //const char *zFunctionName,
											  , "now"
 //int nArg,
											  , 0
 //int eTextRep,
											  , SQLITE_UTF8
 //void*,
											  , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
											  , GetNowFunc
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
											  , NULL
 //void (*xFinal)(sqlite3_context*)
											  , NULL
											  );
	if( rc )
	{
		// error..
	}
	rc = sqlite3_create_function(
 //sqlite3 *,
												odbc->db
  //const char *zFunctionName,
											  , "bytes"
 //int nArg,
											  , 0
 //int eTextRep,
											  , SQLITE_INTEGER
 //void*,
											  , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
											  , GetColumnSize
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
											  , NULL
 //void (*xFinal)(sqlite3_context*)
											  , NULL
											  );
	if( rc )
	{
		// error..
	}
	rc = sqlite3_create_function(
 //sqlite3 *,
										  odbc->db
  //const char *zFunctionName,
										 , "curdate"
 //int nArg,
										 , 0
 //int eTextRep,
										 , SQLITE_UTF8
 //void*,
										 , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
										 , GetCurDateFunc
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
										 , NULL
 //void (*xFinal)(sqlite3_context*)
										 , NULL
										 );
	if( rc )
	{
		// error..
	}
	rc = sqlite3_create_function(
 //sqlite3 *,
										  odbc->db
  //const char *zFunctionName,
										 , "user"
 //int nArg,
										 , 0
 //int eTextRep,
										 , SQLITE_UTF8
 //void*,
										 , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
										 , GetCurUser
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
										 , NULL
 //void (*xFinal)(sqlite3_context*)
										 , NULL
										 );
	if( rc )
	{
		// error..
	}
#ifndef NO_CRYPT
	rc = sqlite3_create_function(
 //sqlite3 *,
										  odbc->db
  //const char *zFunctionName,
										 , "sha1"
 //int nArg,
										 , 1
 //int eTextRep,
										 , SQLITE_UTF8
 //void*,
										 , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
										 , computeSha1
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
										 , NULL
 //void (*xFinal)(sqlite3_context*)
										 , NULL
										 );
	if( rc )
	{
		// error..
	}
	rc = sqlite3_create_function(
 //sqlite3 *,
										  odbc->db
  //const char *zFunctionName,
										 , "encrypt"
 //int nArg,
										 , 1
 //int eTextRep,
										 , SQLITE_UTF8
 //void*,
										 , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
										 , computePassword
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
										 , NULL
 //void (*xFinal)(sqlite3_context*)
										 , NULL
										 );
	if( rc )
	{
		// error..
	}
	rc = sqlite3_create_function(
 //sqlite3 *,
										  odbc->db
  //const char *zFunctionName,
										 , "decrypt"
 //int nArg,
										 , 1
 //int eTextRep,
										 , SQLITE_UTF8
 //void*,
										 , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
										 , decomputePassword
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
										 , NULL
 //void (*xFinal)(sqlite3_context*)
										 , NULL
										 );
	if( rc )
	{
		// error..
	}
#endif
	rc = sqlite3_create_function(
 //sqlite3 *,
										  odbc->db
  //const char *zFunctionName,
										 , "LAST_INSERT_ID"
 //int nArg,
										 , 0
 //int eTextRep,
										 , SQLITE_UTF8
 //void*,
										 , (void*)odbc
 //void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
										 , SQLiteGetLastInsertID
 //void (*xStep)(sqlite3_context*,int,sqlite3_value**),
										 , NULL
 //void (*xFinal)(sqlite3_context*)
										 , NULL
										 );
	if( rc )
	{
		// error..
	}
	if( !sqlite3_get_autocommit(odbc->db) )
	{
		lprintf( WIDE( "auto commit off?" ) );
		//DebugBreak();
	}
	//SQLCommandf( odbc, "PRAGMA read_uncommitted=True" );
	{
		CTEXTSTR result;
		int n = odbc->flags.bNoLogging;
		int m = odbc->flags.bAutoCheckpoint;
		odbc->flags.bNoLogging = 0;
		odbc->flags.bAutoCheckpoint = 0;
		{
			INDEX idx;
			CTEXTSTR cmd;
			LIST_FORALL( g.database_init, idx, CTEXTSTR, cmd ) {
				SQLQueryf( odbc, &result, cmd );
				//if( result )
				//	lprintf( WIDE( " %s" ), result );
				SQLEndQuery( odbc );
			}
		}
		//SQLQueryf( odbc, &result, WIDE( "PRAGMA journal_mode=WAL;" ) );
		//if( result )
		//	lprintf( WIDE( "Journal is now %s" ), result );
		//SQLEndQuery( odbc );
		if( g.flags.bAutoCheckpointRecover ) {
			SQLQueryf( odbc, &result, WIDE( "PRAGMA wal_checkpoint;" ) );
			SQLEndQuery( odbc );
			g.flags.bAutoCheckpointRecover = 0;
		}
		odbc->flags.bNoLogging = n;
		odbc->flags.bAutoCheckpoint = m;
		//SQLQueryf( odbc, &result, WIDE( "PRAGMA journal_mode" ) );
		//lprintf( WIDE( "Journal is now %s" ), result );
	}
}
#endif
//----------------------------------------------------------------------
static void DumpODBCInfo( PODBC odbc )
{
	if( g.odbc && odbc == g.odbc )
	{
		lprintf( WIDE( "GLOBAL ODBC:" ) );
	}
	if( !odbc )
		return;
	lprintf( WIDE( "odbc = %p" ), odbc );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	lprintf( WIDE( "odbc->db = %p" ), odbc->db );
#endif
#ifdef USE_ODBC
	lprintf( WIDE( "odbc->env = %p" ), odbc->env );
	lprintf( WIDE( "odbc->hdbc = %p" ), odbc->hdbc );
#endif
	lprintf( WIDE( "Last native error code: %d" ), odbc->native );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#  define NativeOption odbc->flags.bSQLite_native?WIDE("[Native SQLite]"):WIDE("[Not Native SQLite]")
#else
#  define NativeOption WIDE("[]")
#endif
#ifdef USE_ODBC
#  define ODBCOption odbc->flags.bODBC?WIDE("[ODBC]"):WIDE("[Not ODBC]")
#else
#  define ODBCOption WIDE("[]")
#endif
	lprintf( WIDE( "odbc flags = %s %s %s %s %s %s" )
		, odbc->flags.bConnected?WIDE("[Connected]"):WIDE("[Not Connected]")
		, odbc->flags.bAccess ?WIDE("[MS Access]"):WIDE("[]")
		, odbc->flags.bSQLite?WIDE("[SQLite]"):WIDE("[]")
			 , odbc->flags.bPushed?WIDE("[PendingPush]"):WIDE("[]")
			 , NativeOption
			 , ODBCOption
		);
	lprintf( WIDE("Collection(s)...") );
	{
		PCOLLECT c;
		for( c = odbc->collection; c; c = c->next )
		{
			lprintf( WIDE( "----------" ) );
			lprintf( WIDE( "\tflags: %s %s %s %s %s" )
					 , c->flags.bBuildResultArray?WIDE( "Result Array" ):WIDE( "Result String" )
					 , c->flags.bDynamic?WIDE( "Dynamic" ):WIDE( "Static" )
					 , c->flags.bTemporary?WIDE( "Temporary" ):WIDE( "QueryResult" )
					 , c->flags.bPushed?WIDE( "Pushed" ):WIDE( "Auto" )
					 , c->flags.bEndOfFile?WIDE( "EOF" ):WIDE( "more" )
					 );
			lprintf( WIDE( "\tCommand: %s" )
					 , GetText( VarTextPeek( c->pvt_out ) )
					 );
			lprintf( WIDE( "\tResult: %s" )
					 , GetText( VarTextPeek( c->pvt_result ) )
					 );
			lprintf( WIDE( "\tErr Info: %s" )
					 , GetText( VarTextPeek( c->pvt_errorinfo ) )
					 );
		}
	}
}
void DumpAllODBCInfo( void )
{
	INDEX idx;
	PODBC odbc;
	LIST_FORALL( g.pOpenODBC, idx, PODBC, odbc )
		DumpODBCInfo( odbc );
}
//----------------------------------------------------------------------
void SQLSetFeedbackHandler( void (CPROC*HandleSQLFeedback)(CTEXTSTR message) )
{
	g.feedback_handler = HandleSQLFeedback;
}
//----------------------------------------------------------------------
static LOGICAL IsOdbcIdle( PODBC odbc ) {
	PCOLLECT pCollect;
	pCollect = odbc?odbc->collection:NULL;
	for( ; pCollect; pCollect = NextThing( pCollect ) ) {
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		// still has an active statement.
		if( pCollect->stmt )
			return FALSE;
#endif
#if defined( USE_ODBC )
		// still has an active statement.
		if( pCollect->hstmt )
			return FALSE;
#endif
	}
	return TRUE;
}
static void startAutoCheckpoint( PODBC odbc ) {
	if( odbc->flags.bAutoCheckpoint )
	{
		//lprintf( "enabling oneshot idle chckpoint generator" );
		//DumpODBCInfo( odbc );
		if( !odbc->auto_checkpoint_thread )
			odbc->auto_checkpoint_thread = ThreadTo( AutoCheckpointThread, (uintptr_t)odbc );
	}
}
#ifdef LOG_COLLECTOR_STATES
		static int collectors;
#endif
static PCOLLECT CreateCollectorEx( PSERVICE_ROUTE SourceID, PODBC odbc, LOGICAL bTemporary DBG_PASS )
#define CreateCollector(s,o,t) CreateCollectorEx( s,o,t DBG_SRC )
{
	PCOLLECT pCollect;
	LOGICAL pushed;
	if( !odbc )
		odbc = g.odbc;
	if( !odbc )
	{
		lprintf( WIDE("No certain odbc to create collector ON...") );
		DebugBreak();
		return NULL;
	}
	pushed = odbc->collection?odbc->collection->flags.bPushed:odbc->flags.bPushed;
#ifdef LOG_COLLECTOR_STATES
	lprintf( WIDE( "Creating [%s][%s] collector" ), bTemporary?WIDE( "temp" ):WIDE( "" ), odbc->collection?odbc->collection->flags.bPushed?WIDE( "pushed" ):WIDE( "" ):WIDE( "" ) );
#endif
	pCollect = odbc->collection;
	if( pushed && pCollect && pCollect->flags.bPushed )
	{
#ifdef LOG_COLLECTOR_STATES
		lprintf( WIDE( "New collector should be 'pushed', and prior is pushed (might be end of file query temp)" ) );
#endif
		// don't do anything, but definatly don't do temproary promotions.
	}
	else
	{
		if( pCollect && pCollect->flags.bTemporary && bTemporary )
		{
			// it's a created collector, empty prior command... (query)
			VarTextEmpty( pCollect->pvt_out );
			VarTextEmpty( pCollect->pvt_errorinfo );
			if( odbc->flags.bPushed )
			{
				pCollect->flags.bPushed = 1;
				pCollect->flags.bTemporary = 1;
				odbc->flags.bPushed = 0;
			}
 // already have a temp available.. use it.
			return pCollect;
		}
		else if( pCollect && pCollect->flags.bTemporary && !bTemporary )
		{
#ifdef LOG_COLLECTOR_STATES
			lprintf( WIDE( "Promoting temporary %p to non temp (query)" ), pCollect );
#endif
			VarTextEmpty( pCollect->pvt_out );
			VarTextEmpty( pCollect->pvt_errorinfo );
			pCollect->flags.bTemporary = 0;
			if( odbc->flags.bPushed )
			{
				pCollect->flags.bPushed = 1;
				pCollect->flags.bTemporary = 1;
				odbc->flags.bPushed = 0;
			}
			return pCollect;
		}
	}
	pCollect = (PCOLLECT)AllocateEx( sizeof( COLLECT ) DBG_RELAY );
#ifdef LOG_COLLECTOR_STATES
	lprintf( WIDE( "New collector is %p" ), pCollect );
#endif
	MemSet( pCollect, 0, sizeof( COLLECT ) );
	// there are a couple uninitialized values in thiws...
	pCollect->fields = NULL;
	pCollect->result_len = NULL;
	pCollect->lastop = LAST_NONE;
	pCollect->odbc = odbc;
	pCollect->pvt_out = VarTextCreateEx( DBG_VOIDRELAY );
	pCollect->pvt_result = VarTextCreate();
	pCollect->pvt_errorinfo = VarTextCreate();
	pCollect->SourceID = SourceID;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	pCollect->stmt = NULL;
#endif
#ifdef USE_ODBC
	pCollect->hstmt = NULL;
#endif
	pCollect->flags.bTemporary = bTemporary;
	pCollect->flags.bDynamic = TRUE;
	//lprintf( WIDE("Adding %p to %p at %p"), pCollect, odbc, &odbc->collection );
	if( odbc )
	{
		LinkThing( odbc->collection, pCollect );
	}
	else
		LinkThing( g.collections, pCollect );
#ifdef LOG_COLLECTOR_STATES
	{
		collectors++;
		lprintf( WIDE( "Collectors: %d" ), collectors );
	}
#endif
	if( odbc->flags.bPushed )
	{
		pCollect->flags.bPushed = 1;
		pCollect->flags.bTemporary = 1;
		odbc->flags.bPushed = 0;
	}
	return pCollect;
}
//----------------------------------------------------------------------
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC AddDatabaseInit( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, initSQL );
	if( initSQL && strlen( initSQL ) )
		AddLink( &g.option_database_init, StrDup( initSQL ) );
	return psv;
}
static uintptr_t CPROC AddOptionDatabaseInit( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, initSQL );
	if( initSQL && strlen( initSQL ) )
		AddLink( &g.database_init, StrDup( initSQL ) );
	return psv;
}
static uintptr_t CPROC SetPrimaryDSN( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pDSN );
	g.Primary.info.pDSN = StrDup( pDSN );
	return psv;
}
static uintptr_t CPROC SetOptionDSN( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pDSN );
	g.OptionDb.info.pDSN = StrDup( pDSN );
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetBackupDSN( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pDSN );
	g.Backup.info.pDSN = StrDup( pDSN );
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetConnString( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pUser );
	StrCpyEx( g.Primary.info.pConnString, pUser, sizeof( g.Primary.info.pConnString ) / sizeof( TEXTCHAR ) );
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetUser( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pUser );
	StrCpyEx( g.Primary.info.pID, pUser, sizeof( g.Primary.info.pID ) / sizeof( TEXTCHAR ) );
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetPassword( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pPassword );
	StrCpyEx( g.Primary.info.pPASSWORD, pPassword, sizeof( g.Primary.info.pPASSWORD ) );
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetFallback( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bFallback );
	g.flags.bFallback = bFallback;
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetRequirePrimaryConnection( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bRequired );
	g.Primary.flags.bForceConnection = bRequired;
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetRequireConnection( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bRequired );
	g.flags.bRequireConnection = bRequired;
	return psv;
}
static uintptr_t CPROC SetRequireBackupConnection( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bRequired );
	g.Backup.flags.bForceConnection = bRequired;
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetBackupUser( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pUser );
	StrCpyEx( g.Backup.info.pID, pUser, sizeof( g.Primary.info.pID ) );
	return psv;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
static uintptr_t CPROC SetBackupPassword( uintptr_t psv, arg_list args )
{
	PARAM( args, CTEXTSTR, pPassword );
	StrCpyEx( g.Backup.info.pPASSWORD, pPassword, sizeof( g.Backup.info.pPASSWORD ) );
	return psv;
}
static uintptr_t CPROC SetLoggingEnabled( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bEnable );
	g.flags.bLogging = bEnable;
	return psv;
}
static uintptr_t CPROC SetLoggingEnabled2( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bEnable );
	g.flags.bNoLog = !bEnable;
	return psv;
}
static uintptr_t CPROC SetLoggingEnabled3( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bEnable );
	g.flags.bLogData = bEnable;
	return psv;
}
static uintptr_t CPROC SetAutoCheckpoint( uintptr_t psv, arg_list args ) {
	PARAM( args, LOGICAL, bEnable );
	g.flags.bAutoCheckpoint = bEnable;
	return psv;
}
static uintptr_t CPROC SetLogOptions( uintptr_t psv, arg_list args )
{
	PARAM( args, LOGICAL, bEnable );
	g.flags.bLogOptionConnection = bEnable;
	return psv;
}
void SetSQLLoggingDisable( PODBC odbc, LOGICAL bDisable )
{
	//lprintf( WIDE( "%s SQL logging on %p" ), bDisable?WIDE( "disabling" ):WIDE( "enabling" ), odbc );
	if( odbc )
	{
		odbc->flags.bNoLogging = bDisable;
	}
}
void SetSQLThreadProtect( PODBC odbc, LOGICAL bEnable )
{
	if( odbc )
	{
		odbc->flags.bThreadProtect = bEnable;
		if( bEnable )
		{
			InitializeCriticalSec( &odbc->cs );
		}
		else
			DeleteCriticalSec( &odbc->cs );
	}
}
void SetSQLAutoTransact( PODBC odbc, LOGICAL bEnable )
{
	if( odbc )
		odbc->flags.bAutoTransact = bEnable;
}
void SetSQLAutoTransactCallback( PODBC odbc, void (CPROC*callback)(uintptr_t,PODBC), uintptr_t psv )
{
	if( odbc )
	{
		if( callback )
			odbc->flags.bAutoTransact = 1;
		else
			odbc->flags.bAutoTransact = 0;
		odbc->auto_commit_callback = callback;
		odbc->auto_commit_callback_psv = psv;
	}
}
void SetSQLAutoClose( PODBC odbc, LOGICAL bEnable )
{
	if( odbc )
	{
		odbc->flags.bAutoClose = bEnable;
		if( bEnable )
		{
			// no thread already, and it is connected (otherwise later, connection will be made, and this scheduled)
			if( !odbc->auto_close_thread && odbc->flags.bConnected )
				odbc->auto_close_thread = ThreadTo( AutoCloseThread, (uintptr_t)odbc );
		}
		else
		{
			if( odbc->auto_close_thread )
			{
				WakeThread( odbc->auto_close_thread );
			}
		}
	}
}
void SetSQLAutoCheckpoint( PODBC odbc, LOGICAL bEnable )
{
	if( odbc )
	{
		odbc->flags.bAutoCheckpoint = bEnable;
		if( bEnable )
		{
			// next command will enable checkpoint thread.
		}
		else
		{
			// if disabling, wake up an in-progress thread so it can quit
			if( odbc->auto_checkpoint_thread )
			{
				WakeThread( odbc->auto_checkpoint_thread );
			}
		}
	}
}
LOGICAL GetSQLAutoCheckpoint( PODBC odbc )
{
	if( odbc )
		return odbc->flags.bAutoCheckpoint;
	return 0;
}
LOGICAL EnsureLogOpen( PODBC odbc )
{
	if( odbc && odbc->flags.bNoLogging )
		return FALSE;
	if( g.flags.bLogging )
	{
		if( !g.pSQLLog )
		{
			TEXTCHAR logname[64];
			int attempt = 0;
			do
			{
				// this should be an option...
				if( attempt )
					tnprintf( logname, sizeof( logname ), WIDE( "sql%d.log" ), attempt );
				else
					StrCpyEx( logname, WIDE("sql.log"), sizeof( logname ) );
				attempt++;
				// this is going to be more hassle to conserve
				// than benefit merits.
				g.pSQLLog = sack_fopen( 0, logname, WIDE("at+") );
				if( !g.pSQLLog )
					g.pSQLLog = sack_fopen( 0, logname, WIDE("wt") );
			}
			while( !g.pSQLLog );
		}
		return TRUE;
	}
	return FALSE;
}
void SqlStubInitLibrary( void )
{
	if( !g.flags.bCriticalSectionInited )
	{
		InitializeCriticalSec( &g.Init );
		g.flags.bCriticalSectionInited = 1;
	}
	EnterCriticalSec( &g.Init );
	if( !g.flags.bInited )
	{
		// since they will never have priors, they will
		// never get deleted....as only those with priors
		// deleted when popped.
		if( g.feedback_handler ) g.feedback_handler( WIDE("Loading ODBC") );
		//CreateCollector( 0, &g.Primary, FALSE );
		//CreateCollector( 0, &g.Backup, FALSE );
#ifdef __ANDROID__
		g.OptionDb.info.pDSN = StrDup( WIDE( "./option.db" ) );
#else
#   ifdef __LINUX__
		g.OptionDb.info.pDSN = StrDup( WIDE( "~/.option.db" ) );
#   else
		g.OptionDb.info.pDSN = StrDup( WIDE( "*/../option.db" ) );
#   endif
#endif
		// default to new option database.
#ifndef __NO_OPTIONS__
		//SetOptionDatabaseOption( &g.OptionDb, TRUE );
#endif
		  g.flags.bAutoCheckpoint = 1;
		{
			LOGICAL success = FALSE;
			PCONFIG_HANDLER pch = CreateConfigurationHandler();
			AddConfigurationMethod( pch, WIDE("Auto Checkpoint=%b"), SetAutoCheckpoint );
			AddConfigurationMethod( pch, WIDE("Option DSN=%m"), SetOptionDSN );
			AddConfigurationMethod( pch, WIDE("Primary DSN=%m"), SetPrimaryDSN );
			AddConfigurationMethod( pch, WIDE("Primary User=%m"), SetUser );
			AddConfigurationMethod( pch, WIDE("Primary Connection String=%m"), SetConnString );
			AddConfigurationMethod( pch, WIDE("Primary Password=%m"), SetPassword );
			AddConfigurationMethod( pch, WIDE("Backup DSN=%m"), SetBackupDSN );
			AddConfigurationMethod( pch, WIDE("Backup User=%m"), SetBackupUser );
			AddConfigurationMethod( pch, WIDE("Backup Password=%m"), SetBackupPassword );
			AddConfigurationMethod( pch, WIDE("Log enable=%b"), SetLoggingEnabled );
			AddConfigurationMethod( pch, WIDE("LogFile enable=%b"), SetLoggingEnabled2 );
			AddConfigurationMethod( pch, WIDE("LogFile enable dump data=%b"), SetLoggingEnabled3 );
			AddConfigurationMethod( pch, WIDE("Log Option Connection=%b"), SetLogOptions );
			AddConfigurationMethod( pch, WIDE("Fallback on failure=%b"), SetFallback );
			AddConfigurationMethod( pch, WIDE("Require Connection=%b"), SetRequireConnection );
			AddConfigurationMethod( pch, WIDE("Require Primary Connection=%b"), SetRequirePrimaryConnection );
			AddConfigurationMethod( pch, WIDE("Require Backup Connection=%b"), SetRequireBackupConnection );
			AddConfigurationMethod( pch, WIDE("Database Init SQL=%m"), AddDatabaseInit );
			AddConfigurationMethod( pch, WIDE("Option Database Init SQL=%m"), AddOptionDatabaseInit );
			// If source is encrypted enable tranlation
			//AddConfigurationFilter( pch, TranslateCrypt );
			{
				TEXTCHAR tmp[256];
				tnprintf( tmp, 256, WIDE("%s.sql.config"), GetProgramName() );
				success = ProcessConfigurationFile( pch, tmp, 0 );
			}
			if( !success && !ProcessConfigurationFile( pch, WIDE("sql.config"), 0 ) )
			{
				FILE *file;
				file = sack_fopen( 1
					, WIDE("*/sql.config")
					, WIDE("wt")
#ifdef _UNICODE
					WIDE(", ccs=UNICODE")
#endif
					);
				if( file )
				{
					sack_fprintf( file, "Auto Checkpoint=No\n" );
					sack_fprintf( file, "Option DSN=%s\n", g.OptionDb.info.pDSN );
					sack_fprintf( file, "Primary DSN=MySQL\n" );
					sack_fprintf( file, "#Primary User=\n" );
					sack_fprintf( file, "#Primary Password=\n" );
					sack_fprintf( file, "Backup DSN=MySQL2\n" );
					sack_fprintf( file, "#Backup User=\n" );
					sack_fprintf( file, "#Backup Password=\n" );
					sack_fprintf( file, "Log enable=No\n"  );
					sack_fprintf( file, "LogFile enable=No\n"  );
					sack_fprintf( file, "LogFile enable dump data=No\n"  );
					sack_fprintf( file, "Log Option Connection=No\n"  );
					sack_fprintf( file, "Fallback on failure=No\n" );
					sack_fprintf( file, "Require Connection=No\n" );
					sack_fprintf( file, "Require Primary Connection=Yes\n" );
					sack_fprintf( file, "Require Backup Connection=No\n" );
					sack_fprintf( file, "Database Init SQL=\n" );
					sack_fprintf( file, "Option Database Init SQL=\n" );
					sack_fclose( file );
				}
				ProcessConfigurationFile( pch, WIDE("sql.config"), 0 );
			}
			DestroyConfigurationEvaluator( pch );
		}
		if( !g.Backup.info.pDSN || !g.Backup.info.pDSN[0] )
		{
			g.flags.bNoBackup = 1;
		}
		// allow log to be delayed opened only when something needs to be written the first time.
		g.TimerCollect.pvt_out = VarTextCreate();
		g.TimerCollect.pvt_result = VarTextCreate();
		g.TimerCollect.pvt_errorinfo = VarTextCreate();
		g.flags.bInited = TRUE;
		if( g.feedback_handler ) g.feedback_handler( WIDE("SQL Connecting...") );
	}
	LeaveCriticalSec( &g.Init );
}
#if 0
#undef EnterCriticalSec
#undef LeaveCriticalSec
#define EnterCriticalSec(a) lprintf( "Enter section %p %d", a, odbc->nProtect ); EnterCriticalSection( a ); lprintf( "In Section %p %d", a, odbc->nProtect );
#define LeaveCriticalSec(a) lprintf( "Leave section %p %d", a, odbc->nProtect ); LeaveCriticalSection( a ); lprintf( "Out Section %p %d", a, odbc->nProtect );
#endif
//-----------------------------------------------------------------------
 // expose this so dump info doesn't open on failed open.
static int bOpening;
PRIORITY_PRELOAD( FinalDeadstart, SYSLOG_PRELOAD_PRIORITY + 1 )
{
	g.flags.bDeadstartCompleted = 1;
}
void ParseDSN( CTEXTSTR dsn, char **vfs, char **vfsInfo, char **dbFile ) {
	static TEXTCHAR *tmpvfsvfs;
	static TEXTCHAR *tmp_name;
	static char *tmp;
	if( tmpvfsvfs ) { Release( tmpvfsvfs ); tmpvfsvfs = NULL; }
	if( tmp_name ) { Release( tmp_name ); tmp_name = NULL; }
	if( tmp ) { Release( tmp ); tmp = NULL; }
	if( dsn[0] == '$' ) {
		char *vfs_name;
		CTEXTSTR vfs_end = StrChr( dsn + 1, '@' );
		CTEXTSTR vfs_vfs_end = StrRChr( vfs_end ? vfs_end : (dsn + 1), '$' );
		TEXTCHAR *tmpvfs;
		if( vfs_vfs_end ) {
			tmp_name = ExpandPath( vfs_vfs_end + 1 );
			if( vfs_end && vfs_end < vfs_vfs_end ) {
				tmpvfs = NewArray( TEXTCHAR, (vfs_end - dsn) + 1 );
				tmpvfsvfs = NewArray( TEXTCHAR, (vfs_vfs_end - vfs_end) + 1 );
				StrCpyEx( tmpvfs, dsn + 1, vfs_end - dsn );
				StrCpyEx( tmpvfsvfs, dsn + 1, vfs_vfs_end - vfs_end );
				vfs_name = NewArray( TEXTCHAR, vfs_vfs_end - dsn );
				StrCpyEx( vfs_name, dsn + 1, vfs_vfs_end - dsn );
				StrCpyEx( tmpvfsvfs, vfs_end + 1, vfs_vfs_end - vfs_end );
			}
			else {
				tmpvfsvfs = NULL;
				tmpvfs = NewArray( TEXTCHAR, (vfs_vfs_end - dsn) + 1 );
				StrCpyEx( tmpvfs, dsn + 1, vfs_vfs_end - dsn );
				vfs_name = CStrDup( tmpvfs );
			}
			Deallocate( TEXTCHAR*, tmpvfs );
		}
		else {
			tmp_name = ExpandPath( dsn + 1 );
			vfs_name = NULL;
			tmpvfsvfs = NULL;
		}
		tmp = CStrDup( tmp_name );
		(*vfs) = vfs_name;
		(*vfsInfo) = tmpvfsvfs;
		(*dbFile) = tmp;
		Deallocate( TEXTCHAR *, tmp_name );
		tmp_name = NULL;
	}
	else {
		if( StrCaseCmpEx( dsn, "file:", 5 ) == 0
			|| StrCaseCmpEx( dsn, ":memory:", 8 ) == 0 ) {
			//lprintf( "open:%s", dsn );
			(*vfs) = NULL;
			(*vfsInfo) = NULL;
			(*dbFile) =(char*) dsn;
		}
		else {
			tmp_name = ExpandPath( dsn );
			tmp = CStrDup( tmp_name );
			(*vfs) = NULL;
			(*vfsInfo) = NULL;
			(*dbFile) = tmp;
			Deallocate( TEXTCHAR *, tmp_name );
			tmp_name = NULL;
		}
	}
}
int OpenSQLConnectionEx( PODBC odbc DBG_PASS )
{
	int state = 0;
#ifdef USE_ODBC
	RETCODE rc;
	PTEXT pConnect;
#endif
	if( !odbc->info.pDSN )
	{
		return FALSE;
	}
	if( odbc->flags.bConnected )
	{
		return TRUE;
	}
#ifdef SQLPROXY_LIBRARY_SOURCE
	SqlStubInitLibrary();
#endif
	bOpening = TRUE;
	if( StrStr( odbc->info.pDSN, WIDE(".db") ) || ( StrCmp( odbc->info.pDSN, ":memory:" ) == 0 ) )
		odbc->flags.bSkipODBC = 1;
	else
 // make sure it's set to something...
		odbc->flags.bSkipODBC = 0;
	/*
	 * should fix this someday to check just .mdb files...
	 if( strstr( odbc->info.pDSN, ".mdb" ) )
	 ;
	 */
#if defined( USE_ODBC ) || defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	do
	{
		if( g.flags.bDeadstartCompleted )
		{
			TEXTCHAR msg[80];
			tnprintf( msg, sizeof( msg )/sizeof(TEXTCHAR), WIDE( "Connecting to [%s]%*.*s" ), odbc->info.pDSN, 3+state, 3+state,WIDE( "........." ) );
 // stupid tnprintf, this is going to SUCK.  What the hell microsoft?!
			msg[79] = 0;
			if( g.feedback_handler )
			{
				//_lprintf(DBG_VOIDRELAY)( WIDE( "%s" ), msg );
				g.feedback_handler( msg );
			}
			state++;
			if( state == 5 )
				state = 0;
		}
#ifdef USE_ODBC
		if( !odbc->env && !odbc->flags.bSkipODBC )
		{
#ifdef LOG_EVERYTHING
			lprintf( WIDE("get env") );
#endif
			rc = SQLAllocEnv( &odbc->env );
			if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
			{
				bOpening = FALSE;
				lprintf( WIDE("Fatal error, Could not allocate SQL resource.") );
				exit(1);
				return FALSE;
			}
#ifdef LOG_EVERYTHING
			lprintf( WIDE( "%p new ENV rc %d = %p" ), odbc, rc, odbc->env );
#endif
		}
		if( !odbc->hdbc && !odbc->flags.bSkipODBC )
		{
#ifdef LOG_EVERYTHING
			lprintf( WIDE("get hdbc") );
#endif
			if( rc = SQLAllocConnect( odbc->env,
									  &odbc->hdbc ) )
			{
				lprintf( WIDE("Fatal error, Could not allocate SQL resource.") );
				SQLFreeEnv( odbc->env );
				odbc->env = 0;
				bOpening = FALSE;
				return FALSE;
			}
#ifdef LOG_EVERYTHING
			lprintf( WIDE( "%p new HDBC rc %d = %p" ), odbc, rc, odbc->hdbc );
#endif
		}
		//lprintf( WIDE("connect...%d"), odbc->flags.bConnected );
		if( !odbc->flags.bConnected && !odbc->flags.bSkipODBC )
		{
			int variation;
			PVARTEXT pvt = VarTextCreate();
#ifdef LOG_EVERYTHING
			lprintf( WIDE("Begin ODBC Driver Connect... (may take a LONG time.)") );
#endif
			for( variation = 0; variation < 3; variation++ )
			{
				VarTextEmpty( pvt );
				if( variation == 0 && odbc->info.pConnString[0] == 0 )
					vtprintf( pvt
							  , WIDE("DSN=%s%s%s%s%s")
							  , odbc->info.pDSN
							  , odbc->info.pID[0]?WIDE(";UID="):WIDE("")
							  , odbc->info.pID[0]?odbc->info.pID:WIDE("")
							  , odbc->info.pPASSWORD[0]?WIDE(";PWD="):WIDE("")
							  , odbc->info.pPASSWORD[0]?odbc->info.pPASSWORD:WIDE("")
							  );
				else if( variation == 1 )
					vtprintf( pvt
							  , WIDE("DSN=%s%s%s%s%s%s%s")
							  , odbc->info.pDSN
							  , odbc->info.pConnString[0]?WIDE(";DBQ="):WIDE("")
							  , odbc->info.pConnString[0]?odbc->info.pConnString:WIDE("")
							  , odbc->info.pID[0]?WIDE(";UID="):WIDE("")
							  , odbc->info.pID[0]?odbc->info.pID:WIDE("")
							  , odbc->info.pPASSWORD[0]?WIDE(";PWD="):WIDE("")
							  , odbc->info.pPASSWORD[0]?odbc->info.pPASSWORD:WIDE("")
							  );
				else if( variation == 2 )
					vtprintf( pvt
							  , WIDE("DRIVER=Microsoft Access Driver (*.mdb); UID=admin; UserCommitSync=Yes; Threads=30; SafeTransactions=0; PageTimeout=5; MaxScanRows=8; MaxBufferSize=2048; FIL=MS Access; DriverId=25; DefaultDir=.; DBQ=%s; ")
							  , odbc->info.pDSN
								//, odbc->info.pID[0]?WIDE(";UID="):WIDE("")
								//, odbc->info.pID[0]?odbc->info.pID:WIDE("")
								//, odbc->info.pPASSWORD[0]?WIDE(";PWD="):WIDE("")
								//, odbc->info.pPASSWORD[0]?odbc->info.pPASSWORD:WIDE("")
							  );
				else
					continue;
				pConnect = VarTextGet( pvt );
				if( g.flags.bDeadstartCompleted && (!g.flags.bNoLog) && (~odbc->flags.bNoLogging) )
					_lprintf(DBG_RELAY)( WIDE("Begin ODBC Driver Connect to [%s]"), GetText(pConnect) );
				rc = SQLDriverConnect( odbc->hdbc
 // window handle - do not show dialogs
											, NULL
											,
#ifdef _UNICODE
											 (SQLWCHAR*)GetText( pConnect )
#else
											 (SQLCHAR*)GetText( pConnect )
#endif
											, (SQLSMALLINT)GetTextSize( pConnect )
											, NULL
											, 0
											, NULL
											, SQL_DRIVER_NOPROMPT );
#ifdef LOG_EVERYTHING
				lprintf( WIDE("How long was that?") );
#endif
				LineRelease( pConnect );
				lprintf( WIDE("rc == %d"), rc );
				if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
				{
					//PTEXT result;
					if( !odbc->info.pID[0] && !odbc->info.pPASSWORD[0] )
					{
						odbc->info.flags.bAutoUser = 1;
						// can set odbc->info.pID == USER_TEXT_NAME
						// and odbc->info->pPASSWORD == USER_PASSWORD
						// however, this implementatino trusts implicitly the odbc connection
						// to grant my permissions.
					}
					else
					{
						if( odbc->info.flags.bAutoUser )
						{
							// reset this back to initial conditions, so
							// we rotate to default and retry with user/password.
							odbc->info.pID[0] = 0;
							odbc->info.pPASSWORD[0] = 0;
						}
					}
					DumpInfoEx( odbc, pvt, SQL_HANDLE_DBC, &odbc->hdbc, odbc->flags.bNoLogging DBG_RELAY );
				}
				else
				{
					// hmm something odd here looks like
					// someone suspects that update tasks (while processing)
					// may result with a different primary odbc than they were
					// processing?!
					PODBC SaveOdbc = g.odbc;
					g.odbc = odbc;
					{
						TEXTCHAR buffer[256];
						SQLSMALLINT reslen;
						SQLGetInfo( odbc->hdbc, SQL_DRIVER_NAME, buffer, (SQLSMALLINT)sizeof( buffer ), &reslen );
						if( g.flags.bDeadstartCompleted && (!g.flags.bNoLog) && (~odbc->flags.bNoLogging) )
							lprintf( WIDE("Driver name = %s"), buffer );
						if( strcmp( buffer, WIDE("odbcjt32.dll") ) == 0 )
							odbc->flags.bAccess = 1;
						if( strcmp( buffer, WIDE("sqlite3odbc.dll") ) == 0 || strcmp( buffer, WIDE("sqliteodbc.dll") ) == 0 ) {
							odbc->flags.bSQLite = 1;
						}
						if( !odbc->flags.bSQLite )
							odbc->flags.bAutoCheckpoint = 0;
						SQLGetInfo( odbc->hdbc, SQL_DRIVER_ODBC_VER, buffer, (SQLSMALLINT)sizeof( buffer ), &reslen );
#ifdef LOG_EVERYTHING
						lprintf( WIDE("Driver name = %s"), buffer );
#endif
						SQLGetInfo( odbc->hdbc, SQL_DRIVER_VER, buffer, (SQLSMALLINT)sizeof( buffer ), &reslen );
#ifdef LOG_EVERYTHING
						lprintf( WIDE("Driver name = %s"), buffer );
#endif
						if( StrCaseCmp( buffer, WIDE("05.01.0005") ) == 0 )
						{
							odbc->flags.bFailEnvOnDbcFail = 1;
						}
					}
					odbc->flags.bConnected = TRUE;
					odbc->flags.bODBC = TRUE;
					if( odbc->flags.bAutoClose )
					{
						if( !odbc->auto_close_thread )
							odbc->auto_close_thread = ThreadTo( AutoCloseThread, (uintptr_t)odbc );
					}
					VarTextDestroy( &pvt );
					{
						PUPDATE_TASK task;
						for( task = g.UpdateTasks; task; task = task->next )
						{
							if( task->CheckTables )
							{
								Log( WIDE("invoking plugin to check tables...") );
								task->CheckTables( odbc );
							}
						}
					}
					g.odbc = SaveOdbc;
					bOpening = FALSE;
					if( g.feedback_handler ) g.feedback_handler( WIDE("SQL Connect OK") );
					VarTextDestroy( &pvt );
					return TRUE;
				}
			}
			VarTextDestroy( &pvt );
		}
#endif
		if( !odbc->flags.bConnected &&
			( g.flags.bFallback || odbc->flags.bSkipODBC ) )
		{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
			int rc3;
#ifndef USE_ODBC
			//lprintf( "ODBC not compiled, attempting to use SQLITE which is enabled..." );
#else
			//lprintf( "ODBC Failed, attempting to use SQLITE which is enabled..." );
#endif
			// suffix of dsn was not '.db'
			// and - we REQUIRE connection...
			if( !( odbc->flags.bForceConnection && !odbc->flags.bSkipODBC ) )
			{
				char *tmp;
				char *vfs_name;
				TEXTCHAR *tmpvfsvfs;
				ParseDSN( odbc->info.pDSN, &vfs_name, &tmpvfsvfs, &tmp );
				if( vfs_name )
				//if( odbc->info.pDSN[0] == '$' )
				{
					if( vfs_name )
					{
#ifdef USE_SQLITE_INTERFACE
#  ifdef UNICODE
						TEXTCHAR *_vfs_name = DupCStr( vfs_name );
						char *_tmpvfsvfs = CStrDup( tmpvfsvfs );
#    define vfs_name _vfs_name
#    define tmpvfsvfs _tmpvfsvfs
#  endif
						sqlite_iface->InitVFS( vfs_name, sack_get_mounted_filesystem( tmpvfsvfs ) );
#  ifdef UNICODE
						Deallocate( TEXTCHAR *,_vfs_name );
						Deallocate( char *, _tmpvfsvfs );
#    undef vfs_name
#    undef tmpvfsvsf
#  endif
#endif
					}
					rc3 = sqlite3_open_v2( tmp, &odbc->db, SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_URI, vfs_name );
				}
				else
				{
					if( StrCaseCmpEx( odbc->info.pDSN, "file:", 5 ) == 0
						|| StrCaseCmpEx( odbc->info.pDSN, ":memory:", 8 ) == 0 ) {
						//lprintf( "open:%s", odbc->info.pDSN );
						rc3 = sqlite3_open_v2( odbc->info.pDSN, &odbc->db, SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_URI, NULL );
					}
					else {
						rc3 = sqlite3_open( tmp, &odbc->db );
					}
				}
				if( rc3 )
				{
					lprintf( WIDE("Failed to connect[%s]: %s")
							 , odbc->info.pDSN
							 , sqlite3_errmsg(odbc->db) );
				}
				else
				{
					//lprintf( "Success using SQLITE" );
					// register some new handlers like now()
					odbc->flags.bConnected = TRUE;
					odbc->flags.bSQLite_native = 1;
					ExtendConnection( odbc );
				}
			}
#endif
		}
		if( !odbc->flags.bConnected )
		{
			// finally, should we retry if it's failed to gain connect?
			if( odbc->flags.bForceConnection )
 // wait a second, then retry...
				WakeableSleep( 1000 );
			else
			{
				bOpening = FALSE;
				return FALSE;
			}
		}
	}
	while( odbc->flags.bForceConnection && !odbc->flags.bConnected );
#else
	 bOpening = FALSE;
	// already open, and all is good...
	return FALSE;
#endif
	 bOpening = FALSE;
	// already open, and all is good...
	return TRUE;
}
#undef OpenSQLConnection
int OpenSQLConnection( PODBC odbc )
{
	return OpenSQLConnectionEx( odbc DBG_SRC );
}
//----------------------------------------------------------------------
void SQLCommit( PODBC odbc )
{
	// someone might not want it now, but we already started a thread for it....
	//if( odbc->flags.bAutoTransact )
	{
		if( odbc->flags.bThreadProtect )
		{
			EnterCriticalSec( &odbc->cs );
			odbc->nProtect++;
		}
		// we will own the odbc here, so the timer will either block, or
		// have completed, releasing this.
		// maybe we don't have a pending commit.... (wouldn't if the timer hit just before we ran)
 // otherwise we won't need a commit
		if( odbc->last_command_tick )
		{
			int n = odbc->flags.bAutoTransact;
			odbc->last_command_tick = 0;
			if( odbc->auto_commit_thread )
			{
				uint32_t start = timeGetTime();
				WakeThread( odbc->auto_commit_thread );
				while( odbc->auto_commit_thread && ( ( start + 500 )> timeGetTime() ) )
					Relinquish();
				if( odbc->auto_commit_thread )
					lprintf( WIDE( "Auto commit thread stalled." ) );
			}
			// need to end the thread here too....
			odbc->flags.bAutoTransact = 0;
			// the commit command itself will cause SQLCommit to be called - so we turn off autotransact and would create a transaction thread etc...
			SQLCommand( odbc, WIDE( "COMMIT" ) );
			odbc->flags.bAutoTransact = n;
			if( odbc->auto_commit_callback )
				odbc->auto_commit_callback( odbc->auto_commit_callback_psv, odbc );
		}
		if( odbc->flags.bThreadProtect )
		{
			odbc->nProtect--;
			LeaveCriticalSec( &odbc->cs );
		}
	}
}
//----------------------------------------------------------------------
// had to create this thread - stalling out in the timer thread prevents
// all further commit action (which may unlock the Sqlite database this is
// intended for.
uintptr_t CPROC AutoCloseThread( PTHREAD thread )
{
	uintptr_t psv = GetThreadParam( thread );
	PODBC odbc = (PODBC)psv;
	int tick = 0;
	// initialize this to something; this is called when a connection opens...
	// so that makes the first operation the database open tick.
	odbc->last_command_tick_ = timeGetTime();
	while( odbc->flags.bAutoClose )
	{
		// if it expires, set tick and get out of loop
		// clearing last_command_tick will also end the thread (a manual sqlcommit on the connection)
 // let commits finish first...
		if( !odbc->auto_commit_thread
		  &&( odbc->last_command_tick_ < ( timeGetTime() - 1000 ) )
		  // is idle; no statements active in the collections on the connection
		  && IsOdbcIdle( odbc ) )
		{
			// make sure we still need to close (modeled more after commit; this could be less paranoid)
			if( ( !odbc->flags.bAutoClose )
			// and then claim the thread protection to prevent more statements from starting while we close this
			  || (( odbc->flags.bThreadProtect )?EnterCriticalSecNoWait( &odbc->cs, NULL ):1) )
			{
				tick = 1;
				break;
			}
		}
		WakeableSleep( 250 );
	}
	// a SQLCommit may have happened outside of this, which cleas last_command_tick
	if( tick && odbc->flags.bAutoClose )
	{
		// this will close any in progress result sets... still need a check
		CloseDatabaseEx( odbc, FALSE );
		// release our lock allowing any statement that started JUST as this ticked to resume.
		if( odbc->flags.bThreadProtect )
			LeaveCriticalSec( &odbc->cs );
	}
	odbc->auto_close_thread = NULL;
	return 0;
}
//----------------------------------------------------------------------
// had to create this thread - stalling out in the timer thread prevents
// all further commit action (which may unlock the Sqlite database this is
// intended for.
uintptr_t CPROC AutoCheckpointThread( PTHREAD thread )
{
	uintptr_t psv = GetThreadParam( thread );
	PODBC odbc = (PODBC)psv;
	int tick = 0;
	// initialize this to something; this is called when a connection opens...
	// so that makes the first operation the database open tick.
	odbc->last_command_tick_ = timeGetTime();
	while( odbc->flags.bAutoCheckpoint )
	{
		// if it expires, set tick and get out of loop
		// clearing last_command_tick will also end the thread (a manual sqlcommit on the connection)
 // let commits finish first...
		if( !odbc->auto_commit_thread
		  &&( odbc->last_command_tick_ < ( timeGetTime() - 250 ) )
		  // is idle; no statements active in the collections on the connection
		  && IsOdbcIdle( odbc ) )
		{
			tick = 1;
			break;
		}
		WakeableSleep( 125 );
	}
	// a SQLCommit may have happened outside of this, which cleas last_command_tick
	if( tick && odbc->flags.bAutoCheckpoint )
	{
		int oldCommit = odbc->flags.bAutoTransact;
		int oldCheckpoint = odbc->flags.bAutoCheckpoint;
		if( odbc->flags.bThreadProtect )
			EnterCriticalSec( &odbc->cs );
		odbc->flags.bAutoTransact = 0;
		odbc->flags.bAutoCheckpoint = 0;
		// this will checkpoint any in progress result sets... still need a check
		SQLCommand( odbc, WIDE( "PRAGMA wal_checkpoint" ) );
		odbc->flags.bAutoTransact = oldCommit;
		odbc->flags.bAutoCheckpoint = oldCheckpoint;
		// release our lock allowing any statement that started JUST as this ticked to resume.
		odbc->auto_checkpoint_thread = NULL;
		if( odbc->flags.bThreadProtect )
			LeaveCriticalSec( &odbc->cs );
// redundant; because I want to claer this before unlocking the connection
	}
	odbc->auto_checkpoint_thread = NULL;
	return 0;
}
//----------------------------------------------------------------------
// had to create this thread - stalling out in the timer thread prevents
// all further commit action (which may unlock the Sqlite database this is
// intended for.
static uintptr_t CPROC CommitThread( PTHREAD thread )
{
	uintptr_t psv = GetThreadParam( thread );
	PODBC odbc = (PODBC)psv;
	int tick = 0;
	//lprintf( WIDE( "begin..." ) );
	while( odbc->last_command_tick )
	{
		//lprintf( WIDE( "waiting..." ) );
		// if it expires, set tick and get out of loop
		// clearing last_command_tick will also end the thread (a manual sqlcommit on the connection)
		if( odbc->last_command_tick < ( timeGetTime() - 500 ) )
		{
			if( ( !odbc->flags.bThreadProtect )
				|| EnterCriticalSecNoWait( &odbc->cs, NULL ) )
			{
				//lprintf( WIDE( "tick and out " ));
				tick = 1;
				break;
			}
		}
		WakeableSleep( 250 );
	}
	// a SQLCommit may have happened outside of this, which cleas last_command_tick
	if( odbc->last_command_tick && tick )
	{
		odbc->auto_commit_thread = NULL;
		SQLCommit( odbc );
		if( odbc->flags.bThreadProtect )
			LeaveCriticalSec( &odbc->cs );
	}
	else
	{
		odbc->auto_commit_thread = NULL;
	}
	return 0;
}
//----------------------------------------------------------------------
static void BeginTransactEx( PODBC odbc, int force )
{
	// I Only test this for SQLITE, specifically the optiondb.
	// this transaction phrase is not really as important on server based systems.
	//lprintf( WIDE( "BeginTransact." ) );
	if( !odbc )
		odbc = g.odbc;
	if( !odbc )
		return;
	if( odbc->flags.bAutoTransact || force )
	{
		uint32_t newtick = timeGetTime();
		//lprintf( WIDE( "Allowed. %lu" ), odbc->last_command_tick );
		// again with the tricky expressions....
		// if there is a last tick, then we don't do anything, and fail the expression
		//    okay if there IS a tick, then the OR is triggered, which sets the time, and it will be non zero,
		//    so that will fail the IF, but set the time.
		// if there is NOT a last command tick, then we add the timer
		odbc->last_command_tick_ = newtick;
		if( force || !odbc->last_command_tick )
		{
			int prior;
			odbc->last_command_tick = newtick;
			if( !force && !odbc->auto_commit_thread )
			{
				odbc->auto_commit_thread = ThreadTo( CommitThread, (uintptr_t)odbc );
			}
			prior = odbc->flags.bAutoTransact;
			odbc->flags.bAutoTransact = 0;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
			if( odbc->flags.bSQLite_native )
			{
				SQLCommand( odbc, WIDE( "BEGIN TRANSACTION" ) );
			}
			else
#endif
				if( odbc->flags.bAccess )
				{
					lprintf( "Unhandled; access driver, begintransaction..." );
			}
			else
			{
				SQLCommand( odbc, WIDE( "START TRANSACTION" ) );
			}
			odbc->flags.bAutoTransact = prior;
		}
 // update the tick.
		else
			odbc->last_command_tick = newtick;
		//lprintf( WIDE( "%p gets %lu" ), odbc, odbc->last_command_tick );
	}
	//else
	//   lprintf( WIDE( "No auto transact here." ) );
}
//----------------------------------------------------------------------
void SQLBeginTransact( PODBC odbc ) {
	BeginTransactEx( odbc, 1 );
}
//----------------------------------------------------------------------
void DispatchPriorRequests( PODBC odbc )
{
	PCOLLECT collection, next;
	if( !odbc )
	{
		collection = g.collections;
	}
	else
	{
		collection = odbc->collection;
	}
	while( collection )
	{
		// can now associate with this...
		//if( collection->odbc = g.odbc )
		if( !odbc )
		{
			if( !g.odbc )
			{
				collection->odbc = g.odbc;
				UnlinkThing( collection );
				lprintf( WIDE("Adding %p to %p at %p"), collection, odbc, &odbc->collection );
				LinkThing( odbc->collection, collection );
			}
			else
			{
				// didn't open? yet you're calling me?!" );
				return;
			}
		}
		{
			Log( WIDE("Dispach prior reqeust...") );
			next = collection->next;
			switch( collection->lastop )
			{
			case LAST_COMMAND:
				Log( WIDE("Dispach prior COMMAND") );
				__DoSQLCommand( g.odbc, collection );
				break;
			case LAST_QUERY:
				Log( WIDE("Dispach prior QUERY") );
				{
					PTEXT tmp = VarTextPeek( collection->pvt_out );
					__DoSQLQuery( g.odbc, collection, GetText( tmp ) );
					if( collection->lastop != LAST_QUERY )
					{
					// if the command is now completed... (no longer a query)
						VarTextEmpty( collection->pvt_out );
					}
				}
				break;
			case LAST_RESULT:
				Log( WIDE("Dispach prior RESULT") );
				__GetSQLResult( g.odbc, collection, TRUE );
				break;
			}
			collection = next;
		}
	}
}
//-----------------------------------------------------------------------
void GenerateResponce( PCOLLECT collection, int responce )
{
	collection->responce = responce;
#ifdef SQL_PROXY_SERVER
	//lprintf( WIDE("Generate responce.... %d"), collection->SourceID );
	// otherwise it's locally created...
	if( collection && collection->SourceID )
	{
		int first = 1;
		PTEXT cmd;
		TEXTSTR outdata;
		int len;
		if( collection->flags.bBuildResultArray )
		{
			BUFFER_LENGTH_PAIR *pairs;
			BUFFER_LENGTH_PAIR *tmp_pairs;
			INDEX idx;
			if( collection->columns )
			{
				pairs = (BUFFER_LENGTH_PAIR*)Allocate( sizeof( BUFFER_LENGTH_PAIR ) * 2 * collection->columns + 1);
				pairs[0].len = sizeof( collection->columns );
				pairs[0].buffer = &collection->columns;
				tmp_pairs = pairs + 1;
				for( idx = 0; idx < collection->columns; idx++ )
				{
					tmp_pairs[idx].len = strlen( collection->results[idx] ) + 1;
					tmp_pairs[idx].buffer = (POINTER)collection->results[idx];
				}
				tmp_pairs = pairs + 1 + collection->columns;;
				for( idx = 0; idx < collection->columns; idx++ )
				{
					tmp_pairs[idx].len = strlen( collection->fields[idx] ) + 1;
					tmp_pairs[idx].buffer = (POINTER)collection->fields[idx];
				}
				SendMultiServiceEventPairs( collection->SourceID, responce, collection->columns * 2 + 1, pairs );
			}
			else
			{
				SendMultiServiceEventPairs( collection->SourceID, responce, 0, NULL );
			}
		}
		else
		{
			PTEXT cmd;
			if( responce == WM_SQL_RESULT_ERROR )
				cmd = VarTextPeek( collection->pvt_errorinfo );
			else
				cmd = VarTextPeek( collection->pvt_result );
			outdata = GetText( cmd );
			len = GetTextSize( cmd ) + 1;
			// lie for now... so we don't have to change 16 bit client yet.
			if( responce == WM_SQL_RESULT_NO_DATA )
				responce = WM_SQL_RESULT_DATA;
			lprintf( WIDE("Responce: %d %s"), responce, outdata );
			while( len > 4096 )
			{
				//MemCpy( collection->result, strlen( ofs ) );
				if( first )
					SendServiceEvent( collection->SourceID, WM_SQL_DATA_START, outdata, 4096 );
				//PostMessage( collection->hWnd, WM_SQL_DATA_START, (WPARAM)hWnd, (LPARAM)outatom );
				else
					SendServiceEvent( collection->SourceID, WM_SQL_DATA_MORE, outdata, 4096 );
				//PostMessage( collection->hWnd, WM_SQL_DATA_MORE, (WPARAM)hWnd, (LPARAM)outatom );
				outdata += 4096;
				len -= 4096;
			}
			//PostMessage( collection->hWnd, responce, (WPARAM)hWnd, (LPARAM)outatom );
			SendServiceEvent( collection->SourceID, responce, outdata, len );
			// has been sent, can be released.
			LineRelease( cmd );
		}
	}
#endif
}
//-----------------------------------------------------------------------
int OpenSQL( DBG_VOIDPASS )
{
	static uint32_t _bOpening;
	int bPrimaryComingUp = FALSE;
	int bBackupComingUp = FALSE;
	while( LockedExchange( &_bOpening, 1 ) )
	{
		lprintf( WIDE("Stacked waits here will be very very bad...") );
		lprintf( WIDE("Already attepting to open... hold on... we're trying ...") );
		IdleFor( 250 );
		//return -1; // better to continue (cause test is if !OpenSQL()) than return false false
	}
	if( !g.flags.bPrimaryUp && !g.flags.bBackupUp )
	{
		// had some sort of logging here...
	}
	if( !g.flags.bPrimaryUp )
	{
		//if(  g.PrimaryLastConnect < timeGetTime()
		//	&& ( g.PrimaryLastConnect = timeGetTime() + 1000 ) )
		{
#ifdef LOG_ACTUAL_CONNECTION
			lprintf( "Begin connection gPrimary=%d", g.Primary.flags.bConnected );
#endif
			if( OpenSQLConnectionEx( &g.Primary DBG_RELAY ) )
				if( !g.flags.bPrimaryUp )
					bPrimaryComingUp = TRUE;
#ifdef LOG_ACTUAL_CONNECTION
			lprintf( "after connection gPrimary=%d", g.Primary.flags.bConnected );
#endif
		}
	}
#ifdef LOG_ACTUAL_CONNECTION
	else
		lprintf( "primary up..." );
#endif
	if( !g.flags.bNoBackup
		&&(  !g.flags.bBackupUp ) )
	{
		//if ( g.BackupLastConnect < timeGetTime()
		//	&& ( g.BackupLastConnect = timeGetTime() + 1000 ) )
		{
#ifdef LOG_ACTUAL_CONNECTION
			lprintf( "Begin connection &gBackup=%p", g.Backup );
#endif
			if( OpenSQLConnectionEx( &g.Backup DBG_RELAY ) )
			{
				if( !g.flags.bBackupUp )
					bBackupComingUp = TRUE;
			}
			else
			{
				if( g.feedback_handler )
					g.feedback_handler( WIDE("Disabling backup - stop retrying.") );
				else
					lprintf( WIDE("Disabling backup - stop retrying.") );
				g.flags.bNoBackup = 1;
			}
#ifdef LOG_ACTUAL_CONNECTION
			lprintf( "Begin connection &gBackup=%p", g.Backup );
#endif
		}
	}
#ifdef LOG_ACTUAL_CONNECTION
	else
		lprintf( "%s %s."
				 , g.flags.bNoBackup?"No Backup...":"backup present and..."
				 , g.flags.bBackupUp?"Backup is up.":"Backup Down" );
#endif
 // no connection at all....
	if( !g.odbc )
	{
		if( bPrimaryComingUp )
		{
			g.odbc = &g.Primary;
			g.flags.bPrimaryUp = 1;
		}
		else if( bBackupComingUp )
		{
			g.odbc= &g.Backup;
			g.flags.bBackupUp = 1;
		}
		else
		{
			// else nothing's coming up - can't set anything as up...
 // better let the program know soonest...
			g.flags.bBadODBC = 1;
		}
	}
 // have a connection already..
	else
	{
		// connection is to the backup....
		if( g.odbc == &g.Backup )
		{
			if( bPrimaryComingUp )
			{
				//PUPDATE_TASK task = g.UpdateTasks;
#ifdef LOG_ACTUAL_CONNECTION
				Log( WIDE("Primary is coming up - invoke primary recovered") );
#endif
				g.odbc = &g.Primary;
				g.flags.bPrimaryUp = 1;
			}
		}
 // connection is already primary....
		else
		{
			// but now we have a new backup?
			if( bBackupComingUp )
			{
				// hmm have a primary, and now have a backup
				// invoke BackupRestore ?  to synchronize tables with
				// primary?
				g.flags.bBackupUp = 1;
			}
		}
	}
#ifdef SQL_PROXY_SERVER
	if( g.flags.bPrimaryUp )
	{
		if( g.flags.bNoBackup )
			ChangeIcon( PROXY_FULL );
		else
			if( g.flags.bBackupUp )
				ChangeIcon( PROXY_FULL );
			else
				ChangeIcon( PROXY_PRIMARY );
	}
	else
	{
		if( g.flags.bNoBackup )
			ChangeIcon( PROXY_DOWN );
		else
			if( g.flags.bBackupUp )
				ChangeIcon( WIDE("bck.bmp") );
			else
				ChangeIcon( PROXY_DOWN );
	}
#endif
	// result TRUE if anything is up...
	if( g.flags.bPrimaryUp || g.flags.bBackupUp )
	{
		// dispatch any outstanding requests....
		// dispatch pending requests for primary/backup default connections
		if( bPrimaryComingUp || bBackupComingUp )
		{
			if( g.feedback_handler ) g.feedback_handler( WIDE("SQL Connected OK") );
		}
		_bOpening = FALSE;
		/* oh - I guess we can end up attempting to open here.. */
		DispatchPriorRequests( NULL );
		return TRUE;
	}
	// generate error
	_bOpening = FALSE;
	return FALSE;
}
//----------------------------------------------------------------------
void FailConnection( PODBC odbc )
{
	int is_default = 0;
	// g.odbc failed!
	if( odbc )
	{
		PTEXT text;
		PVARTEXT pvt = VarTextCreate();
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		if( odbc->flags.bSQLite_native )
			DumpInfo2( pvt, SQL_HANDLE_DBC, odbc, odbc->flags.bNoLogging );
#endif
#ifdef USE_ODBC
		if( odbc->flags.bODBC )
		{
			lprintf( WIDE("logging HDBC... (and closing)") );
			DumpInfo( odbc, pvt, SQL_HANDLE_DBC, &odbc->hdbc, odbc->flags.bNoLogging );
			if( odbc->flags.bFailEnvOnDbcFail )
				DumpInfo( odbc, pvt, SQL_HANDLE_ENV, &odbc->env, odbc->flags.bNoLogging );
		}
#endif
		text = VarTextPeek( pvt );
		Log1( WIDE("Status of DBC==%s"), text?GetText( text ):WIDE("NO ERROR RESULT") );
		VarTextDestroy( &pvt );
		odbc->flags.bConnected = 0;
	}
	if( odbc == &g.Primary )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT text;
		is_default = 1;
		Log( WIDE("Failed the primary connection!") );
		// DumpInfo results in the hdbc being closed...
		text = VarTextPeek( pvt );
		Log1( WIDE("Status of DBC==%s"), text?GetText( text ):WIDE("NO ERROR RESULT") );
		VarTextDestroy( &pvt );
		g.Primary.flags.bConnected = 0;
		g.flags.bPrimaryUp = FALSE;
		g.odbc = NULL;
	}
	else if( odbc == &g.Backup )
	{
		PVARTEXT pvt = VarTextCreate();
		PTEXT text;
		is_default = 1;
		Log( WIDE("Failed the BACKUP connection! this is VERY bad") );
		// DumpInfo results in the hdbc being closed...
		text = VarTextPeek( pvt );
		Log1( WIDE("Status of DBC==%s"), text?GetText( text ):WIDE("NO ERROR RESULT") );
		VarTextDestroy( &pvt );
		g.flags.bBackupUp = FALSE;
		g.odbc = NULL;
	}
#ifdef SQL_PROXY_SERVER
	if( is_default )
	{
		if( g.flags.bPrimaryUp )
		{
			if( g.flags.bNoBackup )
				ChangeIcon( PROXY_FULL );
			else
				if( g.flags.bBackupUp )
					ChangeIcon( PROXY_FULL );
				else
					ChangeIcon( PROXY_PRIMARY );
		}
		else
		{
			if( g.flags.bNoBackup )
				ChangeIcon( PROXY_DOWN );
			else
				if( g.flags.bBackupUp )
					ChangeIcon( PROXY_BACKUP );
				else
					ChangeIcon( PROXY_DOWN );
		}
	}
#endif
	//Log( WIDE("Attempting to recover a connection") );
	if( is_default )
	{
		//lprintf( "Default connectionf ailed... open general (backup/primary)" );
		OpenSQL( DBG_VOIDSRC );
	}
	else
	{
		//lprintf( "re-open self?" );
		OpenSQLConnectionEx( odbc DBG_SRC );
		//lprintf( "... " );
	}
}
//----------------------------------------------------------------------
void ReleaseCollectionResults( PCOLLECT pCollect, int bEntire )
{
	{
		int idx;
		if( bEntire && pCollect->fields )
		{
			for( idx = 0; idx < pCollect->columns; idx++ )
			{
				Release( (POINTER)pCollect->fields[idx] );
			}
			Release( (POINTER)pCollect->fields );
			pCollect->fields = NULL;
			Release( pCollect->result_len );
			pCollect->result_len = NULL;
		}
		if( pCollect->results )
		{
			for( idx = 0; idx < pCollect->columns; idx++ )
			{
				if( pCollect->results[idx] )
					Release( (POINTER)pCollect->results[idx] );
			}
			Release( (POINTER)pCollect->results );
			pCollect->results = NULL;
		}
		if( bEntire )
		{
			if( pCollect->colsizes )
			{
				Release( pCollect->colsizes );
				pCollect->colsizes = NULL;
			}
			if( pCollect->coltypes )
			{
				//lprintf( "new column types - columns is 0... all is NULL" );
				Release( pCollect->coltypes );
				pCollect->coltypes = NULL;
			}
			pCollect->columns = 0;
		}
	}
	// and if pResult (single string... might clean that up...
	VarTextEmpty( pCollect->pvt_result );
	VarTextEmpty( pCollect->pvt_errorinfo );
}
//----------------------------------------------------------------------
void DestroyCollectorEx( PCOLLECT pCollect DBG_PASS )
#define DestroyCollector(c) DestroyCollectorEx(c DBG_SRC )
{
#ifdef LOG_COLLECTOR_STATES
	PODBC odbc = pCollect?pCollect->odbc:NULL;
	// added to supprot 'collectors'
	_lprintf(DBG_RELAY)( "Destroying a state, restoring prior if any... %s"
							 ,odbc?odbc->collection?odbc->collection->flags.bPushed?"pushed":"":"":"No ODBC"
			 );
	DumpODBCInfo( odbc );
#endif
// cannot destroy this local thing.
	if( !pCollect )
		return;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( pCollect->odbc->flags.bSQLite_native && pCollect->stmt )
	{
		sqlite3_finalize( pCollect->stmt );
		pCollect->stmt = NULL;
	}
#endif
#ifdef USE_ODBC
	if( pCollect->hstmt )
	{
		SQLFreeHandle( SQL_HANDLE_STMT, pCollect->hstmt );
		pCollect->hstmt = 0;
	}
#endif
 // must keep at least one.
	if( !pCollect->flags.bDynamic )
	{
		return;
	}
	ReleaseCollectionResults( pCollect, TRUE );
	VarTextDestroy( &pCollect->pvt_out );
	VarTextDestroy( &pCollect->pvt_result );
	VarTextDestroy( &pCollect->pvt_errorinfo );
#ifdef LOG_COLLECTOR_STATES
	lprintf( WIDE("pcollect %p is %p and %p"), pCollect, pCollect->next, pCollect->me );
#endif
	UnlinkThing( pCollect );
	Release( pCollect );
#ifdef LOG_COLLECTOR_STATES
	{
		collectors--;
		lprintf( "Collectors: %d", collectors );
		{
			PCOLLECT c;
			for( c = g.collections; c; c = c->next )
			{
				lprintf( "State is %s", GetText( VarTextPeek( c->pvt_out ) ) );
			}
			for( c = odbc->collection; c; c = c->next )
			{
				lprintf( "State is %s", GetText( VarTextPeek( c->pvt_out ) ) );
			}
		}
	}
#endif
}
//----------------------------------------------------------------------
PODBC ConnectToDatabaseLogin( CTEXTSTR DSN, CTEXTSTR user, CTEXTSTR pass, LOGICAL bRequireConnection DBG_PASS )
{
	PODBC pODBC;
	SqlStubInitLibrary();
	pODBC = New( ODBC );
	AddLink( &g.pOpenODBC, pODBC );
	MemSet( pODBC, 0, sizeof( ODBC ) );
	if( user )
		StrCpy( pODBC->info.pID, user );
	if( pass )
		StrCpy( pODBC->info.pPASSWORD, pass );
	pODBC->info.pDSN = StrDup( DSN );
	pODBC->flags.bAutoCheckpoint = g.flags.bAutoCheckpoint;
	pODBC->flags.bForceConnection = bRequireConnection;
	// source ID is not known...
	// is probably static link to library, rather than proxy operation
	//CreateCollector( 0, pODBC, FALSE );
	OpenSQLConnectionEx( pODBC DBG_RELAY );
	return pODBC;
}
PODBC ConnectToDatabaseExx( CTEXTSTR DSN, LOGICAL bRequireConnection DBG_PASS )
{
	return ConnectToDatabaseLogin( DSN, NULL, NULL, bRequireConnection DBG_RELAY );
}
#undef ConnectToDatabaseEx
PODBC ConnectToDatabaseEx( CTEXTSTR DSN, LOGICAL bRequireConnection )
{
	return ConnectToDatabaseLogin( DSN, NULL, NULL, bRequireConnection DBG_SRC );
}
//----------------------------------------------------------------------
#undef ConnectToDatabase
PODBC ConnectToDatabase( CTEXTSTR DSN )
{
	return ConnectToDatabaseLogin( DSN, NULL, NULL, g.flags.bRequireConnection DBG_SRC );
}
//----------------------------------------------------------------------
// result is 0, don't retry
			// result is 1, do retry...
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
int DumpInfo2( PVARTEXT pvt, SQLSMALLINT type, PODBC odbc, LOGICAL bNoLog )
{
	const TEXTCHAR *tmp;
	//DebugBreak();
	VarTextEmpty( pvt );
#ifdef _UNICODE
	tmp = DupCStr( sqlite3_errmsg(odbc->db) );
#else
	tmp = sqlite3_errmsg(odbc->db);
#endif
	if( StrCaseCmpEx( tmp, WIDE( "no such table" ), 13 ) == 0 )
		vtprintf( pvt, WIDE( "(S0002)" ) );
	vtprintf( pvt, WIDE( "%s" ), tmp );
	//lprintf( WIDE( "Result of prepare failed? %s at [%s]" ), tmp, tail );
	if( !bNoLog && EnsureLogOpen( odbc ) )
	{
		sack_fprintf( g.pSQLLog, WIDE("#SQLITE ERROR:%s\n"), tmp );
		sack_fflush( g.pSQLLog );
	}
	//vtprintf( pvt, "%s", sqlite3_errmsg(odbc->db) );
	return 0;
}
#endif
#ifdef USE_ODBC
int DumpInfoEx( PODBC odbc, PVARTEXT pvt, SQLSMALLINT type, SQLHANDLE *handle, LOGICAL bNoLog DBG_PASS )
{
 // result of dumpinfo...
	int retry = 0;
	RETCODE rc;
	TEXTCHAR statecode[6];
	TEXTCHAR message[256];
	/* SQLINTEGER is the same sort of thing as int32_t - it's a constant 32 bit integer value. */
	SQLINTEGER  native;
	short  msglen;
	SQLSMALLINT  n;
	n = 1;
#ifdef LOG_EVERYTHING
	_lprintf( DBG_RELAY )( WIDE( "Dumping Connection error Info..." ) );
#endif
	VarTextEmpty( pvt );
	do
	{
		rc = SQLGetDiagRec( type
								, *handle
								, n++,
#ifdef _UNICODE
                         (SQLWCHAR*)statecode
#else
								 (SQLCHAR*)statecode
#endif
                        ,
								&native
                         ,
#ifdef _UNICODE
								 (SQLWCHAR*)message
                         , sizeof( message )
#else
								 (SQLCHAR*)message
                         , sizeof( message )
#endif
								, &msglen );
		if( rc == SQL_INVALID_HANDLE )
		{
			vtprintf( pvt, WIDE("Invalid handle") );
			if( !bNoLog && EnsureLogOpen( odbc ) )
				sack_fprintf( g.pSQLLog, WIDE("#%s\n"), WIDE("Invalid Handle") );
			break;
		}
		else if( rc != SQL_NO_DATA )
		{
#ifdef LOG_EVERYTHING
			lprintf( WIDE( "Quick info is rc:%d  %d [%s]{%s}" ), rc, native, statecode, message );
#endif
			//DebugBreak();
			if( ( strcmp( statecode, WIDE( "IM002" ) ) == 0 ) && ( handle == &(g.Backup.hdbc) ) )
			{
				/* quiet error... */
				if( g.feedback_handler )
					g.feedback_handler( WIDE("Secondary DSN....") );
				else
					lprintf( WIDE( "Secondary DSN...." ) );
				vtprintf( pvt, WIDE("(%5s)[%") _32f WIDE("]:%s"), statecode, native, message );
				break;
				//
				//return 0;
			}
			// native 2003 == could not connect... (do not retry)
			// native 2013 == lost connection during query.
			if( ( ( strcmp( statecode, WIDE( "S1T00" ) ) == 0 ) ||
				 ( strcmp( statecode, WIDE( "08S01" ) ) == 0 ) )
				&& ( native == 2013 ) )
			{
				if( g.feedback_handler ) g.feedback_handler( WIDE("SQL Connection Lost...\nWaiting for reconnect...") );
				_lprintf(DBG_RELAY)( WIDE( "Connection was lost, closing, and attempting to reopen.  Resulting with a Retry." ) );
				vtprintf( pvt, WIDE("(%5s)[%") _32f WIDE("]:%s"), statecode, native, message );
				if( !bNoLog && EnsureLogOpen( odbc ) )
				{
					sack_fprintf( g.pSQLLog, WIDE("#(%5s)[%") _32f WIDE("]:%s\n"), statecode, native, message );
				}
				if( !bOpening )
				{
					lprintf( WIDE( "not opening, fail connection..." ) );
					FailConnection( odbc );
					if( IsSQLOpen( odbc ) )
					{
						lprintf( WIDE( "Connection closed, and re-open worked." ) );
						retry = 1;
					}
				}
				else
				{
					retry = 1;
					lprintf( WIDE( "Alsready opening?!" ) );
				}
			}
			else if( native == 2006 || native == 2003 )
			{
				if( odbc->flags.bConnected )
					if( g.feedback_handler ) g.feedback_handler( WIDE("SQL Connection Lost...\nWaiting for reconnect...") );
				_lprintf(DBG_RELAY)( WIDE( "[%s] This is 'connection lost' (not tempoary)" ), odbc->info.pDSN );
				if( !bOpening )
				{
					if( type == SQL_HANDLE_STMT )
					{
						RETCODE rc2 = SQLFreeHandle( type, *handle );
						(*handle) = 0;
						lprintf( WIDE( "Result of free (Stmt) : %d" ), rc2 );
					}
					FailConnection( odbc );
					while( !IsSQLOpen( odbc ) );
					lprintf( WIDE( "Connection closed, and re-open worked." ) );
					retry = 1;
				}
				else
				{
				}
			}
			else
			{
				lprintf( WIDE( "This is some other error (%5s)[%d]:%s" ), statecode, native, message );
				if( StrCmp( statecode, WIDE( "IM002" ) ) == 0 )
					vtprintf( pvt, WIDE("(%5s)[%") _32f WIDE("]:%s<%s>"), statecode, native, message, odbc->info.pDSN?odbc->info.pDSN:WIDE("") );
				else
					vtprintf( pvt, WIDE("(%5s)[%") _32f WIDE("]:%s"), statecode, native, message );
				if( !bNoLog && EnsureLogOpen( odbc ) )
					sack_fprintf( g.pSQLLog, WIDE("#%s\n"), GetText( VarTextPeek( pvt ) ) );
			}
		}
		else
		{
			//vtprintf( pvt, WIDE("(E0000)No Data on error!") );
			//if( g.pSQLLog )
			//	 fprintf( g.pSQLLog, WIDE("#No data for error!  This may be caused by the sql server disappearing." ) );
		}
	} while( ( rc != SQL_NO_DATA ) && (*handle) );
	if( !bNoLog && EnsureLogOpen( odbc ) )
		sack_fflush( g.pSQLLog );
#ifdef LOG_EVERYTHING
	lprintf( WIDE("Drop handle %p"), (*handle) );
#endif
	SQLFreeHandle( type, *handle );
	(*handle) = 0;
	return retry;
}
#endif
PCOLLECT FindCollection( PODBC odbc, PSERVICE_ROUTE SourceID )
{
	PCOLLECT pCollect = g.collections;
	// collectors are non-odbc connection specific.
	// they are more like a queue of pending requests against
	// either their own, specified ODBC or the primary/backup path.
#ifdef LOG_COLLECTOR_STATES
	lprintf( WIDE("Find collection for %") _32f , SourceID );
#endif
	if( odbc )
		for( pCollect = odbc->collection;
			pCollect;
			pCollect = NextThing( pCollect) )
			if( pCollect->SourceID == SourceID )
				return pCollect;
	for( pCollect = g.collections;
		pCollect;
		pCollect = NextThing( pCollect) )
		if( pCollect->SourceID == SourceID )
			return pCollect;
	// didn't find one, create one, and return it.
#ifdef LOG_COLLECTOR_STATES
	lprintf( WIDE("Creating new collector on an odbc connection") );
#endif
	return CreateCollector( SourceID, odbc, FALSE );;
}
//-----------------------------------------------------------------------
// also ifndef sql thing...
static PCOLLECT Collect( PCOLLECT collection, uint32_t *params, size_t paramlen )
{
	CTEXTSTR buffer = (CTEXTSTR)params;
	// make sure we have enough room.
	VarTextExpand( collection->pvt_out, paramlen );
	VarTextAddData( collection->pvt_out, buffer, paramlen );
	//lprintf( WIDE("Collected: %s"), buf );
	return collection;
}
void ReleaseODBC( PODBC odbc )
{
	if( odbc )
	{
		PCOLLECT pc = NULL;
		while( odbc->collection && ( pc != odbc->collection ) )
		{
			pc = odbc->collection;
			DestroyCollector( odbc->collection );
		}
	}
}
void CloseDatabaseEx( PODBC odbc, LOGICAL ReleaseConnection )
{
	uint32_t tick = GetTickCount();
	ReleaseODBC( odbc );
	odbc->flags.bClosed = 1;
	odbc->flags.bAutoCheckpoint = 0;
	odbc->last_command_tick = 0;
	while( ( (GetTickCount()-tick) < 100 ) && odbc->auto_checkpoint_thread ) {
		WakeThread( odbc->auto_checkpoint_thread );
		Relinquish();
	}
	while( odbc->auto_commit_thread )
	{
		SQLCommit( odbc );
		WakeThread( odbc->auto_commit_thread );
	}
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
	{
		int err = sqlite3_close( odbc->db );
		if( err )
		{
			lprintf( WIDE("sqlite3 returned %d on close..."), err );
		}
	}
	else
#endif
#ifdef USE_ODBC
	if( odbc->hdbc )
	{
		SQLDisconnect( odbc->hdbc );
		SQLFreeHandle( SQL_HANDLE_ENV, odbc->env );
		odbc->env = NULL;
		SQLFreeHandle( SQL_HANDLE_DBC, odbc->hdbc );
		odbc->hdbc = NULL;
	}
#endif
	DeleteLink( &g.pOpenODBC, odbc );
	if( ReleaseConnection )
		Release( odbc );
	else
		odbc->flags.bConnected = FALSE;
}
void CloseDatabase( PODBC odbc )
{
	CloseDatabaseEx( odbc, TRUE );
}
//-----------------------------------------------------------------------
int __DoSQLCommandEx( PODBC odbc, PCOLLECT collection DBG_PASS )
{
	int retry = 0;
#ifdef USE_ODBC
	RETCODE rc;
#endif
	PTEXT cmd;
	if( !odbc )
	{
		Log( WIDE("Delayed COMMAND") );
		collection->lastop = LAST_COMMAND;
		//collection->hLastWnd = hWnd;
		return FALSE;
	}
	if( odbc->flags.bThreadProtect )
	{
		EnterCriticalSec( &odbc->cs );
		odbc->nProtect++;
	}
corruptRetry:
	if( !OpenSQLConnectionEx( odbc DBG_SRC ) )
	{
		lprintf( WIDE("Fail connect odbc... should already be open?!") );
		GenerateResponce( collection, WM_SQL_RESULT_ERROR );
		if( odbc->flags.bThreadProtect )
		{
			odbc->nProtect--;
			LeaveCriticalSec( &odbc->cs );
		}
		return FALSE;
	}
	cmd = VarTextPeek( collection->pvt_out );
	if( EnsureLogOpen(odbc ) )
	{
		sack_fprintf( g.pSQLLog, WIDE("%s[%p]:%s\n"), odbc->info.pDSN?odbc->info.pDSN:WIDE( "NoDSN?" ), odbc, GetText( cmd ) );
		sack_fflush( g.pSQLLog );
	}
	VarTextEmpty( collection->pvt_result );
	VarTextEmpty( collection->pvt_errorinfo );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
	{
		if( collection->stmt )
		{
			sqlite3_finalize( collection->stmt );
			collection->stmt = NULL;
		}
	}
#endif
#ifdef USE_ODBC
	if( odbc->flags.bODBC )
	{
		if( collection->hstmt )
		{
			SQLFreeHandle( SQL_HANDLE_STMT, collection->hstmt );
			collection->hstmt = 0;
		}
	}
#endif
	if( !(g.flags.bNoLog) )
	{
		if( odbc->flags.bNoLogging )
			//odbc->hidden_messages++
			;
		else
			_lprintf(DBG_RELAY)( WIDE( "Do Command[%p:%s]: %s" ), odbc, odbc->info.pDSN?odbc->info.pDSN:WIDE( "NoDSN?" ), GetText( cmd ) );
	}
#ifdef LOG_EVERYTHING
	lprintf( WIDE( "sql command on %p [%s]" ), collection->hstmt, GetText( cmd ) );
#endif
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
	{
		int result_code = WM_SQL_RESULT_SUCCESS;
		int rc3;
		const TEXTCHAR *tail;
retry:
		odbc->last_command_tick_ = timeGetTime();
		if( odbc->last_command_tick )
			odbc->last_command_tick = odbc->last_command_tick_;
		// can get back what was not used when parsing...
#ifdef UNICODE
		rc3 = sqlite3_prepare16_v2( odbc->db, (void*)GetText( cmd ), (int)(GetTextSize( cmd )) * sizeof( TEXTCHAR ), &collection->stmt, (const void**)&tail );
#else
		rc3 = sqlite3_prepare_v2( odbc->db, GetText( cmd ), (int)(GetTextSize( cmd )), &collection->stmt, &tail );
#endif
		if( rc3 )
		{
			vtprintf( collection->pvt_errorinfo, "Result of prepare failed? %s at char %" _size_f "[%" _string_f "] in [%" _string_f "]"
			       , sqlite3_errmsg(odbc->db), tail - GetText(cmd), tail, GetText(cmd) );
			if( EnsureLogOpen(odbc ) )
			{
				sack_fprintf( g.pSQLLog, WIDE("#SQLITE ERROR:%") _string_f WIDE("\n"), GetText( VarTextPeek( collection->pvt_errorinfo ) ) );
				sack_fflush( g.pSQLLog );
			}
			 GenerateResponce( collection, WM_SQL_RESULT_ERROR );
			if( odbc->flags.bThreadProtect )
			{
				// had to close a prior connection...
				odbc->nProtect--;
				LeaveCriticalSec( &odbc->cs );
			}
			return FALSE;
		}
		else
		{
			if( odbc->flags.bAutoCheckpoint && (!sqlite3_stmt_readonly( collection->stmt )) )
				startAutoCheckpoint( odbc );
			rc3 = sqlite3_step( collection->stmt );
			switch( rc3 )
			{
			case SQLITE_CORRUPT:
				if( odbc->pCorruptionHandler ) {
					odbc->pCorruptionHandler( odbc->psvCorruptionHandler, odbc );
					goto corruptRetry;
				}
				break;
			case SQLITE_OK:
			case SQLITE_DONE:
			case SQLITE_ROW:
				//if( !sqlite3_get_autocommit(odbc->db) )
				{
					// this is a noisy message when we start using start trans and endtrans
					//lprintf( "Database has fallen out of auto commit mode!" );
					//DebugBreak();
				}
				break;
			case SQLITE_BUSY:
				// going to retry the statement as a whole anyhow.
				sqlite3_finalize( collection->stmt );
				if( !odbc->flags.bNoLogging )
				{
					_lprintf(DBG_RELAY)( WIDE( "Database Busy, waiting on[%p:%s]: %s" ), odbc, odbc->info.pDSN?odbc->info.pDSN:WIDE( "NoDSN?" ), GetText( cmd ) );
					//DumpAllODBCInfo();
				}
				WakeableSleep( 25 );
				goto retry;
			default:
				//  SQLITE_CONSTRAINT - statement like an insert with a key that already exists.
				if( !odbc->flags.bNoLogging )
					_lprintf(DBG_RELAY)( WIDE( "[%s] Unknown, unhandled SQLITE error: %s" ), odbc->info.pDSN?odbc->info.pDSN:WIDE( "NoDSN?" ), sqlite3_errmsg(odbc->db ) );
				else
					vtprintf( collection->pvt_errorinfo, "[%s] Unknown, unhandled SQLITE error: %s", odbc->info.pDSN ? odbc->info.pDSN : WIDE( "NoDSN?" ), sqlite3_errmsg( odbc->db ) );
				//DebugBreak();
				result_code = WM_SQL_RESULT_ERROR;
				break;
			}
			// this should be SQLITE_OK || SQLITE_DONE
		}
		if( odbc->flags.bSQLite_native && collection->stmt )
		{
			sqlite3_finalize( collection->stmt );
			collection->stmt = NULL;
		}
		GenerateResponce( collection, result_code );
#ifdef LOG_COLLECTOR_STATES
		DumpODBCInfo( odbc );
#endif
	}
#endif
#ifdef USE_ODBC
	if( odbc->flags.bODBC )
	{
		if( !collection->hstmt )
		{
			rc = SQLAllocHandle( SQL_HANDLE_STMT
									 , odbc->hdbc
									 , &collection->hstmt );
			if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
			{
				lprintf( WIDE("Failed to open ODBC statement handle....") );
				GenerateResponce( collection, WM_SQL_RESULT_ERROR );
				if( odbc->flags.bThreadProtect )
				{
					odbc->nProtect--;
					LeaveCriticalSec( &odbc->cs );
				}
				return FALSE;
			}
		}
		{
			rc = SQLExecDirect( collection->hstmt,
#ifdef _UNICODE
									 (SQLWCHAR*)GetText( cmd )
#else
									 (SQLCHAR*)GetText( cmd )
#endif
									, SQL_NTS );
		}
			if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
			{
				// DumpInfo will do the logging... shouldn't need to re-log it.
				retry = DumpInfo( odbc, collection->pvt_errorinfo, SQL_HANDLE_STMT, &collection->hstmt, odbc->flags.bNoLogging );
				//cmd = VarTextPeek( collection->pvt_errorinfo );
				//DebugBreak();
				//lprintf( WIDE("ODBC Command excecution failed(1)....%s"), cmd?GetText( cmd ):WIDE("NO ERROR RESULT") );
				if( EnsureLogOpen( odbc ) )
				{
					sack_fprintf( g.pSQLLog, WIDE("#%s\n"), GetText( cmd ) );
					sack_fflush( g.pSQLLog );
				}
				//lprintf( WIDE("result err...") );
				GenerateResponce( collection, WM_SQL_RESULT_ERROR );
			}
			else
			{
				if( collection->hstmt )
				{
					SQLFreeHandle( SQL_HANDLE_STMT, collection->hstmt );
					collection->hstmt = 0;
				}
#ifdef LOG_EVERYTHING
				lprintf( WIDE("Resulting okay.") );
#endif
				GenerateResponce( collection, WM_SQL_RESULT_SUCCESS );
			}
	}
#endif
	if( odbc->flags.bThreadProtect )
	{
		odbc->nProtect--;
		LeaveCriticalSec( &odbc->cs );
	}
	//  actually we keep collections around while there's a client...
	//lprintf( WIDE("Command destroy collection...") );
	//DestroyCollector( collection );
	return retry;
}
//-----------------------------------------------------------------------
SQLPROXY_PROC( int, SQLCommandEx )( PODBC odbc, CTEXTSTR command DBG_PASS )
{
	PODBC use_odbc;
	if( odbc->flags.bClosed )
		return 0;
	if( !IsSQLOpenEx( odbc DBG_RELAY ) )
		return 0;
	if( !( use_odbc = odbc ) )
	{
		use_odbc = g.odbc;
	}
	if( use_odbc )
	{
		PCOLLECT pCollector;
		BeginTransactEx( use_odbc, 0 );
		do
		{
#ifdef LOG_COLLECTOR_STATES
			lprintf( "creating collector...cmd: %s", command );
#endif
			Collect( pCollector = CreateCollector( 0, use_odbc, TRUE ), (uint32_t*)command, (uint32_t)strlen( command ) );
			//SimpleMessageBox( NULL, "Please shut down the database...", "Waiting.." );
		} while( __DoSQLCommandEx( use_odbc, pCollector DBG_RELAY ) );
		if( use_odbc->collection )
			return use_odbc->collection->responce == WM_SQL_RESULT_SUCCESS?TRUE:0;
		return WM_SQL_RESULT_ERROR;
	}
	else
		_xlprintf(1 DBG_RELAY )( WIDE("ODBC connection has not been opened") );
	return FALSE;
}
//-----------------------------------------------------------------------
SQLPROXY_PROC( int, SQLCommandExx )(PODBC odbc, CTEXTSTR command, size_t commandLen DBG_PASS)
{
	PODBC use_odbc;
	if( odbc->flags.bClosed )
		return 0;
	if( !IsSQLOpenEx( odbc DBG_RELAY ) )
		return 0;
	if( !(use_odbc = odbc) )
	{
		use_odbc = g.odbc;
	}
	if( use_odbc )
	{
		PCOLLECT pCollector;
		BeginTransactEx( use_odbc, 0 );
		do
		{
#ifdef LOG_COLLECTOR_STATES
			lprintf( "creating collector...cmd: %s", command );
#endif
			Collect( pCollector = CreateCollector( 0, use_odbc, TRUE ), (uint32_t*)command, commandLen?commandLen:strlen( command ) );
			//SimpleMessageBox( NULL, "Please shut down the database...", "Waiting.." );
		} while( __DoSQLCommandEx( use_odbc, pCollector DBG_RELAY ) );
		if( use_odbc->collection )
			return use_odbc->collection->responce == WM_SQL_RESULT_SUCCESS ? TRUE : 0;
		return WM_SQL_RESULT_ERROR;
	}
	else
		_xlprintf( 1 DBG_RELAY )(WIDE( "ODBC connection has not been opened" ));
	return FALSE;
}
//-----------------------------------------------------------------------
int DoSQLCommandEx( CTEXTSTR command DBG_PASS )
{
	return SQLCommandEx( NULL, command DBG_RELAY );
}
//-----------------------------------------------------------------------
void __GetSQLTypes( PODBC odbc, PCOLLECT collection )
{
	VarTextEmpty( collection->pvt_result );
	VarTextEmpty( collection->pvt_errorinfo );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
	{
		lprintf( WIDE("Someone's getting types - haven't figured this one out yet...") );
		/*
		if( collection->stmt )
		{
			sqlite3_finalize( collection->stmt );
			collection->stmt = NULL;
		}
		*/
		GenerateResponce( collection, WM_SQL_RESULT_NO_DATA );
		return;
	}
#endif
#ifdef USE_ODBC
	{
		RETCODE rc;
		if( collection->hstmt )
		{
			SQLFreeHandle( SQL_HANDLE_STMT, collection->hstmt );
			collection->hstmt = 0;
		}
		rc = SQLAllocHandle( SQL_HANDLE_STMT
								 , odbc->hdbc
								 , &collection->hstmt );
		if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
		{
			lprintf( WIDE("Failed to open ODBC statement handle....") );
			GenerateResponce( collection, WM_SQL_RESULT_ERROR );
			return;
		}
		rc = SQLGetTypeInfo( collection->hstmt, SQL_ALL_TYPES );
		if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
		{
			lprintf( WIDE("Failed to get SQL types...") );
			GenerateResponce( collection, WM_SQL_RESULT_ERROR );
			return;
		}
		GenerateResponce( collection, WM_SQL_RESULT_SUCCESS );
	}
#endif
}
//-----------------------------------------------------------------------
int GetSQLTypes( void )
{
	if( !OpenSQL( DBG_VOIDSRC ) )
	{
		return FALSE;
	}
	__GetSQLTypes( g.odbc, g.odbc->collection );
	return g.odbc->collection->responce == WM_SQL_RESULT_SUCCESS?TRUE:0;
}
//-----------------------------------------------------------------------
SQLPROXY_PROC( int, FetchSQLTypes )( PODBC odbc )
{
	if( odbc )
	{
		__GetSQLTypes( odbc, odbc->collection );
		return odbc->collection->responce == WM_SQL_RESULT_SUCCESS?TRUE:0;
	}
	return 0;
}
//-----------------------------------------------------------------------
#define SET_RESULT_STRING( result, string ) {		  static CTEXTSTR default_msg;		                 if( !default_msg )			                        default_msg = StrDup(string);		if( default_msg[0] != string[0] )		  {			                            xlprintf(LOG_ALWAYS)( WIDE("Someone deallocated our message!") );	       exit(0);	                                                         }		(*(result)) = default_msg;	 }
SQLPROXY_PROC( int, FetchSQLError )( PODBC odbc, CTEXTSTR *result )
{
	if( !result )
		return 0;
	if( !odbc )
	{
		odbc = g.odbc;
		if( !odbc )
		{
			SET_RESULT_STRING( result, WIDE("Application has failed to inialize it's ODBC connection") );
			return 1;
		}
	}
	if( odbc->collection )
	{
		// result in the text hanging out ont he collection thing.
		odbc->collection->result_text = VarTextPeek( odbc->collection->pvt_errorinfo );
		if( odbc->collection->result_text )
		{
			*result = GetText( odbc->collection->result_text );
		}
		else
		{
		  SET_RESULT_STRING( result, WIDE("No data on error...") );
		}
	}
	else
		SET_RESULT_STRING( result, WIDE("Collection disappeared...") );
	return 1;
}
//-----------------------------------------------------------------------
SQLPROXY_PROC( int, GetSQLError )( CTEXTSTR *result )
{
	if( !g.odbc )
		if( !OpenSQL( DBG_VOIDSRC ) )
		{
			if( result ) (*result) = NULL;
			return 0;
		}
	return FetchSQLError( g.odbc, result );
}
//-----------------------------------------------------------------------
void __GetSQLError( PODBC odbc, PCOLLECT collection )
{
	GenerateResponce( collection, WM_SQL_RESULT_DATA );
}
//-----------------------------------------------------------------------
CTEXTSTR Deblobify( TEXTCHAR *data, int len )
{
	static TEXTCHAR table[256];
	TEXTCHAR *result;
	TEXTCHAR *output = NewArray( TEXTCHAR, len + 1 );
	if( !table['1'] )
	{
		int n;
		for( n = 0; n <= 9; n++ )
			table['0'+n] = (char)n;
		for( n = 0; n < 6; n++ )
		{
			table['a'+n] = (char)(10 + n);
			table['A'+n] = (char)(10 + n);
		}
	}
	result = output;
	while( data[0] && data[1] && len )
	{
		output[0] = (char)(( table[(int)data[0]] << 4 ) + table[(int)data[1]]);
		data += 2;
		output++;
		len--;
	}
	// add a nul terminator...
	output[0] = 0;
	return result;
}
//-----------------------------------------------------------------------
int __GetSQLResult( PODBC odbc, PCOLLECT collection, int bMore )
{
	int retry = 0;
	int result_cmd = WM_SQL_RESULT_DATA;
	if( !odbc )
	{
		collection->lastop = LAST_RESULT;
		//collection->hLastWnd = hWnd;
		return 0;
	}
#if !defined( SQLPROXY_LIBRARY_SOURCE ) && !defined( SQLPROXY_SOURCE )
	// really this shouldn't be done in get result
	// if the connection failed between query and result there wouldn't be a result anyway?
	// so I guess this is just to protect getresult if the connection did fail.?
	if( !OpenSQLConnectionEx( odbc DBG_SRC ) )
	{
		GenerateResponce( collection, WM_SQL_RESULT_ERROR );
		if( odbc->flags.bThreadProtect )
		{
			odbc->nProtect--;
			LeaveCriticalSec( &odbc->cs );
		}
		return 0;
	}
#endif
	if( bMore )
		result_cmd = WM_SQL_RESULT_MORE;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) || defined( USE_ODBC )
	if(
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		( odbc->flags.bSQLite_native && collection->stmt )
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
		||
#endif
#ifdef USE_ODBC
		( collection->hstmt )
#endif
	  )
	{
#ifdef USE_ODBC
		RETCODE rc;
#endif
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		int rc3;
#endif
		//INDEX idx;
		int lines = 0;
#ifdef USE_ODBC
		TEXTCHAR byResultStatic[256];
		TEXTCHAR *byResult;
#endif
		PVARTEXT pvtData;
		TEXTCHAR *tmpResult = NULL;
#ifdef USE_ODBC
      // used as a buffer length to get odbc result
		uintptr_t byTmpResultLen = 0;
#endif
		// SQLPrepare
		// includes the table to list... therefore list the fields in the table.
		//lprintf( "am I logging: %d %d %d", (!odbc->flags.bNoLogging) , (!g.flags.bNoLog) , g.flags.bLogData )
		if( (!odbc->flags.bNoLogging) && (!g.flags.bNoLog) && g.flags.bLogData )
			pvtData = VarTextCreate();
		else
			pvtData = NULL;
		//lprintf( WIDE("Attempting to fetch data...") );
		//VarTextEmpty( collection->pvt_result );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		if( odbc->flags.bSQLite_native )
		{
		retry:
 // need to do this early to get columns
			rc3 = sqlite3_step( collection->stmt );
			switch( rc3 )
			{
			case SQLITE_BUSY:
				lprintf( WIDE("Database busy, waiting...") );
				WakeableSleep( 25 );
				goto retry;
			case SQLITE_LOCKED:
				lprintf( WIDE("Database locked, waiting...") );
				WakeableSleep( 100 );
				goto retry;
				break;
			case SQLITE_ROW:
			case SQLITE_DONE:
				break;
			case SQLITE_CORRUPT:
				if( odbc->pCorruptionHandler ) {
					odbc->pCorruptionHandler( odbc->psvCorruptionHandler, odbc );
				}
				vtprintf( collection->pvt_errorinfo, WIDE("Database is corrupt (should retry): %s\n"), sqlite3_errmsg(odbc->db ) );
				result_cmd = WM_SQL_RESULT_ERROR;
				break;
			default:
				lprintf( WIDE("Step status %d:%s %08x"), rc3, sqlite3_errmsg(odbc->db ), sqlite3_extended_errcode(odbc->db) );
				result_cmd = WM_SQL_RESULT_ERROR;
				break;
			}
		}
#endif
		if( ( result_cmd != WM_SQL_RESULT_DATA ) && ( result_cmd != WM_SQL_RESULT_MORE ) ) {
			GenerateResponce( collection, result_cmd );
			if( odbc->flags.bThreadProtect )
			{
				odbc->nProtect--;
				LeaveCriticalSec( &odbc->cs );
			}
			return 0;
		}
		ReleaseCollectionResults( collection, FALSE );
		if( collection->flags.bBuildResultArray )
		{
			int len;
			// after initial, and clear, these sizes will be NULL
			// otherwise, it's for getting a result against the current query.
			// the next query will have cleared these to NULL;
			if( !collection->coltypes )
			{
					//lprintf( "making types for %d columns", collection->columns + 1 );
				collection->coltypes = NewArray( SQLSMALLINT, ( collection->columns + 1 ) );
			}
			if( !collection->colsizes )
			{
				collection->colsizes = NewArray( SQLULEN, ( collection->columns + 1 ) );
			}
			if( !collection->results )
			{
				len = ( sizeof( CTEXTSTR ) * (collection->columns + 1) );
				//lprintf( "Allocating for %d columns...", collection->columns );
				collection->results = NewArray( TEXTSTR, collection->columns + 1 );
				MemSet( collection->results, 0, len );
			}
			if( !collection->fields )
			{
				len = ( sizeof( CTEXTSTR ) * (collection->columns + 1) );
				collection->fields = NewArray( TEXTSTR, collection->columns + 1 );
				MemSet( collection->fields, 0, len );
				len = (sizeof( size_t ) * (collection->columns + 1));
				collection->result_len = NewArray( size_t, collection->columns + 1 );
				MemSet( collection->result_len, 0, len );
				len = (sizeof( int ) * (collection->columns + 1));
				collection->column_types = NewArray( int, collection->columns + 1 );
				MemSet( collection->column_types, 0, len );
				// okay and now - pull column info from magic place...
				{
#ifdef USE_ODBC
					TEXTCHAR colname[256];
					short namelen;
#endif
					// cpg29dec2006 c:\work\sack\src\sqllib\sqlstub.c(1222) : warning C4018: '<=' : signed/unsigned mismatch
					// cpg29dec2006 INDEX idx;
					int idx;
					for( idx = 1; idx <= collection->columns; idx++ )
					{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
						//const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
						if( odbc->flags.bSQLite_native )
						{
							collection->fields[idx-1] =
								DupCStr( sqlite3_column_name(collection->stmt
																	 , idx - 1 ) );
							collection->column_types[idx-1] = sqlite3_column_type( collection->stmt, idx - 1 );
						}
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
						else
#endif
#ifdef USE_ODBC
						{
							rc = SQLDescribeCol( collection->hstmt
													 , idx
													 ,
#ifdef _UNICODE
													  (SQLWCHAR*)colname
													  , sizeof(colname)
#else
													  (SQLCHAR*)colname
													  , sizeof(colname)
#endif
													 , (SQLSMALLINT*)&namelen
 // data type short int
													 , collection->coltypes + idx - 1
 // columnsize int
													 , collection->colsizes + idx - 1
 // decimal digits short int
													 , NULL
 // nullable ptr ?
													 , NULL
													 );
							//lprintf( WIDE("column %s is type %d(%d)"), colname, coltypes[idx-1], colsizes[idx-1] );
							if( rc != SQL_SUCCESS_WITH_INFO &&
								rc != SQL_SUCCESS )
							{
								retry = DumpInfo( odbc, collection->pvt_errorinfo, SQL_HANDLE_STMT, &collection->hstmt, odbc->flags.bNoLogging );
								lprintf( WIDE("GetData failed...") );
								result_cmd = WM_SQL_RESULT_ERROR;
								break;
							}
							//lprintf( "col %s is %d %d", colname, collection->colsizes[idx-1], collection->coltypes[idx-1] );
 // always nul terminate this.
							colname[namelen] = 0;
							collection->fields[idx-1] = StrDup( colname );
						}
#endif
 // for
					}
					// and stuff a NULL at the end too..
					collection->fields[idx-1] = NULL;
				}
			}
		}
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		if( odbc->flags.bSQLite_native && ( rc3 == SQLITE_DONE ) )
		{
			if( pvtData )
			{
				lprintf( WIDE("no data") );
				VarTextDestroy( &pvtData );
			}
			result_cmd = WM_SQL_RESULT_NO_DATA;
			collection->flags.bTemporary = 1;
			collection->flags.bEndOfFile = 1;
			GenerateResponce( collection, result_cmd );
			//DestroyCollection( collection );
			if( odbc->flags.bThreadProtect )
			{
				odbc->nProtect--;
				LeaveCriticalSec( &odbc->cs );
			}
			return 0;
		}
#endif
		if(
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
			( odbc->flags.bSQLite_native && ( rc3 == SQLITE_ROW ) )
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
			||
#endif
#ifdef USE_ODBC
			(
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
			 (!odbc->flags.bSQLite_native )
			 &&
#endif
			 ( ( rc = SQLFetch( collection->hstmt ) ) == SQL_SUCCESS )
			  )
#endif
			)
		{
			int idx;
			int first = 1;
#ifdef USE_ODBC
			SQLLEN ResultLen;
#endif
			idx = 1;
			lines++;
			//lprintf( WIDE("Yes, so lets' get the data to result with..") );
			do
			{
				//SQLULEN colsize;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
				if( odbc->flags.bSQLite_native )
				{
					char *text = (char*)sqlite3_column_text( collection->stmt, idx - 1 );
					TEXTSTR real_text;
					int colsize;
					colsize = sqlite3_column_bytes( collection->stmt, idx - 1 );
					real_text = DupCStrLen( text, colsize );
					if( collection->flags.bBuildResultArray )
					{
						collection->result_len[idx - 1] = colsize;
						if( collection->results[idx-1] )
							Release( (char*)collection->results[idx-1] );
						switch( collection->column_types[idx-1] )
						{
						case SQLITE_BLOB:
							//lprintf( "Got a blob..." );
							if( pvtData )vtprintf( pvtData, WIDE( "%s<binary>" ), idx>1?WIDE( "," ):WIDE( "" ) );
							collection->results[idx-1] = NewArray( TEXTCHAR, collection->result_len[idx - 1] );
							MemCpy( collection->results[idx-1], text, collection->result_len[idx - 1] );
							break;
						default:
							if( pvtData )vtprintf( pvtData, WIDE( "%s%s" ), idx>1?WIDE( "," ):WIDE( "" ), real_text );
							collection->results[idx-1] = real_text;
							break;
						}
					}
					else
					{
						if( pvtData )vtprintf( pvtData, WIDE( "%s%s" ), idx>1?WIDE( "," ):WIDE( "" ), real_text?real_text:WIDE( "<NULL>" ) );
						//lprintf( WIDE( "... %p" ), text );
						vtprintf( collection->pvt_result, WIDE("%s%s"), first?WIDE( "" ):WIDE( "," ), real_text?real_text:WIDE( "" ) );
						first=0;
						Release( real_text );
					}
				}
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
				else
#endif
#ifdef USE_ODBC
				{
					short coltype;
					SQLULEN colsize;
					rc = SQLDescribeCol( collection->hstmt
											 , (SQLUSMALLINT)idx
 // colname, bufsize
											 , NULL, 0
 // result colname size
											 , NULL
 // data type short int
											 , &coltype
 // columnsize int
											 , &colsize
 // decimal digits short int
											 , NULL
 // nullable ptr ?
											 , NULL
											 );
					collection->result_len[idx - 1] = colsize;
					colsize = (colsize * 2) + 1 + 1024 ;
					if( colsize >= sizeof( byResultStatic ) )
					{
						if( colsize > byTmpResultLen )
						{
							if( tmpResult )
								Release( tmpResult );
							tmpResult = NewArray( TEXTCHAR, colsize );
							byTmpResultLen = colsize;
						}
						byResult = tmpResult;
					}
					else
					{
						byResult = byResultStatic;
					}
					if( collection->coltypes && ( ( collection->coltypes[idx-1] == SQL_VARBINARY ) || ( collection->coltypes[idx-1] == SQL_LONGVARBINARY ) ) )
					{
						rc = SQLGetData( collection->hstmt
											, (short)(idx)
											, SQL_C_BINARY
											, byResult
											, colsize
											, &ResultLen );
						if( SUS_GT( ResultLen,SQLINTEGER,collection->colsizes[idx-1],SQLUINTEGER) )
						{
							lprintf( WIDE( "SQL Result returned more data than the column described! (returned %d expected %d)" ), (int)ResultLen, (int)(collection->colsizes[idx-1]) );
						}
					}
					else
					{
						rc = SQLGetData( collection->hstmt
											, (short)(idx)
#ifdef _UNICODE
											, SQL_C_WCHAR
#else
											, SQL_C_CHAR
#endif
											, byResult
											, colsize
											, &ResultLen );
						// hvaing this cast as a UINTEGER for colsize comparison
						// breaks -1 being less than colsize... so test negative special and
						// do the same thing as < colsize
						if( ( ResultLen & 0x8000000 )
									|| ( (SQLUINTEGER)ResultLen < colsize ) )
						{
							if( (int)ResultLen < 0 )
								byResult[0] = 0;
							else
								byResult[ResultLen] = 0;
						}
						else
						{
							lprintf( WIDE( "SQL overflow (no room for nul character) %d of %d" ), (int)ResultLen, (int)colsize );
						}
					}
					//lprintf( WIDE( "Column %s colsize %d coltype %d coltype %d idx %d" ), collection->fields[idx-1], colsize, coltype, collection->coltypes[idx-1], idx );
					if( collection->coltypes && coltype != collection->coltypes[idx-1] )
					{
						lprintf( WIDE( "Col type mismatch?" ) );
						DebugBreak();
					}
					if( rc == SQL_SUCCESS ||
						rc == SQL_SUCCESS_WITH_INFO )
					{
  // -4
						if( ResultLen == SQL_NO_TOTAL ||
  // -1
							ResultLen == SQL_NULL_DATA )
						{
							//lprintf( WIDE("result data failed...") );
						}
						if( ResultLen > 0 )
						{
							if( collection->flags.bBuildResultArray )
							{
								if( collection->coltypes[idx-1] == SQL_LONGVARBINARY )
								{
									// I won't modify this anyhow, and it results
									// to users as a CTEXSTR, preventing them from changing it also...
									//lprintf( "Got a blob..." );
									//lprintf( WIDE( "size is %d" ), collection->colsizes[idx-1] );
									if( pvtData )
									{
										SQLUINTEGER n;
										vtprintf( pvtData, WIDE( "%s<" ), idx>1?WIDE( "," ):WIDE( "" ) );
										for( n = 0; n < collection->colsizes[idx-1]; n++ )
											vtprintf( pvtData, WIDE( "%02x " ), byResult[n] );
										vtprintf( pvtData, WIDE( ">" ) );
									}
									collection->results[idx-1] = NewArray( TEXTCHAR, collection->colsizes[idx-1] );
									//lprintf( WIDE( "dest is %p and src is %p" ), collection->results[idx-1], byResult );
									MemCpy( collection->results[idx-1], byResult, collection->colsizes[idx-1] );
									//lprintf( WIDE( "Column %s colsize %d coltype %d coltype %d idx %d" ), collection->fields[idx-1], colsize, coltype, coltypes[idx-1], idx );
									//collection->results[idx-1] = (TEXTSTR)Deblobify( byResult, colsizes[idx-1] );
								}
								else
								{
									if( collection->results[idx-1] )
										Release( (char*)collection->results[idx-1] );
									if( pvtData )vtprintf( pvtData, WIDE( "%s%s" ), idx>1?WIDE( "," ):WIDE( "" ), byResult );
									collection->results[idx-1] = StrDup( byResult );
								}
							}
							else
							{
								//lprintf( WIDE("Got a result: \'%s\'"), byResult );
								/*
								* if this is auto processed for the application, there is no
								* result indicator indicating how long it is, therefore the application
								* must in turn call Deblobify or some other custom routine to handle
								* this SQL database's binary format...
								*/
								/*
								if( coltypes[idx-1] == SQL_LONGVARBINARY )
								{
								POINTER tmp;
								vtprintf( collection->pvt_result, WIDE("%s%s"), first?WIDE( "" ):WIDE( "," ), tmp = Deblobify( byResult, collection->colsizes[idx-1] ) );
								Release( tmp );
								}
								else
								*/
								vtprintf( collection->pvt_result, WIDE("%s%s"), first?WIDE( "" ):WIDE( "," ), byResult );
								if( pvtData )vtprintf( pvtData, WIDE( "%s%s" ), idx>1?WIDE( "," ):WIDE( "" ), byResult );
								first = 0;
							}
						}
						else
						{
							if( !collection->flags.bBuildResultArray )
							{
								//lprintf( WIDE("Didn't get a result... null field?") );
								vtprintf( collection->pvt_result, WIDE("%s"), first?WIDE( "" ):WIDE( "," ) );
								if( pvtData )vtprintf( pvtData, WIDE( "%s%s" ), idx>1?WIDE( "," ):WIDE( "" ), byResult );
								first=0;
							}
							else
							{
								if( pvtData )vtprintf( pvtData, WIDE( "%s<NULL>" ), idx>1?WIDE( "," ):WIDE( "" ) );
							}
							// otherwise the entry will be NULL
						}
					}
					else
					{
						retry = DumpInfo( odbc, collection->pvt_errorinfo, SQL_HANDLE_STMT, &collection->hstmt, odbc->flags.bNoLogging );
						lprintf( WIDE("GetData failed...") );
						result_cmd = WM_SQL_RESULT_ERROR;
					}
				}
#endif
				idx++;
			} while( idx <= collection->columns
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#else
					  && rc == SQL_SUCCESS
#endif
					 );
			//lprintf( WIDE("done...") );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
#else
			rc = SQL_SUCCESS;
#endif
		}
		else
		{
			// turns out the results will be released at the next command/query that uses this
			// or connection closes and destroyes the collection.
			collection->flags.bTemporary = 1;
			collection->flags.bEndOfFile = 1;
			sqlite3_finalize( collection->stmt );
			collection->stmt = NULL;
			//lprintf( WIDE("What about the remainging results?") );
			//ReleaseCollectionResults( collection );
		}
		if( pvtData )
		{
			PTEXT data = VarTextGet( pvtData );
			lprintf( "%s", GetText( data ) );
			LineRelease( data );
			//lprintf( WIDE( "%s" ), GetText( VarTextPeek( pvtData ) ) );
			VarTextDestroy( &pvtData );
		}
		/* these were temporary for collectiong other meta information */
		if( tmpResult )
		{
			Release( tmpResult );
			tmpResult = NULL;
		}
		if( !lines )
		{
			// might want a different result here...
			// is am empty row result.
			//lprintf( WIDE("Result with no lines...") );
			result_cmd = WM_SQL_RESULT_NO_DATA;
			GenerateResponce( collection, result_cmd );
			//DestroyCollection( collection );
			if( odbc->flags.bThreadProtect )
			{
				odbc->nProtect--;
				LeaveCriticalSec( &odbc->cs );
			}
			return 0;
		}
	}
	else
	{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		if( odbc->flags.bSQLite_native ){
		}
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
		else
#endif
#ifdef USE_ODBC
			retry = DumpInfo( odbc, collection->pvt_errorinfo, SQL_HANDLE_STMT, &collection->hstmt, odbc->flags.bNoLogging );
#endif
		lprintf( WIDE("result error") );
		result_cmd = WM_SQL_RESULT_ERROR;
	}
#endif
	GenerateResponce( collection, result_cmd );
	if( odbc->flags.bThreadProtect )
	{
		odbc->nProtect--;
		LeaveCriticalSec( &odbc->cs );
	}
	return 0;
}
//-----------------------------------------------------------------------
int FetchSQLRecord( PODBC odbc, CTEXTSTR **result )
{
	if( result )
	{
		if( *result )
			*result = NULL;
		if( !odbc )
			odbc = g.odbc;
		if( odbc )
		{
			if( odbc->flags.bThreadProtect )
			{
				EnterCriticalSec( &odbc->cs );
				odbc->nProtect++;
			}
			while( odbc->collection && odbc->collection->flags.bTemporary )
			{
				DestroyCollector( odbc->collection );
			}
			if( !odbc->collection )
			{
				lprintf( WIDE("Lost ODBC result collection...") );
				return 0;
			}
			odbc->collection->flags.bBuildResultArray = 1;
			 __GetSQLResult( odbc, odbc->collection, FALSE );
			if( odbc->collection->responce == WM_SQL_RESULT_DATA )
			{
				*result = (CTEXTSTR*)odbc->collection->results;
				// claim that we grabbed that...
				//odbc->collection->results = NULL;
			}
			if( odbc->flags.bThreadProtect )
			{
				LeaveCriticalSec( &odbc->cs );
				odbc->nProtect--;
			}
			return odbc->collection->responce == WM_SQL_RESULT_DATA?TRUE:0;
		}
	}
	return FALSE;
}
//-----------------------------------------------------------------------
SQLPROXY_PROC( int, FetchSQLResult )( PODBC odbc, CTEXTSTR *result )
{
	if( result )
		(*result) = NULL;
	if( !odbc )
		odbc = g.odbc;
	if( odbc )
	{
		if( odbc->flags.bThreadProtect )
		{
			EnterCriticalSec( &odbc->cs );
			odbc->nProtect++;
		}
		odbc->collection->flags.bBuildResultArray = 0;
		__GetSQLResult( odbc, odbc->collection, FALSE );
		if( odbc->collection->responce == WM_SQL_RESULT_DATA )
		{
			odbc->collection->result_text = VarTextPeek( odbc->collection->pvt_result );
			if( odbc->collection->result_text )
			{
				(*result) = GetText( odbc->collection->result_text );
			}
			else
			{
				if( odbc->flags.bThreadProtect )
				{
					LeaveCriticalSec( &odbc->cs );
					odbc->nProtect--;
				}
				return 0;
			}
		}
		if( odbc->flags.bThreadProtect )
		{
			LeaveCriticalSec( &odbc->cs );
			odbc->nProtect--;
		}
		return odbc->collection->responce == WM_SQL_RESULT_DATA?TRUE:0;
	}
	return FALSE;
}
//-----------------------------------------------------------------------
int GetSQLRecord( CTEXTSTR **result )
{
	if( result )
	{
		if( !OpenSQL( DBG_VOIDSRC ) )
		{
			return FALSE;
		}
		return FetchSQLRecord( g.odbc, result );
	}
	return FALSE;
}
//-----------------------------------------------------------------------
int GetSQLResult( CTEXTSTR *result )
{
	if( result )
	{
		if( !OpenSQL( DBG_VOIDSRC ) )
		{
			return FALSE;
		}
		return FetchSQLResult( g.odbc, result );
	}
	return FALSE;
}
//-----------------------------------------------------------------------
int __DoSQLQueryExx( PODBC odbc, PCOLLECT collection, CTEXTSTR query, size_t queryLength DBG_PASS )
{
	size_t queryLen;
	PTEXT tmp = NULL;
	int retry = 0;
#ifdef USE_ODBC
	RETCODE rc;
#endif
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	int rc3;
#endif
	int in_error = 0;
#ifdef LOG_EVERYTHING
	_lprintf(DBG_RELAY)( WIDE( ".... begin query.... " ));
#endif
	if( !query )
	{
		xlprintf(LOG_ALWAYS)( WIDE("REally should pass a query if you expect a query (was passed NULL).") );
		return FALSE;
	}
	if( !odbc )
	{
		Log( WIDE("Delayed QUERY") );
		if( collection->lastop != LAST_QUERY )
		{
			collection->lastop = LAST_QUERY;
			vtprintf( collection->pvt_out, WIDE("%s"), query );
		}
		else
		{
			lprintf( WIDE("Should not be a new query...") );
		}
		//collection->hLastWnd = hWnd;
		return FALSE;
	}
	if( !odbc )
	{
		DebugBreak();
	}
	if( !IsSQLOpen( odbc ) )
	{
		return FALSE;
	}
	odbc->last_command_tick_ = timeGetTime();
	if( odbc->last_command_tick )
		odbc->last_command_tick = odbc->last_command_tick_;
	if( odbc->flags.bThreadProtect )
	{
		EnterCriticalSec( &odbc->cs );
		odbc->nProtect++;
	}
	//lprintf( WIDE("Query: %s"), GetText( cmd ) );
	ReleaseCollectionResults( collection, TRUE );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
	{
		if( collection->stmt )
		{
			sqlite3_finalize( collection->stmt );
			collection->stmt = NULL;
		}
	}
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
	else
#endif
#ifdef USE_ODBC
	{
		if( collection->hstmt )
		{
#ifdef LOG_EVERYTHING
			lprintf( WIDE( "Releasing old handle... %p" ), collection->hstmt );
#endif
			SQLFreeHandle( SQL_HANDLE_STMT, collection->hstmt );
			collection->hstmt = 0;
		}
	}
#endif
	// try and get query from collector if NULL
	if( query )
	{
		VarTextEmpty( collection->pvt_out );
		VarTextAddData( collection->pvt_out, query, queryLength );
		//vtprintf( collection->pvt_out, WIDE( "%s" ), query );
	}
	{
		tmp = VarTextPeek( collection->pvt_out );
		query = GetText( tmp );
		queryLen = GetTextSize( tmp );
	}
	if( EnsureLogOpen(odbc ) )
	{
		sack_fprintf( g.pSQLLog, WIDE("%s[%p]:%s\n"), odbc->info.pDSN?odbc->info.pDSN:WIDE( "NoDSN?" ), odbc, query );
		sack_fflush( g.pSQLLog );
	}
	if( !g.flags.bNoLog )
	{
		if( odbc->flags.bNoLogging )
			//odbc->hidden_messages++
			;
		else
			_lprintf(DBG_RELAY)( WIDE( "Do Command[%p:%s]: %s" ), odbc
					, odbc->info.pDSN?odbc->info.pDSN:WIDE( "NoDSN?" )
					, query );
	}
	//lprintf( DBG_FILELINEFMT WIDE( "Query: %s" ) DBG_RELAY, GetText( query ) );
#ifdef LOG_EVERYTHING
	lprintf( WIDE( "sql command on %p [%s]" ), collection, query );
#endif
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
	{
		const TEXTCHAR *tail;
		// can get back what was not used when parsing...
		retry:
#ifdef UNICODE
		rc3 = sqlite3_prepare16_v2( odbc->db, (void*)query, (int)(querylen) * sizeof( TEXTCHAR ), &collection->stmt, (const void**)&tail );
#else
		rc3 = sqlite3_prepare_v2( odbc->db, query, (int)(queryLen), &collection->stmt, &tail );
#endif
		if( rc3 )
		{
			const char *tmp;
			if( rc3 == SQLITE_BUSY )
			{
				lprintf( WIDE("wait for lock...") );
				DumpAllODBCInfo();
				WakeableSleep( 200 );
				goto retry;
			}
			//DebugBreak();
			tmp = sqlite3_errmsg(odbc->db);
         // this will have to have a Char based version
			if( strnicmp( tmp, "no such table", 13 ) == 0 )
				vtprintf( collection->pvt_errorinfo, WIDE( "(S0002)" ) );
			vtprintf( collection->pvt_errorinfo, WIDE( "Result of prepare failed? %s at-or near char %")_size_f WIDE("[%") _cstring_f WIDE("] in [%") _string_f WIDE("]" ), tmp, tail - query, tail, query );
			if( EnsureLogOpen(odbc ) )
			{
				sack_fprintf( g.pSQLLog, WIDE( "#SQLITE ERROR:%s\n" ), GetText( VarTextPeek( collection->pvt_errorinfo ) ) );
				sack_fflush( g.pSQLLog );
			}
			in_error = 1;
		} else {
			if( odbc->flags.bAutoCheckpoint && !sqlite3_stmt_readonly( collection->stmt ) )
				startAutoCheckpoint( odbc );
		}
		// here don't step, wait for the GetResult to step. (fetch row)
	}
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
	else
#endif
#ifdef USE_ODBC
	{
#ifdef LOG_EVERYTHING
		lprintf( WIDE( "getting a new handle....against %p on %p" ), odbc->hdbc, odbc );
#endif
		rc = SQLAllocHandle( SQL_HANDLE_STMT
								 , odbc->hdbc
								 , &collection->hstmt );
		if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
		{
			xlprintf(LOG_ALWAYS)( WIDE("Failed to open ODBC statement handle....") );
			if( odbc->flags.bThreadProtect )
			{
				odbc->nProtect--;
				LeaveCriticalSec( &odbc->cs );
			}
			return FALSE;
		}
#ifdef LOG_EVERYTHING
		lprintf( WIDE( "new handle... %p" ), collection->hstmt );
#endif
		if( StrCmp( query, WIDE("show tables") ) == 0 )
		{
			rc = SQLTables( collection->hstmt, NULL, 0, NULL, 0, NULL, 0, NULL, 0 );
		}
		else
		{
			rc = SQLExecDirect( collection->hstmt
									,
#ifdef _UNICODE
									 (SQLWCHAR*)query
#else
									 (SQLCHAR*)query
#endif
									, SQL_NTS );
		}
		if( rc != SQL_SUCCESS && rc != SQL_SUCCESS_WITH_INFO )
		{
#ifdef LOG_EVERYTHING
			lprintf( WIDE( "rc is %d [not success]" ),rc );
#endif
			in_error = 1;
		}
	}
#endif
	if( in_error )
	{
		//PTEXT tmp;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		if( odbc->flags.bSQLite_native )
		{
		}
#endif
#if defined( USE_ODBC ) && defined( USE_SQLITE )
		else
#endif
#ifdef USE_ODBC
		{
			retry = DumpInfo( odbc, collection->pvt_errorinfo, SQL_HANDLE_STMT, &collection->hstmt, odbc->flags.bNoLogging );
		}
#endif
		GenerateResponce( collection, WM_SQL_RESULT_ERROR );
		if( odbc->flags.bThreadProtect )
		{
			odbc->nProtect--;
			LeaveCriticalSec( &odbc->cs );
		}
		return retry;
	}
	/*
	*/
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
		collection->columns = (SQLSMALLINT)sqlite3_column_count(collection->stmt);
#endif
#if ( defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE ) ) && defined( USE_ODBC )
	  else
#endif
#ifdef USE_ODBC
	  {
		  if( SQLNumResultCols(collection->hstmt, &collection->columns ) != SQL_SUCCESS )
		  {
			  lprintf( WIDE("Failed to get result cols...") );
			  retry = DumpInfo( odbc, collection->pvt_errorinfo
									, SQL_HANDLE_STMT
									, &collection->hstmt
									, odbc->flags.bNoLogging);
			  GenerateResponce( collection, WM_SQL_RESULT_ERROR );
			  //DestroyCollector( collection );
			  if( odbc->flags.bThreadProtect )
			  {
				  odbc->nProtect--;
				  LeaveCriticalSec( &odbc->cs );
			  }
			  return retry ;
		}
	}
#endif
	//lprintf( WIDE("Get result ...") );
	retry = __GetSQLResult( odbc, collection, FALSE );
	if( odbc->flags.bThreadProtect )
	{
		odbc->nProtect--;
		LeaveCriticalSec( &odbc->cs );
	}
	return retry;
}
//------------------------------------------------------------------
int __DoSQLQueryEx( PODBC odbc, PCOLLECT collection, CTEXTSTR query DBG_PASS ) {
	return __DoSQLQueryExx( odbc, collection, query, strlen( query ) DBG_RELAY );
}
//------------------------------------------------------------------
void PopODBCExx( PODBC odbc, LOGICAL bAllowNonPush DBG_PASS )
{
	//lprintf( WIDE( "pop sql %p" ), odbc );
	if( !odbc )
		odbc = g.odbc;
	if( odbc )
	{
		// pop odbc should pop util a push?
		while( odbc->collection && odbc->collection->flags.bTemporary
				// if it is end of file, it is probable, that it was also the
				// result of a push...
				&& !odbc->collection->flags.bPushed
			  )
			DestroyCollector( odbc->collection );
		//lprintf( WIDE( "Pop ODBC %p %d %p %d" ), odbc, bAllowNonPush, odbc->collection, odbc->collection?odbc->collection->flags.bPushed:-1 );
		if( odbc->collection && !odbc->collection->flags.bPushed && !bAllowNonPush )
		{
			//DebugBreak();
			_lprintf(DBG_RELAY)( WIDE( "Warning! Popping a state which was not pushed! (should be a breakpoint here)" ) );
		}
		DestroyCollector( odbc->collection );
	}
}
//------------------------------------------------------------------
void SQLEndQuery( PODBC odbc )
{
	if( !odbc )
		odbc = g.odbc;
	if( odbc )
	{
		// pop odbc should pop util a push?
		while( odbc->collection && odbc->collection->flags.bTemporary
				// if it is end of file, it is probable, that it was also the
				// result of a push...
				&& !odbc->collection->flags.bPushed
			  )
		{
			if( odbc->collection->flags.bEndOfFile )
			{
#ifdef LOG_COLLECTOR_STATES
				lprintf( WIDE( "Okay, top temporary found, but it was also a query at end of file... set end of file OK. return." ) );
#endif
				//return;
			}
			DestroyCollector( odbc->collection );
		}
//&& odbc->collection->flags.bPushed )
		if( odbc->collection )
		{
			//lprintf( WIDE( "Should have ended with a pop not a EndQuery DebugBreak()" ) );
			//DebugBreak();
#ifdef LOG_COLLECTOR_STATES
			lprintf( WIDE( "End Query forces temporary and end of recordset. (more like a seek(end)" ) );
#endif
			odbc->collection->flags.bTemporary = 1;
			odbc->collection->flags.bEndOfFile = 1;
		}
	}
//	PopODBCExx( odbc, TRUE );
}
//-----------------------------------------------------------------------
int SQLRecordQueryExx( PODBC odbc
                     , CTEXTSTR query
                     , size_t queryLen
                     , int *nResults
                     , CTEXTSTR **result
                     , size_t **resultLengths
                     , CTEXTSTR **fields DBG_PASS )
{
	PODBC use_odbc;
	int once = 0;
	// clean up what we think of as our result set data (reset to nothing)
	if( result )
		(*result) = NULL;
	if( nResults )
		*nResults = 0;
	do
	{
		if( !IsSQLOpenEx( odbc DBG_RELAY ) )
			return FALSE;
		if( !( use_odbc = odbc ) )
		{
			// setup error as invalid databse handle... well.. try the default one also
			// but mostly fail.
			use_odbc = g.odbc;
		}
		// if not a [sS]elect then begin a transaction.... some code uses query record for everything.
		if( !once && query[0] != 's' && query[0] != 'S' ) {
			once = 1;
			BeginTransactEx( use_odbc, 0 );
		}
		// collection is very important to have - even if we will have to be opened,
		// we ill need one, so make at least one.
		if( !use_odbc->collection || !use_odbc->collection->flags.bTemporary )
		{
			if( use_odbc->collection && use_odbc->collection->flags.bTemporary )
			{
#ifdef LOG_COLLECTOR_STATES
				lprintf( WIDE( "using existing collector..." ) );
#endif
				use_odbc->collection->flags.bTemporary = 0;
			}
			else
			{
#ifdef LOG_COLLECTOR_STATES
				lprintf( WIDE( "creating collector..." ) );
#endif
				use_odbc->collection = CreateCollector( 0, use_odbc, FALSE );
			}
		}
		// if it was temporary, it shouldn't be anymore
		use_odbc->collection->flags.bTemporary = 0;
		// ask the collector to build the type of result set we want...
		use_odbc->collection->flags.bBuildResultArray = 1;
		// this will do an open, and delay queue processing and all sorts
		// of good fun stuff...
	}
	while( __DoSQLQueryExx( use_odbc, use_odbc->collection, query, queryLen DBG_RELAY) );
	if( use_odbc->collection->responce == WM_SQL_RESULT_DATA )
	{
		//lprintf( WIDE("Result with data...") );
		if( nResults )
			(*nResults) = use_odbc->collection->columns;
		if( result )
			(*result) = (CTEXTSTR*)use_odbc->collection->results;
		if( resultLengths )
			(*resultLengths) = use_odbc->collection->result_len;
		// claim that we grabbed that...
		if( fields )
			(*fields) = (CTEXTSTR*)use_odbc->collection->fields;
		//use_odbc->collection->results = NULL;
		return TRUE;
	}
	else if( use_odbc->collection->responce == WM_SQL_RESULT_NO_DATA )
	{
		if( nResults )
			(*nResults) = use_odbc->collection->columns;
		if( resultLengths )
			(*resultLengths) = NULL;
		if( fields )
			(*fields) = (CTEXTSTR*)use_odbc->collection->fields;
		return TRUE;
	}
	return FALSE;
}
//--------------------------------------------------------------------
int SQLRecordQueryEx( PODBC odbc
	, CTEXTSTR query
	, int *nResults
	, CTEXTSTR **result, CTEXTSTR **fields DBG_PASS )
{
	return SQLRecordQueryExx( odbc, query, strlen( query ), nResults, result, NULL, fields DBG_RELAY );
}
//--------------------------------------------------------------------
int SQLQueryEx( PODBC odbc, CTEXTSTR query, CTEXTSTR *result DBG_PASS )
{
	PODBC use_odbc;
	LOGICAL once = 0;
	// clean up our result data....
	if( *result )
		(*result) = NULL;
	// if not a [sS]elect then begin a transaction.... some code might use query for everything.
	do
	{
		if( !IsSQLOpen( odbc ) )
			return FALSE;
		if( !( use_odbc = odbc ) )
		{
			// setup error as invalid databse handle... well.. try the default one also
			// but mostly fail.
			use_odbc = g.odbc;
		}
		if( !once && query[0] != 's' && query[0] != 'S' ) {
			BeginTransactEx( use_odbc, 0 );
			once = 1;
		}
		// this would be hard to come by...
		// there's a collector stil around from the open command.
		if( !use_odbc->collection || !use_odbc->collection->flags.bTemporary )
		{
			if( use_odbc->collection && use_odbc->collection->flags.bTemporary )
			{
#ifdef LOG_COLLECTOR_STATES
				lprintf( WIDE( "using existing collector..." ) );
#endif
				use_odbc->collection->flags.bTemporary = 0;
			}
			else
			{
#ifdef LOG_COLLECTOR_STATES
				lprintf( WIDE( "creating collector...: %s" ), query );
#endif
				use_odbc->collection = CreateCollector( 0, use_odbc, FALSE );
			}
		}
		use_odbc->collection->flags.bTemporary = 0;
		// ask the collector GetSQLResult to build our sort of data...
		use_odbc->collection->flags.bBuildResultArray = 0;
		// go ahead, open connection, issue command, get some data
		// or have some sort of failure along that path.
	}
	while( __DoSQLQueryEx( use_odbc, use_odbc->collection, query DBG_RELAY) );
	if( use_odbc->collection->responce == WM_SQL_RESULT_DATA )
	{
		use_odbc->collection->result_text= VarTextPeek( use_odbc->collection->pvt_result );
		if( use_odbc->collection->result_text )
		{
			//lprintf( WIDE("Result with data...") );
			(*result) = GetText( use_odbc->collection->result_text );
		}
		else
		{
			// ahh here's the key - need to result in an empty string...
			SET_RESULT_STRING( result, WIDE("") );
		}
		//return use_odbc->collection->responce == WM_SQL_RESULT_DATA?TRUE:0;
		return TRUE;
	}
	else if( use_odbc->collection->responce == WM_SQL_RESULT_NO_DATA )
	{
		return TRUE;
	}
	return FALSE;
}
//-----------------------------------------------------------------------
int DoSQLQueryEx( CTEXTSTR query, CTEXTSTR *result DBG_PASS )
{
	(*result) = NULL;
	if( result )
	{
		if( !OpenSQL( DBG_VOIDSRC ) )
		{
			return FALSE;
		}
		return SQLQueryEx( NULL, query, result DBG_RELAY );
	}
	return FALSE;
}
//-----------------------------------------------------------------------
int IsSQLOpenEx( PODBC odbc DBG_PASS )
{
	if( !odbc )
	{
		//lprintf( "open default..." );
		OpenSQL( DBG_VOIDRELAY );
		odbc = g.odbc;
	}
	else
		OpenSQLConnectionEx( odbc DBG_RELAY );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc && odbc->flags.bSQLite_native )
		if( odbc && odbc->db )
			return TRUE;
#endif
#ifdef USE_ODBC
	if( odbc && odbc->hdbc && odbc->flags.bConnected )
	{
		return TRUE;
	}
#endif
	// attempt open?
	// odbc library tends to be sluggish when the database fails connection...
	// I dunno - this is intended to be used in an Idle() loop which will get the timer to fire eventually.
	return FALSE;
}
#undef IsSQLOpen
int IsSQLOpen( PODBC odbc )
{
	return IsSQLOpenEx( odbc DBG_SRC );
}
//-----------------------------------------------------------------------
int IsSQLReady( void )
{
	return IsSQLOpen( g.odbc );
}
//-----------------------------------------------------------------------
int PushSQLQueryExEx( PODBC odbc DBG_PASS )
//#define PushSQLQeuryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
{
	//_lprintf(DBG_RELAY)( "push sql %p", odbc );
	if( !odbc )
		odbc = g.odbc;
	if( odbc && odbc->collection )
	{
#ifdef LOG_COLLECTOR_STATES
		lprintf( WIDE( "creating collector..." ) );
#endif
		CreateCollectorEx( 0, odbc, FALSE DBG_RELAY );
		odbc->collection->flags.bPushed = 1;
		odbc->collection->flags.bTemporary = 1;
#ifdef LOG_COLLECTOR_STATES
		_lprintf(DBG_RELAY)( WIDE("pushing the query onto stack... creating new state.") );
#endif
		//lprintf( WIDE("Adding %p to %p at %p"), collection, odbc, &odbc->collection );
		//LinkThing( odbc->collection, collection );
		return 1;
	}
	else
	{
		if( odbc )
			odbc->flags.bPushed = 1;
	}
	return 0;
}
//-----------------------------------------------------------------------
int PushSQLQuery( void )
{
	return PushSQLQueryEx( g.odbc );
}
#undef PushSQLQueryEx
int PushSQLQueryEx( PODBC odbc )
#define PushSQLQueryEx(odbc) PushSQLQueryExEx(odbc DBG_SRC )
{
	return PushSQLQueryExEx( odbc DBG_SRC );
}
//-----------------------------------------------------------------------
#ifdef SQLPROXY_LIBRARY_SOURCE
// insert commands of these varieties are not used by
// the proxy, so we reall need not host them...
// parameters to this are pairs of "name", bQuote, WIDE("value")
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
static struct {
	struct {
		BIT_FIELD  batch  : 1;
	} flags;
	PVARTEXT pvt_insert;
	PVARTEXT pvt_columns;
	PVARTEXT pvt_values;
	PLIST values;
} sql_insert;
 int  SQLInsertFlush ( PODBC odbc )
{
	int status;
	PVARTEXT pvt = VarTextCreate();
	PTEXT tmp, tmp2;
	if( !odbc )
	{
		if( !OpenSQL( DBG_VOIDSRC ) )
			return FALSE;
		odbc = g.odbc;
	}
	tmp = VarTextGet( sql_insert.pvt_insert );
	tmp2 = VarTextGet( sql_insert.pvt_columns );
	vtprintf( pvt, WIDE( "%s (%s) values " ), GetText( tmp ), GetText(  tmp2 ) );
	{
		int first = 1;
		PTEXT value;
		INDEX idx;
		LIST_FORALL( sql_insert.values, idx, PTEXT, value )
		{
			vtprintf( pvt, WIDE( "%s(%s)" ), first?WIDE( "" ):WIDE( "," ), GetText( value ) );
			first = 0;
			LineRelease( value );
			SetLink( &sql_insert.values, idx, NULL );
		}
	}
	LineRelease( tmp );
	LineRelease( tmp2 );
	tmp = VarTextGet( pvt );
	status = SQLCommand( odbc, GetText( tmp ) );
	LineRelease( tmp );
	VarTextDestroy( &pvt );
	sql_insert.flags.batch = 0;
	return status;
}
 int  SQLInsertBegin ( PODBC odbc )
{
	if( sql_insert.flags.batch )
		SQLInsertFlush( odbc );
	sql_insert.flags.batch = 1;
	return 1;
}
 int  vSQLInsert ( PODBC odbc, CTEXTSTR table, va_list args )
{
	// need to do this so we know if the default odbc is perhaps
	// a MSAccess database...
	if( !odbc )
	{
		if( !OpenSQL( DBG_VOIDSRC ) )
			return FALSE;
		odbc = g.odbc;
	}
	{
		int quote;
		int first;
		char *varname;
		char *varval;
		int making_columns;
		const TEXTCHAR *open_quote_string, *close_quote_string;
		first = 1;
		// once I thought values for access were [ ] enclosed...
		// so now this is a silly variable...
		open_quote_string = WIDE( "\'" );
		close_quote_string = WIDE( "\'" );
		//Log2( WIDE("Command = %p (%d)"), command, 12 + strlen( table ) + nVarLen + 7 + nValLen );
		if( !sql_insert.pvt_insert )
		{
			sql_insert.pvt_insert = VarTextCreate();
			sql_insert.pvt_columns = VarTextCreate();
			sql_insert.pvt_values = VarTextCreate();
		}
		if( !sql_insert.flags.batch || !VarTextPeek( sql_insert.pvt_insert ) )
		{
			if( odbc && odbc->flags.bAccess )
				vtprintf( sql_insert.pvt_insert, WIDE("Insert into [%s]"), table );
			else
				vtprintf( sql_insert.pvt_insert, WIDE("Insert into `%s`"), table );
		}
		first = 1;
		making_columns = 0;
		for( varname = va_arg( args, char * );
			varname;
			varname = va_arg( args, char * ) )
		{
			if( making_columns || !sql_insert.flags.batch || !VarTextPeek( sql_insert.pvt_columns ) )
			{
				making_columns = 1;
				vtprintf( sql_insert.pvt_columns, WIDE( "%s%s" ), first?WIDE( "" ):WIDE( "," ), varname );
			}
			quote = va_arg( args, int );
			varval = va_arg( args, char *);
			if( quote == 2)
			{
				vtprintf( sql_insert.pvt_values, WIDE("%s%d")
					, first?WIDE( "" ):WIDE( "," )
 // this generates an error - typecast to different size.  This is probably okay... but that means we needed to have it push a 8 byte value here ...
					, (int)(uintptr_t)varval
					);
			}
			else
				vtprintf( sql_insert.pvt_values, WIDE("%s%s%s%s")
				, first?WIDE( "" ):WIDE( "," )
				, quote?open_quote_string:WIDE( "" )
				, varval
				, quote?close_quote_string:WIDE( "" )
				);
			first = 0;
		}
		if( !sql_insert.flags.batch )
		{
			AddLink( &sql_insert.values, VarTextGet( sql_insert.pvt_values ) );
			return SQLInsertFlush( odbc );
		}
		else
			AddLink( &sql_insert.values, VarTextGet( sql_insert.pvt_values ) );
	}
	return FALSE;
}
//------------------------------------------------------------------
 int  DoSQLInsert ( CTEXTSTR table, ... )
{
	va_list args;
	if( !OpenSQL( DBG_VOIDSRC ) )
	{
		return FALSE;
	}
	va_start( args, table );
	return vSQLInsert( g.odbc, table, args );
}
//------------------------------------------------------------------
// parameters to this are pairs of "name", bQuote, WIDE("value")
// the last pair's name is NULL, and value does not matter.
// insert values into said table.
 int  SQLInsert ( PODBC odbc, CTEXTSTR table, ... )
{
	va_list args;
	va_start( args, table );
	return vSQLInsert( odbc, table, args );
}
#endif
//-----------------------------------------------------------------------
#define natoi(n, p,len) for( n = 0, cnt = 0; p[cnt] && cnt < len; cnt++ ) (n) = ((n)*10) + (p)[cnt] - '0'; if( p[0] ) p += len;
void ConvertSQLDateEx( CTEXTSTR date
                     , int *year, int *month, int *day
                     , int *hour, int *minute, int *second
                     , int *msec, int32_t *nsec
                     , int *zone_ofs_hr, int *zone_ofs_mn
                     )
{
	CTEXTSTR p;
	int n, cnt;
	p = date;
	if( msec )
		*msec = 0;
	if( nsec )
		*nsec = 0;
	natoi( n, p, 4 ); if( year ) *year = n;
	if( p[0]=='-' || p[0] == '/' ) p++;
	natoi( n, p, 2 ); if( month ) *month = n;
	if( p[0]=='-' || p[0] == '/' ) p++;
	natoi( n, p, 2 ); if( day ) *day = n;
	if( p[0] )
	{
		if( p[0]== 'T' || p[0] == ' ' || p[0] == '-'  ) p++;
		natoi( n, p, 2 ); if( hour ) *hour = n;
		if( p[0]==':' ) p++;
		natoi( n, p, 2 ); if( minute ) *minute = n;
		if( p[0]==':' ) p++;
		natoi( n, p, 2 ); if( second ) *second = n;
		if( p[0]=='.' ) {
			p++;
			natoi( n, p, 3 ); if( msec ) *msec = n;
		}
	}
	else
	{
		if( hour ) *hour = 0;
		if( minute ) *minute = 0;
		if( second ) *second = 0;
	}
	if( p[0] )
	{
		int add_zone = 1;
		if( p[0] == ' ' )
			p++;
		if( p[0] == 'Z' )
		{
			p++;
			if( zone_ofs_hr ) (*zone_ofs_hr) = 0;
			if( zone_ofs_mn ) (*zone_ofs_mn) = 0;
		}
		else if( p[0] == '+' )
		{
			p++;
			add_zone = 1;
		}
		else if( p[0] == '-' )
		{
			p++;
			add_zone = 0;
		}
		natoi( n, p, 2 ); if( zone_ofs_hr ) (*zone_ofs_hr) = add_zone?n:-n;
		if( p[0] == ':' ) p++;
		natoi( n, p, 2 ); if( zone_ofs_mn ) (*zone_ofs_mn) = n;
	}
	else
	{
		if( zone_ofs_hr ) (*zone_ofs_hr) = 0;
		if( zone_ofs_mn ) (*zone_ofs_mn) = 0;
	}
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
//#ifdef SQL_PROXY_SERVER
//-----------------------------------------------------------------------
void CPROC Timer( uintptr_t psv )
{
	// this attempts to re-open backup and/or primary
	// and within this is dispatched the backup/restore/init
	// tasks.
	//Log( WIDE("Tick...") );
	OpenSQL( DBG_VOIDSRC );
	if( g.odbc )
	{
		//VarTextEmpty( g.TimerCollect.pvt_out );
		g.flags.bNoLog = 1;
		// this is a command... this is only a command...
		__DoSQLQuery( g.odbc, &g.TimerCollect, WIDE("select 0") );
		if( g.TimerCollect.responce != WM_SQL_RESULT_DATA )
		{
			FailConnection( g.odbc );
			Log( WIDE("Connection FAILED!") );
		}
		else
		{
			// setup for next tick
		}
		g.flags.bNoLog = 0;
	}
}
//-----------------------------------------------------------------------
static void LoadTasks( void )
{
	int n;
	for( n = 1; ;n++ )
	{
		TEXTCHAR taskid[32];
		TEXTCHAR updatetask[256];
		tnprintf( taskid, sizeof( taskid ), WIDE("Task%d"), n );
		updatetask[0] = 0;
		//OptGetPrivateProfileString( WIDE("Recovery Update"), taskid, WIDE(""), updatetask, sizeof( updatetask ), SQL_INI );
		if( updatetask[0] )
		{
			PUPDATE_TASK task = (PUPDATE_TASK)Allocate( sizeof( UPDATE_TASK ) );
			lprintf( WIDE("Task: \'%s\'"), updatetask );
			StrCpyEx( task->name, updatetask, sizeof( task->name ) );
			task->PrimaryRecovered = (void(CPROC *)(PODBC,PODBC))LoadFunction( task->name, WIDE("_PrimaryRecovered") );
			// it better never be  a post _ which implies register convention
			//if( !task->PrimaryRecovered )
			// task->PrimaryRecovered = (void(CPROC *)(PODBC,PODBC))LoadFunction( task->name, WIDE("PrimaryRecovered_") );
			if( !task->PrimaryRecovered )
				task->PrimaryRecovered = (void(CPROC *)(PODBC,PODBC))LoadFunction( task->name, WIDE("PrimaryRecovered") );
			if( !task->PrimaryRecovered )
			{
				lprintf( WIDE("Failure to get task from plugin: %s"), updatetask );
				//MessageBox( NULL, WIDE("Failure to load plugin!"), WIDE("Update Task Error"), MB_OK );
				//Release( task );
			}
			task->CheckTables = (void(CPROC *)(PODBC))LoadFunction( task->name, WIDE("_CheckTables") );
			// it better never be  a post _ which implies register convention
			//if( !task->CheckTables )
			// task->CheckTables = (void(CPROC *)(PODBC))LoadFunction( task->name, WIDE("CheckTables_") );
			if( !task->CheckTables )
				task->CheckTables = (void(CPROC *)(PODBC))LoadFunction( task->name, WIDE("CheckTables") );
			if( !task->CheckTables )
			{
				lprintf( WIDE("Failure to get task from plugin: %s"), updatetask );
				//MessageBox( NULL, WIDE("Failure to load plugin!"), WIDE("Update Task Error"), MB_OK );
				//Release( task );
			}
			LinkThing( g.UpdateTasks, task );
		}
		else
		{
			lprintf( WIDE("Task: %s"), updatetask );
			break;
		}
	}
}
//--------------------------------------------------------------------------
int CPROC SQLServiceHandler( PSERVICE_ROUTE SourceRouteID
									, uint32_t MsgID
									, uint32_t *params, size_t param_length
									, uint32_t *result, size_t *result_length )
{
	//uint32_t result_buffer_length = (*result_length);
	PCOLLECT pCollector = FindCollection( NULL, SourceRouteID );
	// extended messages may provide a way to specify alternate ODBC sources of collectors
	//pCollector->result_buffer = result;
	//pCollector->result_len = result_length;
	if( MsgID != WM_SQL_GET_ERROR
		&& MsgID!= MSG_ServiceLoad
		&& MsgID!= MSG_ServiceUnload )
	{
		if( !IsSQLReady() )
		{
			// result timeout to client. forget this message.
			//(*result_length) = INVALID_INDEX; // by default
			lprintf( WIDE("SQL is not ready...") );
			if( pCollector && pCollector->lastop )
			{
				PTEXT prior;
				// return unexpected ERROR results!
				lprintf( WIDE("SQL command pending already! FAILURE!") );
				prior = VarTextPeek( pCollector->pvt_out );
				lprintf( WIDE("prior command: %s"), GetText( prior ) );
				return FALSE;
			}
			//return TRUE;
		}
	}
	// respond to command after processing
	// success/failure information only applies.
	// no data ever results from this?
	if( result_length )
 // by default
		(*result_length) = (uint32_t)INVALID_INDEX;
	{
		// do stuff here
		switch( MsgID )
		{
		case MSG_ServiceLoad:
			lprintf( WIDE("Service load request... respond with correct startup!") );
			result[0] = WM_SQL_NUM_MESSAGES;
			result[1] = WM_SQL_NUM_MESSAGES;
			(*result_length) = (uint32_t)((result+2) - result);
			return TRUE;
		case MSG_ServiceUnload:
			//do
			{
				PCOLLECT pCollect = g.collections;
										// collectors are non-odbc connection specific.
										// they are more like a queue of pending requests against
										// either their own, specified ODBC or the primary/backup path.
				for( pCollect = g.collections;
					  pCollect;
					  pCollect = NextThing( pCollect) )
				{
					if( pCollect->SourceID == SourceRouteID )
					{
						lprintf( WIDE("Destrying collector for client which is gone.") );
						DestroyCollector( pCollector );
					}
				}
					// also destroy all odbc connectors created
						// by this colient!
 //while( ( pCollector = FindCollection( NULL, SourceRouteID ) ) );
			}
			return TRUE;
		case WM_SQL_COMMAND:
			lprintf( WIDE("Do SQL Command...") );
			// application will get a timeout on this message.
			//
			// who I am and who they are is implied with this message stream...
/*, g.message_id */
			__DoSQLCommand( g.odbc, Collect( pCollector, params, param_length  ) );
			return TRUE;
		case WM_SQL_QUERY:
			lprintf( WIDE("Do SQL Query...") );
			// query will be already on the collector...
			pCollector->flags.bBuildResultArray = 0;
			__DoSQLQuery( g.odbc, Collect( pCollector, params, param_length ), NULL );
			return TRUE;
		case WM_SQL_QUERY_RECORD:
			lprintf( WIDE("Do SQL Query...") );
			// query will be already on the collector...
			pCollector->flags.bBuildResultArray = 1;
			__DoSQLQuery( g.odbc, Collect( pCollector, params, param_length ), NULL );
			return TRUE;
		case WM_SQL_GET_ERROR:
			__GetSQLError( g.odbc, pCollector );
			return TRUE;
		case WM_SQL_MORE:
			lprintf( WIDE("Do SQL More...") );
			__GetSQLResult( g.odbc, pCollector, TRUE );
			return TRUE;
		case WM_SQL_RESULT_SUCCESS:
			lprintf( WIDE("Unexpected result success to SQL Proxy server!") );
			return TRUE;
		case WM_SQL_RESULT_ERROR:
			lprintf( WIDE("Unexpected result error to SQL Proxy server!") );
			return TRUE;
		case WM_SQL_RESULT_DATA:
			lprintf( WIDE("Unexpected result data to SQL Proxy server!") );
			return TRUE;
		case WM_SQL_DATA_START:
			// should validate that we're not already
			// collecting...
			{
				lprintf( WIDE("Start collect data") );
				if( VarTextLength( pCollector->pvt_out ) )
				{
					lprintf( WIDE("Was already having data collected at start... dropping it.") );
					LineRelease( VarTextGet( pCollector->pvt_out ) );
				}
				Collect( pCollector, params, param_length );
			}
			return TRUE;
		case WM_SQL_DATA_MORE:
			lprintf( WIDE("Add more data...") );
			Collect( pCollector, params, param_length );
			return TRUE;
		}
	}
 // respond failure, if there is a responce...
	return FALSE;
}
//--------------------------------------------------------------------------
#if 0
void SQLBeginService( void )
//int main( void )
{
	SqlStubInitLibrary();
	// provide task interface
#ifndef __NO_MSGSVR__
	RegisterServiceHandler( WIDE("SQL"), SQLServiceHandler );
#endif
	// load local schedulable tasks...
	LoadTasks();
	// should probably add some options about what exactly
	// we would wish to log... but for now, and for testing
	// purposes, we log both query and command strings.
#ifdef __HAVE_ICON___
	RegisterIcon( PROXY_DOWN );
#endif
	while( 1 )
	{
		// this COULD be a timerproc...
		// but the main app isn't doing anything so
		// I guess it can do the SQL-alive probing.
		Timer(0);
#ifdef _DEBUG
		// one second wake mode...
		WakeableSleep( 1000 );
#else
		WakeableSleep( 30000 );
		// try every 30 seconds in the real world...
#endif
	}
#ifdef __HAVE_ICON___
	UnregisterIcon();
#endif
	//return 0;
}
#endif
//-------------------------------------------------------------------------
void SQLSetUserData( PODBC odbc, uintptr_t psvUser )
{
	odbc->psvUser = psvUser;
}
//-------------------------------------------------------------------------
uintptr_t SQLGetUserData( PODBC odbc )
{
	return odbc->psvUser;
}
struct day_type_offset
{
	CTEXTSTR type;
	CTEXTSTR result;
};
CTEXTSTR GetSQLOffsetDate( PODBC odbc, CTEXTSTR BeginOfDayType, int default_begin )
{
	TEXTCHAR result[80];
	TEXTCHAR offset[25];
	TEXTCHAR default_val[12];
	int hours, minutes;
	INDEX idx;
	struct day_type_offset *dto;
	LIST_FORALL( g.date_offsets, idx, struct day_type_offset *, dto )
	{
		if( StrCaseCmp( dto->type, BeginOfDayType ) == 0 )
			return dto->result;
	}
	{
		dto = New( struct day_type_offset );
		dto->type = StrDup( BeginOfDayType );
		if( default_begin > 100 )
			tnprintf( default_val, sizeof( default_val ), WIDE( "%d:%02d" ), default_begin / 100, default_begin % 100 );
		else
			tnprintf( default_val, sizeof( default_val ), WIDE( "%d" ), default_begin );
#ifndef __NO_OPTIONS__
		SACK_GetProfileString( WIDE( "SACK/SQL/Day Offset" ), BeginOfDayType, default_val, offset, sizeof( offset ) );
#else
		StrCpyEx( offset, default_val, sizeof( offset ) );
#endif
		if( StrChr( offset, ':' ) )
		{
			tscanf( offset, WIDE( "%d:%d" ), &hours, &minutes );
		}
		else
		{
			minutes = 0;
			tscanf( offset, WIDE( "%d" ), &hours );
		}
		tnprintf( result, sizeof( result ), WIDE( "cast(date_add(now(),interval -%d minute) as date)" ), hours*60+minutes );
		dto->result = StrDup( result );
		AddLink( &g.date_offsets, dto );
	}
	return dto->result;
}
#undef PopODBCEx
void PopODBCEx( PODBC odbc )
{
	PopODBCExx( odbc, FALSE DBG_SRC );
}
#undef PopODBC
void PopODBC( void )
{
	PopODBCEx( NULL );
}
PODBC SQLGetODBCEx( CTEXTSTR dsn, CTEXTSTR user, CTEXTSTR pass )
{
	INDEX idx;
	struct odbc_queue *queue;
retry:
	LIST_FORALL( g.odbc_queues, idx, struct odbc_queue*, queue )
	{
		if( StrCaseCmp( dsn, queue->name ) == 0 )
		{
			PODBC odbc = (PODBC)DequeLink( &queue->connections );
			if( odbc )
				odbc->queue = queue;
			if( !odbc )
				odbc = ConnectToDatabaseLogin( dsn, user, pass, FALSE DBG_SRC );
			if( odbc )
				odbc->queue = queue;
			return odbc;
		}
	}
	{
		queue = New( struct odbc_queue );
		queue->name = StrDup( dsn );
		queue->connections = CreateLinkQueue();
		AddLink( &g.odbc_queues, queue );
		goto retry;
	}
}
PODBC SQLGetODBC( CTEXTSTR dsn )
{
	return SQLGetODBCEx( dsn, NULL, NULL );
}
void SQLDropODBC( PODBC odbc )
{
	EnqueLink( &odbc->queue->connections, odbc );
}
POINTER GetODBCHandle( PODBC odbc ) {
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
		return (POINTER)odbc->db;
	else
#endif
#ifdef USE_ODBC
		return (POINTER)odbc->hdbc;
#else
		;
#endif
	return NULL;
}
void SQLDropAndCloseODBC( CTEXTSTR dsn )
{
	INDEX idx;
	struct odbc_queue *queue;
	LIST_FORALL( g.odbc_queues, idx, struct odbc_queue*, queue )
	{
		if( StrCaseCmp( dsn, queue->name ) == 0 )
		{
			PODBC odbc;
			while( ( odbc = (PODBC)DequeLink( &queue->connections ) ) )
				CloseDatabase( odbc );
			break;
		}
	}
}
void SetSQLCorruptionHandler( PODBC odbc, void (CPROC*f)(uintptr_t psv,PODBC odbc), uintptr_t psv ) {
	if( odbc ) {
		odbc->pCorruptionHandler = f;
		odbc->psvCorruptionHandler = psv;
	}
}
SQL_NAMESPACE_END
SQL_NAMESPACE
#undef DoSQLCommandf
#undef DoSQLQueryf
#undef DoSQLRecordQueryf
#undef SQLCommandf
#undef SQLQueryf
#undef SQLRecordQueryf
#undef SQLRecordQueryf_v2
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
#define WRAP(a,b,c)  CTEXTSTR _FILE_##b = _WIDE(__FILE__); int _LINE_##b; __f_##b __##b(DBG_VOIDPASS)  { _FILE_##b = pFile; _LINE_##b = nLine; return b; }
#define DBG_ARGS(n)  , _FILE_##n, _LINE_##n
#else
#define WRAP(a,b,c)  __f_##b __##b(void)  { return b; }
#define DBG_ARGS(n)
#endif
WRAP( int, DoSQLCommandf, ( CTEXTSTR fmt, ... ) )
WRAP( int, DoSQLQueryf, ( CTEXTSTR *result, CTEXTSTR fmt, ... ) )
WRAP( int, DoSQLRecordQueryf, ( int *nResults, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) )
WRAP( int, SQLCommandf, ( PODBC odbc, CTEXTSTR fmt, ... ) )
WRAP( int, SQLQueryf, ( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... ) )
WRAP( int, SQLRecordQueryf, ( PODBC odbc, int *nResults, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... ) )
WRAP( int, SQLRecordQueryf_v2, ( PODBC odbc, int *nResults, CTEXTSTR **result, CTEXTSTR **fields, size_t **fieldLengths, CTEXTSTR fmt, ... ) )
int DoSQLCommandf( CTEXTSTR fmt, ... )
{
	int result;
	PTEXT cmd;
	PVARTEXT pvt = VarTextCreate();
	va_list args;
	va_start( args, fmt );
	vvtprintf( pvt, fmt, args );
	cmd = VarTextGet( pvt );
	VarTextDestroy( &pvt );
	result = DoSQLCommandEx( GetText( cmd ) DBG_ARGS(DoSQLCommandf) );
	LineRelease( cmd );
	return result;
}
int DoSQLQueryf( CTEXTSTR *result, CTEXTSTR fmt, ... )
{
	int result_code;
	PTEXT cmd;
	PVARTEXT pvt = VarTextCreate();
	va_list args;
	va_start( args, fmt );
	vvtprintf( pvt, fmt, args );
	cmd = VarTextGet( pvt );
	VarTextDestroy( &pvt );
	result_code = DoSQLQueryEx( (CTEXTSTR)GetText( cmd ), result DBG_ARGS(DoSQLQueryf) );
	LineRelease( cmd );
	return result_code;
}
int DoSQLRecordQueryf( int *nResults, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... )
{
	int result_code;
	PTEXT cmd;
	PVARTEXT pvt = VarTextCreate();
	va_list args;
	va_start( args, fmt );
	vvtprintf( pvt, fmt, args );
	cmd = VarTextGet( pvt );
	VarTextDestroy( &pvt );
	result_code = SQLRecordQueryEx( NULL, GetText( cmd ), nResults, result, fields DBG_ARGS(DoSQLRecordQueryf) );
	LineRelease( cmd );
	return result_code;
}
int SQLCommandf( PODBC odbc, CTEXTSTR fmt, ... )
{
	if( !odbc->flags.bClosed ) {
		int result;
		PTEXT cmd;
		PVARTEXT pvt = VarTextCreateExx( 4096, 16384 * 16 );
		va_list args;
		va_start( args, fmt );
		vvtprintf( pvt, fmt, args );
		cmd = VarTextGet( pvt );
		if( cmd )
		{
			VarTextDestroy( &pvt );
			result = SQLCommandEx( odbc, GetText( cmd ) DBG_ARGS( SQLCommandf ) );
			LineRelease( cmd );
		}
		else {
			result = 0;
			lprintf( WIDE( "ERROR: Sql format failed: %s" ), fmt );
		}
		return result;
	}
	return FALSE;
}
int SQLQueryf( PODBC odbc, CTEXTSTR *result, CTEXTSTR fmt, ... )
{
	int result_code;
	PTEXT cmd;
	PVARTEXT pvt = VarTextCreate();
	va_list args;
	va_start( args, fmt );
	vvtprintf( pvt, fmt, args );
	cmd = VarTextGet( pvt );
	VarTextDestroy( &pvt );
	result_code = SQLQueryEx( odbc, (CTEXTSTR)GetText( cmd ), result DBG_ARGS(SQLQueryf) );
	LineRelease( cmd );
	return result_code;
}
int SQLRecordQueryf( PODBC odbc, int *nResults, CTEXTSTR **result, CTEXTSTR **fields, CTEXTSTR fmt, ... )
{
	int result_code;
	PTEXT cmd;
	PVARTEXT pvt = VarTextCreate();
	va_list args;
	va_start( args, fmt );
	vvtprintf( pvt, fmt, args );
	cmd = VarTextGet( pvt );
	VarTextDestroy( &pvt );
	result_code = SQLRecordQueryEx( odbc, GetText( cmd ), nResults, result,fields DBG_ARGS(SQLRecordQueryf) );
	LineRelease( cmd );
	return result_code;
}
int SQLRecordQueryf_v2( PODBC odbc, int *nResults, CTEXTSTR **result, size_t **resultLengths, CTEXTSTR **fields, CTEXTSTR fmt, ... )
{
	int result_code;
	PTEXT cmd;
	PVARTEXT pvt = VarTextCreate();
	va_list args;
	va_start( args, fmt );
	vvtprintf( pvt, fmt, args );
	cmd = VarTextGet( pvt );
	VarTextDestroy( &pvt );
	result_code = SQLRecordQueryExx( odbc, GetText( cmd ), GetTextSize( cmd ), nResults, result, resultLengths,fields  DBG_ARGS(SQLRecordQueryf_v2) );
	LineRelease( cmd );
	return result_code;
}
SQL_NAMESPACE_END
#define SQLLIB_SOURCE
#ifdef USE_SQLITE_INTERFACE
#define USES_SQLITE_INTERFACE
#endif
SQL_NAMESPACE
extern struct pssql_global *global_sqlstub_data;
#define g (*global_sqlstub_data)
PRIORITY_PRELOAD( InitGlobalSqlUtil, GLOBAL_INIT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( global_sqlstub_data );
}
#ifdef __cplusplus
using namespace sack::containers::BinaryTree;
using namespace sack::memory;
#endif
struct params
{
	CTEXTSTR name;
	PODBC odbc;
};
static int CPROC MyParmCmp( uintptr_t s1, uintptr_t s2 )
{
	struct params *p1 = (struct params*)s1;
	struct params *p2 = (struct params*)s2;
	if( p1->odbc == p2->odbc )
		return StrCaseCmp( p1->name, p2->name );
	else
		return 1;
}
static int CPROC MySqlUtilStrCmp( uintptr_t s1, uintptr_t s2 )
{
	return StrCaseCmp( (TEXTCHAR*)s1, (TEXTCHAR*)s2 );
}
PTREEROOT GetTableCache( PODBC odbc, CTEXTSTR tablename )
{
	//static PTREEROOT tables;
	PTREEROOT newcache;
	struct params parameters;
	parameters.odbc = odbc;
	parameters.name = tablename;
	//lprintf( WIDE("Looking for name cache of table %s"), tablename );
	if( !g.tables )
	{
		g.tables = CreateBinaryTreeExx( BT_OPT_NODUPLICATES
										 , MyParmCmp
										 , NULL );
	}
	if( !( newcache = (PTREEROOT)FindInBinaryTree( g.tables, (uintptr_t)&parameters ) ) )
	{
		struct params *saveparams = New( struct params );
		saveparams->name = StrDup( tablename );
		saveparams->odbc = odbc;
		AddBinaryNode( g.tables
						 , newcache = CreateBinaryTreeExx( BT_OPT_NODUPLICATES
																	, MySqlUtilStrCmp
																	, NULL )
						 , (uintptr_t)saveparams );
	}
	return newcache;
}
INDEX GetIndexOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name)
{
	/* this resulting truncation warning is OK. */
	return (INDEX)(((uintptr_t)FindInBinaryTree( GetTableCache( odbc, table ), (uintptr_t)name ))-1);
}
CTEXTSTR GetKeyOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name)
{
	/* this resulting truncation warning is OK. */
	return (CTEXTSTR)FindInBinaryTree( GetTableCache( odbc, table ), (uintptr_t)name );
}
//---------------------------------------------------------------------------
#undef GetNameIndexExx
INDEX GetNameIndexExtended( PODBC odbc
														 , CTEXTSTR name
														 , CTEXTSTR table
														 , CTEXTSTR col
														 , CTEXTSTR namecol
														 , int bCreate
														 , int bQuote DBG_PASS )
{
	TEXTCHAR query[256];
	CTEXTSTR result = NULL;
	INDEX IDName = INVALID_INDEX;
	if( !table || !name )
		return INVALID_INDEX;
 // only check quotable values
	if( bQuote )
		IDName = GetIndexOfName(odbc, table,name);
	if( IDName != INVALID_INDEX )
		return IDName;
	PushSQLQueryEx( odbc );
	tnprintf( query, sizeof( query ), WIDE("select %s from %s where `%s`=%s")
			  , col?col:WIDE( "id" )
			  , table
			  , namecol
			  , EscapeStringOpt( name, TRUE )
			  );
	if( SQLQueryEx( odbc, query, &result DBG_RELAY) && result )
	{
		IDName = (INDEX)IntCreateFromText( result );
		DebugBreak();
		PopODBCEx( odbc );
	}
	else if( bCreate )
	{
		tnprintf( query, sizeof( query ), WIDE("insert into %s (`%s`) values(%s)")
				  , table
				  ,namecol
				  ,EscapeString( name )
				  );
		if( !SQLCommandEx( odbc, query DBG_RELAY ) )
		{
			lprintf( WIDE("isert failed, how can we define name %s?"), EscapeString( name ) );
			// inser failed...
		}
		else
		{
			// all is well.
			IDName = FetchLastInsertIDEx( odbc, table, col DBG_RELAY );
		}
		PopODBCEx( odbc );
	}
	else
		IDName = INVALID_INDEX;
	if( bQuote && ( IDName != INVALID_INDEX ) )
		AddBinaryNode( GetTableCache(odbc, table), (POINTER)(IDName+1), (uintptr_t)StrDup( name ) );
	return IDName;
}
//-----------------------------------------------------------------------
INDEX GetNameIndexExx( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS )
{
	return GetNameIndexExtended( odbc, name,table,col,namecol,bCreate,TRUE DBG_RELAY );
}
//-----------------------------------------------------------------------
CTEXTSTR FetchLastInsertKeyEx( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS )
{
	static TEXTSTR RecordID;
	CTEXTSTR result = NULL;
	if( !odbc )
		odbc = g.odbc;
	if( !odbc )
		return NULL;
	if( RecordID )
	{
		Release( RecordID );
		RecordID = NULL;
	}
	//lprintf( "getting last insert ID?" );
#ifdef POSGRES_BACKEND
	{
		CTEXTSTR result = NULL;
		TEXTCHAR query[256];
		sprintf( query, WIDE("select currval('%s_%s_seq')"), table, col );
		if( SQLQueryEx( odbc, query, &result ) && result DBG_RELAY )
		{
			RecordID = StrDup( result );
			while( FetchSQLResult( odbc, &result ) );
		}
	}
#endif
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	// extended sqlite functions with LAST_INSERT_ID() so the following code would work alos.
	if( odbc->flags.bSQLite_native )
	{
		// can also be done with 'select last_insert_rowid()'
		RecordID = NewArray( TEXTCHAR, 32 );
		tnprintf( RecordID, 32, WIDE("%") _size_f, (INDEX)sqlite3_last_insert_rowid( odbc->db ) );
	}
#endif
#ifdef USE_ODBC
	PushSQLQueryEx( odbc );
	if( odbc->flags.bAccess )
	{
		CTEXTSTR result = NULL;
		if( SQLQueryEx( odbc, WIDE( "select @@IDENTITY" ), &result DBG_RELAY ) && result )
			RecordID = StrDup( result );
	}
	else if( odbc->flags.bODBC )
	{
		CTEXTSTR result = NULL;
		if( SQLQueryEx( odbc, WIDE("select LAST_INSERT_ID()"), &result DBG_RELAY ) && result )
		{
			RecordID = StrDup( result );
		}
	}
	PopODBCEx( odbc );
#endif
//
	return RecordID;
}
//-----------------------------------------------------------------------
INDEX FetchLastInsertIDEx( PODBC odbc, CTEXTSTR table, CTEXTSTR col DBG_PASS )
{
	CTEXTSTR result_key = FetchLastInsertKeyEx( odbc, table, col DBG_RELAY );
	INDEX result = result_key?(INDEX)IntCreateFromText( result_key ) : INVALID_INDEX;
	return result;
}
//-----------------------------------------------------------------------
CTEXTSTR  GetLastInsertKeyEx( CTEXTSTR table, CTEXTSTR col DBG_PASS )
{
	return FetchLastInsertKeyEx( NULL, table, col DBG_RELAY );
}
//-----------------------------------------------------------------------
 INDEX  GetLastInsertIDEx( CTEXTSTR table, CTEXTSTR col DBG_PASS )
{
	return FetchLastInsertIDEx( NULL, table, col DBG_RELAY );
}
//---------------------------------------------------------------------------
#undef EscapeBinary
#undef EscapeString
TEXTSTR EscapeSQLBinaryExx( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen, uintptr_t *resultLen, LOGICAL bQuote DBG_PASS )
{
	int type_mysql = 1;
#if MYSQL_ODBC_CONNECTION_IS_BROKEN
	int first_failure = 1;
#endif
	CTEXTSTR pBlob = blob;
	TEXTCHAR *tmpnamebuf, *result;
	unsigned int n;
	int targetlen;
	if( odbc && ( odbc->flags.bSQLite
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
					 || odbc->flags.bSQLite_native
#endif
					) )
		type_mysql = 0;
	if( type_mysql )
	{
		n = 0;
  // include the ' around it if required... otherwise concat fails.
		targetlen = 2;
		while( n < bloblen )
		{
#if MYSQL_ODBC_CONNECTION_IS_BROKEN
			if( (*pBlob) == '\x9f' || (*pBlob) == '\x9c' )
			{
				if( first_failure )
				{
					first_failure = 0;
 // concat("")
					targetlen += 10;
				}
  // ",char(159),"
				targetlen += 14;
			}
#endif
			if( (*pBlob) == '\'' ||
				(*pBlob) == '\\' ||
				(*pBlob) == '\0' ||
				(*pBlob) == '\"' )
				targetlen++;
			n++;
		}
		n = 0;
		result = tmpnamebuf = (TEXTSTR)AllocateEx( ( sizeof( TEXTCHAR ) * ( targetlen + bloblen + 1 ) ) DBG_RELAY );
#if MYSQL_ODBC_CONNECTION_IS_BROKEN
		if( !first_failure )
			tmpnamebuf += tnprintf( tmpnamebuf, targetlen+bloblen, "concat('" );
		else
#endif
		{
			if( bQuote )
				(*tmpnamebuf++) = '\'';
		}
		while( n < bloblen )
		{
#if MYSQL_ODBC_CONNECTION_IS_BROKEN
			if( (*pBlob) == '\x9f' || (*pBlob) == '\x9c' )
				tmpnamebuf += tnprintf( tmpnamebuf, 15, "\',char(%d),\'", (unsigned char)(*pBlob) );
				else
#endif
			{
				if( (*pBlob) == '\'' ||
					(*pBlob) == '\\' ||
					(*pBlob) == '\0' ||
					(*pBlob) == '\"' )
					(*tmpnamebuf++) = '\\';
				if( (*pBlob) )
					(*tmpnamebuf++) = (*pBlob);
				else
					(*tmpnamebuf++) = '0';
			}
			n++;
		}
#if MYSQL_ODBC_CONNECTION_IS_BROKEN
		if( !first_failure )
		{
			(*tmpnamebuf++) = '\'';
			(*tmpnamebuf++) = ')';
		}
		else
#endif
		{
			if( bQuote )
				(*tmpnamebuf++) = '\'';
		}
 // best terminate this thing.
		(*tmpnamebuf) = 0;
	}
	else
	{
		n = 0;
		targetlen = 0;
		while( n < bloblen )
		{
			if( (*pBlob) == '\'' )
				targetlen++;
			if( (*pBlob) == '\0' )
				targetlen += 13;
			pBlob++;
			n++;
		}
		n = 0;
 // reset blob input
		pBlob = blob;
		result = tmpnamebuf = (TEXTSTR)AllocateEx( ( sizeof( TEXTCHAR ) * ( targetlen + bloblen + 3 ) ) DBG_RELAY );
		if( bQuote )
			( *tmpnamebuf++ ) = '\'';
		while( n < bloblen ) {
			if( (*pBlob) == 0 ) {
				( *tmpnamebuf++ ) = '\'';
				( *tmpnamebuf++ ) = '|';
				( *tmpnamebuf++ ) = '|';
				( *tmpnamebuf++ ) = 'C';
				( *tmpnamebuf++ ) = 'H';
				( *tmpnamebuf++ ) = 'A';
				( *tmpnamebuf++ ) = 'R';
				( *tmpnamebuf++ ) = '(';
				( *tmpnamebuf++ ) = '0';
				( *tmpnamebuf++ ) = ')';
				( *tmpnamebuf++ ) = '|';
				( *tmpnamebuf++ ) = '|';
				( *tmpnamebuf++ ) = '\'';
			}
			else {
				if( (*pBlob) == '\'' )
					( *tmpnamebuf++ ) = '\'';
				( *tmpnamebuf++ ) = (*pBlob);
			}
			n++;
			pBlob++;
		}
		if( bQuote )
			( *tmpnamebuf++ ) = '\'';
 // best terminate this thing.
		( *tmpnamebuf ) = 0;
	}
	if( resultLen )
		( *resultLen ) = tmpnamebuf - result;
	return result;
}
TEXTSTR EscapeSQLBinaryEx ( PODBC odbc, CTEXTSTR blob, uintptr_t bloblen DBG_PASS )
{
	return EscapeSQLBinaryExx( odbc, blob, bloblen, NULL, FALSE DBG_RELAY );
}
TEXTSTR EscapeBinaryEx ( CTEXTSTR blob, uintptr_t bloblen DBG_PASS )
{
	return EscapeSQLBinaryExx( NULL, blob, bloblen, NULL, FALSE DBG_RELAY );
}
TEXTCHAR * EscapeBinary ( CTEXTSTR blob, uintptr_t bloblen )
{
	return EscapeSQLBinaryExx( NULL, blob, bloblen, NULL, FALSE DBG_SRC );
}
//---------------------------------------------------------------------------
TEXTCHAR * EscapeSQLStringEx ( PODBC odbc, CTEXTSTR name DBG_PASS )
{
	if( !name ) return NULL;
	return EscapeSQLBinaryExx( odbc, name, strlen( name ), NULL, FALSE DBG_RELAY );
}
TEXTCHAR * EscapeStringEx ( CTEXTSTR name DBG_PASS )
{
	return EscapeSQLBinaryExx( NULL, name, (uint32_t)strlen( name ), NULL, FALSE DBG_RELAY );
}
TEXTCHAR * EscapeString ( CTEXTSTR name )
{
	return EscapeSQLBinaryExx( NULL, name, strlen( name ), NULL, FALSE DBG_SRC );
}
uint8_t hexbyte( TEXTCHAR *string )
{
	static TEXTCHAR hex[17] = WIDE("0123456789abcdef");
	static TEXTCHAR HEX[17] = WIDE("0123456789ABCDEF");
	TEXTCHAR *digit;
	uint8_t value = 0;
	digit = strchr( hex, string[0] );
	if( !digit )
	{
		digit = strchr( HEX, string[0] );
		if( digit )
		{
//cpg 19 Jan 2007 1>c:\work\sack\src\sqllib\sqlutil.c(187) : warning C4244: '=' : conversion from '__w64 int' to 'sack::uint8_t', possible loss of data
			value = (uint8_t)(digit - HEX);
		}
		else
			return 0;
	}
	else
	{
//cpg 19 Jan 2007 1>c:\work\sack\src\sqllib\sqlutil.c(194) : warning C4244: '=' : conversion from '__w64 int' to 'sack::uint8_t', possible loss of data
		value = (uint8_t)(digit - hex);
	}
	value *= 16;
	digit = strchr( hex, string[1] );
	if( !digit )
	{
		digit = strchr( HEX, string[1] );
		if( digit )
		{
//cpg 19 Jan 2007 1>c:\work\sack\src\sqllib\sqlutil.c(204) : warning C4244: '+=' : conversion from '__w64 int' to 'sack::uint8_t', possible loss of data
			value += (uint8_t)(digit - HEX);
		}
		else
			return 0;
	}
	else
	{
//cpg 19 Jan 2007 1>c:\work\sack\src\sqllib\sqlutil.c(211) : warning C4244: '+=' : conversion from '__w64 int' to 'sack::uint8_t', possible loss of data
		value += (uint8_t)(digit - hex);
	}
	return value;
}
TEXTSTR DeblobifyString( CTEXTSTR blob, TEXTSTR outbuf, size_t outbuflen  )
{
	TEXTCHAR *result;
	TEXTCHAR *x, *y;
	if( blob )
	{
		//lprintf("got blob %s", blob);
		if( !outbuf )
			outbuf = NewArray( TEXTCHAR, ( ( strlen( blob ) / 2 ) + 1 ) );
		result = outbuf;
		for( x=(TEXTSTR)blob, y = result;
			  x[0] && ((size_t)(y-outbuf) < outbuflen);
			  y++, x+=2 )
		{
			y[0] = hexbyte( x );
			y[1] = 0;
			//lprintf("y is %s", y);
		}
		//lprintf("returning %s", result );
		return result;
	}
	else
		lprintf( WIDE("Duh.  No Blob.") );
	return NULL;
}
//---------------------------------------------------------------------------
TEXTSTR RevertEscapeBinary( CTEXTSTR blob, size_t *bloblen )
{
	TEXTCHAR *tmpnamebuf, *result;
	CTEXTSTR pBlob = blob;
	int n;
	int escape;
	int targetlen;
	n = 0;
	escape = 0;
	targetlen = 0;
	for( n = 0; (*pBlob); pBlob++, n++ )
	{
		if( !escape && ( (*pBlob) == '\\' ) )
			escape = 1;
		else if( escape )
		{
			if( (*pBlob) == '\\' ||
				(*pBlob) == '0' ||
				(*pBlob) =='\'' ||
				(*pBlob) == '\"' )
			{
				// targetlen is a subtraction for missing charactercount
				targetlen++;
			}
			escape = 0;
		}
	}
	if( bloblen )
	{
		(*bloblen) = n - targetlen;
	}
	escape = 0;
	result = tmpnamebuf = NewArray( TEXTCHAR, (*bloblen) );
	for( n = 0; (*pBlob); n++ )
	{
		if( !escape && ( (*pBlob) == '\\' ) )
			escape = 1;
		else if( escape )
		{
			if( (*pBlob) == '\\' ||
				(*pBlob) =='\'' ||
				(*pBlob) == '\"' )
			{
			// targetlen is a subtraction for missing charactercount
				(*tmpnamebuf++) = (*pBlob);
			}
			else if( (*pBlob) == '0' )
				(*tmpnamebuf++) = 0;
			else
			{
				(*tmpnamebuf++) = '\\';
				(*tmpnamebuf++) = (*pBlob);
			}
			escape = 0;
		}
		else
			(*tmpnamebuf++) = (*pBlob);
	}
 // best terminate this thing.
	(*tmpnamebuf) = 0;
	return result;
}
//---------------------------------------------------------------------------
TEXTSTR RevertEscapeString( CTEXTSTR name )
{
	return RevertEscapeBinary( name, NULL );
}
//---------------------------------------------------------------------------
 INDEX  SQLReadNameTableExEx( PODBC odbc, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS )
{
			TEXTCHAR query[256];
			TEXTCHAR *tmp;
			CTEXTSTR result = NULL;
			INDEX IDName = INVALID_INDEX;
			if( !table || !name )
				return INVALID_INDEX;
			// look in internal cache first...
			IDName = GetIndexOfName( odbc,table,name);
			if( IDName != INVALID_INDEX )
				return IDName;
			PushSQLQueryEx( odbc );
			tmp = EscapeSQLStringEx( odbc, name DBG_RELAY );
			tnprintf( query, sizeof( query ), WIDE("select %s from %s where %s like \'%s\'"), col?col:WIDE("id"), table, namecol, tmp );
			Release( tmp );
			if( SQLQueryEx( odbc, query, &result DBG_RELAY) && result )
			{
				IDName = (INDEX)IntCreateFromText( result );
			}
			else if( bCreate )
			{
				TEXTSTR newval = EscapeSQLString( odbc, name );
				tnprintf( query, sizeof( query ), WIDE("insert into %s (%s) values( \'%s\' )"), table, namecol, newval );
				if( !SQLCommandEx( odbc, query DBG_RELAY ) )
				{
					lprintf( WIDE("insert failed, how can we define name %s?"), name );
					// inser failed...
				}
				else
				{
					// all is well.
					IDName = FetchLastInsertIDEx( odbc, table, col?col:WIDE("id") DBG_RELAY );
				}
				Release( newval );
			}
			else
				IDName = INVALID_INDEX;
			PopODBCEx(odbc);
			if( IDName != INVALID_INDEX )
			{
				// instead of strdup, consider here using SaveName from procreg?
				AddBinaryNode( GetTableCache(odbc,table), (POINTER)((uintptr_t)(IDName+1))
								 , (uintptr_t)StrDup( name ) );
			}
			return IDName;
}
 INDEX  ReadNameTableExEx( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS )
{
	return SQLReadNameTableExEx( NULL, name, table,col,namecol,bCreate DBG_RELAY );
}
//---------------------------------------------------------------------------
 INDEX  ReadNameTableEx( CTEXTSTR name, CTEXTSTR table, CTEXTSTR col DBG_PASS )
{
	return ReadNameTableExEx( name,table,col,WIDE("name"),TRUE DBG_RELAY);
}
//---------------------------------------------------------------------------
 int  ReadFromNameTableEx ( INDEX id, CTEXTSTR table, CTEXTSTR id_colname, CTEXTSTR name_colname, CTEXTSTR *result DBG_PASS)
{
	TEXTCHAR query[256];
	if( !result || !table || id == INVALID_INDEX )
		return FALSE;
	// the tree locally cached is in NAME order, but the data is
	// the key, so we would have to scan the tree otherwise both directions
	// keyed so that we could get the name key from the ID data..
	tnprintf( query, sizeof( query ), WIDE("select %s from %s where %s=%") _size_f
			  , name_colname?name_colname:WIDE("name")
			  , table
			  , id_colname?id_colname:WIDE("id")
			  , id );
	if( !DoSQLQueryEx( query, result DBG_RELAY ) || !(*result) )
	{
		lprintf( WIDE("name ID(%") _size_f WIDE(" as %s) was not found in %s.%s"), id, id_colname?id_colname:WIDE("id"), table, id_colname?id_colname:WIDE("id") );
		return FALSE;
	}
	else
	{
		//PopODBC();
	}
	return TRUE;
}
//---------------------------------------------------------------------------
 int  ReadFromNameTableExEx ( INDEX id, CTEXTSTR table, CTEXTSTR id_col, CTEXTSTR colname, CTEXTSTR *result DBG_PASS)
{
	TEXTCHAR query[256];
	if( !result || !table || id == INVALID_INDEX )
		return FALSE;
	// the tree locally cached is in NAME order, but the data is
	// the key, so we would have to scan the tree otherwise both directions
	// keyed so that we could get the name key from the ID data..
	tnprintf( query, sizeof( query ), WIDE("select %s from %s where %s=%") _size_f
			, colname
			  , table
			 , id_col?id_col:WIDE("id")
			  , id );
	if( !DoSQLQueryEx( query, result DBG_RELAY ) || !(*result) )
	{
		lprintf( WIDE("name ID(%") _size_fs WIDE(") was not found in %s.%s"), id, table, colname?colname:WIDE("id") );
		return FALSE;
	}
	else
	{
		//PopODBC();
	}
	return TRUE;
}
//---------------------------------------------------------------------------
 int  SQLCreateTableEx ( PODBC odbc, CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options )
{
	//CTEXTSTR result;
	//TEXTCHAR query[256];
	if( !tablename )
		tablename = templatename;
	//if( odbc->flags.bSQLite_native )
	//	;
	//else if( odbc->flags.bAccess )
	//	tnprintf( query, 256, WIDE("DESCRIBE [%s]"), tablename );
	//else
	//	tnprintf( query, 256, WIDE("DESCRIBE `%s`"), tablename );
	//if( !SQLQuery( odbc, query, &result ) || !result || (options & (CTO_DROP|CTO_MATCH|CTO_MERGE)) )
	{
		TEXTCHAR sec_file[284];
		FILE *file;
		sec_file[0] = 0;
		file = sack_fopen( 0, filename, WIDE("rt") );
		if( !file )
		{
			if( !pathchr( filename ) )
			{
#ifndef HAVE_ENVIRONMENT
				CTEXTSTR path = OSALOT_GetEnvironmentVariable( WIDE( "MY_LOAD_PATH" ) );
				tnprintf( sec_file, sizeof( sec_file ), WIDE( "%s/%s" ), path, filename );
#else
				tnprintf( sec_file, sizeof( sec_file ), WIDE( "%s" ), filename );
#endif
				file = sack_fopen( 0, sec_file, WIDE("rt") );
			}
		}
		if( file )
		{
			int done = FALSE;
			int gathering = FALSE;
			TEXTCHAR *buf;
			TEXTCHAR fgets_buf[1024];
			PVARTEXT pvt_cmd = VarTextCreate();
			INDEX nOfs = 0;
			if( !odbc->flags.bNoLogging )
				lprintf( WIDE("Opened %s to read for table %s(%s)"), sec_file[0]?sec_file:filename, tablename,templatename );
			while( sack_fgets( fgets_buf, sizeof( fgets_buf ), file ) )
			{
				TEXTCHAR *p;
				buf = fgets_buf;
				p = buf + strlen( buf ) - 1;
				while( p[0] == ' ' || p[0] == '\t' || p[0] == '\n' || p[0] == '\r')
				{
					p[0] = 0;
					p--;
				}
				p = buf;
				while( p[0] )
				{
					if ( p[0] == '#' )
					{
						p[0] = 0;
						break;
					}
					p++;
				}
				p = buf;
				while( p[0] == ' ' || p[0] == '\t' )
					p++;
				if( p[0] )
				{
					// have content on the line...
					TEXTCHAR *end = p + strlen( p ) - 1;
					if( gathering && end[0] == ';' )
					{
						done = TRUE;
						end[0] = 0;
					}
					if( !gathering )
					{
						if( StrCaseCmpEx( p, WIDE("CREATE"), 6 ) == 0 )
						{
							CTEXTSTR tabname;
							// cpg29dec2006  c:\work\sack\src\sqllib\sqlutil.c(498) : warning C4267: 'initializing' : conversion from 'size_t' to 'int', possible loss of data
							// cpg29dec2006                             int len = strlen( tablename );
							int len = (int)strlen( tablename );
							if( (tabname = StrStr( p, templatename )) &&
								(tabname[len] == '`' || tabname[len] ==' ' || tabname[len] =='\t' ) &&
								(tabname[-1] == '`' || tabname[-1] ==' ' || tabname[-1] =='\t'))
							{
								// need to gather, repace...
								TEXTCHAR line[1024];
								CTEXTSTR trailer;
								trailer = tabname;
								while( trailer[0] != '\'' &&
										trailer[0] != '`' &&
										trailer[0] != ' ' &&
										trailer[0] != '\t' )
									trailer++;
								tnprintf( line, sizeof( line ), WIDE("%*.*s%s%s")
										 , (int)(tabname - p), (int)(tabname - p), p
										 , templatename
										 , trailer
										 );
								StrCpyEx( buf, line, 1024 );
								gathering = TRUE;
							}
							else
							{
							}
						}
					}
					if( gathering )
					{
						nOfs += vtprintf( pvt_cmd, WIDE("%s "), p );
						if( done )
						{
							if( options & CTO_DROP )
							{
								TEXTCHAR buf[1024];
								tnprintf( buf, 1024, WIDE("Drop table %s"), templatename );
								if( !SQLCommand( odbc, buf ) )
								{
									CTEXTSTR result;
									GetSQLError( &result );
									lprintf( WIDE("Failed to do drop: %s"), result );
								}
							}
							// result is set with the first describe result
							// the matching done in CheckMySQLTable should
							// be done here, after parsing the line from the file (cmd)
							// into a TABLE structure.
							//DebugBreak();
							{
								PTABLE table;
								PTEXT cmd = VarTextGet( pvt_cmd );
								table = GetFieldsInSQL( GetText( cmd ), 1 );
								CheckODBCTable( odbc, table, options );
								DestroySQLTable( table );
								LineRelease( cmd );
							}
							break;
						}
					}
				}
#ifdef __cplusplus_cli
				Release( buf );
#endif
			}
			//lprintf( WIDE("Done with create...") );
			VarTextDestroy( &pvt_cmd );
			sack_fclose( file );
		}
		else
		{
			lprintf( WIDE("Unable to open templatefile: %s or %s/%s"), filename
					 , OSALOT_GetEnvironmentVariable( WIDE( "MY_LOAD_PATH" ) )
			        , filename );
		}
	}
	return TRUE;
}
//---------------------------------------------------------------------------
void DestroySQLTable( PTABLE table )
{
	int n;
	int m;
	if( !table )
		return;
// don't release tables created statically in C files...
	if( !table->flags.bDynamic )
		return;
	for( n = 0; n < table->fields.count; n++ )
	{
		Release( (POINTER)table->fields.field[n].name );
		Release( (POINTER)table->fields.field[n].type );
		Release( (POINTER)table->fields.field[n].extra );
		for( m = 0; table->fields.field[n].previous_names[m] && m < MAX_PREVIOUS_FIELD_NAMES; m++ )
		{
			Release( (POINTER)table->fields.field[n].previous_names[m] );
		}
	}
	for( n = 0; n < table->keys.count; n++ )
	{
		for( m = 0; table->keys.key[n].colnames[m] && m < MAX_KEY_COLUMNS; m++ )
		{
			Release( (POINTER)table->keys.key[n].colnames[m] );
		}
		Release( (POINTER)table->keys.key[n].name );
	}
	for( n = 0; n < table->constraints.count; n++ )
	{
		for( m = 0; table->constraints.constraint[n].colnames[m] && m < MAX_KEY_COLUMNS; m++ )
		{
			Release( (POINTER)table->constraints.constraint[n].colnames[m] );
		}
		for( m = 0; table->constraints.constraint[n].foriegn_colnames[m] && m < MAX_KEY_COLUMNS; m++ )
		{
			Release( (POINTER)table->constraints.constraint[n].foriegn_colnames[m] );
		}
		Release( (POINTER)table->constraints.constraint[n].name );
		Release( (POINTER)table->constraints.constraint[n].references );
	}
	Release( (POINTER)table->name );
	Release( (POINTER)table->constraints.constraint );
	Release( (POINTER)table->fields.field );
	Release( (POINTER)table->keys.key );
	Release( table );
}
void DumpSQLTable( PTABLE table )
{
	int n;
	int m;
	//if( 1 )
	//   return;
	// don't release tables created statically in C files...
	lprintf( WIDE( "Table name: %s" ), table->name );
	for( n = 0; n < table->fields.count; n++ )
	{
		lprintf( WIDE( "Column %d '%s' [%s] [%s]" )
		        , n
				 ,( table->fields.field[n].name )
				, table->fields.field[n].type?table->fields.field[n].type:""
				 ,( table->fields.field[n].extra )
				 );
		for( m = 0; table->fields.field[n].previous_names[m] && m < MAX_PREVIOUS_FIELD_NAMES; m++ )
		{
			//Release( (POINTER)table->fields.field[n].previous_names[m] );
		}
	}
	for( n = 0; n < table->keys.count; n++ )
	{
		lprintf( WIDE( "Key %s" ), table->keys.key[n].name?table->keys.key[n].name:WIDE( "<NONAME>" ) );
		for( m = 0; table->keys.key[n].colnames[m] && m < MAX_KEY_COLUMNS; m++ )
		{
			lprintf( WIDE( "Key part = %s" )
					 , table->keys.key[n].colnames[m]
					 );
		}
	}
}
 int  CreateTableEx ( CTEXTSTR filename, CTEXTSTR templatename, CTEXTSTR tablename, uint32_t options )
{
	OpenSQL( DBG_VOIDSRC );
	if( g.odbc )
		return SQLCreateTableEx( g.odbc, filename, templatename, tablename, options );
	return FALSE;
}
#define FAILPARSE() do { if( ( start[0] < '0' ) || ( start[0] > '9' ) ) {  lprintf( WIDE("string fails date parsing... %s"), timestring );                  return 0; } } while (0);
 int  ConvertDBTimeString ( CTEXTSTR timestring
                                        , CTEXTSTR *endtimestring
													 , int *pyr, int *pmo, int *pdy
													 , int *phr, int *pmn, int *psc )
{
	int mo,dy,yr;
	int hr = 0,mn = 0,sc = 0;
	CTEXTSTR start;
	start = timestring;
	if( !start )
	{
		if( pyr ) (*pyr) = 0;
		if( pmo ) (*pmo) = 0;
		if( pdy ) (*pdy) = 0;
		if( phr ) (*phr) = 0;
		if( pmn ) (*pmn) = 0;
		if( psc ) (*psc) = 0;
		return 0;
	}
	yr = 0;
	FAILPARSE();
	yr = (yr * 10) + (*start++) - '0';
	FAILPARSE();
	yr = (yr * 10) + (*start++) - '0';
	FAILPARSE();
	yr = (yr * 10) + (*start++) - '0';
	FAILPARSE();
	yr = (yr * 10) + (*start++) - '0';
	if( (*start) == '-' ) start++;
	mo = 0;
	FAILPARSE();
	mo = (mo * 10) + (*start++) - '0';
	FAILPARSE();
	mo = (mo * 10) + (*start++) - '0';
	if( (*start) == '-' ) start++;
	dy = 0;
	FAILPARSE();
	dy = (dy * 10) + (*start++) - '0';
	FAILPARSE();
	dy = (dy * 10) + (*start++) - '0';
	if( (*start) == ' ' )
	{
		start++;
		FAILPARSE();
		hr = (hr * 10) + (*start++) - '0';
		FAILPARSE();
		hr = (hr * 10) + (*start++) - '0';
		if( (*start) == ':' ) start++;
		FAILPARSE();
		mn = (mn * 10) + (*start++) - '0';
		FAILPARSE();
		mn = (mn * 10) + (*start++) - '0';
		if( (*start) == ':' ) start++;
		FAILPARSE();
		sc = (sc * 10) + (*start++) - '0';
		FAILPARSE();
		sc = (sc * 10) + (*start++) - '0';
	}
	if( endtimestring )
		*endtimestring = start;
	if( pyr )
		*pyr = yr;
	if( pmo )
		*pmo = mo;
	if( pdy )
		*pdy = dy;
	if( phr )
		*phr = hr;
	if( pmn )
		*pmn = mn;
	if( psc )
		*psc = sc;
	return 1;
}
LOGICAL CheckAccessODBCTable( PODBC odbc, PTABLE table, uint32_t options )
{
	CTEXTSTR *_fields = NULL;
	CTEXTSTR *fields;
	int columns;
	PVARTEXT pvtCreate = NULL;
	CTEXTSTR cmd = WIDE("select top 1 * from [%s]");
	int retry = 0;
retry:
	if( SQLRecordQueryf( odbc, &columns, NULL, &_fields, cmd, table->name ) )
	{
		int n;
		fields = NewArray( CTEXTSTR, columns );
		for( n = 0; n < columns; n++ )
			fields[n] = StrDup( _fields[n] );
		for( n = 0; n < columns; n++ )
		{
			int m;
			for( m = 0; m < table->fields.count; m++ )
			{
				if( StrCaseCmp( fields[n], table->fields.field[m].name ) == 0 )
					break;
			}
			if( m == table->fields.count )
			{
				// did not find this column in the definition drop it.
				{
					for( m = 0; m < table->fields.count; m++ )
					{
						int prev;
						for( prev = 0; table->fields.field[m].previous_names[prev]; prev++ )
						{
							if( strcmp( table->fields.field[m].previous_names[prev]
										 , fields[n] ) == 0 )
							{
								break;
							}
						}
						if( table->fields.field[m].previous_names[prev] )
							break;
					}
					if( m < table->fields.count )
					{
						// this column was known to be named something else
						// and we should do some extra fun stuff to preserve the data
						// In access rename is done with DROP and ADD column
 // release so that the alter statement may be done.
						ReleaseODBC( odbc );
						SQLCommandf( odbc
									  , WIDE("alter table [%s] add column [%s] %s%s%s")
									  , table->name
									  , table->fields.field[m].name
									  , table->fields.field[m].type?table->fields.field[m].type:""
									  , table->fields.field[m].extra?WIDE(" "):WIDE("")
									  , table->fields.field[m].extra?table->fields.field[m].extra:WIDE("")
									  );
						SQLCommandf( odbc, WIDE("update [%s] set [%s]=[%s]")
									  , table->name
									  , table->fields.field[m].name
									  , fields[n] );
					}
 // release all prior locks on the table...
					ReleaseODBC( odbc );
					SQLCommandf( odbc
								  , WIDE("alter table [%s] drop column [%s]")
								  , table->name
								  , fields[n] );
					if( m < table->fields.count )
					{
						/* this field is now handled and done, forget it.*/
						Release( (void*)fields[n] );
						// okay we already added this one, so make it
						// match our definition... otherwise following code will
						// also attempt to add this...
						// but in the process of dropping we may NOT
						// drop a renamed column- but must instead preserve it's data
						fields[n] = StrDup( table->fields.field[m].name );
					}
				}
			}
		}
		for( n = 0; n < table->fields.count; n++ )
		{
			int m;
			for( m = 0; m < columns; m++ )
			{
				if( fields[m] )
					if( StrCaseCmp( fields[m], table->fields.field[n].name ) == 0 )
						break;
			}
			if( m == columns )
			{
				// did not find this defined column in the table, add it.
				PTEXT pt_cmd;
				if( !pvtCreate )
					pvtCreate = VarTextCreate();
				vtprintf( pvtCreate, WIDE("alter table [%s] add column [%s] %s%s%s")
						  , table->name
						  , table->fields.field[n].name
						  , table->fields.field[n].type?table->fields.field[n].type:""
						  , table->fields.field[n].extra?WIDE(" "):WIDE("")
						  , table->fields.field[n].extra?table->fields.field[n].extra:WIDE("")
						  );
				pt_cmd = VarTextGet( pvtCreate );
				// close all prior statement handles so it's not locked
				// especially my own.
 // release so that the alter statement may be done.
				PopODBCEx( odbc );
				SQLCommand( odbc, GetText( pt_cmd ) );
				LineRelease( pt_cmd );
			}
		}
		// release the duplicated fields...
		for( n = 0; n < columns; n++ )
			Release( (POINTER)fields[n] );
		Release( (POINTER)fields );
	}
	else
	{
		// table doesn't exist?
		CTEXTSTR error = NULL;
		FetchSQLError( odbc, &error );
		if( StrCmpEx( error, WIDE("(37000)"), 7 ) == 0 )
		{
			// ODBC driver is old and does not support
			// 'TOP' command... please try again, using a less fancy
			// select... since it's file based, probably the data is not
			// all read, but one row at a time is read from the database.
			if( !retry )
			{
				cmd = WIDE("select * from [%s]");
				retry++;
				goto retry;
			}
		}
		if( StrCmpEx( error, WIDE("(S0002)"), 7 ) == 0 )
		{
			PTEXT pt_cmd;
			int n;
			int first = 1;
			if( !pvtCreate )
				pvtCreate = VarTextCreate();
			vtprintf( pvtCreate, WIDE("create table [%s] ("), table->name );
			for( n = 0; n < table->fields.count; n++ )
			{
				CTEXTSTR type;
				if( StrCaseCmpEx( table->fields.field[n].type, WIDE( "varchar" ), 7 ) == 0 )
					type = WIDE( "TEXT" );
				else if( StrCaseCmpEx( table->fields.field[n].type, WIDE( "tinyint" ), 7 ) == 0 )
					type = WIDE( "INT" );
				else if( StrCaseCmpEx( table->fields.field[n].type, WIDE( "int(" ), 4 ) == 0 )
					type = WIDE( "INT" );
				else
				{
					if( table->fields.field[n].extra && StrStr( table->fields.field[n].extra, WIDE( "auto_increment" ) ) )
						type = WIDE( "COUNTER" );
					else
						type = table->fields.field[n].type;
				}
				if( strchr( table->fields.field[n].name, ' ' ) )
				{
					vtprintf( pvtCreate, WIDE("%s[%s] %s%s%s")
							  , first?WIDE( "" ):WIDE( "," )
							  , table->fields.field[n].name
							  , type?type:""
//table->fields.field[n].extra?WIDE( " " ):WIDE( "" )
							  , WIDE( "" )
//table->fields.field[n].extra?table->fields.field[n].extra:WIDE( "" )
							  , WIDE( "" )
							  );
				}
				else
				{
					vtprintf( pvtCreate, WIDE("%s[%s] %s%s%s")
							  , first?WIDE( "" ):WIDE( "," )
							  , table->fields.field[n].name
							  , type?type:""
//(strstr( table->fields.field[n].extra, WIDE( "auto_increment" ) ))?WIDE( "COUNTER" ):WIDE( "" )
							  , WIDE( "" )
//table->fields.field[n].extra?table->fields.field[n].extra:WIDE( "" )
							  , WIDE( "" )
							  );
				}
				first = 0;
			}
			// not even sure where in the syntax key fields go...
			// does access actually have key fields?  or just things
			// called key fields
			//for( n = 0; n < table->keys.count; n++ )
			//{
				// for implementation see Check MYSQL
			//}
			vtprintf( pvtCreate, WIDE(")") );
			pt_cmd = VarTextGet( pvtCreate );
			SQLCommand( odbc, GetText( pt_cmd ) );
			LineRelease( pt_cmd );
		}
		else
		{
			lprintf( WIDE("error is : %s"), error );
		}
	}
	if( pvtCreate )
		VarTextDestroy( &pvtCreate );
	return 1;
}
LOGICAL CPROC CheckMySQLODBCTable( PODBC odbc, PTABLE table, uint32_t options )
{
// when this gets to be implemented...
// the type "counter" needs to be interpreted as auto increment.
// also, the behavior for mysql auto increment (in extra fields )
// needs to be interpreted counter-intuitively for access databases..
	CTEXTSTR *fields = NULL;
	CTEXTSTR *result = NULL;
	FILE *f_odbc = NULL;
	int columns;
	int retry;
	int success;
	int buflen;
	PVARTEXT pvtCreate = NULL;
	int status = 1;
	TEXTCHAR *cmd;
	if( options & CTO_LOG_CHANGES )
	{
		f_odbc = sack_fopen( 0, WIDE( "changes.sql" ), WIDE( "at+" ) );
		if( !f_odbc )
			f_odbc = sack_fopen( 0, WIDE( "changes.sql" ), WIDE( "wt" ) );
	}
	cmd = NewArray( TEXTCHAR, 1024);
	buflen = 0;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( odbc->flags.bSQLite_native )
		buflen += tnprintf( cmd+buflen , 1024-buflen,WIDE("select tbl_name,sql from sqlite_master where type='table' and name='%s'")
								, table->name );
	else
#endif
		buflen += tnprintf( cmd+buflen , 1024-buflen,WIDE("show create table `%s`") ,table->name);
	if( buflen < 1024 )
		cmd[buflen] = 0;
	else
		cmd[1023] = 0;
	retry = 0;
retry:
	if( ( success = SQLRecordQueryf( odbc, &columns, &result, &fields, cmd, table->name ) )
		&& result )
			//    if( DoSQLQuery( cmd, &result ) && result )
	{
		int n;
		PTABLE pTestTable;
		//lprintf("Does this work or not?");
		pTestTable = GetFieldsInSQL( result[1] , 0 );
		SQLEndQuery( odbc );
		//lprintf(" ---------------Table to test-----------------------------------------" );
		//DumpSQLTable( pTestTable );
		//lprintf(" ---------------original table -----------------------------------------" );
		//DumpSQLTable( table );
		//lprintf(" -----------------end tables ---------------------------------------" );
		//lprintf(" . . . I guess so");
		if( pTestTable )
		{
			for( n = 0; n < pTestTable->fields.count; n++ )
			{
				int m;
				for( m = 0; m < table->fields.count; m++ )
				{
					if( StrCaseCmp( pTestTable->fields.field[n].name
								  , table->fields.field[m].name ) == 0 )
						break;
				}
				if( m == table->fields.count )
				{
				// did not find this column in the definition drop it.
					{
						int prev = 0;
						for( m = 0; m < table->fields.count; m++ )
						{
							for( prev = 0; table->fields.field[m].previous_names[prev]; prev++ )
							{
								if( strcmp( table->fields.field[m].previous_names[prev]
											 , pTestTable->fields.field[n].name ) == 0 )
								{
									break;
								}
							}
							if( table->fields.field[m].previous_names[prev] )
								break;
						}
						if( m < table->fields.count )
						{
						// this column was known to be named something else
						// and we should do some extra fun stuff to preserve the data
						// In access rename is done with DROP and ADD column
							if( options & CTO_DROP )
							{
								if( f_odbc )
									fprintf( f_odbc, WIDE("drop table `%s`;\n"), table->name );
								else
									SQLCommandf( odbc, WIDE("drop table `%s`"), table->name );
								goto do_create_table;
							}
							if( f_odbc )
							{
								fprintf( f_odbc
										 , WIDE("alter table `%s` add column `%s` %s%s%s;\n")
										 , table->name
										 , table->fields.field[m].name
										 , table->fields.field[m].type?table->fields.field[m].type:""
										 , table->fields.field[m].extra?WIDE(" "):WIDE("")
										 , table->fields.field[m].extra?table->fields.field[m].extra:WIDE("")
										 );
								fprintf( f_odbc, WIDE("update `%s` set `%s`=`%s`;\n")
										 , table->name
										 , table->fields.field[m].name
										 , table->fields.field[m].previous_names[prev] );
							}
							else
							{
								SQLCommandf( odbc
											  , WIDE("alter table `%s` add column `%s` %s%s%s")
											  , table->name
											  , table->fields.field[m].name
											 , table->fields.field[m].type?table->fields.field[m].type:""
											  , table->fields.field[m].extra?WIDE(" "):WIDE("")
											  , table->fields.field[m].extra?table->fields.field[m].extra:WIDE("")
											  );
								SQLCommandf( odbc, WIDE("update `%s` set `%s`=`%s`")
											  , table->name
											  , table->fields.field[m].name
											  , table->fields.field[m].previous_names[prev] );
							}
						}
						if( !( options & CTO_MERGE ) )
						{
							if( options & CTO_DROP )
							{
								if( f_odbc )
									fprintf( f_odbc, WIDE("drop table `%s`"), table->name );
								else
									SQLCommandf( odbc, WIDE("drop table `%s`"), table->name );
								goto do_create_table;
							}
							if( f_odbc )
								fprintf( f_odbc
											  , WIDE("alter table `%s` drop column `%s`;\n")
											  , table->name
											  , pTestTable->fields.field[n].name );
							else
								SQLCommandf( odbc
											  , WIDE("alter table `%s` drop column `%s`")
											  , table->name
											  , pTestTable->fields.field[n].name );
							if( m < table->fields.count )
							{
							/* this field is now handled and done, forget it.*/
								Release( (void*)pTestTable->fields.field[n].name );
							// okay we already added this one, so make it
							// match our definition... otherwise following code will
							// also attempt to add this...
							// but in the process of dropping we may NOT
							// drop a renamed column- but must instead preserve it's data
								pTestTable->fields.field[n].name = StrDup( table->fields.field[m].name );
							}
						}
					}
				}
			}
			for( n = 0; n < table->fields.count; n++ )
			{
				int m;
				for( m = 0; m < pTestTable->fields.count; m++ )
				{
				//                if( fields[m] )
					if( StrCaseCmp( pTestTable->fields.field[m].name, table->fields.field[n].name ) == 0 )
						break;
				}
				if( m == pTestTable->fields.count )
				{
				// did not find this defined column in the table, add it.
					PTEXT txt_cmd;
					if( options & CTO_DROP )
					{
						if( f_odbc )
							fprintf( f_odbc, WIDE("drop table `%s`"), table->name );
						else
							SQLCommandf( odbc, WIDE("drop table `%s`"), table->name );
						goto do_create_table;
					}
					if( !pvtCreate )
						pvtCreate = VarTextCreate();
					vtprintf( pvtCreate, WIDE("alter table `%s` add column `%s` %s%s%s")
							  , table->name
							  , table->fields.field[n].name
							  , table->fields.field[n].type?table->fields.field[n].type:""
							  , table->fields.field[n].extra?WIDE(" "):WIDE("")
							  , table->fields.field[n].extra?table->fields.field[n].extra:WIDE("")
							  );
					txt_cmd = VarTextGet( pvtCreate );
					if( f_odbc )
						fprintf( f_odbc, WIDE( "%s;\n" ), GetText( txt_cmd ) );
					else
						SQLCommand( odbc, GetText( txt_cmd ) );
					LineRelease( txt_cmd );
				}
			}
		}
		DestroySQLTable( pTestTable );
	}
	else
	{
		// table doesn't exist?
		if( success && !result )
		{
			// do_create_table results in a PopODBC, so this one is redundant.
			// and we don't want to pop before it gets popped below.
			//PopODBCEx(odbc);
			goto do_create_table;
		}
		if( !success )
		{
			CTEXTSTR error;
			error = NULL;
			FetchSQLError( odbc, &error );
			if( StrCmpEx( error, WIDE("(37000)"), 7 ) == 0 )
			{
				// ODBC driver is old and does not support
				// 'TOP' command... please try again, using a less fancy
				// select... since it's file based, probably the data is not
				// all read, but one row at a time is read from the database.
				if( !retry )
				{
					StrCpyEx( cmd, WIDE("select * from `%s`"), 1024 );
					retry++;
					PopODBCEx(odbc);
					goto retry;
				}
			}
			if( StrCmpEx( error, WIDE("(S0002)"), 7 ) == 0 )
			{
				PTEXT txt_cmd;
				int n;
				int first;
				CTEXTSTR auto_increment_column;
			do_create_table:
				auto_increment_column = NULL;
				first = 1;
				if( !pvtCreate )
					pvtCreate = VarTextCreate();
				vtprintf( pvtCreate, WIDE("create table `%s` ("), table->name );
				for( n = 0; n < table->fields.count; n++ )
				{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
					if( odbc->flags.bSQLite_native )
					{
						if( table->fields.field[n].extra
							&&  StrCaseStr( table->fields.field[n].extra, WIDE( "auto_increment" ) ) )
						{
							if( auto_increment_column )
								lprintf( WIDE( "SQLITE ERROR: Failure will happen - more than one auto_increment" ) );
							auto_increment_column = table->fields.field[n].name;
							vtprintf( pvtCreate, WIDE( "%s`%s` %s%s" )
									  , first?WIDE(""):WIDE(",")
									  , table->fields.field[n].name
 //table->fields.field[n].type
									  , WIDE( "INTEGER" )
									  , WIDE( " PRIMARY KEY" )
									  );
						}
						else
						{
							CTEXTSTR unsigned_word;
							if(  table->fields.field[n].extra
								&& (unsigned_word=StrStr( table->fields.field[n].extra
								                        , WIDE( "unsigned" ) )) )
							{
								TEXTSTR extra = StrDup( table->fields.field[n].extra );
								size_t len = StrLen( unsigned_word + 8 );
								// use same buffer allocated to write into...
								tnprintf( extra, strlen( table->fields.field[n].extra ), WIDE( "%*.*s%*.*s" )
								       , (int)(unsigned_word-table->fields.field[n].extra)
								       , (int)(unsigned_word-table->fields.field[n].extra)
									   , table->fields.field[n].extra
									   , (int)len
									   , (int)len
									   , unsigned_word + 8
									   );
								vtprintf( pvtCreate, WIDE("%s`%s` %s %s")
										  , first?WIDE(""):WIDE(",")
										  , table->fields.field[n].name
										  , table->fields.field[n].type? table->fields.field[n].type:""
										  , extra
										  );
								Release( extra );
							}
							else
								vtprintf( pvtCreate, WIDE("%s`%s` %s%s%s")
										  , first?WIDE(""):WIDE(",")
										  , table->fields.field[n].name
										  , table->fields.field[n].type ? table->fields.field[n].type : ""
										  , table->fields.field[n].extra?WIDE(" "):WIDE("")
										  , table->fields.field[n].extra?table->fields.field[n].extra:WIDE("")
										  );
						}
					}
					else
#endif
						vtprintf( pvtCreate, WIDE("%s`%s` %s%s%s")
								  , first?WIDE(""):WIDE(",")
								  , table->fields.field[n].name
								  , table->fields.field[n].type ? table->fields.field[n].type : ""
								  , table->fields.field[n].extra?WIDE(" "):WIDE("")
								  , table->fields.field[n].extra?table->fields.field[n].extra:WIDE("")
								  );
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
					if( odbc->flags.bSQLite_native )
					{
						int k;
						for( k = 0; k < table->keys.count; k++ )
						{
							if( table->keys.key[k].flags.bPrimary && !table->keys.key[k].colnames[1] )
							{
								if( StrCmp( table->keys.key[k].colnames[0], table->fields.field[n].name ) == 0 )
								{
									vtprintf( pvtCreate, WIDE(" PRIMARY KEY") );
								}
							}
							if( table->keys.key[k].flags.bUnique && !table->keys.key[k].colnames[1] )
							{
								if( StrCmp( table->keys.key[k].colnames[0], table->fields.field[n].name ) == 0 )
								{
									vtprintf( pvtCreate, WIDE( " UNIQUE" ) );
								}
							}
						}
					}
#endif
					first = 0;
				}
				for( n = 0; n < table->keys.count; n++ )
				{
					int col;
					int colfirst = 1;
					if( table->keys.key[n].flags.bPrimary )
					{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
						if( odbc->flags.bSQLite_native )
						{
							if( auto_increment_column )
							{
								if( table->keys.key[n].colnames[1] )
								{
									lprintf( WIDE( "SQLITE ERROR: Complex PRIMARY KEY promoting to UNIQUE" ) );
									vtprintf( pvtCreate, WIDE("%sUNIQUE `primary` (")
											  , first?WIDE(""):WIDE(",") );
								}
								if( strcmp( auto_increment_column, table->keys.key[n].colnames[0] ) ) {
									lprintf( WIDE( "SQLITE ERROR: auto_increment column was not the PRMIARY KEY" ) );
								} else
								{
									// ignore key
									continue;
								}
							}
							else
							{
								//vtprintf( pvtCreate, WIDE("%sPRIMARY KEY (")
								//		  , first?WIDE(""):WIDE(",") );
							}
						}
						else
#endif
						{
							vtprintf( pvtCreate, WIDE("%sPRIMARY KEY (")
									  , first?WIDE(""):WIDE(",") );
							for( col = 0; table->keys.key[n].colnames[col]; col++ )
							{
								if( !table->keys.key[n].colnames[col] )
									break;
								vtprintf( pvtCreate, WIDE("%s`%s`")
										  , colfirst?WIDE(""):WIDE(",")
										  , table->keys.key[n].colnames[col]
										  );
								colfirst = 0;
							}
							vtprintf( pvtCreate, WIDE(")") );
						}
					}
					else
					{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
						if( odbc->flags.bSQLite_native )
						{
							if( table->keys.key[n].flags.bUnique )
							{
								if( table->keys.key[n].colnames[1] )
								{
									int c;
									vtprintf( pvtCreate, WIDE("%sCONSTRAINT `%s` UNIQUE (")
											  , first?WIDE(""):WIDE(",")
											  , table->keys.key[n].name
											  );
									for( c = 0; table->keys.key[n].colnames[c]; c++ )
										vtprintf( pvtCreate, WIDE( "%s`%s`"), (c==0)?WIDE(""):WIDE(","), table->keys.key[n].colnames[c] );
									vtprintf( pvtCreate, WIDE(")") );
                           if( table->keys.key[n].flags.uniqueResolution != UNIQRES_UNSET )
										vtprintf( pvtCreate, WIDE("ON CONFLICT %s")
													, table->keys.key[n].flags.uniqueResolution == UNIQRES_REPLACE ? "REPLACE"
													: table->keys.key[n].flags.uniqueResolution == UNIQRES_ABORT ? "ABORT"
													: table->keys.key[n].flags.uniqueResolution == UNIQRES_FAIL ? "FAIL"
													: table->keys.key[n].flags.uniqueResolution == UNIQRES_IGNORE ? "IGNORE"
													: table->keys.key[n].flags.uniqueResolution == UNIQRES_ROLLBACK ? "ROLLBACK"
													: "ABORT"
												  );
									first = 0;
								}
							}
						}
						else
#endif
						{
							vtprintf( pvtCreate, WIDE("%s%sKEY `%s` (")
									  , first?WIDE(""):WIDE(",")
									  , table->keys.key[n].flags.bUnique?WIDE("UNIQUE "):WIDE("")
									  , table->keys.key[n].name );
							for( col = 0; table->keys.key[n].colnames[col]; col++ )
							{
								if( !table->keys.key[n].colnames[col] )
									break;
								vtprintf( pvtCreate, WIDE("%s`%s`")
										  , colfirst?WIDE(""):WIDE(",")
										  , table->keys.key[n].colnames[col]
										  );
								colfirst = 0;
							}
							vtprintf( pvtCreate, WIDE(")") );
							first = 0;
						}
					}
				}
				for( n = 0; n < table->constraints.count; n++ )
				{
					int col;
					int colfirst = 1;
					{
						{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
							if( odbc->flags.bSQLite_native )
								vtprintf( pvtCreate, WIDE("%s FOREIGN KEY  (" )
										  , first?WIDE(""):WIDE(",") );
							else
#endif
								vtprintf( pvtCreate, WIDE("%sCONSTRAINT `%s` FOREIGN KEY (" )
										  , first?WIDE(""):WIDE(",")
										  , table->constraints.constraint[n].name );
							colfirst = 1;
							for( col = 0; table->constraints.constraint[n].colnames[col]; col++ )
							{
								if( !table->constraints.constraint[n].colnames[col] )
									break;
								vtprintf( pvtCreate, WIDE("%s`%s`")
										  , colfirst?WIDE(""):WIDE(",")
										  , table->constraints.constraint[n].colnames[col]
										  );
								colfirst = 0;
							}
							vtprintf( pvtCreate, WIDE(") REFERENCES `%s`(")
									  , table->constraints.constraint[n].references );
							colfirst = 1;
							for( col = 0; table->constraints.constraint[n].foriegn_colnames[col]; col++ )
							{
								if( !table->constraints.constraint[n].foriegn_colnames[col] )
									break;
								vtprintf( pvtCreate, WIDE("%s`%s`")
										  , colfirst?WIDE(""):WIDE(",")
										  , table->constraints.constraint[n].foriegn_colnames[col]
										  );
								colfirst = 0;
							}
							vtprintf( pvtCreate, WIDE(")%s %s")
									  , table->constraints.constraint[n].flags.cascade_on_update?WIDE("ON UPDATE CASCADE")
										:table->constraints.constraint[n].flags.restrict_on_update?WIDE("ON UPDATE RESTRICT")
										:table->constraints.constraint[n].flags.setnull_on_update?WIDE("ON UPDATE SET NULL")
										:table->constraints.constraint[n].flags.setdefault_on_update?WIDE("ON UPDATE SET DEFAULT")
										:table->constraints.constraint[n].flags.noaction_on_update?WIDE("ON UPDATE NO ACTION")
										:WIDE("")
									  , table->constraints.constraint[n].flags.cascade_on_delete?WIDE("ON DELETE CASCADE")
										:table->constraints.constraint[n].flags.restrict_on_delete?WIDE("ON DELETE RESTRICT")
										:table->constraints.constraint[n].flags.setnull_on_delete?WIDE("ON DELETE SET NULL")
										:table->constraints.constraint[n].flags.setdefault_on_delete?WIDE("ON DELETE SET DEFAULT")
										:table->constraints.constraint[n].flags.noaction_on_delete?WIDE("ON DELETE NO ACTION")
										:WIDE("")
									  );
							 first = 0;
						}
					}
				}
 // closing paren of all columns...
				vtprintf( pvtCreate, WIDE(")") ) ;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
				if( !odbc->flags.bSQLite_native )
#endif
				{
					/* these are not supported under sqlite backend*/
					if( table->type )
						vtprintf( pvtCreate, WIDE("TYPE=%s"),table->type ) ;
					//else
					//	vtprintf( pvtCreate, WIDE("TYPE=MyISAM") ); // cpg 15 dec 2006
					if( table->comment )
						vtprintf( pvtCreate, WIDE(" COMMENT=\'%s\'" ), table->comment );
				}
				PopODBCEx(odbc);
				txt_cmd = VarTextPeek( pvtCreate );
				if( f_odbc )
					fprintf( f_odbc, WIDE( "%s;\n" ), GetText( txt_cmd ) );
				else
					if( !SQLCommand( odbc, GetText( txt_cmd ) ) )
						status = 0;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
				if( odbc->flags.bSQLite_native ) {
					VarTextEmpty( pvtCreate );
					for( n = 0; n < table->keys.count; n++ ) {
						int col;
						int colfirst;
						colfirst = 1;
						if( !table->keys.key[n].flags.bPrimary) {
							vtprintf( pvtCreate, WIDE( "CREATE %sINDEX '%s' ON '%s'(" )
								, table->keys.key[n].flags.bUnique ? WIDE( "UNIQUE " ) : WIDE( "" )
								, table->keys.key[n].name
								, table->name );
							for( col = 0; table->keys.key[n].colnames[col]; col++ ) {
								if( !table->keys.key[n].colnames[col] )
									break;
								vtprintf( pvtCreate, WIDE( "%s'%s'" )
									, colfirst ? WIDE( "" ) : WIDE( "," )
									, table->keys.key[n].colnames[col]
								);
								colfirst = 0;
							}
							vtprintf( pvtCreate, WIDE( ")" ) );
							first = 0;
							if( !SQLCommand( odbc, GetText( VarTextPeek( pvtCreate ) ) ) )
								status = 0;
							VarTextEmpty( pvtCreate );
						}
					}
				}
#endif
			}
			else
			{
				lprintf( WIDE("error is : %s"), error );
			}
		}
	}
	Release(cmd);
	if( pvtCreate )
		VarTextDestroy( &pvtCreate );
	if( f_odbc )
		fclose( f_odbc );
	return status;
}
LOGICAL CheckODBCTableEx( PODBC odbc, PTABLE table, uint32_t options DBG_PASS )
{
	if( !odbc )
	{
		OpenSQL( DBG_VOIDRELAY );
		odbc = g.odbc;
	}
			  //    DebugBreak();
	if( !odbc )
		return FALSE;
			  // should check some kinda flag on ODBC to see if it's MySQL or Access
			  //    DebugBreak();
	if( odbc->flags.bAccess )
		return CheckAccessODBCTable( odbc, table, options );
	else
		return CheckMySQLODBCTable( odbc, table, options );
}
#undef CheckODBCTable
LOGICAL CheckODBCTable( PODBC odbc, PTABLE table, uint32_t options )
{
	return CheckODBCTableEx( odbc, table, options DBG_SRC );
}
static void CreateNameTable( PODBC odbc, CTEXTSTR table_name )
{
	TEXTCHAR field1[256];
	TEXTCHAR field2[256];
	TABLE table;
	FIELD fields[2];
#ifdef __cplusplus
#else
	DB_KEY_DEF keys[1];
#endif
	tnprintf( field1, sizeof( field1 ), WIDE("%s_id"), table_name );
#ifdef __cplusplus
	DB_KEY_DEF keys[1] = { required_key_def( TRUE, FALSE, NULL, field1 ) };
#endif
	table.name = table_name;
	table.fields.count = 2;
	table.fields.field = fields;
	table.keys.count = 1;
	table.keys.key = keys;
	table.type = NULL;
	table.comment = WIDE( "Auto Created table." );
	fields[0].name = field1;
	fields[0].type = WIDE("int");
	fields[0].extra = WIDE("auto_increment");
	fields[0].previous_names[0] = NULL;
	tnprintf( field2, sizeof( field2 ), WIDE("%s_name"), table_name );
	fields[1].name = field2;
	fields[1].type = WIDE("varchar(100)");
	fields[1].extra = NULL;
	fields[1].previous_names[0] = NULL;
#ifndef __cplusplus
 // primary key needs no name
	keys[0].name = NULL;
	keys[0].flags.bPrimary = 1;
	keys[0].flags.bUnique = 0;
	keys[0].colnames[0] = field1;
	keys[0].colnames[1] = NULL;
	keys[0].null = NULL;
#endif
	CheckODBCTable( odbc, &table, CTO_MERGE );
}
INDEX FetchSQLNameID( PODBC odbc, CTEXTSTR table_name, CTEXTSTR name )
{
	{
		CTEXTSTR result;
		int bTried = 0;
	retry:
		if( !SQLQueryf( odbc
						  , &result
						  , WIDE("select %s_id from %s where %s_name=\'%s\'")
						  , table_name
						  , table_name
						  , table_name
						  , name ) )
		{
			FetchSQLError( odbc, &result );
			if( ( StrCmpEx( result, WIDE("(S0022)"), 7 ) == 0 ) ||
				( StrCmpEx( result, WIDE("(S0002)"), 7 ) == 0 ) )
			{
				if( !bTried )
				{
					bTried = 1;
					CreateNameTable( odbc, table_name );
					goto retry;
				}
			}
		}
		else
		{
			if( !result )
			{
				if( !SQLCommandf( odbc, WIDE("insert into %s (%s_name)values(\'%s\')"), table_name, table_name, name ) )
				{
					lprintf( WIDE("blah!") );
				}
				else
				{
					TEXTCHAR table_name_id[256];
					tnprintf( table_name_id, sizeof( table_name_id ), WIDE("%s_id"), table_name );
					return FetchLastInsertID( odbc, table_name, table_name_id );
				}
			}
			else
			{
				return (INDEX)IntCreateFromText( result );
			}
		}
	}
	return INVALID_INDEX;
}
CTEXTSTR FetchSQLName( PODBC odbc, CTEXTSTR table_name, INDEX iName )
{
	{
		CTEXTSTR result;
		int bTried = 0;
	retry:
		if( !SQLQueryf( odbc
						  , &result
						  , WIDE("select %s_name from %s where %s_id=%lu")
						  , table_name
						  , table_name
						  , table_name
						  , iName ) )
		{
			FetchSQLError( odbc, &result );
			if( ( StrCmpEx( result, WIDE("(S0022)"), 7 ) == 0 ) ||
				( StrCmpEx( result, WIDE("(S0002)"), 7 ) == 0 ) )
			{
				if( !bTried )
				{
					bTried = 1;
					CreateNameTable( odbc, table_name );
					goto retry;
				}
			}
		}
		else
		{
			if( !result )
			{
				return NULL;
			}
			else
			{
				return StrDup( result );
			}
		}
	}
	return NULL;
}
INDEX GetSQLNameID( CTEXTSTR table_name, CTEXTSTR name )
{
	if( !g.odbc )
		OpenSQL( DBG_VOIDSRC );
	if( !g.odbc )
		return INVALID_INDEX;
	return FetchSQLNameID( g.odbc, table_name, name );
}
CTEXTSTR GetSQLName( CTEXTSTR table_name, INDEX iName )
{
	if( !g.odbc )
		OpenSQL( DBG_VOIDSRC );
	if( !g.odbc )
		return NULL;
	return FetchSQLName( g.odbc, table_name, iName );
}
LOGICAL BackupDatabase( PODBC source, PODBC dest )
{
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	if( source->flags.bSQLite_native && dest->flags.bSQLite_native ) {
		sqlite3_backup *sb = sqlite3_backup_init( dest->db, "main", source->db, "main" );
		if( sb )
		{
			sqlite3_backup_step( sb, 1 );
			sqlite3_backup_step( sb, sqlite3_backup_remaining( sb ) );
			sqlite3_backup_finish( sb );
			return TRUE;
		}
	}
#endif
	  return FALSE;
}
SQL_NAMESPACE_END
#ifndef NEED_SHLOBJ
#  define NEED_SHLOBJ
#endif
#if !defined( __LINUX__ ) && !defined( __INTERNAL_UUID__ )
#include <rpc.h>
SQL_NAMESPACE
PRELOAD( SqlPreloadInitCo )
{
   CoInitializeEx( NULL, COINIT_MULTITHREADED );
}
#if ( defined( __WATCOMC__) && ( __WATCOMC__ < 1280 ) ) || defined( MINGW_SUX )
#ifdef __cplusplus
	extern "C" {
#endif
	RPC_STATUS RPC_ENTRY UuidCreateSequential( UUID __RPC_FAR *Uuid );
	RPC_STATUS RPC_ENTRY UuidCreate(
											  UUID __RPC_FAR *Uuid
											 );
#ifndef MINGW_SUX
	RPC_STATUS RPC_ENTRY UuidToString(
												 UUID __RPC_FAR *Uuid ,
												 unsigned char __RPC_FAR * __RPC_FAR *StringUuid
												);
	RPC_STATUS RPC_ENTRY UuidFromString(
													unsigned char __RPC_FAR *StringUuid,
													UUID __RPC_FAR *Uuid
												  );
#endif
#ifdef __cplusplus
	}
#endif
#endif
CTEXTSTR GetGUID( void )
{
	GUID guid;
	TEXTSTR text_guid = NewArray( TEXTCHAR, 37 );
	CTEXTSTR result;
	//TEXTSTR ext;
	int n;
	int x = 1;
	//CoCreateGuid( &guid );
	//UuidCreate( &guid );
	UuidCreate( &guid );
	tnprintf( text_guid, 37, WIDE("%08lx-%04x-%04x-")
			  , guid.Data1
			  , guid.Data2
			  , guid.Data3
			  );
	for( n = 0; n < 8; n++ )
	{
		if( n == 2 )
		{
			// plus 2 more for being AFTER the digits.
			text_guid[18 + (n*2) + x] = '-';
			x++;
		}
		tnprintf( text_guid + 18 + (n*2) + x, 3, WIDE("%02x"), guid.Data4[n] );
	}
	//lprintf( "Created GUid {%s}", text_guid );
	//lprintf( "My Conversion: %s", text_guid );
	//UuidToString( &guid, &ext );
	//lprintf( "   Conversion : %s", ext );
	result = SaveText( text_guid );
	Release( text_guid );
	return result;
}
CTEXTSTR GetSeqGUID( void )
{
	GUID guid;
	TEXTSTR text_guid = NewArray( TEXTCHAR, 37 );
	//TEXTSTR ext;
	int n;
	int x = 1;
	//CoCreateGuid( &guid );
	//UuidCreate( &guid );
	UuidCreateSequential( &guid );
	tnprintf( text_guid, 37, WIDE("%08lx-%04x-%04x-")
			  , guid.Data1
			  , guid.Data2
			  , guid.Data3
			  );
	for( n = 0; n < 8; n++ )
	{
		if( n == 2 )
		{
			// plus 2 more for being AFTER the digits.
			text_guid[18 + (n*2) + x] = '-';
			x++;
		}
		tnprintf( text_guid + 18 + (n*2) + x, 3, WIDE("%02x"), guid.Data4[n] );
	}
	//lprintf( "Created GUid {%s}", text_guid );
	//lprintf( "My Conversion: %s", text_guid );
	//UuidToString( &guid, &ext );
	//lprintf( "   Conversion : %s", ext );
	return SaveText( text_guid );
}
#else
#  ifdef __INTERNAL_UUID__
/*
**  OSSP uuid - Universally Unique Identifier
**  Copyright (c) 2004-2008 Ralf S. Engelschall <rse@engelschall.com>
**  Copyright (c) 2004-2008 The OSSP Project <http://www.ossp.org/>
**
**  This file is part of OSSP uuid, a library for the generation
**  of UUIDs which can found at http://www.ossp.org/pkg/lib/uuid/
**
**  Permission to use, copy, modify, and distribute this software for
**  any purpose with or without fee is hereby granted, provided that
**  the above copyright notice and this permission notice appear in all
**  copies.
**
**  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
**  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
**  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
**  IN NO EVENT SHALL THE AUTHORS AND COPYRIGHT HOLDERS AND THEIR
**  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
**  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
**  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
**  USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
**  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
**  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
**  OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
**  SUCH DAMAGE.
**
**  uuid.h: library API definition
*/
#ifndef __UUID_H__
#define __UUID_H__
/* workaround conflicts with system headers */
#define uuid_t       __vendor_uuid_t
#define uuid_create  __vendor_uuid_create
#define uuid_compare __vendor_uuid_compare
#undef  uuid_t
#undef  uuid_create
#undef  uuid_compare
/* required system headers */
#ifdef UUID_SOURCE
#define UUID_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define UUID_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
/* minimum C++ support */
#ifdef __cplusplus
#define DECLARATION_BEGIN extern "C" {
#define DECLARATION_END   }
#else
#define DECLARATION_BEGIN
#define DECLARATION_END
#endif
DECLARATION_BEGIN
/* OSSP uuid version (compile-time information) */
#define UUID_VERSION  @UUID_VERSION_HEX@
/* encoding octet stream lengths */
 /*bit*/
 /*bytes*/
#define UUID_LEN_BIN  (128 / 8)
 /*bit*/
 /*nibbles*/
 /*hyphens*/
#define UUID_LEN_STR  (128 / 4 + 4)
  /*int(log(10,exp(2,128)-1)+1) digits*/
#define UUID_LEN_SIV  (39)
/* API return codes */
typedef enum {
    UUID_RC_OK   = 0,
    UUID_RC_ARG  = 1,
    UUID_RC_MEM  = 2,
    UUID_RC_SYS  = 3,
    UUID_RC_INT  = 4,
    UUID_RC_IMP  = 5
} uuid_rc_t;
/* UUID make modes */
enum {
    UUID_MAKE_V1 = (1 << 0),
    UUID_MAKE_V3 = (1 << 1),
    UUID_MAKE_V4 = (1 << 2),
    UUID_MAKE_V5 = (1 << 3),
    UUID_MAKE_MC = (1 << 4)
};
/* UUID import/export formats */
typedef enum {
    UUID_FMT_BIN = 0,
    UUID_FMT_STR = 1,
    UUID_FMT_SIV = 2,
    UUID_FMT_TXT = 3
} uuid_fmt_t;
/* UUID abstract data type */
struct uuid_st;
typedef struct uuid_st uuid_t;
/* UUID object handling */
UUID_PROC( uuid_rc_t, uuid_create )(      uuid_t **_uuid);
UUID_PROC( uuid_rc_t, uuid_destroy )(      uuid_t  *_uuid);
UUID_PROC( uuid_rc_t, uuid_clone )(const uuid_t  *_uuid, uuid_t **_clone);
/* UUID generation */
UUID_PROC( uuid_rc_t, uuid_load )(      uuid_t  *_uuid, const char *_name);
UUID_PROC( uuid_rc_t, uuid_make )(      uuid_t  *_uuid, unsigned int _mode, ...);
/* UUID comparison */
UUID_PROC( uuid_rc_t, uuid_isnil )(const uuid_t  *_uuid,                       int *_result);
UUID_PROC( uuid_rc_t, uuid_compare )(const uuid_t  *_uuid, const uuid_t *_uuid2, int *_result);
/* UUID import/export */
UUID_PROC( uuid_rc_t, uuid_import )(      uuid_t  *_uuid, uuid_fmt_t _fmt, const void  *_data_ptr, size_t  _data_len);
UUID_PROC( uuid_rc_t, uuid_export )(const uuid_t  *_uuid, uuid_fmt_t _fmt,       void  *_data_ptr, size_t *_data_len);
/* library utilities */
UUID_PROC( char*, uuid_error )(uuid_rc_t _rc);
UUID_PROC( unsigned long, uuid_version  )(void);
DECLARATION_END
#endif
#  else
#    include <uuid/uuid.h>
#  endif
SQL_NAMESPACE
#  ifdef __INTERNAL_UUID__
CTEXTSTR GetGUID( void )
{
	uuid_t *tmp;
	char *str = NULL;
	TEXTCHAR *out_guid;
	CTEXTSTR out_guid2;
	uuid_create( &tmp );
	uuid_make( tmp, UUID_MAKE_V1 );
	uuid_export( tmp, UUID_FMT_STR, &str, NULL );
	out_guid = DupCharToText( str );
	out_guid2 = SaveText( out_guid );
	Release( out_guid );
	return out_guid2;
}
CTEXTSTR GetSeqGUID( void )
{
	uuid_t *tmp;
	char *str = NULL;
	TEXTCHAR *out_guid;
	CTEXTSTR out_guid2;
	uuid_create( &tmp );
	uuid_make( tmp, UUID_MAKE_V1 );
	uuid_export( tmp, UUID_FMT_STR, &str, NULL );
	out_guid = DupCharToText( str );
	out_guid2 = SaveText( out_guid );
	Release( out_guid );
	return out_guid2;
}
#  else
CTEXTSTR GetGUID( void )
{
	uuid_t tmp;
   char str[37];
	TEXTCHAR *out_guid;
	CTEXTSTR out_guid2;
	uuid_generate_random ( tmp );
   uuid_unparse( tmp, str );
   //uuid_unparse_lower( tmp, str );
   //uuid_unparse_upper( tmp, str );
	out_guid = DupCharToText( str );
	out_guid2 = SaveText( out_guid );
	Release( out_guid );
	return out_guid2;
}
CTEXTSTR GetSeqGUID( void )
{
	uuid_t tmp;
   char str[37];
	TEXTCHAR *out_guid;
	CTEXTSTR out_guid2;
	uuid_generate_time( tmp );
   uuid_unparse( tmp, str );
   //uuid_unparse_lower( tmp, str );
   //uuid_unparse_upper( tmp, str );
	out_guid = DupCharToText( str );
	out_guid2 = SaveText( out_guid );
	Release( out_guid );
	return out_guid2;
}
#  endif
#endif
uint8_t* GetGUIDBinaryEx( CTEXTSTR guid, LOGICAL little_endian )
{
	static uint8_t buf[18];
	static int8_t char_lookup[256];
	int n;
   int b;
	if( char_lookup['1'] == 0 )
	{
		buf[16] = 0;
      buf[17] = 0;
		for( n = '0'; n <= '9'; n++ )
		{
         char_lookup[n] = n - '0';
		}
		for( n = 'a'; n <= 'f'; n++ )
		{
         char_lookup[n] = 10 + n - 'a';
		}
		for( n = 'A'; n <= 'F'; n++ )
		{
         char_lookup[n] = 10 + n - 'A';
		}
      char_lookup['-'] = -1;
	}
	for( b = n = 0; guid[n]; n++ )
	{
		if( char_lookup[(int)guid[n]] < 0 )
			continue;
      if( !( b & 1 ) )
			buf[b / 2] = char_lookup[guid[n]] << 4;
      else
			buf[b / 2] |= char_lookup[guid[n]];
      b++;
	}
	if( little_endian )
	{
		uint8_t tmp;
		tmp = buf[0];
		buf[0] = buf[3];
		buf[3] = tmp;
		tmp = buf[1];
		buf[1] = buf[2];
      buf[2] = tmp;
		tmp = buf[4];
		buf[4] = buf[5];
      buf[5] = tmp;
		tmp = buf[6];
		buf[6] = buf[7];
      buf[7] = tmp;
		tmp = buf[8];
		buf[8] = buf[9];
      buf[9] = tmp;
		tmp = buf[10];
		buf[10] = buf[15];
      buf[15] = tmp;
		tmp = buf[11];
		buf[11] = buf[14];
      buf[14] = tmp;
		tmp = buf[12];
		buf[12] = buf[13];
      buf[13] = tmp;
	}
   return buf;
}
CTEXTSTR GuidZero( void )
{
	return WIDE("00000000-0000-0000-0000-000000000000");
}
SQL_NAMESPACE_END
SQL_NAMESPACE
//----------------------------------------------------------------------
int ValidateCreateTable( PTEXT *word )
{
	if( !TextLike( (*word), WIDE( "create" ) ) )
		return FALSE;
	(*word) = NEXTLINE( (*word) );
	if( TextLike( (*word), WIDE( "temporary" ) ) )
		(*word) = NEXTLINE( (*word) );
	else if( TextLike( (*word), WIDE( "temp" ) ) )
		(*word) = NEXTLINE( (*word) );
	if( !TextLike( (*word), WIDE( "table" ) ) )
		return FALSE;
	(*word) = NEXTLINE( (*word) );
	if( TextLike( (*word), WIDE( "if" ) ) )
	{
		(*word) = NEXTLINE( (*word) );
		if( TextLike( (*word), WIDE( "not" ) ) )
		{
			(*word) = NEXTLINE( (*word) );
			if( TextLike( (*word), WIDE( "exists" ) ) )
				(*word) = NEXTLINE( (*word) );
			else
				return FALSE;
		}
		else
			return FALSE;
	}
	return TRUE;
}
//----------------------------------------------------------------------
int GrabName( PTEXT *word, TEXTSTR *result, int *bQuoted DBG_PASS )
{
	TEXTSTR name = NULL;
	CTEXTSTR open;
	//PTEXT start = (*word);
	//printf( WIDE( "word is %s" ), GetText( *word ) );
	if( TextLike( (*word), open = WIDE( "`" ) ) || TextLike( (*word), open = "\'" ) || TextLike( (*word),open="\"") )
	{
		PTEXT phrase = NULL;
		PTEXT line;
		if( bQuoted )
			(*bQuoted) = 1;
		(*word) = NEXTLINE( *word );
		while( (*word) && ( GetText( *word )[0] != open[0] ) )
		{
			phrase = SegAppend( phrase, SegDuplicateEx(*word DBG_RELAY ) );
			(*word) = NEXTLINE( *word );
		}
		// skip one more - end after the last `
		(*word) = NEXTLINE( *word );
		if( GetText( *word )[0] == '.' )
		{
			(*word) = NEXTLINE( *word );
			LineRelease( phrase );
			phrase = NULL;
			if( TextLike( (*word), open = WIDE( "`" ) ) || TextLike( (*word), open = "\'" ) || TextLike( (*word), open = "\"" ) )
			{
				(*word) = NEXTLINE( *word );
				while( (*word) && ( GetText( *word )[0] != open[0]) )
				{
					phrase = SegAppend( phrase, SegDuplicateEx(*word DBG_RELAY ) );
					(*word) = NEXTLINE( *word );
				}
				(*word) = NEXTLINE( *word );
			}
			else
			{
				phrase = SegAppend( phrase, SegDuplicateEx( *word DBG_RELAY ));
				(*word) = NEXTLINE( *word );
			}
		}
		line = BuildLine( phrase );
		LineRelease( phrase );
		name = StrDupEx( GetText( line ) DBG_RELAY );
		LineRelease( line );
	}
	else
	{
		// don't know...
		TEXTCHAR *next;
		if( bQuoted )
			(*bQuoted) = 0;
		next = GetText( NEXTLINE( *word ) );
		if( next && next[0] == '.' )
		{
			// database and table name...
			(*word) = NEXTLINE( *word );
			(*word) = NEXTLINE( *word );
			name = StrDup( GetText(*word ) );
			(*word) = NEXTLINE( *word );
		}
		else
		{
			name = StrDupEx( GetText(*word ) DBG_RELAY );
			(*word) = NEXTLINE( *word );
		}
	}
	if( result )
		(*result) = name;
	return name?TRUE:FALSE;
}
//----------------------------------------------------------------------
static int GrabType( PTEXT *word, TEXTSTR *result DBG_PASS )
{
	if( (*word ) )
	{
		//int quote = 0;
		//int escape = 0;
		int parens = 0;
		TEXTCHAR *tmp;
		if( (*word) && ( ( tmp = GetText( *word ) )[0] != ',' || ( parens > 0 ) ) && ( ( parens > 0 ) || (tmp[0] != ')') ) )
		{
			PTEXT type = SegDuplicate(*word);
			type->format.position.offset.spaces = 0;
			type->format.position.offset.tabs = 0;
			(*word) = NEXTLINE( *word );
			if( StrCaseCmp( GetText( type ), WIDE( "unsigned" ) ) == 0 )
			{
				SegAppend( type, SegDuplicate(*word) );
				(*word) = NEXTLINE( *word );
			}
			if( (*word) && GetText( *word )[0] == '(' )
			{
				while( (*word) && GetText( *word )[0] != ')' )
				{
					type = SegAppend( type, SegDuplicate( *word ) );
					(*word) = NEXTLINE( *word );
				}
				type = SegAppend( type, SegDuplicate( *word ) );
				(*word) = NEXTLINE( *word );
			}
			{
				PTEXT tmp = BuildLine( type );
				LineRelease( type );
				if( result )
					(*result) = StrDupEx( GetText( tmp ) DBG_RELAY );
				LineRelease( tmp );
			}
		}else {
			(*result) = NULL;
		}
		return TRUE;
	}
	return FALSE;
}
//----------------------------------------------------------------------
static int GrabExtra( PTEXT *word, TEXTSTR *result )
{
	if( (*word ) )
	{
		PTEXT type = NULL;
		{
			int parens = 0;
			TEXTCHAR *tmp;
			while( (*word) && ( ( tmp = GetText( *word ) )[0] != ',' || ( parens > 0 ) ) && ( ( parens > 0 ) || (tmp[0] != ')') ) )
			{
				if( tmp[0] == '(' )
					parens++;
				if( tmp[0] == ')' ) {
					parens--;
					//break;
				}
				type = SegAppend( type, SegDuplicate( *word ) );
				(*word) = NEXTLINE( *word );
			}
		}
		if( type )
		{
			type->format.position.offset.spaces = 0;
			type->format.position.offset.tabs = 0;
			{
				PTEXT tmp = BuildLine( type );
				LineRelease( type );
				if( result )
					(*result) = StrDup( GetText( tmp ) );
				LineRelease( tmp );
			}
		}
		else
			if( result )
				(*result) = NULL;
	}
	return TRUE;
}
void GrabKeyColumns( PTEXT *word, CTEXTSTR *columns )
{
	int cols = 0;
	if( (*word) && GetText( *word )[0] == '(' )
	{
		do
		{
			(*word) = NEXTLINE( *word );
			if( cols >= MAX_KEY_COLUMNS )
			{
				lprintf( WIDE( "Too many key columns specified in key for current structure limits." ) );
				DebugBreak();
			}
			GrabName( word, (TEXTSTR*)columns + cols, NULL DBG_SRC );
			cols++;
			columns[cols] = NULL;
		}
		while( (*word) && GetText( *word )[0] != ')' );
		(*word) = NEXTLINE( *word );
	}
}
//----------------------------------------------------------------------
void AddConstraint( PTABLE table, PTEXT *word )
{
	TEXTSTR tmpname;
	GrabName( word, (TEXTSTR*)&tmpname, NULL  DBG_SRC);
	if( StrCaseCmp( GetText(*word), WIDE( "UNIQUE" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		if( StrCaseCmp( GetText(*word), WIDE( "KEY" ) ) == 0 )
		{
			(*word) = NEXTLINE( *word );
		}
		table->keys.count++;
		table->keys.key = Renew( DB_KEY_DEF
		                  , table->keys.key
		                  , table->keys.count + 1 );
		table->keys.key[table->keys.count-1].null = NULL;
		table->keys.key[table->keys.count-1].flags.bPrimary = 0;
		table->keys.key[table->keys.count-1].flags.bUnique = 1;
		table->keys.key[table->keys.count-1].name = tmpname;
		table->keys.key[table->keys.count-1].colnames[0] = NULL;
		table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_UNSET;
		GrabKeyColumns( word, table->keys.key[table->keys.count-1].colnames );
		if( StrCaseCmp( GetText(*word), WIDE( "ON" ) ) == 0 )
		{
			(*word) = NEXTLINE( *word );
			if( StrCaseCmp( GetText(*word), WIDE( "CONFLICT" ) ) == 0 )
			{
				(*word) = NEXTLINE( *word );
				if( StrCaseCmp( GetText(*word), WIDE( "REPLACE" ) ) == 0 )
				{
					table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_REPLACE;
					(*word) = NEXTLINE( *word );
				}
				if( StrCaseCmp( GetText(*word), WIDE( "IGNORE" ) ) == 0 )
				{
					table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_IGNORE;
					(*word) = NEXTLINE( *word );
				}
				if( StrCaseCmp( GetText(*word), WIDE( "FAIL" ) ) == 0 )
				{
					table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_FAIL;
					(*word) = NEXTLINE( *word );
				}
				if( StrCaseCmp( GetText(*word), WIDE( "ABORT" ) ) == 0 )
				{
					table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_ABORT;
					(*word) = NEXTLINE( *word );
				}
				if( StrCaseCmp( GetText(*word), WIDE( "ROLLBACK" ) ) == 0 )
				{
					table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_ROLLBACK;
					(*word) = NEXTLINE( *word );
				}
			}
		}
		return;
	}
	table->constraints.count++;
	table->constraints.constraint = Renew( DB_CONSTRAINT_DEF
                          , table->constraints.constraint
                          , table->constraints.count + 1 );
	table->constraints.constraint[table->constraints.count-1].name = tmpname;
	if( StrCaseCmp( GetText(*word), WIDE( "UNIQUE" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
	}
	else if( StrCaseCmp( GetText(*word), WIDE( "FOREIGN" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		if( StrCaseCmp( GetText(*word), WIDE( "KEY" ) ) == 0 )
		{
			// next word is the type, skip that word too....
			(*word) = NEXTLINE( *word );
			table->constraints.constraint[table->constraints.count-1].flags.foreign_key = 1;
		}
			table->constraints.constraint[table->constraints.count-1].flags.foreign_key = 1;
	}
	GrabKeyColumns( word, table->constraints.constraint[table->constraints.count-1].colnames );
	if( StrCaseCmp( GetText(*word), WIDE( "REFERENCES" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		GrabName( word, (TEXTSTR*)&table->constraints.constraint[table->constraints.count-1].references, NULL  DBG_SRC);
		GrabKeyColumns( word, table->constraints.constraint[table->constraints.count-1].foriegn_colnames );
	}
	while( StrCaseCmp( GetText(*word), WIDE( "ON" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		if( StrCaseCmp( GetText(*word), WIDE( "DELETE" ) ) == 0 )
		{
			(*word) = NEXTLINE( *word );
			if( StrCaseCmp( GetText(*word), WIDE( "CASCADE" ) ) == 0 )
			{
				table->constraints.constraint[table->constraints.count-1].flags.cascade_on_delete = 1;
				(*word) = NEXTLINE( *word );
			}
			else if( StrCaseCmp( GetText(*word), WIDE( "RESTRICT" ) ) == 0 )
			{
				table->constraints.constraint[table->constraints.count-1].flags.restrict_on_delete = 1;
				(*word) = NEXTLINE( *word );
			}
			else if( StrCaseCmp( GetText(*word), WIDE( "NO" ) ) == 0 )
			{
				(*word) = NEXTLINE( *word );
				if( StrCaseCmp( GetText(*word), WIDE( "ACTION" ) ) == 0 )
				{
					table->constraints.constraint[table->constraints.count-1].flags.noaction_on_delete = 1;
					(*word) = NEXTLINE( *word );
				}
			}
			if( StrCaseCmp( GetText(*word), WIDE( "SET" ) ) == 0 )
			{
				(*word) = NEXTLINE( *word );
				if( StrCaseCmp( GetText(*word), WIDE( "NULL" ) ) == 0 )
				{
					table->constraints.constraint[table->constraints.count-1].flags.setnull_on_delete = 1;
					(*word) = NEXTLINE( *word );
				}
				else if( StrCaseCmp( GetText(*word), WIDE( "DEFAULT" ) ) == 0 )
				{
					table->constraints.constraint[table->constraints.count-1].flags.setdefault_on_delete = 1;
					(*word) = NEXTLINE( *word );
				}
			}
		}
		if( StrCaseCmp( GetText(*word), WIDE( "UPDATE" ) ) == 0 )
		{
			(*word) = NEXTLINE( *word );
			if( StrCaseCmp( GetText(*word), WIDE( "CASCADE" ) ) == 0 )
			{
				table->constraints.constraint[table->constraints.count-1].flags.cascade_on_update = 1;
				(*word) = NEXTLINE( *word );
			}
			else if( StrCaseCmp( GetText(*word), WIDE( "RESTRICT" ) ) == 0 )
			{
				table->constraints.constraint[table->constraints.count-1].flags.restrict_on_update = 1;
				(*word) = NEXTLINE( *word );
			}
			else if( StrCaseCmp( GetText(*word), WIDE( "NO" ) ) == 0 )
			{
				(*word) = NEXTLINE( *word );
				if( StrCaseCmp( GetText(*word), WIDE( "ACTION" ) ) == 0 )
				{
					table->constraints.constraint[table->constraints.count-1].flags.noaction_on_update = 1;
					(*word) = NEXTLINE( *word );
				}
			}
			else if( StrCaseCmp( GetText(*word), WIDE( "SET" ) ) == 0 )
			{
				(*word) = NEXTLINE( *word );
				if( StrCaseCmp( GetText(*word), WIDE( "NULL" ) ) == 0 )
				{
					table->constraints.constraint[table->constraints.count-1].flags.setnull_on_update = 1;
					(*word) = NEXTLINE( *word );
				}
				else if( StrCaseCmp( GetText(*word), WIDE( "DEFAULT" ) ) == 0 )
				{
					table->constraints.constraint[table->constraints.count-1].flags.setdefault_on_update = 1;
					(*word) = NEXTLINE( *word );
				}
			}
		}
	}
}
void AddIndexKey( PTABLE table, PTEXT *word, int has_name, int primary, int unique )
{
	table->keys.count++;
	table->keys.key = Renew( DB_KEY_DEF
                          , table->keys.key
                          , table->keys.count + 1 );
	table->keys.key[table->keys.count-1].null = NULL;
	table->keys.key[table->keys.count-1].flags.bPrimary = primary;
	table->keys.key[table->keys.count-1].flags.bUnique = unique;
	if( has_name )
		GrabName( word, (TEXTSTR*)&table->keys.key[table->keys.count-1].name, NULL  DBG_SRC);
	else
		table->keys.key[table->keys.count-1].name = NULL;
	//lprintf( "add index key name: %s",table->keys.key[table->keys.count-1].name );
	//table->keys.key[table->keys.count-1].colnames = New( CTEXTSTR );
	table->keys.key[table->keys.count-1].colnames[0] = NULL;
	if( StrCaseCmp( GetText(*word), WIDE( "USING" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		// next word is the type, skip that word too....
		(*word) = NEXTLINE( *word );
	}
	GrabKeyColumns( word, table->keys.key[table->keys.count-1].colnames );
	// using can be after the columns also...
	if( StrCaseCmp( GetText(*word), WIDE( "USING" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		// next word is the type, skip that word too....
		(*word) = NEXTLINE( *word );
	}
	if( StrCaseCmp( GetText(*word), WIDE( "ON" ) ) == 0 )
	{
		(*word) = NEXTLINE( *word );
		if( StrCaseCmp( GetText(*word), WIDE( "CONFLICT" ) ) == 0 )
		{
			(*word) = NEXTLINE( *word );
			if( StrCaseCmp( GetText(*word), WIDE( "REPLACE" ) ) == 0 )
			{
				table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_REPLACE;
				(*word) = NEXTLINE( *word );
			}
			if( StrCaseCmp( GetText(*word), WIDE( "IGNORE" ) ) == 0 )
			{
				table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_IGNORE;
				(*word) = NEXTLINE( *word );
			}
			if( StrCaseCmp( GetText(*word), WIDE( "FAIL" ) ) == 0 )
			{
				table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_FAIL;
				(*word) = NEXTLINE( *word );
			}
			if( StrCaseCmp( GetText(*word), WIDE( "ABORT" ) ) == 0 )
			{
				table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_ABORT;
				(*word) = NEXTLINE( *word );
			}
			if( StrCaseCmp( GetText(*word), WIDE( "ROLLBACK" ) ) == 0 )
			{
				table->keys.key[table->keys.count-1].flags.uniqueResolution = UNIQRES_ROLLBACK;
				(*word) = NEXTLINE( *word );
			}
		}
	}
}
//----------------------------------------------------------------------
int GetTableColumns( PTABLE table, PTEXT *word DBG_PASS )
{
	if( !*word)
		return FALSE;
	//DebugBreak();
	if( GetText( *word )[0] != '(' )
	{
		PTEXT line;
		lprintf( WIDE( "Failed to find columns... extra data between table name and columns...." ) );
		lprintf( WIDE( "Failed at %s" ), GetText( line = BuildLine( *word ) ) );
		LineRelease( line );
		return FALSE;
	}
	while( (*word) && GetText( *word )[0] != ')' )
	{
		TEXTSTR name = NULL;
		TEXTSTR type = NULL;
		TEXTSTR extra = NULL;
		int bQuoted;
		(*word) = NEXTLINE( *word );
		while( !GetTextSize( *word ) )
			(*word) = NEXTLINE( *word );
		//if( (*word) && GetText( *word )[0] == ',' )
		//	(*word) = NEXTLINE( *word );
		if( !GrabName( word, &name, &bQuoted  DBG_SRC) )
		{
			lprintf( WIDE( "Failed column parsing..." ) );
		}
		else
		{
			if( !bQuoted )
			{
				if( StrCaseCmp( name, WIDE( "PRIMARY" ) ) == 0 )
				{
					if( StrCaseCmp( GetText(*word), WIDE( "KEY" ) ) == 0 )
					{
						(*word) = NEXTLINE( *word );
						if( StrCaseCmp( GetText(*word), WIDE( "USING" ) ) == 0 )
						{
							(*word) = NEXTLINE( *word );
							// next word is the type, skip that word too....
							(*word) = NEXTLINE( *word );
						}
						AddIndexKey( table, word, 0, 1, 0 );
					}
					else
					{
						lprintf( WIDE( "PRIMARY keyword without KEY keyword is invalid." ) );
						DebugBreak();
					}
					Release( name );
				}
				else if( StrCaseCmp( name, WIDE( "UNIQUE" ) ) == 0 )
				{
					if( ( StrCaseCmp( GetText(*word), WIDE( "KEY" ) ) == 0 )
						|| ( StrCaseCmp( GetText(*word), WIDE( "INDEX" ) ) == 0 ) )
					{
						// skip this word.
						(*word) = NEXTLINE( *word );
					}
					AddIndexKey( table, word, 1, 0, 1 );
					Release( name );
				}
				else if( StrCaseCmp( name, WIDE( "CONSTRAINT" ) ) == 0 || StrCaseCmp( name, WIDE( "FOREIGN" ) ) == 0 )
				{
					//lprintf( "Skipping constraint parsing" );
					AddConstraint( table, word );
					Release( name );
				}
				else if( ( StrCaseCmp( name, WIDE( "INDEX" ) ) == 0 )
				      || ( StrCaseCmp( name, WIDE( "KEY" ) ) == 0 ) )
				{
					AddIndexKey( table, word, 1, 0, 0 );
					Release( name );
				}
				else
				{
					GrabType( word, &type DBG_SRC );
					GrabExtra( word, &extra );
					table->fields.count++;
					table->fields.field = Renew( FIELD, table->fields.field, table->fields.count + 1 );
					table->fields.field[table->fields.count-1].name = name;
					table->fields.field[table->fields.count-1].type = type;
					table->fields.field[table->fields.count-1].extra = extra;
					table->fields.field[table->fields.count-1].previous_names[0] = NULL;
				}
			}
			else
			{
				GrabType( word, &type DBG_SRC );
				GrabExtra( word, &extra );
				table->fields.count++;
				table->fields.field = Renew( FIELD, table->fields.field, table->fields.count + 1 );
				table->fields.field[table->fields.count-1].name = name;
				table->fields.field[table->fields.count-1].type = type;
				table->fields.field[table->fields.count-1].extra = extra;
				table->fields.field[table->fields.count-1].previous_names[0] = NULL;
			}
		}
	}
	return TRUE;
}
//----------------------------------------------------------------------
int GetTableExtra( PTABLE table, PTEXT *word )
{
	return TRUE;
}
void LogTable( PTABLE table )
{
	FILE *out;
	out = sack_fopen( 0, WIDE("sparse.txt"), WIDE("at") );
	if( out )
	{
		if( table )
		{
			int n;
			sack_fprintf( out, WIDE( "\n" ) );
			sack_fprintf( out, WIDE( "//--------------------------------------------------------------------------\n" ) );
			sack_fprintf( out, WIDE( "// %s \n" ), table->name );
			sack_fprintf( out, WIDE( "// Total number of fields = %d\n" ), table->fields.count );
			sack_fprintf( out, WIDE( "// Total number of keys = %d\n" ), table->keys.count );
			sack_fprintf( out, WIDE( "//--------------------------------------------------------------------------\n" ) );
			sack_fprintf( out, WIDE( "\n" ) );
			sack_fprintf( out, WIDE( "FIELD %s_fields[] = {\n" ), table->name );
			for( n = 0; n < table->fields.count; n++ )
				sack_fprintf( out, WIDE( "\t%s{%s%s%s, %s%s%s, %s%s%s }\n" )
					, n?WIDE( ", " ):WIDE( "" )
					, table->fields.field[n].name?WIDE("\""):WIDE( "" )
					, table->fields.field[n].name?table->fields.field[n].name:WIDE( "NULL" )
					, table->fields.field[n].name?WIDE("\""):WIDE( "" )
					, table->fields.field[n].type?WIDE("\""):WIDE( "" )
					, table->fields.field[n].type?table->fields.field[n].type:WIDE( "NULL" )
					, table->fields.field[n].type?WIDE("\""):WIDE( "" )
					, table->fields.field[n].extra?WIDE("\""):WIDE( "" )
					, table->fields.field[n].extra?table->fields.field[n].extra:WIDE( "NULL" )
					, table->fields.field[n].extra?WIDE("\""):WIDE( "" )
				);
			sack_fprintf( out, WIDE( "};\n" ) );
			sack_fprintf( out, WIDE( "\n" ) );
			if( table->keys.count )
			{
				sack_fprintf( out, WIDE( "DB_KEY_DEF %s_keys[] = { \n" ), table->name );
				for( n = 0; n < table->keys.count; n++ )
				{
					int m;
					sack_fprintf( out, WIDE( "#ifdef __cplusplus\n" ) );
					sack_fprintf( out, WIDE("\t%srequired_key_def( %d, %d, %s%s%s, \"%s\" )\n")
							 , n?", ":""
							 , table->keys.key[n].flags.bPrimary
							 , table->keys.key[n].flags.bUnique
							 , table->keys.key[n].name?WIDE("\""):WIDE(""  )
							 , table->keys.key[n].name?table->keys.key[n].name:WIDE("NULL")
							 , table->keys.key[n].name?WIDE("\""):WIDE("")
							 , table->keys.key[n].colnames[0] );
					if( table->keys.key[n].colnames[1] )
						sack_fprintf( out, WIDE( ", ... columns are short this is an error.\n" ) );
					sack_fprintf( out, WIDE( "#else\n" ) );
					sack_fprintf( out, WIDE( "\t%s{ {%d,%d}, %s%s%s, { " )
							 , n?WIDE( ", " ):WIDE( "" )
							 , table->keys.key[n].flags.bPrimary
							 , table->keys.key[n].flags.bUnique
							 , table->keys.key[n].name?WIDE("\""):WIDE( "" )
							 , table->keys.key[n].name?table->keys.key[n].name:WIDE( "NULL" )
							 , table->keys.key[n].name?WIDE("\""):WIDE( "" )
							 );
					for( m = 0; table->keys.key[n].colnames[m]; m++ )
						sack_fprintf( out, WIDE("%s\"%s\"")
								 , m?WIDE( ", " ):WIDE( "" )
								 , table->keys.key[n].colnames[m] );
					sack_fprintf( out, WIDE( " } }\n" ) );
					sack_fprintf( out, WIDE( "#endif\n" ) );
				}
				sack_fprintf( out, WIDE( "};\n" ) );
				sack_fprintf( out, WIDE( "\n" ) );
			}
			sack_fprintf( out, WIDE( "\n" ) );
			sack_fprintf( out, WIDE("TABLE %s = { \"%s\" \n"), table->name, table->name );
			sack_fprintf( out, WIDE( "	 , FIELDS( %s_fields )\n" ), table->name );
			if( table->keys.count )
				sack_fprintf( out, WIDE( "	 , TABLE_KEYS( %s_keys )\n" ), table->name );
			else
				sack_fprintf( out, WIDE( "	 , { 0, NULL }\n" ) );
			sack_fprintf( out, WIDE( "	, { 0 }\n" ) );
			sack_fprintf( out, WIDE( "	, NULL\n" ) );
			sack_fprintf( out, WIDE( "	, NULL\n" ) );
			sack_fprintf( out, WIDE( "	,NULL\n" ) );
			sack_fprintf( out, WIDE( "};\n" ) );
			sack_fprintf( out, WIDE( "\n" ) );
		}
		else
		{
			sack_fprintf( out, WIDE( "//--------------------------------------------------------------------------\n" ) );
			sack_fprintf( out, WIDE( "// No Table\n" ) );
			sack_fprintf( out, WIDE( "//--------------------------------------------------------------------------\n" ) );
		}
		sack_fclose( out );
	}
}
//----------------------------------------------------------------------
PTABLE GetFieldsInSQLEx( CTEXTSTR cmd, int writestate DBG_PASS )
{
	PTEXT tmp;
	PTEXT pParsed;
	PTEXT pWord;
	PTABLE pTable = New( TABLE );
	MemSet( pTable, 0, sizeof( TABLE ) );
	pTable->fields.field = New( FIELD );
	pTable->flags.bDynamic = TRUE;
	pTable->keys.key = New( DB_KEY_DEF );
	tmp = SegCreateFromText( cmd);
	// tmp will become parsed... the first segment is
	// not released, it is merely truncated.
	{
		// but first, go through, and remove carriage returns... which even
		// if a delimieter need to be considered more like spaces...
		size_t n, m;
		TEXTCHAR *str = GetText( tmp );
		for( n = 0, m = GetTextSize( tmp ); n < m; n++ )
			if( str[n] == '\n' )
				str[n] = ' ';
	}
	pParsed = TextParse( tmp, WIDE("\'\"\\({[<>]}):@%/,;!?=*&$^~#`"), WIDE(" \t\n\r" ), 1, 1 DBG_RELAY );
	LineRelease( tmp );
	//{
	//   PTEXT outline = DumpText( pParsed );
	//	fprintf( stderr, "%s", GetText( outline ) );
	//}
	// pparsed is tmp...
	pWord = pParsed;
	if( pWord )
	{
		if( ValidateCreateTable( &pWord ) )
		{
			if( !GrabName( &pWord, (TEXTSTR*)&pTable->name, NULL  DBG_SRC) )
			{
				DestroySQLTable( pTable );
				pTable = NULL;
			}
			else
			{
				if( !GetTableColumns( pTable, &pWord DBG_SRC ) )
				{
					DestroySQLTable( pTable );
					pTable = NULL;
				}
				else
					GetTableExtra( pTable, &pWord );
			}
		}
		else
		{
			DestroySQLTable( pTable );
			pTable = NULL;
		}
	}
	LineRelease( pParsed );
	 if( writestate )
		LogTable( pTable );
	return pTable;
}
SQL_NAMESPACE_END
#define FORIEGN_KEYS_WORK
#define OPTION_MAIN_SOURCE
#define NO_UNICODE_C
#ifndef GETOPTION_SOURCE
#define GETOPTION_SOURCE
#endif
// we want access to GLOBAL from sqltub
#define SQLLIB_SOURCE
//#include <controls.h> // INI prompt
#ifdef __WATCOMC__
 // unlink
#endif
#ifndef SQL_STRUCT_DEFINED
#define SQL_STRUCT_DEFINED
# if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
# endif
#if defined( __NO_ODBC__ )
// if not using odbc, need these
// otherwise they will be defined in sql.h
 // sqllite uses a generic int type for result codes
typedef int RETCODE;
typedef int SQLSMALLINT;
typedef unsigned int SQLULEN;
typedef int SQLINTEGER;
enum {
	SQL_HANDLE_DBC
      , SQL_HANDLE_STMT
};
#else
#  define USE_ODBC 1
#endif
 // critical section
SQL_NAMESPACE
enum {
	WM_SQL_COMMAND = MSG_UserServiceMessages
	  , WM_SQL_QUERY
	  , WM_SQL_DATA_START
	  , WM_SQL_DATA_MORE
	  , WM_SQL_RESULT_ERROR
	  , WM_SQL_RESULT_SUCCESS
     , WM_SQL_RESULT_DATA
     , WM_SQL_RESULT_MORE
	  , WM_SQL_MORE
	  , WM_SQL_GET_ERROR
 // no error, but no lines result
	  , WM_SQL_RESULT_NO_DATA
	  // which is not the same as no error, but an empty line resulted...
	  , WM_SQL_QUERY_RECORD
     , WM_SQL_RESULT_RECORD
     , WM_SQL_NUM_MESSAGES
};
typedef struct data_collection_tag
{
	struct {
 // sql commands during queries are given temporary status.
		BIT_FIELD  bTemporary  : 1;
 // not a static member
		BIT_FIELD  bDynamic : 1;
		BIT_FIELD  bBuildResultArray  : 1;
		BIT_FIELD bEndOfFile : 1;
 // pop should work up to this point.
		BIT_FIELD bPushed : 1;
	} flags;
 // the last SQL command for this...
	PVARTEXT pvt_out;
 // the last result for this...
	PVARTEXT pvt_result;
 // the last error info for this...
	PVARTEXT pvt_errorinfo;
	PSERVICE_ROUTE SourceID;
	struct odbc_handle_tag *odbc;
	uint32_t      responce;
	uint32_t      lastop;
   int    *column_types;
	size_t *result_len;
	TEXTSTR *results;
	//uint32_t nResults; // this is columns
	TEXTSTR *fields;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	sqlite3_stmt *stmt;
#endif
#if !defined( __NO_ODBC__ )
	SQLHSTMT    hstmt;
#endif
	SQLSMALLINT columns;
	PTEXT result_text;
	SQLULEN  *colsizes;
	SQLSMALLINT *coltypes;
	DeclareLink( struct data_collection_tag );
#ifdef WINDOWS_PROXY_EXTENSION
	uint32_t MyID;
	HWND     hLastWnd;
	HWND     hWnd;
#endif
} COLLECT, *PCOLLECT;
typedef struct database_info_tag
{
	struct {
		BIT_FIELD  bAutoUser  : 1;
	} flags;
	CTEXTSTR pDSN;
	TEXTCHAR pID[64];
	TEXTCHAR pPASSWORD[64];
	TEXTCHAR pConnString[256];
} DB_INFO, *PDB_INFO;
struct odbc_handle_tag{
	DB_INFO info;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
	sqlite3 *db;
#endif
#if !defined( __NO_ODBC__ )
  // odbc database access handle...
	SQLHENV    env;
 // handle to database connection
	SQLHDBC    hdbc;
#endif
	struct {
		BIT_FIELD  bConnected  : 1;
 // operate as if talking to an access MDB
		BIT_FIELD  bAccess  : 1;
 // sqllite via sqlite odbc driver...
		BIT_FIELD  bSQLite  : 1;
  // for selecting how transactions are done.
		BIT_FIELD  bMySQL : 1;
#if defined( USE_SQLITE ) || defined( USE_SQLITE_INTERFACE )
		BIT_FIELD  bSQLite_native  : 1;
#endif
#if USE_ODBC
 // odbc is actually an odbc
		BIT_FIELD  bODBC  : 1;
#endif
 // set to skip ODBC connection (if dsn has a '.' in it)
		BIT_FIELD bSkipODBC  : 1;
 // do NOT log to SQL.log
		BIT_FIELD bNoLogging  : 1;
 // pop should work up to this point. just did a push... next collector should be marked.
		BIT_FIELD bPushed : 1;
 // same sort of thing as the global flag... but that should just apply to default connection?
		BIT_FIELD bForceConnection : 1;
		BIT_FIELD bFailEnvOnDbcFail : 1;
		// generate begintransaction and commit automatically.
		BIT_FIELD bAutoTransact : 1;
 // use enter/leave critical section on this connector (auto transact protector)
		BIT_FIELD bThreadProtect : 1;
 // don't leave the connection open 100%; open when required and close when idle
		BIT_FIELD bAutoClose : 1;
 // sqlite; alternative to closing; generate wal_checkpoints automatically on idle.
		BIT_FIELD bAutoCheckpoint : 1;
		BIT_FIELD bClosed : 1;
	} flags;
 // this one tracks auto commit state; it is cleared when a commit happens
	uint32_t last_command_tick;
 // this one tracks truly the last operation on a connection
	uint32_t last_command_tick_;
	uint32_t commit_timer;
	PCOLLECT collection;
 // saved for resulting with native error code...
	int native;
 // allow user to associate some data with this.
	uintptr_t psvUser;
	CRITICALSECTION cs;
 // critical section is currently owned
	int nProtect;
	PTHREAD auto_commit_thread;
	PTHREAD auto_close_thread;
	PTHREAD auto_checkpoint_thread;
	struct odbc_queue *queue;
	void (CPROC*auto_commit_callback)(uintptr_t,PODBC);
	uintptr_t auto_commit_callback_psv;
	void (CPROC*pCorruptionHandler)(uintptr_t psv, PODBC odbc);
	uintptr_t psvCorruptionHandler;
};
struct odbc_queue
{
	CTEXTSTR name;
   PLINKQUEUE connections;
};
#ifdef SQLLIB_SOURCE
struct pssql_global
{
	CRITICALSECTION Init;
	//POPTION_INTERFACE pOptionInterface;
	uint32_t PrimaryLastConnect, BackupLastConnect;
	ODBC Primary, Backup;
 // current connection
	PODBC odbc;
#ifdef __cplusplus
//	sack::containers::list::
#endif
 // list of PODBC objects which are open.
	PLIST pOpenODBC;
 // collections which were created for g.odbc while it was NULL
	PCOLLECT collections;
 // this is used for fatal errors when neither primary or backup are set in g.odbc
	COLLECT LocalCollect;
 // used when checking status... as a static element it's more reliable.
	COLLECT TimerCollect;
	struct {
		BIT_FIELD  bInited  : 1;
		// when this happens, something
		// needs to be done to update information from the
		// backup to the primary
		// and from the primary to the backup
		// if BOTH have failed - we're how shall I say... fucked.
		BIT_FIELD  bPrimaryRestored  : 1;
		BIT_FIELD  bNoBackup  : 1;
		BIT_FIELD  bPrimaryUp  : 1;
		BIT_FIELD  bBackupUp  : 1;
		BIT_FIELD  bNoLog  : 1;
		BIT_FIELD  bOpening  : 1;
		BIT_FIELD  bMySQL  : 1;
		BIT_FIELD  bPostgresql  : 1;
		BIT_FIELD  bBadODBC  : 1;
 // do log to SQL.log
		BIT_FIELD  bLogging  : 1;
		BIT_FIELD  bFallback : 1;
		BIT_FIELD  bRequireConnection : 1;
		BIT_FIELD bLogData : 1;
		BIT_FIELD  bLogOptionConnection : 1;
		BIT_FIELD bCriticalSectionInited : 1;
		BIT_FIELD bDeadstartCompleted : 1;
		BIT_FIELD bAutoCheckpoint : 1;
		BIT_FIELD bAutoCheckpointRecover : 1;
	} flags;
	struct update_task_def *UpdateTasks;
	PSERVICE_ROUTE SQLMsgBase;
	FILE *pSQLLog;
	void (CPROC*feedback_handler)(CTEXTSTR message);
 // a third, well-known DSN used for option library by default.  May be SQLite.
	ODBC OptionDb;
	PLIST date_offsets;
	PLIST odbc_queues;
	PLIST option_database_init;
	PLIST database_init;
	// ----- shared with option code; these need to be shared between instances.
  // some
	PTREEROOT tables;
};
#endif
INDEX GetIndexOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name);
PTREEROOT GetTableCache( PODBC odbc, CTEXTSTR tablename );
CTEXTSTR GetKeyOfName(PODBC odbc, CTEXTSTR table,CTEXTSTR name);
int OpenSQL( DBG_VOIDPASS );
void CloseDatabaseEx( PODBC odbc, LOGICAL ReleaseConnection );
#ifdef USE_SQLITE_INTERFACE
#  if defined( __WATCOMC__ ) && !defined( BUILDS_INTERFACE ) && ( __WATCOMC__ < 1300 )
#    define FIXREF
#    define FIXDEREF
#    define FIXREF2 *
#    define FIXDEREF2 *
#  else
#    define FIXREF
#    define FIXDEREF
#    define FIXREF2
#    define FIXDEREF2
#  endif
struct sqlite_interface
{
	void(FIXREF2 *sqlite3_result_text)(sqlite3_context*, const char*, int, void(*)(void*));
	void*(FIXREF*sqlite3_user_data)(sqlite3_context*);
	sqlite3_int64 (FIXREF2*sqlite3_last_insert_rowid)(sqlite3*);
	int (FIXREF*sqlite3_create_function)(  sqlite3 *db,
	  const char *zFunctionName,
	  int nArg,
	  int eTextRep,
	  void *pApp,
	  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
	  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
	  void (*xFinal)(sqlite3_context*)
	);
	int (FIXREF2*sqlite3_get_autocommit)(sqlite3*);
	int (FIXREF2*sqlite3_open)(  const char *filename,
	  sqlite3 **ppDb
	);
	int (FIXREF2*sqlite3_open_v2)(
	  const char *filename,
	  sqlite3 **ppDb,
	  int flags,
	  const char *zVfs
	);
	const char* (FIXREF2*sqlite3_errmsg)(sqlite3*);
	int (FIXREF2*sqlite3_finalize)(sqlite3_stmt *);
	int (FIXREF2*sqlite3_close)(sqlite3*);
#  if ( SQLITE_VERSION_NUMBER > 3007013 )
	int (FIXREF2*sqlite3_close_v2)(sqlite3*);
#  endif
	int (FIXREF2*sqlite3_prepare_v2)(
	  sqlite3 *db,
	  const char *zSql,
	  int nByte,
	  sqlite3_stmt **ppStmt,
	  const char **pzTail     );
	int (FIXREF2*sqlite3_prepare16_v2)(
		  sqlite3 *db,
		  const void *zSql,
		  int nByte,
		  sqlite3_stmt **ppStmt,
		  const void **pzTail
		);
	int (FIXREF2*sqlite3_step)(sqlite3_stmt *);
	const char* (FIXREF2*sqlite3_column_name)(sqlite3_stmt *pStmt, int col);
	const unsigned char* (FIXREF*sqlite3_column_text)(sqlite3_stmt *pStmt, int col);
	int (FIXREF2*sqlite3_column_bytes)(sqlite3_stmt *pStmt, int col);
	int (FIXREF*sqlite3_column_type )(sqlite3_stmt *pStmt, int col);
	int (FIXREF2*sqlite3_column_count)(sqlite3_stmt *pStmt);
	int (FIXREF2*sqlite3_config)(int,...);
	int (FIXREF2*sqlite3_db_config)(sqlite3*, int op, ...);
	// allow full definition of a VFS including the FS interface
	void (*InitVFS)( CTEXTSTR name, struct file_system_mounted_interface *fsi );
	sqlite3_backup *( FIXREF2*sqlite3_backup_init)(
			  sqlite3 *pDest,
			  const char *zDestName,
			  sqlite3 *pSource,
			  const char *zSourceName
				);
	int ( FIXREF2*sqlite3_backup_step)(sqlite3_backup *p, int nPage);
	int ( FIXREF2*sqlite3_backup_remaining)(sqlite3_backup *p);
	//int ( FIXREF2*sqlite3_backup_pagecount)(sqlite3_backup *p);
	int ( FIXREF2*sqlite3_backup_finish)(sqlite3_backup *p);
	int ( FIXREF2*sqlite3_extended_errcode)(sqlite3 *db);
	int ( FIXREF2*sqlite3_stmt_readonly)(sqlite3_stmt *pStmt);
	const char *( FIXREF2*sqlite3_column_table_name )( sqlite3_stmt *odbc, int col );
	const char *( FIXREF2*sqlite3_column_table_alias )( sqlite3_stmt *odbc, int col );
};
#  ifndef DEFINES_SQLITE_INTERFACE
extern
#  endif
        struct sqlite_interface *sqlite_iface;
#  ifdef DEFINES_SQLITE_INTERFACE
PRIORITY_PRELOAD( LoadSQLiteInterface, SQL_PRELOAD_PRIORITY-1 )
{
   sqlite_iface = (struct sqlite_interface*)GetInterface( WIDE("sqlite3") );
}
#  endif
#  ifndef BUILDS_INTERFACE
#    define sqlite3_result_text          (FIXDEREF2 (sqlite_iface->sqlite3_result_text))
#    define sqlite3_user_data            (FIXDEREF (sqlite_iface->sqlite3_user_data))
#    define sqlite3_last_insert_rowid    (FIXDEREF2 (sqlite_iface->sqlite3_last_insert_rowid))
#    define sqlite3_create_function      (FIXDEREF (sqlite_iface->sqlite3_create_function))
#    define sqlite3_get_autocommit       (FIXDEREF2 (sqlite_iface->sqlite3_get_autocommit))
#    define sqlite3_open(a,b)            (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_open))(a,b):SQLITE_ERROR
#    define sqlite3_open_v2(a,b,c,d)     (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_open_v2))(a,b,c,d):SQLITE_ERROR
#    define sqlite3_errmsg(db)           (sqlite_iface)?(FIXDEREF2((sqlite_iface)->sqlite3_errmsg))(db):"No Sqlite3 Interface"
#    define sqlite3_finalize             (FIXDEREF2 (sqlite_iface->sqlite3_finalize))
#    define sqlite3_close                (FIXDEREF2 (sqlite_iface->sqlite3_close))
#    define sqlite3_close_v2             (FIXDEREF2 (sqlite_iface->sqlite3_close_v2))
#    define sqlite3_prepare_v2           (FIXDEREF2 (sqlite_iface->sqlite3_prepare_v2))
#    define sqlite3_prepare16_v2         (FIXDEREF2 (sqlite_iface->sqlite3_prepare16_v2))
#    define sqlite3_step                 (FIXDEREF2 (sqlite_iface->sqlite3_step))
#    define sqlite3_column_name          (FIXDEREF2 (sqlite_iface->sqlite3_column_name))
#    define sqlite3_column_text          (FIXDEREF (sqlite_iface->sqlite3_column_text))
#    define sqlite3_column_bytes         (FIXDEREF2 (sqlite_iface->sqlite3_column_bytes))
#    define sqlite3_column_type          (FIXDEREF (sqlite_iface->sqlite3_column_type))
#    define sqlite3_column_count         (FIXDEREF2 (sqlite_iface->sqlite3_column_count))
#    define sqlite3_config               (FIXDEREF2 (sqlite_iface->sqlite3_config))
#    define sqlite3_db_config            (FIXDEREF2 (sqlite_iface->sqlite3_db_config))
#    define sqlite3_backup_init          (FIXDEREF2 (sqlite_iface->sqlite3_backup_init))
#    define sqlite3_backup_step          (FIXDEREF2 (sqlite_iface->sqlite3_backup_step))
#    define sqlite3_backup_finish        (FIXDEREF2 (sqlite_iface->sqlite3_backup_finish))
#    define sqlite3_backup_remaining     (FIXDEREF2 (sqlite_iface->sqlite3_backup_remaining))
#    define sqlite3_extended_errcode     (FIXDEREF2 (sqlite_iface->sqlite3_extended_errcode))
#    define sqlite3_stmt_readonly        (FIXDEREF2 (sqlite_iface->sqlite3_stmt_readonly))
#    define sqlite3_column_table_name    (FIXDEREF2 (sqlite_iface->sqlite3_column_table_name))
#    define sqlite3_column_table_alias (FIXDEREF2 (sqlite_iface->sqlite3_column_table_alias))
#  endif
#endif
SQL_NAMESPACE_END
#endif
// define this to show very verbose logging during creation and
// referencing of option tree...
//#define DETAILED_LOGGING
#define DEFAULT_PUBLIC_KEY WIDE( "DEFAULT" )
//#define DEFAULT_PUBLIC_KEY "system"
SQL_NAMESPACE
extern struct pssql_global *global_sqlstub_data;
SQL_NAMESPACE_END
/*
 Dump Option table...
 SELECT oname2.name,oname.name,optionvalues.string,omap.*
 FROM `optionmap` as omap
 join optionname as oname on omap.name_id=oname.name_id
 left join optionvalues on omap.value_id=optionvalues.value_id
 left join optionmap as omap2 on omap2.node_id=omap.parent_node_id
 left join optionname as oname2 on omap2.name_id=oname2.name_id
*/
SACK_OPTION_NAMESPACE
// some inter module linkings...
// these are private for access between utils and the core interface lib
#define OPTION_ROOT_VALUE 0
typedef struct sack_option_tree_family OPTION_TREE;
//typedef struct sack_option_tree_family *POPTION_TREE;
typedef struct sack_option_tree_family_node OPTION_TREE_NODE;
struct sack_option_tree_family_node {
	CTEXTSTR name;
	CTEXTSTR guid;
	CTEXTSTR value;
	PFAMILYNODE node;
	struct {
		BIT_FIELD bExpanded : 1;
		BIT_FIELD bHasValue : 1;
	} flags;
 // connection this was written on for the commit event.
	PODBC uncommited_write;
	//uint32_t expansion_tick;
};
#define MAXOPTION_TREE_NODESPERSET 256
DeclareSet( OPTION_TREE_NODE );
struct sack_option_tree_family {
	POPTION_TREE_NODE root;
	PFAMILYTREE option_tree;
  // each option tree associates with a ODBC connection.
	PODBC odbc;
 // a second connection which handles all inserts and updates
	PODBC odbc_writer;
	PFAMILYNODE system_mask_root;
	struct {
		BIT_FIELD bCreated : 1;
	} flags;
 // list of option values that were written.
	PLIST uncommited;
	POPTION_TREE_NODESET nodes;
};
struct option_odbc_tracker
{
	CTEXTSTR name;
	PLINKQUEUE available;
	PLIST outstanding;
	PFAMILYTREE shared_option_tree;
};
struct sack_option_global_tag {
	struct {
		BIT_FIELD bRegistered : 1;
		BIT_FIELD bInited : 1;
		BIT_FIELD bUseProgramDefault : 1;
		BIT_FIELD bUseSystemDefault : 1;
		BIT_FIELD bPromptDefault : 1;
		BIT_FIELD bEnableSystemMapping : 2;
	} flags;
	TEXTCHAR SystemName[128];
	INDEX SystemID;
	uint32_t Session;
	//PFAMILYTREE option_tree;
 // list of struct sack_option_family_tree's
	PLIST trees;
 // primary ODBC for option use.
	PODBC Option;
	CRITICALSECTION cs_option;
	PLIST odbc_list;
};
//INDEX GetOptionIndexEx( INDEX parent, CTEXTSTR file, CTEXTSTR pBranch, CTEXTSTR pValue, int bCreate DBG_PASS );
//#define GetOptionIndex( f,b,v ) GetOptionIndexEx( OPTION_ROOT_VALUE, f, b, v, FALSE DBG_SRC )
POPTION_TREE_NODE New4DuplicateValue( PODBC odbc, POPTION_TREE_NODE iOriginalValue, POPTION_TREE_NODE iNewValue );
CTEXTSTR New4ReadOptionNameTable( POPTION_TREE tree, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
void InitMachine( void );
#define GetOptionTreeExx(o,... )  GetOptionTreeExxx( o,NULL,##__VA_ARGS__ )
#define GetOptionTreeEx(o) GetOptionTreeExx(o DBG_SRC )
POPTION_TREE GetOptionTreeExxx( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS );
//POPTION_TREE GetOptionTreeEx( PODBC odbc );
LOGICAL SetOptionValueEx( POPTION_TREE tree, POPTION_TREE_NODE optval );
//INDEX SetOptionValue( INDEX optval, INDEX iValue );
POPTION_TREE_NODE DuplicateValue( POPTION_TREE_NODE iOriginalValue, POPTION_TREE_NODE iNewValue );
POPTION_TREE_NODE New4DuplicateValue( PODBC odbc, POPTION_TREE_NODE iOriginalValue, POPTION_TREE_NODE iNewValue );
void New4DuplicateOption( PODBC odbc, POPTION_TREE_NODE iRoot, CTEXTSTR pNewName );
//POPTION_TREE GetOptionTreeEx( PODBC odbc );
PFAMILYTREE* GetOptionTree( PODBC odbc );
POPTION_TREE_NODE New4GetOptionIndexExxx( PODBC odbc, POPTION_TREE tree, POPTION_TREE_NODE parent, CTEXTSTR system, CTEXTSTR program, CTEXTSTR file, CTEXTSTR pBranch, CTEXTSTR pValue, int bCreate, int bBypassParsing, int bIKnowItDoesntExist DBG_PASS );
size_t New4GetOptionStringValue( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS );
LOGICAL New4CreateValue( POPTION_TREE odbc, POPTION_TREE_NODE value, CTEXTSTR pValue );
LOGICAL New4CreateValueEx( PODBC odbc, POPTION_TREE_NODE value, CTEXTSTR pValue );
void New4DeleteOption( PODBC odbc, POPTION_TREE_NODE iRoot );
void NewEnumOptions( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
												  , uintptr_t psvUser );
void New4EnumOptions( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
												  , uintptr_t psvUser );
void OpenWriterEx( POPTION_TREE option DBG_PASS);
#define OpenWriter(o) OpenWriterEx( o DBG_SRC )
INDEX ReadOptionNameTable( POPTION_TREE tree, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS );
LOGICAL SetOptionStringValue( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue );
INDEX IndexCreateFromText( CTEXTSTR string );
void New4FindOptions( POPTION_TREE odbc, PLIST *result_list, CTEXTSTR name );
typedef struct sack_option_global_tag OPTION_GLOBAL;
#ifdef _cut_sql_statments_
SQL table create is in 'mkopttabs.sql'
#endif
#define og (*sack_global_option_data)
	OPTION_GLOBAL *sack_global_option_data;
//------------------------------------------------------------------------
//int mystrcmp( TEXTCHAR *x, TEXTCHAR *y )
//{
//   lprintf( WIDE("Is %s==%s?"), x, y );
//   return strcmp( x, y );
//}
//------------------------------------------------------------------------
#define MKSTR(n,...) #__VA_ARGS__
//char *tablestatements =
#ifdef OPTION_MAIN_SOURCE
#define OPT_EXTERN(a,b,...) a b= __VA_ARGS__
#else
#define OPT_EXTERN(a,b,...) extern a b
#endif
//------------------------------------------------------------------------
// Option V4 tables
//------------------------------------------------------------------------
#if THIS_IS_A_GOOD_IDEA_OR_THIS_HAS_A_USE
//# Table: 'option4_exception_time'
//#
#define OPTION4_EXCEPTION WIDE("option4_exception")
OPT_EXTERN( CTEXTSTR, option4_exception, WIDE( "CREATE TABLE `option4_exception` (" )
WIDE( "  `option_exception_id` char(36) NOT NULL,\n" )
WIDE( "  `apply_from` datetime default '0000-00-00 00:00:00',\n" )
WIDE( "  `apply_until` datetime default '0000-00-00 00:00:00',\n" )
WIDE( "  `system_id` int(11) NOT NULL default '0',\n" )
WIDE( "  `override_value_id` char(36) NOT NULL default '0',\n" )
WIDE( "  `option_id` char(36) NOT NULL default '0',\n" )
WIDE( "   UNIQUE `option_exception_idkey` (`option_exception_id`),\n" )
WIDE( "   KEY `FK_map_exception` (`option_id`),\n" )
WIDE( "   CONSTRAINT `FK_map_exception` FOREIGN KEY (`option_id`) REFERENCES `option4_map` (`option_id`) ON DELETE CASCADE ON UPDATE CASCADE\n" )
WIDE( " ) TYPE=InnoDB;\n" ) );
#endif
//# Table: 'option4_map'
//#
#define OPTION4_MAP WIDE("option4_map")
OPT_EXTERN( CTEXTSTR, option4_map, WIDE( "CREATE TABLE `option4_map` (" )
WIDE( "  `option_id` char(36) NOT NULL,\n" )
WIDE( "  `parent_option_id` char(36) NOT NULL default '0',\n" )
WIDE( "  `name_id` char(36) NOT NULL default '0',\n" )
WIDE( "  `description` tinytext,\n" )
WIDE( "  PRIMARY KEY  (`option_id`)," )
WIDE( "  INDEX `parent_key`(`parent_option_id`)," )
WIDE( "  UNIQUE `parent_key2`(`parent_option_id`,`name_id`)," )
WIDE( "  CONSTRAINT `FK_map_map` FOREIGN KEY (`parent_option_id`) REFERENCES `option4_map` (`option_id`) ON DELETE CASCADE ON UPDATE CASCADE,\n" )
WIDE( "  CONSTRAINT `FK_name_map` FOREIGN KEY (`name_id`) REFERENCES `option4_name` (`name_id`) ON DELETE CASCADE ON UPDATE CASCADE\n" )
WIDE( " ) TYPE=InnoDB COMMENT='Table ID defines ID for use in OptionValues';\n" ) );
//# Table: 'option4_name'
//#
#define OPTION4_NAME WIDE( "option4_name" )
OPT_EXTERN( CTEXTSTR, option4_name, WIDE( "CREATE TABLE `option4_name` (" )
WIDE( "  `name_id` char(36) NOT NULL,\n" )
WIDE( "  `name` varchar(255) NOT NULL default '',\n" )
WIDE( "  PRIMARY KEY  (`name_id`),\n" )
WIDE( "  UNIQUE `name` (`name`)" )
WIDE( " ) TYPE=InnoDB;\n" ) );
//# Table: 'option4_values'
//#
#define OPTION4_VALUES WIDE("option4_values")
OPT_EXTERN( CTEXTSTR, option4_values, WIDE( "CREATE TABLE `option4_values` (" )
WIDE( "  `option_id` char(36) default '0',\n" )
WIDE( "  `string` varchar(100) default NULL,\n" )
WIDE( "  `segment` int(11) default 0,\n" )
WIDE( "  UNIQUE `value_id` (`option_id`,`segment`),\n" )
WIDE( "  CONSTRAINT `FK_map_values` FOREIGN KEY (`option_id`) REFERENCES `option4_map` (`option_id`) ON DELETE CASCADE ON UPDATE CASCADE\n" )
WIDE( " ) TYPE=InnoDB;\n" ) );
//# Table: 'option4_blobs'
//#
#define OPTION4_BLOBS WIDE("option4_blobs")
OPT_EXTERN( CTEXTSTR, option4_blobs, WIDE( "CREATE TABLE `option4_blobs` (" )
WIDE( "  `option_id` char(36) default '0',\n" )
WIDE( "  `binary` blob,\n" )
WIDE( "  UNIQUE `value_id` (`option_id`)," )
WIDE( "  CONSTRAINT `FK_map_blobs` FOREIGN KEY (`option_id`) REFERENCES `option4_map` (`option_id`) ON DELETE CASCADE ON UPDATE CASCADE\n" )
WIDE( " ) TYPE=InnoDB;\n" ) );
//#SELECT
//#//#a.name_id, b.name_id, c.name_id,d.name_id, e.name_id, f.node_id, g.node_id, h.node_id
//#ona.name,onb.name,onc.name,ond.name,one.name,onf.name,ong.name,onh.name
//#FROM `option_map` as a
//#left join option_map as b on b.parent_node_id=a.node_id
//#left join option_map as c on c.parent_node_id=b.node_id
//#left join option_map as d on d.parent_node_id=c.node_id
//#left join option_map as e on e.parent_node_id=d.node_id
//#left join option_map as f on f.parent_node_id=e.node_id
//#left join option_map as g on g.parent_node_id=f.node_id
//#left join option_map as h on h.parent_node_id=g.node_id
//#
//#join option_name as ona on ona.name_id=a.name_id
//#join option_name as onb on onb.name_id=b.name_id
//#join option_name as onc on onc.name_id=c.name_id
//#join option_name as ond on ond.name_id=d.name_id
//#join option_name as one on one.name_id=e.name_id
//#left join option_name as onf on onf.name_id=f.name_id
//#left join option_name as ong on ong.name_id=g.name_id
//#left join option_name as onh on onh.name_id=h.name_id
;
SQLGETOPTION_PROC( void,SetOptionStringValueEx )( PODBC odbc, POPTION_TREE_NODE node, CTEXTSTR pValue )
{
	int drop_odbc = FALSE;
	if( !odbc )
	{
		odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
		drop_odbc = TRUE;
	}
	POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	OpenWriter( tree );
	New4CreateValue( tree, node, pValue );
	if( drop_odbc )
		DropOptionODBC( odbc );
}
SQLGETOPTION_PROC( POPTION_TREE_NODE, GetOptionIndexEx )( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS );
#define GetOptionIndex(p,f,b,v) GetOptionIndexEx( p,f,b,v,FALSE,FALSE DBG_SRC )
SQLGETOPTION_PROC( void, CreateOptionDatabaseEx )( PODBC odbc, POPTION_TREE tree );
POPTION_TREE GetOptionTreeExxx( PODBC odbc, PFAMILYTREE existing_tree DBG_PASS )
{
	int drop_odbc = FALSE;
	POPTION_TREE tree = NULL;
	INDEX idx;
	if( !odbc )
	{
		odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
		drop_odbc = TRUE;
	}
	//_lprintf(DBG_RELAY)( "Finding tree for %p", odbc );
	LIST_FORALL( og.trees, idx, struct sack_option_tree_family*, tree )
	{
		if( tree->odbc == odbc )
		{
			//lprintf( "Tree existed." );
			break;
		}
	}
	if( !tree )
	{
		//_lprintf(DBG_RELAY)( WIDE( "need a new option tree for %p" ), odbc );
		tree = New( struct sack_option_tree_family );
		MemSet( tree, 0, sizeof( struct sack_option_tree_family ) );
		tree->root = GetFromSet( OPTION_TREE_NODE, &tree->nodes );
		//MemSet( tree->root, 0, sizeof( struct sack_option_tree_family_node ) );
		tree->root->guid = GuidZero();
		tree->root->flags.bHasValue = 0;
		tree->root->value = NULL;
		// if it's a new optiontree, pass it to create...
		if( existing_tree )
		{
         //_lprintf(DBG_RELAY)( "attaching existing tree..." );
			tree->option_tree = existing_tree;
		}
		else
		{
         //_lprintf(DBG_RELAY)( "attaching NEW tree..." );
			tree->option_tree = CreateFamilyTree( (int(CPROC*)(uintptr_t,uintptr_t))StrCaseCmp, NULL );
		}
		tree->odbc = odbc;
		tree->odbc_writer = NULL;
		// default to the old version... allow other code to select new version.
		tree->flags.bCreated = 0;
		AddLink( &og.trees, tree );
	}
	if( drop_odbc )
		DropOptionODBC( odbc );
	//lprintf( "return tree %p for odbc %p", tree, odbc );
	return tree;
}
POPTION_TREE SetOptionDatabase( PODBC odbc )
{
	if( odbc )
	{
		POPTION_TREE tree;
		// maybe, if previously open with private database, close that connection
#ifdef DETAILED_LOGGING
		lprintf( WIDE( "Set a new option databsae : %p" ), odbc );
#endif
		//lprintf( "new global database is %p", odbc );
		og.Option = odbc;
		og.flags.bInited = FALSE;
 // make sure the option tables exist.
		CreateOptionDatabaseEx( odbc, tree = GetOptionTreeExxx( odbc, NULL DBG_SRC ) );
		return tree;
	}
	else
		return GetOptionTreeExxx( og.Option, NULL DBG_SRC );
}
PFAMILYTREE* GetOptionTree( PODBC odbc )
{
	POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	if( tree )
		return &tree->option_tree;
	return NULL;
}
SQLGETOPTION_PROC( void, CreateOptionDatabaseEx )( PODBC odbc, POPTION_TREE tree )
{
#ifdef DETAILED_LOGGING
	lprintf( "Create Option Database. %d", tree->flags.bCreated );
#endif
	if( !global_sqlstub_data->flags.bLogOptionConnection )
		SetSQLLoggingDisable( tree->odbc, TRUE );
	{
		PTABLE table;
		if( !tree->flags.bCreated )
		{
			table = GetFieldsInSQLEx( option4_name, FALSE DBG_SRC );
			CheckODBCTable( tree->odbc, table, CTO_MERGE );
			DestroySQLTable( table );
			table = GetFieldsInSQLEx( option4_map, FALSE DBG_SRC );
			CheckODBCTable( tree->odbc, table, CTO_MERGE );
			DestroySQLTable( table );
#if THIS_IS_A_GOOD_IDEA_OR_THIS_HAS_A_USE
			table = GetFieldsInSQLEx( option4_exception, FALSE DBG_SRC );
			CheckODBCTable( tree->odbc, table, CTO_MERGE );
			DestroySQLTable( table );
#endif
			table = GetFieldsInSQLEx( option4_values, FALSE DBG_SRC );
			CheckODBCTable( tree->odbc, table, CTO_MATCH );
			DestroySQLTable( table );
			table = GetFieldsInSQLEx( option4_blobs, FALSE DBG_SRC );
			CheckODBCTable( tree->odbc, table, CTO_MERGE );
			DestroySQLTable( table );
			{
				// this needs a self-looped root to satisfy constraints.
				CTEXTSTR result;
				if( !SQLQueryf( tree->odbc, &result, WIDE("select parent_option_id from option4_map where option_id='%s'"), GuidZero() )
					|| !result )
				{
					OpenWriter( tree );
					SQLCommandf( tree->odbc_writer
					           , WIDE("insert into option4_map (option_id,parent_option_id,name_id)values('%s','%s','%s' )")
					           , GuidZero(), GuidZero()
					           , New4ReadOptionNameTable(tree,WIDE("."),OPTION4_NAME,WIDE( "name_id" ),WIDE( "name" ),1 DBG_SRC)
									);
				}
				SQLEndQuery( tree->odbc );
			}
			//SQLCommit( odbc );
			//SQLCommand( odbc, WIDE( "COMMIT" ) );
			tree->flags.bCreated = 1;
		}
	}
}
void SetOptionDatabaseOption( PODBC odbc )
{
	POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	if( tree )
	{
		if( global_sqlstub_data->flags.bInited )
			CreateOptionDatabaseEx( odbc, tree );
	}
}
static void CPROC OptionsCommited( uintptr_t psv, PODBC odbc )
{
	INDEX idx;
	POPTION_TREE_NODE optval;
	POPTION_TREE option = (POPTION_TREE)psv;
	LIST_FORALL( option->uncommited, idx, POPTION_TREE_NODE, optval )
	{
		if( optval->uncommited_write == odbc )
		{
			Deallocate( CTEXTSTR, optval->value );
			optval->value = NULL;
			optval->uncommited_write = NULL;
		}
	}
}
void OpenWriterEx( POPTION_TREE option DBG_PASS )
{
	if( !option->odbc_writer )
	{
#ifdef DETAILED_LOGGING
		_lprintf(DBG_RELAY)( WIDE( "Connect to writer database for tree %p odbc %p" ), option, option->odbc );
#endif
		option->odbc_writer = ConnectToDatabaseExx( option->odbc?option->odbc->info.pDSN:global_sqlstub_data->Primary.info.pDSN, FALSE DBG_RELAY );
		SQLCommand( option->odbc_writer, "pragma foreign_keys=on" );
      /*
		SQLCommand( option->odbc_writer, "pragma integrity_check" );
		{
			CTEXTSTR res = NULL;
			for( SQLQuery( option->odbc_writer, "select * from option4_name where name = 'system Settings'", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) );
			for( SQLQuery( option->odbc_writer, "PRAGMA foreign_key_check", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) )
				;// lprintf( "result:%s", res );;
			for( SQLQuery( option->odbc_writer, "PRAGMA foreign_key_check(option4_map)", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) )
				;//lprintf( "result:%s", res );;
			for( SQLQuery( option->odbc_writer, "PRAGMA foreign_key_list(option4_map)", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) )
				;//lprintf( "result:%s", res );;
			for( SQLQuery( option->odbc_writer, "PRAGMA foreign_key_list(option4_name)", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) )
				;//lprintf( "result:%s", res );;
			for( SQLQuery( option->odbc_writer, "PRAGMA foreign_key_list(option4_value)", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) )
				;//lprintf( "result:%s", res );;
			for( SQLQuery( option->odbc_writer, "select * from sqlite_master", &res );
				res;
				FetchSQLResult( option->odbc_writer, &res ) )
				;//lprintf( "result:%s", res );;
		}
*/
		//option->odbc_writer = SQLGetODBC( option->odbc?option->odbc->info.pDSN:global_sqlstub_data->Primary.info.pDSN );
		if( option->odbc_writer )
		{
			if( !global_sqlstub_data->flags.bLogOptionConnection )
				SetSQLLoggingDisable( option->odbc_writer, TRUE );
			SetSQLThreadProtect( option->odbc_writer, TRUE );
			SetSQLAutoTransactCallback( option->odbc_writer, OptionsCommited, (uintptr_t)option );
			//SetSQLAutoClose( option->odbc_writer, TRUE );
		}
	}
}
//------------------------------------------------------------------------
#define CreateName(o,n) SQLReadNameTable(o,n,OPTION_MAP,WIDE( "name_id" ))
//------------------------------------------------------------------------
INDEX ReadOptionNameTable( POPTION_TREE tree, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS )
{
	int first_try = 1;
	TEXTCHAR query[256];
	TEXTCHAR *tmp;
	CTEXTSTR result = NULL;
	INDEX IDName = INVALID_INDEX;
	if( !table || !name )
		return INVALID_INDEX;
	// look in internal cache first...
	IDName = GetIndexOfName(tree->odbc,table,name);
	if( IDName != INVALID_INDEX )
		return IDName;
	if( !tree->odbc )
		DebugBreak();
	CreateOptionDatabaseEx( tree->odbc, tree );
	PushSQLQueryEx( tree->odbc );
retry:
	tmp = EscapeSQLStringEx( tree->odbc, name DBG_RELAY );
	tnprintf( query, sizeof( query ), WIDE("select %s from %s where %s like '%s'")
			  , col?col:WIDE("id")
			  , table, namecol, tmp );
	Release( tmp );
	if( SQLQueryEx( tree->odbc, query, &result DBG_RELAY) && result )
	{
		IDName = (INDEX)IntCreateFromText( result );
		SQLEndQuery( tree->odbc );
	}
	else if( bCreate )
	{
		TEXTSTR newval = EscapeSQLString( tree->odbc, name );
		tnprintf( query, sizeof( query ), WIDE("insert into %s (%s) values( '%s' )"), table, namecol, newval );
      //lprintf( "openwriter..." );
		OpenWriterEx( tree DBG_RELAY );
      //lprintf( "and the command..." );
		if( !SQLCommandEx( tree->odbc_writer, query DBG_RELAY ) )
		{
			// insert failed;  assume it's a duplicate key now, and retry.
			// on an option connection, maybe the name has been inserted, and is waiting in a commit-on-idle
			// ... if we try this a few times, the commit will happen; then we can re-select and continue as normal
			//lprintf( WIDE("insert failed, how can we define name %s?"), name );
			if( first_try )
			{
				first_try = 0;
				goto retry;
			}
         else
				lprintf( WIDE("insert failed, and retry again failed, how can we define name %s?"), name );
		}
		else
		{
			// all is well.
			IDName = FetchLastInsertIDEx( tree->odbc_writer, table, col?col:WIDE("id") DBG_RELAY );
		}
		Release( newval );
	}
	else
		IDName = INVALID_INDEX;
	PopODBCEx(tree->odbc);
	if( IDName != INVALID_INDEX )
	{
		AddBinaryNode( GetTableCache(tree->odbc,table), (POINTER)((uintptr_t)(IDName+1))
						 , (uintptr_t)SaveText( name ) );
	}
	return IDName;
}
//---------------------------------------------------------------------------
INDEX IndexCreateFromText( CTEXTSTR string )
{
   return (INDEX)IntCreateFromText( string );
}
//---------------------------------------------------------------------------
void ResetOptionMap( PODBC odbc )
{
	POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	if( tree )
		FamilyTreeClear( tree->option_tree );
}
//#define OPTION_ROOT_VALUE INVALID_INDEX
#define OPTION_ROOT_VALUE 0
static POPTION_TREE_NODE GetOptionIndexExxx( PODBC odbc, POPTION_TREE_NODE parent
														 , const TEXTCHAR *program_override
														 , const TEXTCHAR *file
														 , const TEXTCHAR *pBranch
														 , const TEXTCHAR *pValue
														 , int bCreate
                                           , int bBypassParsing
														 , int bIKnowItDoesntExist DBG_PASS )
{
	const TEXTCHAR *_program = program_override;
	size_t _program_length = _program?StrLen( _program ):0;
	const TEXTCHAR *program = NULL;
	static const TEXTCHAR *_system = NULL;
	const TEXTCHAR *system = NULL;
	POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	if( !parent )
		parent = tree->root;
	if( og.flags.bUseProgramDefault )
	{
		if( !_program )
		_program_length = StrLen( _program = GetProgramName() );
		if( ( StrCaseCmp( file, DEFAULT_PUBLIC_KEY ) == 0 )
			&& ( StrCaseCmpEx( pBranch, _program, _program_length ) == 0 ) )
		{
		}
		else if( ( StrCaseCmp( file, DEFAULT_PUBLIC_KEY ) != 0 )
			|| ( StrCaseCmpEx( pBranch, _program, _program_length ) != 0 ) )
		{
			program = file;
			file = _program;
		}
		else
		{
			if( !program )
				program = _program;
			// default options were SACK_GetProfileXX( GetProgramName(), Branch, ... )
			// so this should be that condition, with aw NULL file, which gwets promoted to DEFAULT_PUBLIC_KEY
			// before being called, and section will already be programname, and pValue will
			// just be the string default.
		}
	}
	if( og.flags.bUseSystemDefault )
	{
#ifndef __NO_NETWORK__
		if( !_system )
			_system = GetSystemName();
#else
		if( !_system )
			_system = GetSystemID();
#endif
		system = _system;
	}
	//lprintf( WIDE("GetOptionIndex for %s %s %s"), program?program:WIDE("NO PROG"), file, pBranch );
	return New4GetOptionIndexExxx( odbc, tree, parent, system, program, file, pBranch, pValue, bCreate, bBypassParsing, bIKnowItDoesntExist DBG_RELAY );
}
POPTION_TREE_NODE GetOptionIndexExx( PODBC odbc, POPTION_TREE_NODE parent, CTEXTSTR program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS )
{
   return GetOptionIndexExxx( odbc, parent, program, file, pBranch, pValue, bCreate, bBypassParsing, FALSE DBG_RELAY );
}
POPTION_TREE_NODE GetOptionIndexEx( POPTION_TREE_NODE parent, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing DBG_PASS )
{
   return GetOptionIndexExxx( og.Option, parent, NULL, file, pBranch, pValue, bCreate, bBypassParsing, FALSE DBG_RELAY );
}
//------------------------------------------------------------------------
INDEX GetSystemIndex( CTEXTSTR pSystemName )
{
	if( pSystemName )
		return SQLReadNameTable( og.Option, pSystemName, WIDE("systems"), WIDE("system_id") );
	else
	{
		if( !og.SystemID )
			og.SystemID = SQLReadNameTable( og.Option, pSystemName, WIDE("systems"), WIDE("system_id")  );
		return og.SystemID;
	}
}
//------------------------------------------------------------------------
POPTION_TREE_NODE New4DuplicateValue( PODBC odbc, POPTION_TREE_NODE iOriginalOption, POPTION_TREE_NODE iNewOption )
{
	TEXTCHAR query[256];
	CTEXTSTR *results;
	TEXTSTR tmp;
	PushSQLQueryEx( odbc );
	// my nested parent may have a select state in a condition that I think it's mine.
	SQLRecordQueryf( odbc, NULL, &results, NULL, WIDE( "select `string` from " )OPTION4_VALUES WIDE( " where option_id='%s'" ), iOriginalOption->guid );
	if( results && results[0] )
	{
		tnprintf( query, sizeof( query )
			  , WIDE( "replace into " )OPTION4_VALUES WIDE( " (option_id,`string`) values ('%s',%s)" )
				  , iNewOption->guid, tmp = EscapeSQLBinaryOpt( odbc, results[0], StrLen( results[0] ), TRUE ) );
		Release( tmp );
		SQLEndQuery( odbc );
		SQLCommand( odbc, query );
	}
	SQLRecordQueryf( odbc, NULL, &results, NULL, WIDE( "select `binary` from " )OPTION4_BLOBS WIDE( " where option_id='%s'" ), iOriginalOption->guid );
	if( results && results[0] )
	{
		tnprintf( query, sizeof( query )
				  , WIDE( "replace into " )OPTION4_BLOBS WIDE( " (option_id,`binary`) values ('%s',%s)" )
				  , iNewOption->guid, tmp = EscapeSQLBinaryOpt( odbc, results[0], StrLen( results[0] ), TRUE ) );
		Release( tmp );
		SQLEndQuery( odbc );
		SQLCommand( odbc, query );
	}
	PopODBCEx( odbc );
	return iNewOption;
}
// this changes in the new code...
POPTION_TREE_NODE DuplicateValue( POPTION_TREE_NODE iOriginalValue, POPTION_TREE_NODE iNewValue )
{
	POPTION_TREE_NODE result;
	PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	result = New4DuplicateValue( odbc, iOriginalValue, iNewValue );
	DropOptionODBC( odbc );
	return result;
}
//------------------------------------------------------------------------
size_t GetOptionStringValueEx( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS )
{
	size_t res = New4GetOptionStringValue( odbc, optval, buffer, len DBG_RELAY );
	return res;
}
size_t GetOptionStringValue( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len )
{
	size_t result;
	PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	result = GetOptionStringValueEx( odbc, optval, buffer, len DBG_SRC );
	DropOptionODBC( odbc );
	return result;
}
int GetOptionBlobValueOdbc( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len )
{
	CTEXTSTR *result = NULL;
	size_t tmplen;
	if( !len )
		len = &tmplen;
	PushSQLQueryEx( odbc );
	if( SQLRecordQueryf( odbc, NULL, &result, NULL
								, WIDE("select `binary`,length(`binary`) from ")OPTION4_BLOBS WIDE(" where option_id='%s'")
								, optval->guid ) )
	{
		int success = FALSE;
		//lprintf( WIDE(" query succeeded....") );
		if( buffer && result && result[0] && result[1] )
		{
			success = TRUE;
			(*buffer) = NewArray( TEXTCHAR, (*len)=(size_t)IntCreateFromText( result[1] ));
			MemCpy( (*buffer), result[0], (uintptr_t)(*len) );
		}
		PopODBCEx( odbc );
		return success;
	}
   return FALSE;
}
int GetOptionBlobValue( POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len )
{
	return GetOptionBlobValueOdbc( og.Option, optval, buffer, len );
}
//------------------------------------------------------------------------
LOGICAL GetOptionIntValue( POPTION_TREE_NODE optval, int *result_value DBG_PASS )
{
	TEXTCHAR *value;
	if( GetOptionStringValueEx( og.Option, optval, &value, NULL DBG_RELAY ) != INVALID_INDEX )
	{
		if( value[0] == 'y' || value[0] == 'Y' || ( value[0] == 't' || value[0] == 'T' ) )
			*result_value = 1;
		else
			*result_value = (int)IntCreateFromText( value );
		return TRUE;
	}
	return FALSE;
}
//------------------------------------------------------------------------
/*
static LOGICAL CreateValue( POPTION_TREE tree, POPTION_TREE_NODE iOption, CTEXTSTR pValue )
{
	OpenWriter( tree );
	return New4CreateValue( tree, iOption, pValue );
}
*/
//------------------------------------------------------------------------
// result with option value ID
LOGICAL SetOptionStringValue( POPTION_TREE tree, POPTION_TREE_NODE optval, CTEXTSTR pValue )
{
	LOGICAL retval = TRUE;
	EnterCriticalSec( &og.cs_option );
	OpenWriter( tree );
	retval = New4CreateValue( tree, optval, pValue );
	LeaveCriticalSec( &og.cs_option );
	return retval;
}
//------------------------------------------------------------------------
// result with option value ID
static LOGICAL SetOptionBlobValueEx( POPTION_TREE tree, POPTION_TREE_NODE optval, POINTER buffer, size_t length )
{
	OpenWriter( tree );
	{
		TEXTSTR newval = EscapeSQLBinaryOpt( tree->odbc_writer, (CTEXTSTR)buffer, length, TRUE );
		LOGICAL retval =
			SQLCommandf( tree->odbc_writer, WIDE( "replace into " )OPTION4_BLOBS WIDE( " (`option_id`,`binary` ) values ('%s',%s)" )
							, optval->guid
							, newval
							);
		Release( newval );
		return retval;
	}
}
#define DIA_X(x) x * 2
#define DIA_Y(y) y * 2
#define DIA_W(w) w * 2
#define DIA_H(h) h * 2
typedef int (CPROC *_F)(
									  CTEXTSTR lpszSection,
									  CTEXTSTR lpszEntry,
									  CTEXTSTR lpszDefault,
									  TEXTSTR lpszReturnBuffer,
									  size_t cbReturnBuffer,
									  CTEXTSTR filename
											  );
size_t SQLPromptINIValue(
													 CTEXTSTR lpszSection,
													 CTEXTSTR lpszEntry,
													 CTEXTSTR lpszDefault,
													 TEXTSTR lpszReturnBuffer,
													 size_t cbReturnBuffer,
													 CTEXTSTR filename
													)
{
#ifndef __NO_GUI__
#ifndef __STATIC__
	static _F _SQLPromptINIValue;
	if( !_SQLPromptINIValue )
		_SQLPromptINIValue = (_F)LoadFunction( _WIDE( TARGETNAME ), WIDE( "_SQLPromptINIValue" ) );
	if( !_SQLPromptINIValue )
		_SQLPromptINIValue = (_F)LoadFunction( WIDE( "bag.psi.dll" ), WIDE( "_SQLPromptINIValue" ) );
	if( !_SQLPromptINIValue )
		_SQLPromptINIValue =  (_F)LoadFunction( WIDE( "libbag.psi.so" ), WIDE( "_SQLPromptINIValue" ) );
	if( !_SQLPromptINIValue )
		_SQLPromptINIValue =  (_F)LoadFunction( WIDE( "sack_bag.dll" ), WIDE( "_SQLPromptINIValue" ) );
	if( _SQLPromptINIValue )
		return _SQLPromptINIValue(lpszSection, lpszEntry, lpszDefault, lpszReturnBuffer, cbReturnBuffer, filename );
#else
	//return _SQLPromptINIValue(lpszSection, lpszEntry, lpszDefault, lpszReturnBuffer, cbReturnBuffer, filename );
#endif
#endif
#if prompt_stdout
	fprintf( stdout, WIDE( "[%s]%s=%s?\nor enter new value:" ), lpszSection, lpszEntry, lpszDefault );
	fflush( stdout );
	if( fgets( lpszReturnBuffer, cbReturnBuffer, stdin ) && lpszReturnBuffer[0] != '\n' && lpszReturnBuffer[0] )
	{
      return StrLen( lpszReturnBuffer );
	}
#endif
	StrCpyEx( lpszReturnBuffer, lpszDefault, cbReturnBuffer );
	lpszReturnBuffer[cbReturnBuffer-1] = 0;
	return StrLen( lpszReturnBuffer );
}
struct check_mask_param
{
	LOGICAL is_found;
	LOGICAL is_mapped;
	CTEXTSTR section_name;
	CTEXTSTR file_name;
	PODBC odbc;
};
static int CPROC CheckMasks( uintptr_t psv_params, CTEXTSTR name, POPTION_TREE_NODE this_node, int flags )
{
	struct check_mask_param *params = (struct check_mask_param*)psv_params;
	// return 0 to break loop.
	//lprintf( "Had mask to check [%s]", name );
	if( CompareMask( name, params->section_name, FALSE ) )
	{
		params->is_found = TRUE;
		//GetOptionStringValue( ... );
		{
			TEXTCHAR resultbuf[12];
			TEXTCHAR key[256];
			tnprintf( key, 256, WIDE("System Settings/Map INI Local/%s"), params->file_name );
			SACK_GetPrivateProfileStringExxx( params->odbc, key, name, WIDE("0"), resultbuf, 12, NULL, TRUE DBG_SRC );
			if( resultbuf[0] != '0' )
				params->is_mapped = TRUE;
		}
		return 0;
	}
	return TRUE;
}
//------------------------------------------------------------------------
static CTEXTSTR CPROC ResolveININame( PODBC odbc, CTEXTSTR pSection, TEXTCHAR *buf, CTEXTSTR pINIFile )
{
	if( pINIFile[0] == '.' && ( pINIFile[1] == '/' || pINIFile[1] == '\\' ) )
		pINIFile += 2;
	while( pINIFile[0] == '/' || pINIFile[0] == '\\' )
	pINIFile++;
	if( !pathchr( pINIFile ) )
	{
		if( ( pINIFile != DEFAULT_PUBLIC_KEY )
			&& ( StrCaseCmp( pINIFile, DEFAULT_PUBLIC_KEY ) != 0 ) )
		{
			//lprintf( "(Convert %s)", pINIFile );
			if( og.flags.bEnableSystemMapping == 2 )
				og.flags.bEnableSystemMapping = SACK_GetPrivateProfileIntExx( odbc, WIDE( "System Settings")
																									 , WIDE( "Enable System Mapping" ), 0, NULL, TRUE DBG_SRC );
			if( og.flags.bEnableSystemMapping )
			{
				TEXTCHAR resultbuf[12];
				struct check_mask_param params;
				params.is_mapped = FALSE;
				params.is_found = FALSE;
				// check masks first for wildcarded relocations.
				{
					POPTION_TREE_NODE node;
					params.section_name = pSection;
					params.file_name = pINIFile;
					params.odbc = odbc;
					//lprintf( "FILE is not mapped entirly, check enumerated options..." );
					tnprintf( buf, 128, WIDE("System Settings/Map INI Local Masks/%s"), pINIFile );
					//lprintf( "buf is %s", buf );
					node = GetOptionIndexExxx( odbc, NULL, DEFAULT_PUBLIC_KEY, NULL, NULL, buf, TRUE, FALSE, FALSE DBG_SRC );
					if( node )
					{
						//lprintf( "Node is %p?", node );
						EnumOptionsEx( odbc, node, CheckMasks, (uintptr_t)&params );
						//lprintf( "Done enumerating..." );
					}
				}
				if( !params.is_found )
				{
					SACK_GetPrivateProfileStringExxx( odbc, WIDE("System Settings/Map INI Local"), pINIFile, WIDE("0"), resultbuf, 12, NULL, TRUE DBG_SRC );
					if( resultbuf[0] != '0' )
					{
						params.is_found = 1;
						params.is_mapped = 1;
					}
				}
				if( !params.is_found )
				{
					tnprintf( buf, 128, WIDE("System Settings/Map INI Local/%s"), pINIFile );
					SACK_GetPrivateProfileStringExxx( odbc, buf, pSection, WIDE("0"), resultbuf, 12, NULL, TRUE DBG_SRC );
					if( resultbuf[0] != '0' )
						params.is_mapped = TRUE;
				}
#ifndef __NO_NETWORK__
				if( params.is_mapped )
				{
					tnprintf( buf, 128, WIDE("System Settings/%s/%s"), GetSystemName(), pINIFile );
					buf[127] = 0;
					pINIFile = buf;
				}
#endif
			  }
			  //lprintf( "(result %s)", pINIFile );
		  }
	  }
   return pINIFile;
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExxx )( PODBC odbc
																				, CTEXTSTR pSection
																				, CTEXTSTR pOptname
																				, CTEXTSTR pDefaultbuf
																				, TEXTCHAR *pBuffer
																				, size_t nBuffer
																				, CTEXTSTR pINIFile
																				, LOGICAL bQuiet
																				 DBG_PASS
																				)
{
	LOGICAL drop_odbc = FALSE;
	EnterCriticalSec( &og.cs_option );
	if( !odbc )
	{
		odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
		drop_odbc = TRUE;
	}
	if( !pINIFile )
		pINIFile = DEFAULT_PUBLIC_KEY;
	else
	{
		TEXTCHAR buf[128];
		pINIFile = ResolveININame( odbc, pSection, buf, pINIFile );
	}
	{
		// first try, do it as false, so we can fill in default values.
		POPTION_TREE_NODE opt_node;
		char *buffer;
		size_t buflen;
		// maybe do an if( l.flags.bLogOptionsRead )
#if defined( _DEBUG )
		if( global_sqlstub_data->flags.bLogOptionConnection )
			_lprintf(DBG_RELAY)( WIDE( "Getting option {%s}[%s]%s=%s" ), pINIFile, pSection, pOptname, pDefaultbuf );
#endif
		opt_node = GetOptionIndexExx( odbc, OPTION_ROOT_VALUE, NULL, pINIFile, pSection, pOptname, TRUE, FALSE DBG_RELAY );
		// used to have a test - get option value index; but option index == node_id
		// so it just returned the same node; but not quite, huh?
		GetOptionStringValueEx( odbc, opt_node, &buffer, &buflen DBG_RELAY );
		if( !buffer )
		{
			// this actually implies to delete the entry... but since it doesn't exist no worries...
			if( !pDefaultbuf )
			{
				if( drop_odbc )
					DropOptionODBC( odbc );
				LeaveCriticalSec( &og.cs_option );
				return 0;
			}
			// issue dialog
		//do_defaulting:
			//if( !bQuiet && og.flags.bPromptDefault )
			//{
			//	SQLPromptINIValue( pSection, pOptname, pDefaultbuf, pBuffer, nBuffer, pINIFile );
			//}
			//else
			{
				if( pDefaultbuf ){
					StrCpyEx( pBuffer, pDefaultbuf, nBuffer/sizeof( TEXTCHAR ) );
					buflen = StrLen( pBuffer );
				} else {
					pBuffer[0] = 0;
					buflen = 0;
				}
			}
			// create the option branch since it doesn't exist...
			{
				SetOptionStringValue( GetOptionTreeExxx( odbc, NULL DBG_SRC ), opt_node, pBuffer );
#if defined( _DEBUG )
				if( global_sqlstub_data->flags.bLogOptionConnection )
					lprintf( WIDE("default Result [%s]"), pBuffer );
#endif
				if( drop_odbc )
					DropOptionODBC( odbc );
				LeaveCriticalSec( &og.cs_option );
				return buflen;
			}
			//strcpy( pBuffer, pDefaultbuf );
		}
		else
		{
			MemCpy( pBuffer, buffer, buflen = ((buflen+1<(nBuffer) )?(buflen+1):nBuffer) );
			buflen--;
			pBuffer[buflen] = 0;
#if defined( _DEBUG )
			if( global_sqlstub_data->flags.bLogOptionConnection )
				lprintf( WIDE( "buffer result is [%s]" ), pBuffer );
#endif
			if( drop_odbc )
				DropOptionODBC( odbc );
			LeaveCriticalSec( &og.cs_option );
			return buflen;
		}
	}
}
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringExx )( CTEXTSTR pSection
																		  , CTEXTSTR pOptname
																		  , CTEXTSTR pDefaultbuf
																		  , TEXTCHAR *pBuffer
																		  , size_t nBuffer
																		  , CTEXTSTR pINIFile
																		  , LOGICAL bQuiet
																			DBG_PASS
																				)
{
	PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	size_t result;
	result = SACK_GetPrivateProfileStringExxx( odbc,    pSection
																		  , pOptname
																		  , pDefaultbuf
																		  , pBuffer
																		  , nBuffer
																		  , pINIFile
																		  , bQuiet
																			DBG_RELAY
																		  );
	DropOptionODBC( odbc );
	return result;
}
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileStringEx )( CTEXTSTR pSection
																		  , CTEXTSTR pOptname
																		  , CTEXTSTR pDefaultbuf
																		  , TEXTCHAR *pBuffer
																		  , size_t nBuffer
																		  , CTEXTSTR pINIFile
																		  , LOGICAL bQuiet
																		  )
{
	return SACK_GetPrivateProfileStringExx( pSection, pOptname, pDefaultbuf, pBuffer, nBuffer, pINIFile, bQuiet DBG_SRC );
}
SQLGETOPTION_PROC( size_t, SACK_GetPrivateProfileString )( CTEXTSTR pSection
                                                 , CTEXTSTR pOptname
                                                 , CTEXTSTR pDefaultbuf
                                                 , TEXTCHAR *pBuffer
                                                 , size_t nBuffer
                                                 , CTEXTSTR pINIFile )
{
	return SACK_GetPrivateProfileStringEx( pSection, pOptname, pDefaultbuf, pBuffer, nBuffer, pINIFile, FALSE );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntExx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pINIFile, LOGICAL bQuiet DBG_PASS )
{
	TEXTCHAR buffer[32];
	TEXTCHAR defaultbuf[32];
	tnprintf( defaultbuf, sizeof( defaultbuf ), WIDE("%") _32fs, nDefault );
	if( SACK_GetPrivateProfileStringExxx( odbc, pSection, pOptname, defaultbuf, buffer, sizeof( buffer )/sizeof(TEXTCHAR), pINIFile, bQuiet DBG_RELAY ) )
	{
		if( buffer[0] == 'Y' || buffer[0] == 'y' )
			return 1;
		return (int32_t)IntCreateFromText( buffer );
	}
	return nDefault;
}
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pINIFile, LOGICAL bQuiet )
{
	int32_t result;
	PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	result = SACK_GetPrivateProfileIntExx( odbc, pSection, pOptname, nDefault, pINIFile, bQuiet DBG_SRC );
	DropOptionODBC( odbc );
	return result;
}
SQLGETOPTION_PROC( int32_t, SACK_GetPrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t nDefault, CTEXTSTR pINIFile )
{
	return SACK_GetPrivateProfileIntEx( pSection, pOptname, nDefault, pINIFile, FALSE );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( size_t, SACK_GetProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer, LOGICAL bQuiet )
{
	return SACK_GetPrivateProfileStringEx( pSection, pOptname, pDefaultbuf, pBuffer, nBuffer, NULL, bQuiet );
}
#undef SACK_GetProfileString
SQLGETOPTION_PROC( size_t, SACK_GetProfileString )( CTEXTSTR pSection, CTEXTSTR pOptname, CTEXTSTR pDefaultbuf, TEXTCHAR *pBuffer, size_t nBuffer )
{
	return SACK_GetPrivateProfileString( pSection, pOptname, pDefaultbuf, pBuffer, nBuffer, NULL );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( int, SACK_GetProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer )
{
	POPTION_TREE_NODE optval;
#ifdef DETAILED_LOGGING
	lprintf( WIDE( "Only single odbc available here." ) );
#endif
	optval = GetOptionIndexExx( odbc, OPTION_ROOT_VALUE, NULL, NULL, pSection, pOptname, FALSE, FALSE DBG_SRC );
	if( !optval )
	{
		return FALSE;
	}
	else
	{
		return GetOptionBlobValueOdbc( odbc, optval, pBuffer, pnBuffer );
	}
	return FALSE;
//   int status = SACK_GetProfileString( );
}
SQLGETOPTION_PROC( int, SACK_GetProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR **pBuffer, size_t *pnBuffer )
{
   return SACK_GetProfileBlobOdbc( og.Option, pSection, pOptname, pBuffer, pnBuffer );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( int32_t, SACK_GetProfileIntEx )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval, LOGICAL bQuiet )
{
   return SACK_GetPrivateProfileIntEx( pSection, pOptname, defaultval, NULL, bQuiet );
}
//------------------------------------------------------------------------
#undef SACK_GetProfileInt
SQLGETOPTION_PROC( int32_t, SACK_GetProfileInt )( CTEXTSTR pSection, CTEXTSTR pOptname, int32_t defaultval )
{
   return SACK_GetPrivateProfileInt( pSection, pOptname, defaultval, NULL );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateOptionStringEx )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush )
{
	POPTION_TREE_NODE optval;
	if( !pINIFile )
		pINIFile = DEFAULT_PUBLIC_KEY;
	else
	{
      TEXTCHAR buf[128];
      pINIFile = ResolveININame( odbc, pSection, buf, pINIFile );
	}
#if defined( _DEBUG )
	if( global_sqlstub_data->flags.bLogOptionConnection )
		_lprintf( DBG_SRC )( WIDE( "Setting option {%s}[%s]%s=%s" ), pINIFile, pSection, pName, pValue );
#endif
	optval = GetOptionIndexExxx( odbc, NULL, NULL, pINIFile, pSection, pName, TRUE, FALSE, FALSE DBG_SRC );
	if( !optval )
	{
		lprintf( WIDE("Creation of path failed!") );
		return FALSE;
	}
	else
	{
		POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
		LOGICAL result = SetOptionStringValue( tree, optval, pValue );
		if( flush && tree->odbc_writer )
			SQLCommit( tree->odbc_writer );
#ifdef DETAILED_LOGGING
		lprintf( WIDE( "Set option value %d [%d]" ), optval, pValue );
#endif
		return result;
	}
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush )
{
	PODBC odbc;
	LOGICAL result;
	odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	result = SACK_WritePrivateOptionStringEx( odbc, pSection, pName, pValue, pINIFile, flush );
	DropOptionODBC( odbc );
	return result;
}
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile )
{
	return SACK_WritePrivateProfileStringEx( pSection, pName, pValue, pINIFile, FALSE );
}
SQLGETOPTION_PROC( LOGICAL, SACK_WritePrivateOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile )
{
	return SACK_WritePrivateOptionStringEx( odbc, pSection, pName, pValue, pINIFile, FALSE );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( int32_t, SACK_WritePrivateProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value, CTEXTSTR pINIFile )
{
	TEXTCHAR valbuf[32];
	tnprintf( valbuf, sizeof( valbuf ), WIDE("%") _32fs, value );
	return SACK_WritePrivateProfileString( pSection, pName, valbuf, pINIFile );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileStringEx )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue, CTEXTSTR pINIFile, LOGICAL flush )
{
	return SACK_WritePrivateProfileStringEx( pSection, pName, pValue, DEFAULT_PUBLIC_KEY, flush );
}
SQLGETOPTION_PROC( LOGICAL, SACK_WriteProfileString )( CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue )
{
	return SACK_WritePrivateProfileString( pSection, pName, pValue, DEFAULT_PUBLIC_KEY );
}
SQLGETOPTION_PROC( LOGICAL, SACK_WriteOptionString )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pName, CTEXTSTR pValue )
{
	return SACK_WritePrivateOptionString( odbc, pSection, pName, pValue, DEFAULT_PUBLIC_KEY );
}
//------------------------------------------------------------------------
SQLGETOPTION_PROC( int32_t, SACK_WriteProfileInt )( CTEXTSTR pSection, CTEXTSTR pName, int32_t value )
{
	return SACK_WritePrivateProfileInt( pSection, pName, value, NULL );
}
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app )
{
	POPTION_TREE_NODE optval;
	optval = GetOptionIndexExx( odbc, OPTION_ROOT_VALUE, app, NULL, pSection, pOptname, TRUE, FALSE DBG_SRC );
	if( !optval )
	{
		lprintf( WIDE("Creation of path failed!") );
		return FALSE;
	}
	else
	{
		POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
		return SetOptionBlobValueEx( tree, optval, pBuffer, nBuffer );
	}
	return 0;
}
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer, CTEXTSTR app )
{
	return SACK_WritePrivateProfileBlobOdbc( og.Option, pSection, pOptname, pBuffer, nBuffer, app );
}
SQLGETOPTION_PROC( int, SACK_WriteProfileBlobOdbc )( PODBC odbc, CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer )
{
   return SACK_WritePrivateProfileBlobOdbc( odbc, pSection, pOptname, pBuffer, nBuffer, NULL );
}
SQLGETOPTION_PROC( int, SACK_WriteProfileBlob )( CTEXTSTR pSection, CTEXTSTR pOptname, TEXTCHAR *pBuffer, size_t nBuffer )
{
   return SACK_WritePrivateProfileBlobOdbc( og.Option, pSection, pOptname, pBuffer, nBuffer, NULL );
}
//------------------------------------------------------------------------
#if 0
/// this still needs a way to communicate the time from and time until.
SQLGETOPTION_PROC( int, SACK_WritePrivateProfileExceptionString )( CTEXTSTR pSection
                                                            , CTEXTSTR pName
                                                            , CTEXTSTR pValue
                                                            , CTEXTSTR pINIFile
 // SQLTIME
                                                            , uint32_t from
   // SQLTIME
                                                            , uint32_t to
                                                            , CTEXTSTR pSystemName )
{
	INDEX optval = GetOptionIndexEx( OPTION_ROOT_VALUE, pINIFile, pSection, pName, TRUE DBG_SRC );
	if( optval == INVALID_INDEX )
	{
		lprintf( WIDE("Creating of path failed!") );
		return FALSE;
	}
	else
	{
		//CTEXTSTR result = NULL;
		TEXTCHAR exception[256];
		INDEX system;
		INDEX IDValue = CreateValue( og.Option, optval,pValue );
		system = GetSystemIndex( pSystemName );
		tnprintf( exception, sizeof( exception ), WIDE("insert into option_exception (`apply_from`,`apply_to`,`value_id`,`override_value_id`,`system`) ")
																	  WIDE( "values( \'%04d%02d%02d%02d%02d\', \'%04d%02d%02d%02d%02d\', %")_size_f WIDE(", %")_size_f WIDE(",%" _size_f )
             , wYrFrom, wMoFrom, wDyFrom
             , wHrFrom, wMnFrom,wScFrom
             , wYrTo, wMoTo, wDyTo
             , wHrTo, wMnTo,wScTo
             , optval
              , IDValue
 // system
              , system
              );
		if( !SQLCommand( og.Option, exception ) )
		{
			CTEXTSTR result = NULL;
			GetSQLResult( &result );
			lprintf( WIDE("Insert exception failed: %s"), result );
		}
		else
		{
			if( system || session )
			{
	            INDEX IDTime = FetchLastInsertID( og.Option, WIDE("option_exception"), WIDE("exception_id") );
				// lookup system name... provide detail record
			}
		}
	}
	return 1;
}
#endif
struct option_interface_tag DefaultInterface =
{
   SACK_GetPrivateProfileString
   , SACK_GetPrivateProfileInt
   , SACK_GetProfileString
   , SACK_GetProfileInt
   , SACK_WritePrivateProfileString
   , SACK_WritePrivateProfileInt
   , SACK_WriteProfileString
   , SACK_WriteProfileInt
   , SACK_GetPrivateProfileStringEx
   , SACK_GetPrivateProfileIntEx
   , SACK_GetProfileStringEx
   , SACK_GetProfileIntEx
   , SACK_WritePrivateProfileStringEx
};
#undef GetOptionInterface
SQLGETOPTION_PROC( POPTION_INTERFACE, GetOptionInterface )( void )
{
   return &DefaultInterface;
}
SQLGETOPTION_PROC( void, DropOptionInterface )( POPTION_INTERFACE interface_drop )
{
}
PRIORITY_UNLOAD( AllocateOptionGlobal, CONFIG_SCRIPT_PRELOAD_PRIORITY )
{
   // other data to destroy?
	DeleteCriticalSec( &og.cs_option );
}
PRIORITY_PRELOAD( AllocateOptionGlobal, CONFIG_SCRIPT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( sack_global_option_data );
	InitializeCriticalSec( &og.cs_option );
}
PRIORITY_PRELOAD(RegisterSQLOptionInterface, SQL_PRELOAD_PRIORITY + 1 )
{
   // have a multiple test because of C++ and C playing together with shared global; not threading issue
	if( !og.flags.bRegistered )
	{
		og.flags.bRegistered = 1;
		RegisterInterface( WIDE("SACK_SQL_Options"), (POINTER(CPROC *)(void))GetOptionInterface, (void(CPROC *)(POINTER))DropOptionInterface );
		og.flags.bEnableSystemMapping = 2;
	}
}
// delay reading options until after interface configuration is processed which has option defaults.
PRIORITY_PRELOAD( ReadOptionOptions, NAMESPACE_PRELOAD_PRIORITY + 1 )
{
#ifndef __NO_OPTIONS__
	og.flags.bUseProgramDefault = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/SQL/Options/Options Use Program Name Default" ), 1, TRUE );
	og.flags.bUseSystemDefault = SACK_GetProfileIntEx( GetProgramName(), WIDE( "SACK/SQL/Options/Options Use System Name Default" ), 0, TRUE );
#else
	og.flags.bUseProgramDefault = 1;
	og.flags.bUseSystemDefault = 0;
#endif
}
SQLGETOPTION_PROC( CTEXTSTR, GetSystemID )( void )
{
#ifndef __NO_NETWORK__
	static TEXTCHAR result[12];
	tnprintf( result, 12, WIDE("%")_size_f, GetSystemIndex( GetSystemName() ) );
	return result;
#else
	{
      static TEXTCHAR buf[42];
		SACK_GetPrivateProfileStringExxx( NULL, "SACK/System", "Name", GetSeqGUID(), buf, 42, NULL, TRUE DBG_SRC );
		return buf;
	}
#endif
}
SQLGETOPTION_PROC( void, BeginBatchUpdate )( void )
{
	//   SQLCommand(
   //SQLCommand( og.Option, WIDE( "BEGIN TRANSACTION" ) );
}
SQLGETOPTION_PROC( void, EndBatchUpdate )( void )
{
   //SQLCommand( og.Option, WIDE( "COMMIT" ) );
}
ATEXIT( CommitOptions )
{
	INDEX idx;
	POPTION_TREE tree;
#ifdef DETAILED_LOGGING
	lprintf( WIDE( "Running Option cleanup..." ) );
#endif
	if( sack_global_option_data )
	{
		LIST_FORALL( og.trees, idx, POPTION_TREE, tree )
		{
			if( tree->odbc_writer )
			{
#ifdef DETAILED_LOGGING
				lprintf( WIDE( "flushing a write on %p" ), tree->odbc_writer );
#endif
				SQLCommit( tree->odbc_writer );
			}
		}
	}
}
static void CloseAllODBC( CTEXTSTR dsn ) {
	INDEX idx;
	LOGICAL new_tracker = FALSE;
	struct option_odbc_tracker *tracker;
	if( !dsn )
		dsn = GetDefaultOptionDatabaseDSN();
	LIST_FORALL( og.odbc_list, idx, struct option_odbc_tracker *, tracker )
	{
		//lprintf( "Check %s(%d) vs %s(%d)", dsn, version, tracker->name, tracker->version );
		if( StrCaseCmp( dsn, tracker->name ) == 0 ) {
			//lprintf( "yes, it matched." );
			break;
		}
	}
	if( tracker ) {
		PODBC odbc;
		PLIST list = NULL;
		LIST_FORALL( tracker->outstanding, idx, PODBC, odbc ) {
			CloseDatabaseEx( odbc, FALSE );
		}
		while( odbc = (PODBC)DequeLink( &tracker->available ) ) {
			CloseDatabaseEx( odbc, FALSE );
			AddLink( &list, odbc );
		}
		LIST_FORALL( list, idx, PODBC, odbc ) {
			EnqueLink( &tracker->available, odbc );
		}
	}
}
static void repairOptionDb( uintptr_t psv, PODBC odbc ) {
	static int fixing = 0;
	CTEXTSTR *results;
	size_t *lengths;
	int cols;
	int n;
	if( fixing ) {
		lprintf( "Already fixing, must have been selecting something?" );
		return;
	}
	fixing = 1;
	//lprintf( "Check:" );
	for( SQLRecordQueryf_v2( odbc, &cols, &results, &lengths, NULL, "pragma integrity_check" );
		results;
		FetchSQLRecord( odbc, &results ) ) {
		for( n = 0; n < cols; n++ ) {
			lprintf( "Rsult:%s", results[n] );
		}
	}
	{
		char newDb[256];
		char newDbFile[256];
		PODBC newOdbc;
		CTEXTSTR *fields;
		int row = 0;
		struct file_system_mounted_interface *mount = NULL;
		PVARTEXT pvtCmd = VarTextCreate();
		char *pDbOrigFile;
		{
			char * pVfs, *pVfsInfo, *pDbFile;
			//size_t nVfs, nVfsInfo, nDbFile;
			//ParseDSN( odbc->info.pDSN, &pVfs, &nVfs, &pVfsInfo, &nVfsInfo, &pDbFile, &nDbFile );
			ParseDSN( odbc->info.pDSN, &pVfs, &pVfsInfo, &pDbFile );
			pDbOrigFile = StrDup( pDbFile );
			snprintf( newDbFile, 256, "%s-r2", pDbFile );
			if( pVfsInfo )
				mount = sack_get_mounted_filesystem( pVfsInfo );
			else
				mount = sack_get_default_mount();
			sack_unlinkEx( 0, newDbFile, mount );
			snprintf( newDb, 256, "%s-r2", odbc->info.pDSN );
		}
		//snprintf( newDb, 256, "%s-r2", odbc->info.pDSN );
		newOdbc = GetOptionODBC( newDb );
		SetOptionDatabaseOption( newOdbc );
		SQLCommand( odbc, "delete from option4_map" );
		SQLCommand( odbc, "delete from option4_name" );
		for( row=0, SQLRecordQueryf_v2( odbc, &cols, &results, &lengths, &fields, "select * from option4_map" );
			results;
			row++, FetchSQLRecord( odbc, &results ) ) {
			if( !row ) {
				vtprintf( pvtCmd, "insert into option4_map(" );
				for( n = 0; n < cols; n++ ) {
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", fields[n] );
				}
				vtprintf( pvtCmd, ")VALUES" );
			}
			vtprintf( pvtCmd, "%s(", row?",":"" );
			for( n = 0; n < cols; n++ ) {
				if( results[n] )
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", EscapeSQLBinary( newOdbc, results[n], lengths[n] ) );
				else
					vtprintf( pvtCmd, "%sNULL", n ? "," : "" );
			}
			vtprintf( pvtCmd, ")" );
		}
		{
			PTEXT cmd = VarTextPeek( pvtCmd );
			if( cmd )
				SQLCommand( newOdbc, GetText( cmd ) );
		}
		VarTextEmpty( pvtCmd );
		for( row = 0, SQLRecordQueryf_v2( odbc, &cols, &results, &lengths, &fields, "select * from option4_name" );
			results;
			row++, FetchSQLRecord( odbc, &results ) ) {
			if( !row ) {
				vtprintf( pvtCmd, "insert into option4_name(" );
				for( n = 0; n < cols; n++ ) {
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", fields[n] );
				}
				vtprintf( pvtCmd, ")VALUES" );
			}
			vtprintf( pvtCmd, "%s(", row ? "," : "" );
			for( n = 0; n < cols; n++ ) {
				if( results[n] )
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", EscapeSQLBinary( newOdbc, results[n], lengths[n] ) );
				else
					vtprintf( pvtCmd, "%sNULL", n ? "," : "" );
			}
			vtprintf( pvtCmd, ")" );
		}
		{
			PTEXT cmd = VarTextPeek( pvtCmd );
			if( cmd )
				SQLCommand( newOdbc, GetText( cmd ) );
		}
		VarTextEmpty( pvtCmd );
		for( row = 0, SQLRecordQueryf_v2( odbc, &cols, &results, &lengths, &fields, "select * from option4_values" );
			results;
			row++, FetchSQLRecord( odbc, &results ) ) {
			if( !row ) {
				vtprintf( pvtCmd, "insert into option4_values(" );
				for( n = 0; n < cols; n++ ) {
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", fields[n] );
				}
				vtprintf( pvtCmd, ")VALUES" );
			}
			vtprintf( pvtCmd, "%s(", row ? "," : "" );
			for( n = 0; n < cols; n++ ) {
				if( results[n] )
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", EscapeSQLBinary( newOdbc, results[n], lengths[n] ) );
				else
					vtprintf( pvtCmd, "%sNULL", n ? "," : "" );
			}
			vtprintf( pvtCmd, ")" );
		}
		{
			PTEXT cmd = VarTextPeek( pvtCmd );
			if( cmd )
				SQLCommand( newOdbc, GetText( cmd ) );
		}
		VarTextEmpty( pvtCmd );
		for( row=0, SQLRecordQueryf_v2( odbc, &cols, &results, &lengths, &fields, "select * from option4_blobs" );
			results;
			row++, FetchSQLRecord( odbc, &results ) ) {
			if( !row ) {
				vtprintf( pvtCmd, "insert into option4_blobs(" );
				for( n = 0; n < cols; n++ ) {
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", fields[n] );
				}
				vtprintf( pvtCmd, ")VALUES" );
			}
			vtprintf( pvtCmd, "%s(", row ? "," : "" );
			for( n = 0; n < cols; n++ ) {
				if( results[n] )
					vtprintf( pvtCmd, "%s'%s'", n ? "," : "", EscapeSQLBinary( newOdbc, results[n], lengths[n] ) );
				else
					vtprintf( pvtCmd, "%sNULL", n ? "," : "" );
			}
			vtprintf( pvtCmd, ")" );
		}
		{
			PTEXT cmd = VarTextPeek( pvtCmd );
			if( cmd )
				SQLCommand( newOdbc, GetText( cmd ) );
		}
		VarTextDestroy( &pvtCmd );
		CloseDatabaseEx( newOdbc, FALSE );
		CloseAllODBC( odbc->info.pDSN );
		sack_unlinkEx( 0, pDbOrigFile, mount );
		sack_renameEx( pDbOrigFile, newDbFile, mount );
		Release( pDbOrigFile );
	}
	fixing = 0;
}
SQLGETOPTION_PROC( CTEXTSTR, GetDefaultOptionDatabaseDSN )( void )
{
	return global_sqlstub_data->OptionDb.info.pDSN;
}
PODBC GetOptionODBCEx( CTEXTSTR dsn  DBG_PASS )
{
	INDEX idx;
	LOGICAL new_tracker = FALSE;
	struct option_odbc_tracker *tracker;
	if( !dsn )
		dsn = GetDefaultOptionDatabaseDSN();
	LIST_FORALL( og.odbc_list, idx, struct option_odbc_tracker *, tracker )
	{
		//lprintf( "Check %s(%d) vs %s(%d)", dsn, version, tracker->name, tracker->version );
		if( StrCaseCmp( dsn, tracker->name ) == 0 )
		{
			//lprintf( "yes, it matched." );
			break;
		}
	}
	if( !tracker )
	{
		//lprintf( "Needed a new tracker." );
		tracker = New( struct option_odbc_tracker );
		tracker->name = StrDup( dsn );
		tracker->shared_option_tree = NULL;
		tracker->available = CreateLinkQueue();
		tracker->outstanding = NULL;
		AddLink( &og.odbc_list, tracker );
		new_tracker = TRUE;
	}
	{
		PODBC odbc = (PODBC)DequeLink( &tracker->available );
		if( !odbc )
		{
#ifdef DETAILED_LOGGING
			lprintf( "none available, create new connection." );
#endif
			odbc = ConnectToDatabaseExx( tracker->name, TRUE DBG_RELAY );
			SetSQLCorruptionHandler( odbc, repairOptionDb, (uintptr_t)odbc );
			SQLCommand( odbc, "pragma foreign_keys=on" );
			{
				INDEX idx;
				CTEXTSTR cmd;
				CTEXTSTR result;
				LIST_FORALL( global_sqlstub_data->option_database_init, idx, CTEXTSTR, cmd ) {
					SQLQueryf( odbc, &result, cmd );
					//if( result )
					//	lprintf( WIDE( " %s" ), result );
					SQLEndQuery( odbc );
				}
			}
			//SetSQLAutoClose( odbc, TRUE );
			if( !tracker->shared_option_tree )
			{
				POPTION_TREE option = GetOptionTreeExxx( odbc, NULL DBG_RELAY );
				//lprintf( "setting tracker shared to %p", option->option_tree );
				tracker->shared_option_tree =  option->option_tree;
			}
			else
			{
#ifdef DETAILED_LOGGING
				lprintf( "get the tree...." );
#endif
				GetOptionTreeExxx( odbc, tracker->shared_option_tree DBG_RELAY );
			}
			// only if it's a the first connection should we leave created as false.
			if( !new_tracker )
			{
				POPTION_TREE tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
				tree->flags.bCreated = 1;
			}
			SetOptionDatabaseOption( odbc );
		}
		AddLink( &tracker->outstanding, odbc );
#ifdef DETAILED_LOGGING
		_lprintf( DBG_RELAY )( "%p result...", odbc );
#endif
		return odbc;
	}
}
#undef GetOptionODBC
PODBC GetOptionODBC( CTEXTSTR dsn )
{
	return GetOptionODBCEx( dsn DBG_SRC );
}
void DropOptionODBCEx( PODBC odbc DBG_PASS )
{
	INDEX idx;
	struct option_odbc_tracker *tracker;
	//_lprintf( DBG_RELAY )( "%p Drop...", odbc );
	LIST_FORALL( og.odbc_list, idx, struct option_odbc_tracker *, tracker )
	{
		INDEX idx2;
		PODBC connection;
		LIST_FORALL( tracker->outstanding, idx2, PODBC, connection )
		{
			if( connection == odbc )
			{
				SetLink( &tracker->outstanding, idx2, NULL );
				EnqueLink( &tracker->available, odbc );
				break;
			}
		}
		if( !connection )
		{
			lprintf( WIDE("Failed to find the thing to drop.") );
		}
		if( connection )
			break;
	}
}
#undef DropOptionODBC
void DropOptionODBC( PODBC odbc )
{
	DropOptionODBCEx( odbc DBG_SRC );
}
PRIORITY_PRELOAD( CommitOptionsLoad, 150 )
{
	INDEX idx;
	POPTION_TREE tree;
#ifdef DETAILED_LOGGING
	lprintf( WIDE( "Running Option cleanup..." ) );
#endif
	LIST_FORALL( og.trees, idx, POPTION_TREE, tree )
	{
		if( tree->odbc_writer )
		{
#ifdef DETAILED_LOGGING
			lprintf( WIDE( "flushing a write on %p" ), tree->odbc_writer );
#endif
			SQLCommit( tree->odbc_writer );
		}
	}
}
void FindOptions( PODBC odbc, PLIST *result_list, CTEXTSTR name )
{
	POPTION_TREE tree;
	if( !odbc )
		odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	tree = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	New4FindOptions( tree, result_list, name );
}
SACK_OPTION_NAMESPACE_END
#ifndef GETOPTION_SOURCE
#define GETOPTION_SOURCE
#endif
// we want access to GLOBAL from sqltub
#define SQLLIB_SOURCE
#ifdef __WATCOMC__
 // unlink
#endif
// define this to show very verbose logging during creation and
// referencing of option tree...
//#define DETAILED_LOGGING
SQL_NAMESPACE
extern struct pssql_global *global_sqlstub_data;
SQL_NAMESPACE_END
/*
 Dump Option table...
 SELECT oname2.name,oname.name,optionvalues.string,omap.*
 FROM `optionmap` as omap
 join optionname as oname on omap.name_id=oname.name_id
 left join optionvalues on omap.value_id=optionvalues.value_id
 left join optionmap as omap2 on omap2.node_id=omap.parent_node_id
 left join optionname as oname2 on omap2.name_id=oname2.name_id
*/
SACK_OPTION_NAMESPACE
typedef struct sack_option_global_tag OPTION_GLOBAL;
#define og (*sack_global_option_data)
extern OPTION_GLOBAL *sack_global_option_data;
//------------------------------------------------------------------------
#define MKSTR(n,...) #__VA_ARGS__
;
//------------------------------------------------------------------------
void FixCorruption( PODBC odbc ) {
}
//------------------------------------------------------------------------
CTEXTSTR New4ReadOptionNameTable( POPTION_TREE tree, CTEXTSTR name, CTEXTSTR table, CTEXTSTR col, CTEXTSTR namecol, int bCreate DBG_PASS )
{
			TEXTCHAR query[256];
			TEXTCHAR *tmp;
			CTEXTSTR result = NULL;
			CTEXTSTR IDName = NULL;
			if( !table || !name )
				return NULL;
			// look in internal cache first...
			IDName = GetKeyOfName(tree->odbc,table,name);
			if( IDName )
				return IDName;
			if( !tree->odbc )
				DebugBreak();
			PushSQLQueryEx( tree->odbc );
			tmp = EscapeSQLStringEx( tree->odbc, name DBG_RELAY );
			tnprintf( query, sizeof( query ), WIDE("select %s from %s where %s like '%s'"), col?col:WIDE("id"), table, namecol, tmp );
			Release( tmp );
			if( SQLQueryEx( tree->odbc, query, &result DBG_RELAY) && result )
			{
				IDName = SaveText( result );
				SQLEndQuery( tree->odbc );
			}
			else if( bCreate )
			{
				TEXTSTR newval = EscapeSQLString( tree->odbc, name );
				tnprintf( query, sizeof( query ), WIDE("insert into %s (%s,%s) values( '%s','%s' )")
						  , table, col, namecol, IDName = GetSeqGUID(), newval );
				OpenWriterEx( tree DBG_RELAY );
				if( !SQLCommandEx( tree->odbc_writer, query DBG_RELAY ) )
				{
#ifdef DETAILED_LOGGING
					lprintf( WIDE("insert failed, how can we define name %s?"), name );
#endif
					// inser failed...
				}
				else
				{
					// all is well.
				}
				Release( newval );
			}
			else
				IDName = NULL;
			PopODBCEx(tree->odbc);
			if( IDName )
			{
				// instead of strdup, consider here using SaveName from procreg?
				AddBinaryNode( GetTableCache(tree->odbc,table), (POINTER)IDName
								 , (uintptr_t)SaveText( name ) );
			}
			return IDName;
}
//------------------------------------------------------------------------
LOGICAL CPROC LogProcessNode( uintptr_t psvForeach, uintptr_t psvNodeData, int level )
{
	POPTION_TREE_NODE nodeval = (POPTION_TREE_NODE)psvNodeData;
	lprintf( WIDE("%d %s"), level, nodeval->name );
	return TRUE;
}
void DumpFamilyTree( PFAMILYTREE tree )
{
	FamilyTreeForEach( tree, NULL, LogProcessNode, 0 );
}
//#define OPTION_ROOT_VALUE INVALID_INDEX
#define OPTION_ROOT_VALUE 0
POPTION_TREE_NODE New4GetOptionIndexExxx( PODBC odbc, POPTION_TREE tree, POPTION_TREE_NODE parent, const TEXTCHAR *system, const TEXTCHAR *program, const TEXTCHAR *file, const TEXTCHAR *pBranch, const TEXTCHAR *pValue, int bCreate, int bBypassParsing, int bIKnowItDoesntExist DBG_PASS )
//#define GetOptionIndex( f,b,v ) GetOptionIndexEx( OPTION_ROOT_VALUE, f, b, v, FALSE )
{
 // temp
	POPTION_TREE_NODE node;
	const TEXTCHAR **start = NULL;
	TEXTCHAR namebuf[256];
	TEXTCHAR query[256];
	const TEXTCHAR *p;
	CTEXTSTR *result = NULL;
	CTEXTSTR ID = NULL;
	// resets the search/browse cursor... not empty...
	FamilyTreeReset( &tree->option_tree );
	while( system || program || file || pBranch || pValue || start )
	{
#ifdef DETAILED_LOGGING
		lprintf( WIDE("Top of option loop") );
#endif
		if( !start || !(*start) )
		{
			if( program )
				start = &program;
			if( !start && system )
				start = &system;
			if( !start && file )
			{
#ifdef DETAILED_LOGGING
				lprintf( WIDE("Token parsing at FILE") );
#endif
				start = &file;
			}
			if( !start && pBranch )
			{
#ifdef DETAILED_LOGGING
				lprintf( WIDE("Token parsing at branch") );
#endif
				start = &pBranch;
			}
			if( !start && pValue )
			{
#ifdef DETAILED_LOGGING
				lprintf( WIDE("Token parsing at value") );
#endif
				start = &pValue;
			}
			if( !start || !(*start) ) continue;
		}
		p = bBypassParsing?NULL:pathchr( *start );
		if( p )
		{
			if( p-(*start) > 0 )
			{
				MemCpy( namebuf, (*start), (p - (*start)) * sizeof(TEXTCHAR) );
				namebuf[p-(*start)] = 0;
			}
			else
			{
				(*start) = p + 1;
				continue;
			}
			(*start) = p + 1;
		}
		else
		{
			StrCpyEx( namebuf, (*start), sizeof( namebuf )-1 );
			(*start) = NULL;
			start = NULL;
		}
		// remove references of 'here' during parsing.
		if( strcmp( namebuf, WIDE( "." ) ) == 0 )
			continue;
		// trim trailing spaces from option names.
		{
			int n = (int)(StrLen( namebuf ) - 1);
			while( n >= 0 && namebuf[n] == ' ' )
			{
				namebuf[n] = 0;
				n--;
			}
		}
#ifdef DETAILED_LOGGING
		lprintf( "Find [%s]", namebuf );
#endif
		//DumpFamilyTree( tree->option_tree );
		node = (POPTION_TREE_NODE)FamilyTreeFindChildEx( tree->option_tree, parent?parent->node:NULL, (uintptr_t)namebuf );
		if( node ) {
			parent = node;
			continue;
		}
		// else parent is ; and new node needs to be...
		{
			CTEXTSTR IDName = New4ReadOptionNameTable(tree,namebuf,OPTION4_NAME,WIDE( "name_id" ),WIDE( "name" ),1 DBG_RELAY);
			if( !bIKnowItDoesntExist )
			{
				PushSQLQueryExEx(tree->odbc DBG_RELAY );
				tnprintf( query, sizeof( query )
						  , WIDE( "select option_id from " )OPTION4_MAP WIDE( " where parent_option_id='%s' and name_id='%s'" )
						  , parent?parent->guid:GuidZero()
						  , IDName );
			}
			//lprintf( WIDE( "doing %s" ), query );
			if( bIKnowItDoesntExist || !SQLRecordQueryEx( tree->odbc, query, NULL, &result, NULL DBG_RELAY ) || !result )
			{
				if( bCreate )
				{
					// this is the only place where ID must be set explicit...
						// otherwise our root node creation failes if said root is gone.
					//lprintf( WIDE( "New entry... create it..." ) );
					tnprintf( query, sizeof( query ), WIDE( "Insert into " )OPTION4_MAP WIDE( "(`option_id`,`parent_option_id`,`name_id`) values ('%s','%s','%s')" )
							  , ID = GetSeqGUID(), parent->guid, IDName );
					OpenWriter( tree );
					if( SQLCommand( tree->odbc_writer, query ) )
					{
					}
					else
					{
						CTEXTSTR error;
						FetchSQLError( tree->odbc_writer, &error );
						lprintf( WIDE("Error inserting option: %s"), error );
						ID = NULL;
					}
#ifdef DETAILED_LOGGING
					lprintf( WIDE("Created option root...") );
#endif
					//lprintf( WIDE("Adding new option to family tree... ") );
					{
						POPTION_TREE_NODE new_node = GetFromSet( OPTION_TREE_NODE, &tree->nodes );
						//MemSet( new_node, 0, sizeof( struct sack_option_tree_family_node ) );
						new_node->guid = ID;
 // no value (yet?)
						new_node->flags.bHasValue = 0;
						new_node->name = SaveText( namebuf );
						new_node->value = NULL;
						new_node->node = FamilyTreeAddChild( &tree->option_tree, parent?parent->node:NULL, new_node, (uintptr_t)new_node->name );
						//lprintf( "New parent has been created in the tree... %p %s", new_node, new_node->guid );
						parent = new_node;
					}
					if( !bIKnowItDoesntExist )
						PopODBCEx( tree->odbc );
 // get out of this loop, continue outer.
					continue;
				}
				if( global_sqlstub_data->flags.bLogOptionConnection )
					_lprintf(DBG_RELAY)( WIDE("Option node missing; and was not created='%s'"), namebuf );
				if( !bIKnowItDoesntExist )
					PopODBCEx( tree->odbc );
				return NULL;
			}
			else
			{
// New( struct sack_option_tree_family_node );
				POPTION_TREE_NODE new_node = GetFromSet( OPTION_TREE_NODE, &tree->nodes );
				//MemSet( new_node, 0, sizeof( struct sack_option_tree_family_node ) );
#ifdef DETAILED_LOGGING
				lprintf( WIDE("found the node which has the name specified...") );
#endif
				new_node->guid = SaveText( result[0] );
				new_node->flags.bHasValue = 0;
				new_node->name = SaveText( namebuf );
				new_node->value = NULL;
				new_node->node = FamilyTreeAddChild( &tree->option_tree, parent?parent->node:NULL, new_node, (uintptr_t)new_node->name );
				//lprintf( "New parent has been created in the tree...2 %p %s", new_node, new_node->guid );
				parent = new_node;
			}
			if( !bIKnowItDoesntExist )
				PopODBCEx( tree->odbc );
		}
	}
	return parent;
}
//------------------------------------------------------------------------
struct resultBuffer {
	TEXTCHAR *buffer;
	size_t buflen;
};
static void expandResultBuffer( struct resultBuffer *buf, size_t x ) {
	TEXTCHAR *newbuf = NewArray( TEXTCHAR, buf->buflen+x );
	MemCpy( newbuf, buf->buffer, buf->buflen );
	buf->buflen += x;
	if( buf->buffer ) Release( buf->buffer );
	buf->buffer = newbuf;
}
static struct resultBuffer plqBuffers[16];
static int nBuffer;
size_t New4GetOptionStringValue( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len DBG_PASS )
{
	TEXTCHAR query[256];
	CTEXTSTR *result = NULL;
	size_t result_len = 0;
	size_t query_len;
	size_t *result_lengths;
	struct resultBuffer *buf;
	PVARTEXT pvtResult = NULL;
	buf = &plqBuffers[nBuffer++];
	if( nBuffer >= 16 ) nBuffer = 0;
	if( optval->uncommited_write )
	{
		if( !optval->value ) {
			(*buffer) = NULL;
			return 0;
		}
		result_len = StrLen( optval->value ) + 1;
		if(result_len > buf->buflen)  expandResultBuffer( buf, result_len * 2 );
		StrCpyEx( buf->buffer, optval->value, result_len+1 );
		buf->buffer[result_len-1] = 0;
		(*buffer) = buf->buffer;
		(*len) = result_len-1;
		return result_len-1;
	}
#if 0
	tnprintf( query, sizeof( query ), WIDE( "select override_value_id from " )OPTION4_EXCEPTION WIDE( " " )
            WIDE( "where ( apply_from<=now() or apply_from=0 )" )
            WIDE( "and ( apply_until>now() or apply_until=0 )" )
            WIDE( "and ( system_id=%d or system_id=0 )" )
            WIDE( "and option_id=%d " )
           , og.SystemID
           , optval->guid );
	PushSQLQueryEx( odbc );
	for( SQLQuery( odbc, query, &result ); result; FetchSQLResult( odbc, &result ) )
	{
		_optval = optval;
		tmp_value_id = atol( result );
		if( (!optval->guid) )
			optval = _optval;
		SQLEndQuery( odbc );
	}
#endif
	PushSQLQueryEx( odbc );
	query_len = tnprintf( query, sizeof( query ), WIDE( "select string from " )OPTION4_VALUES WIDE( " where option_id='%s' order by segment" ), optval->guid );
	// have to push here, the result of the prior is kept outstanding
	// if this was not pushed, the prior result would evaporate.
	(*buffer) = NULL;
	//lprintf( WIDE("do query for value string...") );
	result_len = (size_t)-1;
	if( optval->value )
		Release( (POINTER)optval->value );
	optval->value = NULL;
	optval->flags.bHasValue = 1;
	for( SQLRecordQueryLen( odbc, query, query_len, NULL, &result, &result_lengths, NULL ); result; FetchSQLRecord( odbc, &result ) )
	{
		if( !pvtResult )
			pvtResult = VarTextCreate();
		VarTextAddData( pvtResult, result[0], result_lengths[0] );
	}
	if( pvtResult )
	{
		PTEXT pResult = VarTextPeek( pvtResult );
		if( pResult ) {
			result_len = GetTextSize( pResult ) + 1;
			if( result_len > buf->buflen )  expandResultBuffer( buf, result_len );
			( *buffer ) = buf->buffer;
			( *len ) = result_len - 1;
			memcpy( ( *buffer ), GetText( pResult ), result_len );
			( *buffer )[result_len - 1] = 0;
			optval->value = DupCStrLen( *buffer, result_len - 1 );
		}
		//optval->value = StrDup( GetText( pResult ) );
		VarTextDestroy( &pvtResult );
	}
	PopODBCEx( odbc );
	return result_len-1;
}
int New4GetOptionBlobValueOdbc( PODBC odbc, POPTION_TREE_NODE optval, TEXTCHAR **buffer, size_t *len )
{
	CTEXTSTR *result = NULL;
	size_t tmplen;
	if( !len )
		len = &tmplen;
	PushSQLQueryEx( odbc );
#ifdef DETAILED_LOGGING
	lprintf( WIDE("do query for value string...") );
#endif
	if( SQLRecordQueryf( odbc, NULL, &result, NULL
							  , WIDE( "select `binary`,length(`binary`) from " )OPTION4_BLOBS WIDE( " where option_id='%s'" )
							  , optval->guid ) )
	{
		int success = FALSE;
		//lprintf( WIDE(" query succeeded....") );
		if( buffer && result && result[0] && result[1] )
		{
			success = TRUE;
			(*buffer) = NewArray( TEXTCHAR, (*len)=(size_t)IntCreateFromText( result[1] ));
			MemCpy( (*buffer), result[0], (*len) );
		}
		PopODBCEx( odbc );
		return success;
	}
	PopODBCEx( odbc );
	return FALSE;
}
//------------------------------------------------------------------------
LOGICAL New4CreateValue( POPTION_TREE tree, POPTION_TREE_NODE value, CTEXTSTR pValue )
{
	TEXTCHAR insert[256];
	CTEXTSTR result=NULL;
	TEXTSTR newval = EscapeSQLBinaryOpt( tree->odbc_writer, pValue, StrLen( pValue ), TRUE );
	LOGICAL retval = TRUE;
	size_t tmpOfs;
	if( value->value )
		Release( (POINTER)value->value );
	value->value = NULL;
	if( pValue == NULL )
	{
		tnprintf( insert, sizeof( insert ), WIDE( "delete from " )OPTION4_VALUES WIDE( " where `option_id`='%s'" )
				  , value->guid
				  );
	}
	else
	{
		size_t len = StrLen( pValue );
		size_t offset = 0;
		int segment = 0;
		size_t valLen;
		while( len > 95)
		{
			newval = EscapeSQLBinaryExx( tree->odbc_writer, pValue + offset, 95, &valLen, TRUE DBG_SRC );
			tmpOfs = tnprintf( insert, sizeof( insert ), WIDE( "replace into " )OPTION4_VALUES WIDE( " (`option_id`,`string`,`segment` ) values ('%s'," )
				, value->guid
			);
			memcpy( insert + tmpOfs, newval, valLen );
			tmpOfs += valLen;
			tmpOfs += tnprintf( insert + tmpOfs, sizeof( insert ), WIDE( ", %d)" )
				, segment
			);
			if( SQLCommandExx( tree->odbc_writer, insert, tmpOfs DBG_SRC ) )
			{
				value->flags.bHasValue = 1;
			}
			else
			{
				FetchSQLError( tree->odbc_writer, &result );
				lprintf( WIDE("Insert value failed: %s"), result );
				retval = FALSE;
			}
			offset += 95;
			len -= 95;
			segment++;
		}
		newval = EscapeSQLBinaryExx( tree->odbc_writer, pValue + offset, len, &valLen, TRUE DBG_SRC );
		tmpOfs = tnprintf( insert, sizeof( insert ), WIDE( "replace into " )OPTION4_VALUES WIDE( " (`option_id`,`string`,`segment` ) values ('%s',")
				  , value->guid
				  );
		memcpy( insert + tmpOfs, newval, valLen );
		tmpOfs += valLen;
		tmpOfs += tnprintf( insert + tmpOfs, sizeof( insert ), WIDE( ", %d)" )
			, segment
		);
		if( SQLCommandExx( tree->odbc_writer, insert, tmpOfs DBG_SRC ) )
		{
		}
		tnprintf( insert, sizeof( insert ), WIDE( "delete from " )OPTION4_VALUES WIDE( " where `option_id`='%s' and segment > %d" )
				  , value->guid
				  , segment
				  );
	}
	// save the value that we last wrote; then we can get it without worrying about the commit state
	value->value = StrDup( pValue );
	value->uncommited_write = tree->odbc_writer;
	AddLink( &tree->uncommited, value );
	if( SQLCommand( tree->odbc_writer, insert ) )
	{
		value->flags.bHasValue = 1;
	}
	else
	{
		FetchSQLError( tree->odbc_writer, &result );
		lprintf( WIDE("Insert value failed: %s"), result );
		retval = FALSE;
	}
	Release( newval );
	return retval;
}
int ResolveOptionName( POPTION_TREE options, CTEXTSTR parent_id, CTEXTSTR option_id, CTEXTSTR name_id, CTEXTSTR option_name, TEXTSTR output_buffer, size_t output_buffer_size )
{
	CTEXTSTR *results;
	if( StrCaseCmp( parent_id, GuidZero() ) == 0 )
	{
		return tnprintf( output_buffer, output_buffer_size, WIDE("%s"), option_name );
	}
	PushSQLQueryEx( options->odbc );
	for( SQLRecordQueryf( options->odbc, NULL, &results, NULL
						, WIDE("select parent_option_id,option_id,name_id,name from ") OPTION4_MAP WIDE( " join ") OPTION4_NAME WIDE(" using(name_id) where option_id='%s'" )
						, parent_id );
		results;
		FetchSQLRecord( options->odbc, &results ) )
	{
		int offset;
		offset = ResolveOptionName( options, results[0], results[1], results[2], results[3]
					, output_buffer, output_buffer_size );
		PopODBCEx( options->odbc );
		return offset + tnprintf( output_buffer + offset, output_buffer_size - offset, WIDE("/%s"), option_name );
	}
	return 0;
}
void New4FindOptions( POPTION_TREE options, PLIST *result_list, CTEXTSTR name )
{
	CTEXTSTR *results;
	for( SQLRecordQueryf( options->odbc, NULL, &results, NULL
						, WIDE("select parent_option_id,option_id,name_id,name from ") OPTION4_MAP WIDE( " join ") OPTION4_NAME WIDE(" using(name_id) where name like '%s'" )
						, name );
		results;
		FetchSQLRecord( options->odbc, &results ) )
	{
		TEXTCHAR option_name[256];
		ResolveOptionName( options, results[0], results[1], results[2], results[3], option_name, 256 );
		AddLink( result_list, StrDup( option_name ) );
	}
}
SACK_OPTION_NAMESPACE_END
#ifndef GETOPTION_SOURCE
#define GETOPTION_SOURCE
#endif
// we want access to GLOBAL from sqltub
#define SQLLIB_SOURCE
SQL_NAMESPACE
extern struct pssql_global *global_sqlstub_data;
SQL_NAMESPACE_END
SACK_OPTION_NAMESPACE
SQLGETOPTION_PROC( void, EnumOptionsEx )( PODBC odbc, POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
											  , uintptr_t psvUser )
{
	New4EnumOptions( odbc, parent, Process, psvUser );
}
SQLGETOPTION_PROC( void, EnumOptions )( POPTION_TREE_NODE parent
					 , int (CPROC *Process)(uintptr_t psv, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
											  , uintptr_t psvUser )
{
	PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	EnumOptionsEx( odbc, parent, Process, psvUser );
	DropOptionODBC( odbc );
}
SQLGETOPTION_PROC( void, DuplicateOptionEx )( PODBC odbc, POPTION_TREE_NODE iRoot, CTEXTSTR pNewName )
{
	New4DuplicateOption( odbc, iRoot, pNewName );
}
SQLGETOPTION_PROC( void, DuplicateOption )( POPTION_TREE_NODE iRoot, CTEXTSTR pNewName )
{
	   PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	DuplicateOptionEx( odbc, iRoot, pNewName );
	   DropOptionODBC( odbc );
}
SQLGETOPTION_PROC( void, DeleteOption )( POPTION_TREE_NODE iRoot )
{
	PODBC odbc = GetOptionODBC( GetDefaultOptionDatabaseDSN() );
	New4DeleteOption( odbc, iRoot );
	DropOptionODBC( odbc );
}
SACK_OPTION_NAMESPACE_END
//--------------------------------------------------------------------------
//
// $Log: optionutil.c,v $
// Revision 1.3  2005/03/21 19:37:08  jim
// Update to reflect newest database standardized changes
//
// Revision 1.2  2004/07/08 18:23:26  jim
// roughly works now.
//
// Revision 1.1  2004/04/15 00:12:56  jim
// Checkpoint
//
//
#ifndef GETOPTION_SOURCE
#define GETOPTION_SOURCE
#endif
SACK_OPTION_NAMESPACE
#define og (*sack_global_option_data)
extern struct sack_option_global_tag *sack_global_option_data;
#define ENUMOPT_FLAG_HAS_VALUE 1
#define ENUMOPT_FLAG_HAS_CHILDREN 2
struct new4_enum_params
{
	int (CPROC *Process)(uintptr_t psv
							  , CTEXTSTR name
							  , POPTION_TREE_NODE ID
							  , int flags );
	uintptr_t psvEnum;
};
static LOGICAL CPROC New4CheckOption( uintptr_t psvForeach, uintptr_t psvNode )
{
	POPTION_TREE_NODE option_node = (POPTION_TREE_NODE)psvNode;
	struct new4_enum_params *params = (struct new4_enum_params *)psvForeach;
	return params->Process( params->psvEnum, option_node->name, option_node
								 , ((option_node->flags.bHasValue)?1:0) );
}
void New4EnumOptions( PODBC odbc
												  , POPTION_TREE_NODE parent
												  , int (CPROC *Process)(uintptr_t psv
																				, CTEXTSTR name
																				, POPTION_TREE_NODE ID
																				, int flags )
												  , uintptr_t psvUser )
{
	POPTION_TREE node = GetOptionTreeExxx( odbc, NULL DBG_SRC );
	TEXTCHAR query[256];
	static PODBC pending;
	POPTION_TREE_NODE tmp_node;
	CTEXTSTR *results = NULL;
	if( !odbc )
		odbc = pending;
	if( !odbc )
		odbc = node->odbc;
	if( !odbc )
		return;
	if( !parent )
		parent = node->root;
	pending = odbc;
	// first should check the exisiting loaded family tree....
	//lprintf( WIDE("Enumerating for %p %p %s %s"), parent, parent->guid, parent->guid, parent->name_guid );
	{
		struct new4_enum_params params;
		params.Process = Process;
		params.psvEnum = psvUser;
		FamilyTreeForEachChild( node->option_tree, parent->node, New4CheckOption, (uintptr_t)&params );
	}
	//if( !parent->flags.bExpanded || ( ( timeGetTime() - 5000 ) > parent->expansion_tick ) )
	{
		parent->flags.bExpanded = 1;
		//parent->expansion_tick = timeGetTime();
		// any existing query needs to be saved...
 // any subqueries will of course clean themselves up.
		PushSQLQueryEx( odbc );
		tnprintf( query
			  , sizeof( query )
			  , WIDE( "select option_id,n.name,n.name_id " )
				WIDE( "from " )OPTION4_MAP WIDE( " as m " )
				WIDE( "join " )OPTION4_NAME WIDE( " as n on n.name_id=m.name_id " )
				WIDE( "where parent_option_id='%s' " )
				WIDE( "order by n.name" )
			  , parent->guid?parent->guid:GuidZero() );
		for( SQLRecordQuery( odbc, query, NULL, &results, NULL );
			 results;
			  FetchSQLRecord( odbc, &results ) )
		{
			// if it was already in the tree, it was processed in the loop above.
			// there is no actual sorting on insert of family nodes, it's more about their relations
			// then their stats...
			// try adding this node into the tree.
			POPTION_TREE_NODE existing = (POPTION_TREE_NODE)FamilyTreeFindChildEx( node->option_tree, parent->node, (uintptr_t)results[1] );
			if( !existing )
			{
				tmp_node = New( OPTION_TREE_NODE );
				MemSet( tmp_node, 0, sizeof( struct sack_option_tree_family_node ) );
				tmp_node->guid = SaveText( results[0] );
				tmp_node->flags.bHasValue = 0;
				tmp_node->name = SaveText( results[1] );
				tmp_node->node = FamilyTreeAddChild( &node->option_tree, parent->node, tmp_node, (uintptr_t)tmp_node->name );
				// psv is a pointer to args in some cases...
				//lprintf( WIDE( "Enum %s %ld" ), optname, node );
				//ReadFromNameTable( name, WIDE(""OPTION_NAME""), WIDE("name_id"), &result);
				if( !Process( psvUser, tmp_node->name, tmp_node
								, ((tmp_node->flags.bHasValue )?1:0)
								) )
				{
					break;
				}
			}
			//lprintf( WIDE("reget: %s"), query );
		}
		PopODBCEx( odbc );
	}
	pending = NULL;
}
struct complex_args
{
	POPTION_TREE_NODE iNewRoot;
	POPTION_TREE_NODE iOldRoot;
	PODBC odbc;
};
static int CPROC v4CopyRoot( uintptr_t psvArgs, CTEXTSTR name, POPTION_TREE_NODE ID, int flags )
{
	struct complex_args *args = (struct complex_args*)psvArgs;
	POPTION_TREE_NODE iCopy = GetOptionIndexEx( args->iNewRoot, NULL, name, NULL, TRUE, FALSE DBG_SRC );
	New4DuplicateValue( args->odbc, ID, iCopy );
	{
		struct complex_args c_args;
		c_args.iNewRoot = iCopy;
		c_args.odbc = args->odbc;
		EnumOptions( ID, v4CopyRoot, (uintptr_t)&c_args );
	}
	return TRUE;
}
void New4DuplicateOption( PODBC odbc, POPTION_TREE_NODE iRoot, CTEXTSTR pNewName )
{
	CTEXTSTR result = NULL;
	POPTION_TREE_NODE iNewName;
	if( SQLQueryf( odbc, &result, WIDE( "select parent_option_id from " ) OPTION4_MAP WIDE( " where option_id=%ld" ), iRoot ) && result )
	{
		POPTION_TREE_NODE tmp_node = New( OPTION_TREE_NODE );
		struct complex_args args;
		tmp_node->guid = StrDup( result );
		tmp_node->flags.bHasValue = iRoot->flags.bHasValue;
		tmp_node->value = NULL;
		SQLEndQuery( odbc );
		iNewName = GetOptionIndexEx( tmp_node, NULL, pNewName, NULL, TRUE, FALSE DBG_SRC );
		args.iNewRoot = iNewName;
		args.odbc = odbc;
		New4EnumOptions( args.odbc, iRoot, v4CopyRoot, (uintptr_t)&args );
	}
}
void New4DeleteOption( PODBC odbc, POPTION_TREE_NODE iRoot )
{
	SQLCommandf( odbc, WIDE( "delete from " )OPTION4_MAP WIDE( " where option_id='%s'" ), iRoot->guid );
	//   foriegn keys should be cascade, so these will disappear without specifically removing.
}
SACK_OPTION_NAMESPACE_END
//--------------------------------------------------------------------------
//
// $Log: optionutil.c,v $
// Revision 1.3  2005/03/21 19:37:08  jim
// Update to reflect newest database standardized changes
//
// Revision 1.2  2004/07/08 18:23:26  jim
// roughly works now.
//
// Revision 1.1  2004/04/15 00:12:56  jim
// Checkpoint
//
//
#ifdef _WIN32
#define SACKHIDLIST_SOURCE
#ifndef LISTHIDS_H
#define LISTHIDS_H
#ifdef SACKHIDLIST_SOURCE
#define SACKHIDLIST_PROC(type,name) EXPORT_METHOD type CPROC name
#else
#define SACKHIDLIST_PROC(type,name) IMPORT_METHOD type CPROC name
#endif
#define VERSION_LISTHIDS 0x00020000
#ifdef __cplusplus
extern "C"{
#endif
//#include <windows.h>
typedef struct
{
	TEXTSTR lpTechnology;
	TEXTSTR lpHid;
	TEXTSTR lpClass;
	TEXTSTR lpClassGuid;
}LISTHIDS_HIDINFO;
typedef LOGICAL (CPROC* ListHidsCallback)( uintptr_t psv, LISTHIDS_HIDINFO* lpHidInfo );
SACKHIDLIST_PROC( LOGICAL, ListHids )( ListHidsCallback lpCallback, uintptr_t psv );
#ifdef __cplusplus
}
#endif
#elif VERSION_LISTHIDS!=0x00020000
#error You have included two LISTHIDS.H with different version numbers
#endif
//static LOGICAL Win9xListPorts( ListHidsCallback lpCallback, uintptr_t psv );
//static LOGICAL WinNT40ListPorts( ListHidsCallback lpCallback, uintptr_t psv );
static LOGICAL Win2000ListPorts( ListHidsCallback lpCallback, uintptr_t psv );
//static LOGICAL WinCEListPorts( ListHidsCallback lpCallback, uintptr_t psv);
static LOGICAL ScanEnumTree( CTEXTSTR lpEnumPath, ListHidsCallback lpCallback, uintptr_t psv );
static uint32_t OpenSubKeyByIndex( HKEY hKey, uint32_t dwIndex, REGSAM samDesired, PHKEY phkResult, TEXTSTR* lppSubKeyName );
static uint32_t QueryStringValue( HKEY hKey, CTEXTSTR lpValueName, TEXTSTR* lppStringValue );
#if 0
LOGICAL  CPROC cb( uintptr_t psv, LISTHIDS_HIDINFO* lpHidInfo ) {
	lprintf( "%s %s %s %s", lpHidInfo->lpTechnology,
		lpHidInfo->lpHid,
		lpHidInfo->lpClass,
		lpHidInfo->lpClassGuid );
	return TRUE;
}
void dump( ) {
	ListHids( cb, 0 );
}
PRELOAD( testhids ) {
	dump();
}
#endif
LOGICAL ListHids( ListHidsCallback lpCallback, uintptr_t psv )
{
#ifdef WIN32
	OSVERSIONINFO osvinfo;
	// check parameters
	if( !lpCallback )
	{
		SetLastError( ERROR_INVALID_PARAMETER );
		return FALSE;
	}
	// determine which platform we're running on and forward
	// to the appropriate routine
	ZeroMemory( &osvinfo, sizeof( osvinfo ) );
	osvinfo.dwOSVersionInfoSize = sizeof( osvinfo );
	GetVersionEx( &osvinfo );
	lprintf( WIDE(" Platform ID: %d, Major Version: %d"), osvinfo.dwPlatformId, osvinfo.dwMajorVersion );
	switch( osvinfo.dwPlatformId )
	{
		case VER_PLATFORM_WIN32_WINDOWS:
			//return Win9xListPorts( lpCallback, psv );
			SetLastError( ERROR_OLD_WIN_VERSION );
			return FALSE;
			//break;
		case VER_PLATFORM_WIN32_NT:
			if( osvinfo.dwMajorVersion < 4 )
			{
				SetLastError( ERROR_OLD_WIN_VERSION );
				return FALSE;
			}
			else if( osvinfo.dwMajorVersion == 4 )
			{
				//return WinNT40ListPorts( lpCallback, psv );
				SetLastError( ERROR_OLD_WIN_VERSION );
				return FALSE;
			}
			else
			{
 // hopefully it'll also work for XP
				return Win2000ListPorts( lpCallback, psv );
			}
			break;
#ifdef _WIN32_WCE
		case VER_PLATFORM_WIN32_CE:
			//return WinCEListPorts( lpCallback, lpCallbackValue );
			SetLastError( ERROR_OLD_WIN_VERSION );
			return FALSE;
#endif
		default:
			SetLastError( ERROR_OLD_WIN_VERSION );
			return FALSE;
			break;
	}
#else
#endif
}
/*
static LOGICAL Win9xListPorts( ListHidsCallback lpCallback, uintptr_t psv )
{
	return ScanEnumTree( WIDE( "ENUM" ), lpCallback, psv );
}
*/
/*
static LOGICAL WinNT40ListPorts( ListHidsCallback lpCallback, uintptr_t psv )
{
	uint32_t     dwError = 0;
	HKEY    hKey = NULL;
	uint32_t     dwIndex;
	TEXTSTR lpValueName = NULL;
	TEXTSTR lpPortName = NULL;
	if( dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WIDE( "HARDWARE\\DEVICEMAP\\SERIALCOMM" ), 0, KEY_READ,&hKey ) )
	{
		// it is really strange that this key does not exist, but could happen in theory
		if( dwError == ERROR_FILE_NOT_FOUND ) dwError = 0;
		goto end;
	}
	for(dwIndex=0;;++dwIndex)
	{
		uint32_t              cbValueName = 32 * sizeof( TEXTCHAR );
		uint32_t              cbPortName = 32 * sizeof( TEXTCHAR );
		LISTHIDS_HIDINFO portinfo;
		// loop asking for the value data til we allocated enough memory
		for(;;)
		{
			free( lpValueName );
			if( !( lpValueName = (TEXTSTR)malloc( cbValueName ) ) )
			{
				dwError = ERROR_NOT_ENOUGH_MEMORY;
				goto end;
			}
			free( lpPortName );
			if( !( lpPortName = (TEXTSTR)malloc( cbPortName ) ) )
			{
				dwError = ERROR_NOT_ENOUGH_MEMORY;
				goto end;
			}
			if( !( dwError = RegEnumValue( hKey, dwIndex, lpValueName, &cbValueName, NULL, NULL, (LPBYTE)lpPortName, &cbPortName) ) )
			{
				break; // we did it
			}
			else if( dwError == ERROR_MORE_DATA )
			{
				// not enough space
				dwError = 0;
				// no indication of space required, we try doubling
				cbValueName =( cbValueName + sizeof( TEXTCHAR ) ) * 2;
			}
			else goto end;
		}
		portinfo.lpPortName = lpPortName;
		portinfo.lpFriendlyName = lpPortName; // no friendly name in NT 4.0
		portinfo.lpTechnology = WIDE(""); // this information is not available
		if( !lpCallback( psv,&portinfo ) )
		{
			goto end; // listing aborted by callback
		}
	}
end:
	free( lpValueName );
	free( lpPortName );
	if( hKey != NULL )
		RegCloseKey( hKey );
	if( dwError!=0 )
	{
		SetLastError(dwError);
		return FALSE;
	}
	else return TRUE;
}
*/
static LOGICAL Win2000ListPorts( ListHidsCallback lpCallback, uintptr_t psv )
{
  return ScanEnumTree( WIDE( "SYSTEM\\CURRENTCONTROLSET\\ENUM" ), lpCallback, psv );
}
/*
static LOGICAL WinCEListPorts( ListHidsCallback lpCallback, uintptr_t psv )
{
	uint32_t                 dwError = 0;
	HKEY                hKey = NULL;
	uint32_t                 dwIndex;
	TEXTSTR             lpPortName = NULL;
	HKEY                hkLevel1 = NULL;
	TEXTSTR             lpFriendlyName = NULL;
	LISTPORTS_PORTINFO  portinfo;
	uint32_t                 index;
	uint32_t                 wordSize = sizeof( uint32_t );
	portinfo.lpPortName = (TEXTSTR)malloc( 64 );
	if( dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, WIDE( "Drivers\\BuiltIn" ), 0, KEY_READ, &hKey ) )
	{
		// it is really strange that this key does not exist, but could happen in theory
		if( dwError == ERROR_FILE_NOT_FOUND )
			dwError = 0;
		goto end;
	}
	for( dwIndex=0; ; ++dwIndex )
	{
		dwError = 0;
		if ( dwError = OpenSubKeyByIndex( hKey, dwIndex, KEY_ENUMERATE_SUB_KEYS, &hkLevel1, NULL ) )
		{
			if ( dwError == ERROR_NO_MORE_ITEMS ) dwError = 0;
			break;
		}
		if ( dwError = QueryStringValue( hkLevel1, WIDE( "PREFIX" ), &lpPortName ) )
		{
			if( dwError == ERROR_FILE_NOT_FOUND )
				continue;
			else
				break;
		}
		if ( StrCaseCmpEx( lpPortName, WIDE( "COM" ), 3 ) != 0 )
			continue; // We want only COM serial ports
		if ( dwError = RegQueryValueEx( hkLevel1, WIDE( "INDEX" ), NULL, NULL, (LPBYTE)&index, &wordSize) )
		{
			if( dwError == ERROR_FILE_NOT_FOUND )
				continue;
			else
				break;
		}
		// Now "index" contains serial port number, we put it together with "COM"
		// to format like "COM<index>"
		snprintf( portinfo.lpPortName, sizeof( portinfo.lpPortName ), WIDE("COM%u"), index );
		// Get friendly name
		dwError = QueryStringValue( hkLevel1, WIDE( "FRIENDLYNAME" ), &lpFriendlyName );
		portinfo.lpFriendlyName = dwError ? (TEXTSTR)WIDE( "" ) : lpFriendlyName;
		portinfo.lpTechnology = WIDE( "" ); // this information is not available
		if( !lpCallback( psv, &portinfo ) )
		{
			break;
		}
	}
end:
	free( portinfo.lpPortName );
	free( lpFriendlyName );
	free( lpPortName );
	if( hKey != NULL )
		RegCloseKey( hKey );
	if( hkLevel1 != NULL )
		RegCloseKey( hkLevel1 );
	if( dwError != 0 )
	{
		SetLastError( dwError );
		return FALSE;
	}
	else
		return TRUE;
}
*/
static LOGICAL ScanEnumTree( CTEXTSTR lpEnumPath, ListHidsCallback lpCallback, uintptr_t psv )
{
	uint32_t    dwError = 0;
	HKEY   hkEnum = NULL;
	uint32_t    dwIndex1;
	HKEY   hkLevel1 = NULL;
	uint32_t    dwIndex2;
	HKEY   hkLevel2 = NULL;
	uint32_t    dwIndex3;
	HKEY   hkLevel3 = NULL;
	TEXTSTR lpTechnology = NULL;
	TEXTSTR lpClass = NULL;
	TEXTSTR lpClassGuid = NULL;
	TEXTSTR lpHid = NULL;
	if( dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE, lpEnumPath, 0, KEY_ENUMERATE_SUB_KEYS, &hkEnum ) )
	{
		goto end;
	}
	for( dwIndex1 = 0; ; ++dwIndex1 )
	{
		if( hkLevel1 != NULL )
		{
			RegCloseKey( hkLevel1 );
			hkLevel1 = NULL;
		}
		if( dwError = OpenSubKeyByIndex( hkEnum, dwIndex1, KEY_ENUMERATE_SUB_KEYS, &hkLevel1, &lpTechnology ) )
		{
			if( dwError == ERROR_NO_MORE_ITEMS )
			{
				dwError = 0;
				break;
			}
			else
				goto end;
		}
		for( dwIndex2 = 0; ; ++dwIndex2 )
		{
			if( hkLevel2 != NULL )
			{
				RegCloseKey( hkLevel2 );
				hkLevel2 = NULL;
			}
			if( dwError = OpenSubKeyByIndex( hkLevel1, dwIndex2, KEY_ENUMERATE_SUB_KEYS, &hkLevel2, NULL ) )
			{
				if( dwError == ERROR_NO_MORE_ITEMS )
				{
					dwError = 0;
					break;
				}
				else
					goto end;
			}
			for( dwIndex3 = 0; ;++dwIndex3 )
			{
				LISTHIDS_HIDINFO hidinfo;
				if( hkLevel3 != NULL )
				{
					RegCloseKey( hkLevel3 );
					hkLevel3 = NULL;
				}
				if( dwError = OpenSubKeyByIndex( hkLevel2, dwIndex3, KEY_READ, &hkLevel3, &lpClass ) )
				{
					if( dwError == ERROR_NO_MORE_ITEMS )
					{
						dwError = 0;
						break;
					}
					else
						goto end;
				}
				dwError = QueryStringValue( hkLevel3, WIDE( "HardwareID" ), &lpHid );
				if( dwError )
				{
					if( dwError == ERROR_FILE_NOT_FOUND )
					{
						// boy that was strange, we better skip this device
						dwError = 0;
						continue;
					}
					else
						goto end;
				}
				/*
				dwError = QueryStringValue( hkLevel3, WIDE( "Class" ), &lpClass );
				if( dwError )
				{
					if( dwError == ERROR_FILE_NOT_FOUND )
					{
						dwError = 0;
					}
					else
						goto end;
				}
				*/
				dwError = QueryStringValue( hkLevel3, WIDE( "ClassGUID" ), &lpClassGuid );
				if( dwError )
				{
					if( dwError == ERROR_FILE_NOT_FOUND )
					{
						dwError = 0;
					}
					else
						goto end;
				}
				hidinfo.lpTechnology = lpTechnology;
				hidinfo.lpHid = lpHid;
				hidinfo.lpClass = lpClass;
				hidinfo.lpClassGuid = lpClassGuid;
				if( !lpCallback( psv, &hidinfo ) )
				{
 // listing aborted by callback
					goto end;
				}
			}
		}
	}
end:
	free( lpTechnology );
	free( lpHid );
	free( lpClass );
	free( lpClassGuid );
	if( hkLevel3!=NULL ) RegCloseKey( hkLevel3 );
	if( hkLevel2!=NULL ) RegCloseKey( hkLevel2 );
	if( hkLevel1!=NULL ) RegCloseKey( hkLevel1 );
	if( hkEnum != NULL )  RegCloseKey( hkEnum );
	if( dwError != 0 )
	{
		SetLastError( dwError );
		return FALSE;
	}
	else
		return TRUE;
}
static uint32_t OpenSubKeyByIndex( HKEY hKey, uint32_t dwIndex, REGSAM samDesired, PHKEY phkResult, TEXTSTR* lppSubKeyName )
{
	uint32_t              dwError = 0;
	LOGICAL          bLocalSubkeyName = FALSE;
	TEXTSTR          lpSubkeyName = NULL;
 // an initial guess
	uint32_t              cbSubkeyName = 128 * sizeof( TEXTCHAR );
	FILETIME         filetime;
	if( lppSubKeyName == NULL )
	{
		bLocalSubkeyName = TRUE;
		lppSubKeyName = &lpSubkeyName;
	}
	// loop asking for the subkey name til we allocated enough memory
	for( ; ; )
	{
		free( *lppSubKeyName );
		if( !( *lppSubKeyName = (TEXTSTR)malloc( cbSubkeyName ) ) )
		{
			dwError = ERROR_NOT_ENOUGH_MEMORY;
			goto end;
		}
		if( !( dwError = RegEnumKeyEx( hKey, dwIndex, *lppSubKeyName, (LPDWORD)&cbSubkeyName, 0, NULL, NULL, &filetime ) ) )
		{
 // we did it
			break;
		}
		else if( dwError == ERROR_MORE_DATA )
		{
			// not enough space
			dwError=0;
			// no indication of space required, we try doubling
			cbSubkeyName = ( cbSubkeyName + sizeof( TEXTCHAR ) ) * 2;
		}
		else
			goto end;
	}
	dwError = RegOpenKeyEx( hKey, *lppSubKeyName, 0, samDesired, phkResult );
end:
	if( bLocalSubkeyName )
		free( *lppSubKeyName );
	return dwError;
}
static uint32_t QueryStringValue( HKEY hKey, CTEXTSTR lpValueName, TEXTSTR* lppStringValue )
{
 // an initial guess
	uint32_t cbStringValue = 128 * sizeof( TEXTCHAR );
	for(;;)
	{
		uint32_t dwError;
		free( *lppStringValue );
		if( !( *lppStringValue = (TEXTSTR)malloc( cbStringValue ) ) )
		{
			return ERROR_NOT_ENOUGH_MEMORY;
		}
		if( !( dwError = RegQueryValueEx( hKey, lpValueName, NULL, NULL, (LPBYTE)*lppStringValue, (LPDWORD)&cbStringValue ) ) )
		{
			return ERROR_SUCCESS;
		}
		else if( dwError == ERROR_MORE_DATA )
		{
			// not enough space, keep looping
		}
		else
			return dwError;
	}
}
#endif
#define TRANSLATION_SOURCE
/* provides text translation.
  Primary Usage:
      SetTranslation( "some string" );
	 CTEXTSTR result = TranslateText( "some string to translate" );
	 lprintf( TranslateText( "Some format string %d:%d" ), x, y );
*/
#ifndef TRANSLATIONS_DEFINED
/* Multiple inclusion protection symbol. */
#define TRANSLATIONS_DEFINED
#ifdef __cplusplus
#  define _TRANSLATION_NAMESPACE namespace translation {
#  define _TRANSLATION_NAMESPACE_END }
#  define	 SACK_TRANSLATION_NAMESPACE_END } }
#  define USE_TRANSLATION_NAMESPACE using namespace sack::translation;
#else
#  define _TRANSLATION_NAMESPACE
#  define _TRANSLATION_NAMESPACE_END
#  define	 SACK_TRANSLATION_NAMESPACE_END
#  define USE_TRANSLATION_NAMESPACE
#endif
#  define TRANSLATION_NAMESPACE SACK_NAMESPACE _TRANSLATION_NAMESPACE
#  define TRANSLATION_NAMESPACE_END _TRANSLATION_NAMESPACE_END  SACK_NAMESPACE_END
SACK_NAMESPACE
	/* Namespace of custom math routines.  Contains operators
	 for Vectors and fractions. */
	_TRANSLATION_NAMESPACE
#define TRANSLATION_API CPROC
#  ifdef TRANSLATION_SOURCE
#    define TRANSLATION_PROC EXPORT_METHOD
#  else
/* Define the library linkage for a these functions. */
#    define TRANSLATION_PROC IMPORT_METHOD
#  endif
struct translation {
	TEXTSTR name;
	PLIST strings;
};
typedef struct translation *PTranslation;
TRANSLATION_PROC LOGICAL TRANSLATION_API SetCurrentTranslation( CTEXTSTR language );
TRANSLATION_PROC CTEXTSTR TRANSLATION_API TranslateText( CTEXTSTR text );
TRANSLATION_PROC PTranslation TRANSLATION_API CreateTranslation( CTEXTSTR language );
TRANSLATION_PROC struct translation * TRANSLATION_API GetTranslation( CTEXTSTR language );
TRANSLATION_PROC void TRANSLATION_API SetTranslatedString( PTranslation translation, INDEX idx, CTEXTSTR string );
TRANSLATION_PROC CTEXTSTR TRANSLATION_API GetTranslationName( PTranslation translation );
TRANSLATION_PROC void TRANSLATION_API SaveTranslationDataEx( const char *filename );
TRANSLATION_PROC void TRANSLATION_API SaveTranslationData( void );
TRANSLATION_PROC void TRANSLATION_API SaveTranslationDataToFile( FILE *output );
TRANSLATION_PROC void TRANSLATION_API LoadTranslationDataEx( const char *filename );
TRANSLATION_PROC void TRANSLATION_API LoadTranslationData( void );
TRANSLATION_PROC void TRANSLATION_API LoadTranslationDataFromMemory( POINTER data, size_t length );
TRANSLATION_PROC void TRANSLATION_API LoadTranslationDataFromFile( FILE *file );
/*
   return: PLIST is a list of PTranslation
*/
TRANSLATION_PROC PLIST TRANSLATION_API GetTranslations( void );
TRANSLATION_PROC CTEXTSTR TRANSLATION_API GetTranslationName( struct translation *translation );
/*
	return: PLIST of CTEXTSTR which are result strings of this translation
*/
TRANSLATION_PROC PLIST TRANSLATION_API GetTranslationStrings( struct translation *translation );
/*
  return: PLIST of CTEXTSTR which are source index strings
  */
TRANSLATION_PROC PLIST TRANSLATION_API GetTranslationIndexStrings( );
SACK_TRANSLATION_NAMESPACE_END
USE_TRANSLATION_NAMESPACE
#endif
TRANSLATION_NAMESPACE
//struct translation {
//	TEXTSTR name;
//	PLIST strings;
//};
#define STRING_INDEX_TYPE uint32_t
#define STRINGSPACE_SIZE (8192 - sizeof( uint32_t ) - 2 * sizeof( POINTER ))
typedef struct stringspace_tag
{
	uint32_t nextname;
	TEXTCHAR buffer[STRINGSPACE_SIZE];
	DeclareLink( struct stringspace_tag );
} STRINGSPACE, *PSTRINGSPACE;
static struct translation_local_tag
{
	PTREEROOT index;
	PLIST index_list;
	PSTRINGSPACE index_strings;
	PSTRINGSPACE translated_strings;
	uint32_t string_count;
	PLIST translations;
	struct translation *current_translation;
	LOGICAL updated;
} *_translate_local;
#define translate_local (*_translate_local)
//---------------------------------------------------------------------------
PRELOAD( InitTrasnlationLocal )
{
	SimpleRegisterAndCreateGlobal( _translate_local );
	translate_local.index = CreateBinaryTreeEx( (GenericCompare)(int (MEM_API *)(CTEXTSTR , CTEXTSTR ))StrCmp, NULL );
}
//---------------------------------------------------------------------------
static CTEXTSTR SaveString( PSTRINGSPACE *root, uint32_t index, CTEXTSTR text )
{
	PSTRINGSPACE space = root[0];
	TEXTCHAR *p;
	size_t len = StrLen( text ) + sizeof( TEXTCHAR );
	translate_local.updated = TRUE;
	for( ; space; space = space->next )
	{
		//lprintf( "Finding next name space free %p %p %p", l.NameSpace, space, space->next );
		if( ( space->nextname + len ) < ( STRINGSPACE_SIZE - ( index?5:1 ) ) )
		{
			break;
		}
	}
	if( !space )
	{
		space = New( STRINGSPACE );
		space->nextname = 0;
		//lprintf( "Adding new namespace %p", space );
		if( space->next = root[0] )
			root[0]->me = &space->next;
		space->me = root;
		root[0] = space;
	}
	if( index )
	{
		MemCpy( p = space->buffer + space->nextname + sizeof( STRING_INDEX_TYPE )
			, text,(uint32_t)(sizeof( TEXTCHAR)*(len)) );
		((STRING_INDEX_TYPE*)(space->buffer + space->nextname))[0] = index;
		space->nextname += (uint32_t)len + sizeof( STRING_INDEX_TYPE );
	}
	else
	{
		MemCpy( p = space->buffer + space->nextname, text,(uint32_t)(sizeof( TEXTCHAR)*(len)) );
		space->nextname += (uint32_t)len;
	}
	// +2 1 for byte of len, 1 for nul at end.
#if defined( __ARM__ ) || defined( UNDER_CE )
	space->nextname = ( space->nextname + 3 ) & 0xFFFFC;
	// +3&0xFC rounds to next full dword segment
	// arm requires this name be aligned on a dword boundry
	// because later code references this as a DWORD value.
#endif
	return (CTEXTSTR)p;
}
//---------------------------------------------------------------------------
static FILE *dumpOutput;
static LOGICAL dumpFirst;
static int Dump( CPOINTER user, uintptr_t key )
{
	sack_fprintf( dumpOutput, "\t\t%s\"%d\":\"%s\"\n", dumpFirst?"":",", (uint32_t)(uintptr_t)user, key );
	dumpFirst = FALSE;
	return 0;
}
//---------------------------------------------------------------------------
void SaveTranslationDataToFile( FILE *output )
{
	//uint32_t n;
	//PSTRINGSPACE strings;
	/*
	for( n = 0, strings = translate_local.index_strings;
		 strings;
		  n++, strings = strings->next );
	sack_fwrite( &n, 1, sizeof( n ), output );
	for( strings = translate_local.index_strings;
		 strings;
		  strings = strings->next )
	{
		sack_fwrite( strings, 1, sizeof( strings[0] ), output );
	}
	*/
	sack_fprintf( output, "{\n" );
	{
		INDEX idx;
		LOGICAL firstTranslation = TRUE;
		LOGICAL first = TRUE;
		//TEXTCHAR *string;
		struct translation *translation;
		sack_fprintf( output, "\t\"DEFAULT\":{\n" );
		dumpOutput = output;
		dumpFirst = TRUE;
		DumpTree( translate_local.index, Dump );
		sack_fprintf( output, "\t}\n" );
		LIST_FORALL( translate_local.translations, idx, struct translation *, translation )
		{
			//size_t len;
			INDEX string_idx;
			//uint32_t tmp;
			//uint8_t length[3];
			CTEXTSTR string;
			first = TRUE;
			sack_fprintf( output,"\t,\"%s\":{\n", translation->name );
			//len = StrLen( translation->name );
			//sack_fwrite( &len, sizeof( len ), 1, output );
			//sack_fwrite( translation->name, len, 1, output );
			LIST_FORALL( translation->strings, string_idx, CTEXTSTR, string )
			{
				char *tmp;
				sack_fprintf( output,"\t\t%s\"%d\":\"%s\"\n", (first)?"":",", string_idx, tmp = json_escape_string(string) );
				first = FALSE;
				Deallocate( char *, tmp );
/*
				tmp = (uint32_t)(string_idx + 1);
				sack_fwrite( &tmp, 1, 4, output );
				tmp = (uint32_t)StrLen( string );
				if( tmp > 127 )
				{
					if( tmp > 32768 )
					{
						length[0] = 0x80 | ( ( tmp & 0x3FC000 ) >> 14 );
						length[1] = 0x80 | ( ( tmp & 0x3F80 ) >> 7 );
						length[2] =  ( tmp & 0x7F );
						sack_fwrite( length, 1, 3, output );
					}
					else
					{
						length[0] = 0x80 | ( ( tmp & 0x3F80 ) >> 7 );
						length[1] =  ( tmp & 0x7F );
						sack_fwrite( length, 1, 2, output );
					}
				}
				else
					sack_fwrite( &tmp, 1, 1, output );
				sack_fwrite( string, 1, tmp, output );
*/
			}
			sack_fprintf( output, "\t}\n");
			//tmp = 0;
			//sack_fwrite( &tmp, 1, 4, output );
		}
	}
	sack_fprintf( output, "}\n");
}
//---------------------------------------------------------------------------
void SaveTranslationDataEx( const char *filename )
{
	if( translate_local.updated ) {
		FILE *output = sack_fopen( 0, filename, WIDE("wb") );
		if( !output )
			return;
		SaveTranslationDataToFile( output );
		sack_fclose( output );
	}
}
//---------------------------------------------------------------------------
void SaveTranslationData( void )
{
	SaveTranslationDataEx( "strings.json" );
}
//---------------------------------------------------------------------------
void LoadTranslationDataFromMemory( POINTER input, size_t length )
{
	PDATALIST data = NULL;
	if( json_parse_message( (char*)input, length, &data ) ) {
		struct json_value_container *val;
		INDEX idx;
		struct json_value_container *val3;
		INDEX idx3;
		DATA_FORALL( data, idx3, struct json_value_container *, val3 ) {
			if( val3->value_type == VALUE_OBJECT ) {
				DATA_FORALL( val3->contains, idx, struct json_value_container *, val ) {
					if( val->value_type != VALUE_OBJECT )
						continue;
					struct json_value_container *val2;
					INDEX idx2;
					if( StrCmp( val->name, "DEFAULT" ) == 0 ) {
						DATA_FORALL( val->contains, idx2, struct json_value_container *, val2 ) {
							if( val2->value_type != VALUE_STRING ) continue;
							CTEXTSTR index_text = SaveString( &translate_local.index_strings, (uint32_t)IntCreateFromText( val2->name ), val2->string );
							PLIST list = SetLink( &translate_local.index_list, translate_local.string_count, index_text );
							AddBinaryNode( translate_local.index, (CPOINTER)((uintptr_t)translate_local.string_count+1), (uintptr_t)index_text );
							translate_local.string_count++;
						}
					} else {
						struct translation *translation = CreateTranslation( val->name );
						DATA_FORALL( val->contains, idx2, struct json_value_container *, val2 ) {
							int64_t index = IntCreateFromText( val2->name );
							SetTranslatedString( translation, index, val2->string );
						}
					}
				}
			}
		}
		json_dispose_message( &data );
	}
	translate_local.updated = FALSE;
}
//---------------------------------------------------------------------------
void LoadTranslationDataEx( const char *filename )
{
	size_t size = 0;
	char *tmp = ExpandPath( filename );
	POINTER file = OpenSpace( NULL, tmp, &size );
	Deallocate( char *, tmp );
	//lprintf( "load file:%p", file );
	if( file )
	{
		LoadTranslationDataFromMemory( file, size );
		CloseSpace( file );
	}
}
void LoadTranslationDataFromFile( FILE *file ) {
	size_t size;
	char *data;
	size = sack_fsize( file );
	data = NewArray( char, size );
	size = sack_fread( data, size, 1, file );
	LoadTranslationDataFromMemory( data, size );
}
//---------------------------------------------------------------------------
void LoadTranslationData( void )
{
	LoadTranslationDataEx( "strings.json" );
}
//---------------------------------------------------------------------------
CTEXTSTR TranslateText( CTEXTSTR text )
{
	uintptr_t psvIndex = (uintptr_t)FindInBinaryTree( translate_local.index, (uintptr_t)text );
	if( !psvIndex )
	{
		text = SaveString( &translate_local.index_strings, translate_local.string_count+1, text );
		SetLink( &translate_local.index_list, translate_local.string_count, text );
		AddBinaryNode( translate_local.index, (CPOINTER)((uintptr_t)translate_local.string_count+1), (uintptr_t)text );
		translate_local.string_count++;
		psvIndex = translate_local.string_count;
	}
	if( translate_local.current_translation )
	{
		CTEXTSTR output = (CTEXTSTR)GetLink( &translate_local.current_translation->strings, psvIndex-1 );
		if( output )
			return output;
	}
	return text;
}
//---------------------------------------------------------------------------
LOGICAL SetCurrentTranslation( CTEXTSTR language )
{
	INDEX idx;
	struct translation *translation;
	LIST_FORALL( translate_local.translations, idx, struct translation *, translation )
	{
		if( StrCaseCmp( translation->name, language ) == 0 )
		{
			translate_local.current_translation = translation;
			return TRUE;
		}
	}
	return FALSE;
}
//---------------------------------------------------------------------------
struct translation * GetTranslation( CTEXTSTR language )
{
	INDEX idx;
	struct translation *translation;
	LIST_FORALL( translate_local.translations, idx, struct translation *, translation )
	{
		if( StrCaseCmp( translation->name, language ) == 0 )
		{
			return translation;
		}
	}
	return NULL;
}
//---------------------------------------------------------------------------
struct translation * CreateTranslation( CTEXTSTR language )
{
	INDEX idx;
	struct translation *translation;
	LIST_FORALL( translate_local.translations, idx, struct translation *, translation )
	{
		if( StrCaseCmp( translation->name, language ) == 0 )
		{
			translate_local.current_translation = translation;
			return translation;
		}
	}
	translate_local.updated = TRUE;
	translation = New( struct translation );
	translation->name = StrDup( language );
	translation->strings = NULL;
	AddLink( &translate_local.translations, translation );
	return translation;
}
//---------------------------------------------------------------------------
void SetTranslatedString( struct translation *translation, INDEX idx, CTEXTSTR string )
{
	if( translation )
	{
		SetLink( &translation->strings, idx - 1, SaveString( &translate_local.translated_strings, 0, string ) );
	}
}
//---------------------------------------------------------------------------
CTEXTSTR GetTranslationName( struct translation *translation )
{
	return translation->name;
}
//---------------------------------------------------------------------------
PLIST GetTranslations( void )
{
	return translate_local.translations;
}
//---------------------------------------------------------------------------
PLIST GetTranslationStrings( struct translation *translation )
{
	return translation->strings;
}
//---------------------------------------------------------------------------
PLIST GetTranslationIndexStrings( void )
{
	return translate_local.index_list;
}
TRANSLATION_NAMESPACE_END
#define DISABLE_DEBUG_REGISTER_AND_DISPATCH
#if defined( __GNUC__ )
#ifndef __cplusplus
#pragma GCC visibility push(hidden)
#ifndef paste
#  define paste(a,b) a##b
#endif
#define paste2(a,b) paste(a,b)
//#ifndef (
//static
//#endif
	void paste2( TARGET_LABEL,_RegisterStartups)( void ) __attribute__((constructor)) __attribute__((used));
//PRIORITY_PRELOAD( RunStartups, 25 )
// This becomes the only true contstructor...
// this is loaded in the main program, and not in a library
// this ensures that the libraries registration (if any)
// is definatly done to the main application
//(the one place for doing the work)
static int Registered;
// this one is used when the library loads.  (there is only one of these.)
// and constructors are run every time a library is loaded....
// I wonder whose fault that is....
void paste2( TARGET_LABEL,_RegisterStartups)( void )
{
#define DeclareList(n) paste2(n,TARGET_LABEL)
	extern struct rt_init DeclareList( begin_deadstart_ );
	extern struct rt_init DeclareList( end_deadstart_ );
	struct rt_init *begin = &DeclareList( begin_deadstart_ );
	struct rt_init *end = &DeclareList( end_deadstart_ );
	struct rt_init *current;
#ifdef __NO_BAG__
   printf( "Not doing deadstarts\n" );
	return;
#endif
	Registered=1;
	//cygwin_dll_init();
	if( begin[0].scheduled )
      return;
	if( (begin+1) < end )
	{
		for( current = begin + 1; current < end; current++ )
		{
			if( !current[0].scheduled )
			{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
				RegisterPriorityStartupProc( current->routine, current->funcname, current->priority, NULL, current->file, current->line );
#else
				RegisterPriorityStartupProc( current->routine, current->funcname, current->priority, NULL );
#endif
				current[0].scheduled = 1;
			}
			else
			{
#ifndef  DISABLE_DEBUG_REGISTER_AND_DISPATCH
				lprintf( WIDE("Not Register(already did this once) %d %s@%s(%d)"), current->priority, current->funcname, current->file, current->line );
#endif
			}
		}
	}
	// should be setup in such a way that this ignores all external invokations until the core app runs.
	//InvokeDeadstart();
}
#pragma GCC visibility pop
#endif
#endif
/*
 * Crafted by Jim Buckeyne
 * Resembles function of SYSV IPC Message Queueus, and handle event based, inter-process, shared
 * queue, message transport.
 *
 * (c)1999-2006++ Freedom Collective
 *
 */
 // Sleep
 // offsetof
#ifdef __LINUX__
#define SetLastError(n)  errno = n
#else
#define SetLastError(n)  SetLastError(n);errno = n
#endif
#ifdef __cplusplus
namespace sack {
	namespace containers {
	namespace message {
		using namespace sack::memory;
		using namespace sack::timers;
		using namespace sack::logging;
#endif
//#define DISABLE_MSGQUE_LOGBINARY
//#define DISABLE_MSGQUE_LOGGING
#define DISABLE_MSGQUE_LOGGING_DETAILED
static INDEX _tmp, __tmp;
void _UpdatePos( INDEX *tmp, INDEX inc DBG_PASS )
{
	if( inc == 0 )
		DebugBreak();
	__tmp = _tmp;
	_tmp = (*tmp);
	(*tmp) += inc;
	if( (*tmp) > 0x8000 )
		DebugBreak();
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	_xlprintf(5 DBG_RELAY )( WIDE("updating position from %d,%d,%d by %d"), __tmp, _tmp, (*tmp), inc );
#endif
}
void _SetPos( INDEX *tmp, INDEX inc, INDEX initial DBG_PASS )
{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	if( initial )
		_xlprintf(5 DBG_RELAY )( WIDE("Setting position to %d"), inc );
	else
		_xlprintf(5 DBG_RELAY )( WIDE("Setting position from %d to %d"), (*tmp), inc );
#endif
	if( !initial )
	{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
		__tmp = _tmp;
		_tmp = (*tmp);
#endif
		(*tmp) = inc;
	}
	else
	{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
		__tmp = _tmp =
#endif
			(*tmp) = inc;
	}
}
#define UpdatePos(t,i) _UpdatePos( &(t), (i) DBG_SRC )
#define SetPos(t,i) _SetPos( &(t), (i), FALSE DBG_SRC )
#define SetPosI(t,i) _SetPos( &(t), (i), TRUE DBG_SRC )
//--------------------------------------------------------------------------
//  MSG Queue functions.
//--------------------------------------------------------------------------
typedef PREFIX_PACKED struct MsgInternalData {
	// length  & 0x80000000 == after msg, return to head of queue
	// length == 0x80000000 == next is actually first in queue...
	// length & 0x40000000 message has already been received...
	// length & 0x20000000 message tag for request for specific message
	//   then length(low) points at next waiting.
	//   MsgID is the ID being waited for
	//   datalength is sizeof( THREAD_ID ) and data is MyThreadID()
	uint32_t length;
 // size resulting in read...
	uint32_t real_length;
  // this is tick count + time to live, if tick count is greater than this, message is dropped.
	uint32_t ttl;
	// space which we added ourselves...
} PACKED MSGCORE;
typedef PREFIX_PACKED struct MsgData
{
	  MSGCORE msg;
	long MsgID;
	// ... end of this structure is
	// defined by length & 0x0FFFFFFC
} PACKED MSGDATA, *PMSGDATA;
typedef PREFIX_PACKED struct ThreadWaitMsgData
{
	MSGDATA msgdata;
	THREAD_ID thread;
	// ... end of this structure is
	// defined by length & 0x0FFFFFFC
} PACKED THREADMSGDATA, *PTHREADMSGDATA;
typedef struct MsgDataQueue
{
	TEXTCHAR name[128];
	INDEX   Top;
	INDEX   Bottom;
   // number of times this is open, huh?
	INDEX   Cnt;
 // reference of first element in queue waiting for specific ID
	uint32_t     waiter_top;
 // reference of first element in queue waiting for specific ID
	uint32_t     waiter_bottom;
	//THREAD_ID waiting;  // a thread waiting for any message...
	CRITICALSECTION cs;
	INDEX   Size;
	// this is a lot of people using this queue....
	// 1000 unique people waiting for a message....
	// this is fairly vast..
	struct {
 // and this is the message I wait for.
		long msg;
  // my ID - who I am that I am waiting...
		THREAD_ID me;
	} waiters[1024];
	uint8_t      data[1];
} MSGQUEUE, *PMSGQUEUE;
typedef struct MsgDataHandle
{
	PMSGQUEUE pmq;
	uint32_t default_ttl;
	MsgQueueReadCallback Read;
	uintptr_t psvRead;
	DeclareLink( struct MsgDataHandle );
} MSGHANDLE;
//--------------------------------------------------------------------------
//--------------------------------------------------------------------------
// in this case size is the size of the queue, there
// is no expansion possible...
// this should be created such that it is at least 3 * largest message
 PMSGHANDLE  SackCreateMsgQueue ( CTEXTSTR name, size_t size
                                , MsgQueueReadCallback Read
                                , uintptr_t psvRead )
{
	PMSGHANDLE pmh;
	PMSGQUEUE pmq;
	uintptr_t dwSize = size + sizeof( MSGQUEUE );
	uint32_t bCreated;
#ifdef __LINUX__
	TEXTCHAR tmpname[128];
	sprintf( tmpname, WIDE("/tmp/%s"), name );
#endif
	pmq = (PMSGQUEUE)OpenSpaceExx(
#ifdef __LINUX__
							 NULL
						  , tmpname
#else
							 name
						  , NULL
#endif
						  , 0
						  , &dwSize
							, &bCreated );
	if( !pmq )
		return NULL;
	InitializeCriticalSec( &pmq->cs );
	pmh          = (PMSGHANDLE)Allocate( sizeof( MSGHANDLE ) );
	pmh->default_ttl = 250;
	pmh->Read    = Read;
	pmh->psvRead = psvRead;
	pmh->pmq     = pmq;
	// now - how to see if result is new...
	// space is 0'd on create.
	// so if the second open results before the create
	// always increment this - otherwise the create open will
	// obliterate the second opener's presense.
	StrCpyEx( pmq->name, name?name:WIDE("Anonymous"),127 );
	pmq->name[127] = 0;
	pmq->Cnt++;
	if( bCreated )
	{
		pmq->Size = size;
	}
	return pmh;
}
//--------------------------------------------------------------------------
// in this case size is the size of the queue, there
// is no expansion possible...
// this should be created such that it is at least 3 * largest message
 PMSGHANDLE  SackOpenMsgQueue ( CTEXTSTR name
													 , MsgQueueReadCallback Read
													 , uintptr_t psvRead )
{
	PMSGHANDLE pmh;
	PMSGQUEUE pmq;
	uintptr_t dwSize = 0;
	uint32_t bCreated;
#ifdef __LINUX__
	char tmpname[128];
	sprintf( tmpname, WIDE("/tmp/%s"), name );
#endif
	pmq = (PMSGQUEUE)OpenSpaceExx(
#ifdef __LINUX__
							 NULL
						  , tmpname
#else
							 name
						  , NULL
#endif
						  , 0
						  , &dwSize
							, &bCreated );
	if( !pmq )
		return NULL;
	pmh          = (PMSGHANDLE)Allocate( sizeof( MSGHANDLE ) );
	pmh->default_ttl = 250;
	pmh->Read    = Read;
	pmh->psvRead = psvRead;
	pmh->pmq     = pmq;
	// now - how to see if result is new...
	// space is 0'd on create.
	// so if the second open results before the create
	// always increment this - otherwise the create open will
	// obliterate the second opener's presense.
	StrCpyEx( pmq->name, name?name:WIDE("Anonymous"), sizeof( pmq->name ) );
	pmq->Cnt++;
	if( bCreated )
	{
		lprintf( WIDE("SackOpenMsgQueue should never result with a created queue!") );
		DebugBreak();
		//pmq->Size = size;
	}
	return pmh;
}
//--------------------------------------------------------------------------
 void  DeleteMsgQueueEx ( PMSGHANDLE *ppmh DBG_PASS )
{
	if( ppmh )
	{
		EnterCriticalSec( &(*ppmh)->pmq->cs );
		if( (*ppmh)->pmq )
		{
			INDEX owners;
			owners = --(*ppmh)->pmq->Cnt;
			lprintf( WIDE("Remaining owners of queue: %") _size_f, owners );
			CloseSpaceEx( (*ppmh)->pmq, (!owners) );
		}
		Release( *ppmh );
		*ppmh = NULL;
	}
}
#define DBG_SOURCE DBG_SRC
//--------------------------------------------------------------------------
#define ACTUAL_LEN_MASK           0x000FFFFF
#define MARK_FLAGS                0xF0000000
#define MARK_END_OF_QUE           0x80000000
#define MARK_MESSAGE_ALREADY_READ 0x40000000
#define MARK_THREAD_WAITING       0x20000000
#define MESSAGE_SKIPABLE          0xc0000000
//--------------------------------------------------------------------------
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
 void DumpMessageQueue( PMSGQUEUE pmq )
 {
	 int tmp;
	 for( tmp = pmq->Bottom; tmp != pmq->Top; tmp = tmp + (((uint32_t*)(pmq->data+tmp))[0] & ACTUAL_LEN_MASK ) )
	 {
		 lprintf( "Message In Queue... %d", (((uint32_t*)(pmq->data+tmp))[0] & ACTUAL_LEN_MASK ) );
		 LogBinary( pmq->data + tmp, (((uint32_t*)(pmq->data+tmp))[0] & ACTUAL_LEN_MASK ) );
	 }
 }
void DumpWaiterQueue( PMSGQUEUE pmq )
{
	INDEX tmp;
	tmp = pmq->waiter_bottom;
	while( tmp != pmq->waiter_top )
	{
		lprintf( WIDE("[%d] waiter sleeping is %016") _64fX WIDE(" for %") _32f WIDE("")
				  , tmp
				 , pmq->waiters[tmp].me
				 , pmq->waiters[tmp].msg
				 );
		tmp++;
		if( tmp >= 1024 )
			tmp = 0;
	}
}
#endif
//--------------------------------------------------------------------------
static void CollapseWaiting( PMSGQUEUE pmq, long msg )
{
	//int nWoken = 0;
	int32_t tmp = pmq->waiter_bottom;
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	lprintf( WIDE("before moving the waiters forward on %s... msg %ld (or me? %s)"), pmq->name, msg, msg?"no":"yes" );
	DumpWaiterQueue( pmq );
#endif
	// now walk tmp backwards...
	// and move entried before the threads woken forward...
	// end up with a new bottom always (if having awoken something)
	if( pmq->waiter_top != pmq->waiter_bottom )
	{
		//uint32_t last = 0;
		uint32_t found = 0;
		uint32_t marked = 0;
		int32_t next = pmq->waiter_top - 1;
		INDEX tmp_bottom = pmq->waiter_bottom;
		if( next < 0 )
			next = 1023;
		// start at the last used queue spot (tmp)
		tmp = next;
		tmp_bottom = pmq->waiter_bottom;
		while( 1 )
		{
			if( !pmq->waiters[next].me ||
				( msg &&
				 ( msg == pmq->waiters[next].msg ) ) )
			{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				lprintf( WIDE("Skipping a next %d... "), next );
#endif
				if( !marked )
				{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
					lprintf( WIDE("marking tmp to copy into...") );
#endif
					tmp = next;
					marked = 1;
				}
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				else
					lprintf( WIDE("Already marked... and moving every element..") );
#endif
				if( (++tmp_bottom) >= 1024 )
				{
					tmp_bottom = 0;
				}
				// no reason to move next if it's still NULL...
				//continue;
			}
			else
			{
				found = 1;
				if( marked )
				{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
					lprintf( WIDE("Marked something... and now we move next %d into %d"), next, tmp );
#endif
					pmq->waiters[tmp--] = pmq->waiters[next];
					if( tmp < 0 )
						tmp = 1023;
					//continue;
				}
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				lprintf( WIDE("Next queue element is kept... set temp here.") );
#endif
			}
			// update next
			if( next == pmq->waiter_bottom )
					break;
			next--;
			if( next < 0 )
				next = 1023;
		}
		if( !found )
		{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
			lprintf( WIDE("Found nothing of interest.  Empty queue.") );
#endif
			pmq->waiter_bottom = pmq->waiter_top;
		}
		else if( marked )
		{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
			lprintf( WIDE("Moving final into last position, and updating bottom to %d"), tmp_bottom );
#endif
			pmq->waiters[tmp] = pmq->waiters[next];
			pmq->waiter_bottom = (uint32_t)tmp_bottom;
		}
	}
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	lprintf( WIDE("And then after moving waiters forward....") );
	DumpWaiterQueue( pmq );
#endif
}
//--------------------------------------------------------------------------
static int ScanForWaiting( PMSGQUEUE pmq, long msg )
{
	int nWoken = 0;
	INDEX tmp = pmq->waiter_bottom;
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	lprintf( WIDE("before Scanning waiting on %s"), pmq->name );
	DumpWaiterQueue( pmq );
#endif
	while( tmp != pmq->waiter_top )
	{
		if( pmq->waiters[tmp].me )
		{
			// if waiting for any message....
			// or waiting for the exact message... and it is that message
			// or waiting for any other message... and it's not the message...
			if( !pmq->waiters[tmp].msg ||
				( (msg & 0x80000000)
				 ? (pmq->waiters[tmp].msg != (msg & 0x7FFFFFFF))
				 : (pmq->waiters[tmp].msg == msg) ) )
			{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				lprintf( WIDE("Wake thread %016Lx"), pmq->waiters[tmp].me );
#endif
				WakeThreadID( pmq->waiters[tmp].me );
				// reset the waiter ID... it's been
				// awoken, and is no longer waiting....
				pmq->waiters[tmp].me = 0;
				nWoken++;
				// go through all possible people who might wake up
				// because of this message... it's typically bad form
				// to have two or more processes watiing on the same ID...
			}
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
			else
			{
				lprintf( WIDE("Not waking thread %016Lx %08lx %08lx"), pmq->waiters[tmp].me
						 , msg, pmq->waiters[tmp].msg );
			}
#endif
		}
		tmp++;
		if( tmp >= 1024 )
			tmp = 0;
	}
	// now walk tmp backwards...
	// and move entried before the threads woken forward...
	// end up with a new bottom always (if having awoken something)
	if( nWoken )
	{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
		lprintf( WIDE("Scanning to delete messages that have been awoken.") );
#endif
		CollapseWaiting( pmq, 0 );
	}
	if( nWoken > 1 )
	{
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
		lprintf( WIDE("Woke %d threads as a result of message id %08lx"), nWoken, msg );
#endif
	}
	return 0;
}
//--------------------------------------------------------------------------
 int  EnqueMsgEx ( PMSGHANDLE pmh,  POINTER msg, size_t size, uint32_t opts DBG_PASS )
{
	if( pmh )
	{
		PMSGQUEUE pmq = pmh->pmq;
		INDEX tmp;
#ifndef DISABLE_MSGQUE_LOGGING
		int bNoSpace = 0;
#endif
		uint32_t realsize = (( size + (sizeof( MSGDATA ) ) ) + 3 ) & 0x7FFFFFFC;
		if( !pmq )
		{
			// errno = ENOSPACE; // or something....
 // cannot create this - no idea how big.
			return -1;
		}
		if( ( size > ( pmq->Size >> 2 ) )
			||( realsize > ( pmq->Size >> 2 ) ) )
		{
			//errno = E2BIG;
 // message is too big for this queue...
			return -1;
		}
		// probably someday need an error variable of
		// some sort or another...
#ifndef DISABLE_MSGQUE_LOGGING
		_xlprintf(3 DBG_RELAY)( WIDE("Enque space left...raw: %") _size_f WIDE(" %") _size_f WIDE(" Avail: %") _size_f WIDE(" %") _size_f WIDE(" used: %") _size_f WIDE(" %") _size_f WIDE(" %d")
				 , pmq->Top, pmq->Bottom
				 , pmq->Bottom-pmq->Top, pmq->Size-pmq->Top + pmq->Bottom
				 , pmq->Top-pmq->Bottom, pmq->Size-pmq->Bottom + pmq->Top
				 , realsize );
		_xlprintf(3 DBG_RELAY)( WIDE("[%s] ENqueMessage [%p] %ld len %") _MsgID_f WIDE(" %08") _32fx WIDE(""), pmq->name, pmq, *(MSGIDTYPE*)msg, size, *(uint32_t*)(pmq->data + pmq->Bottom) );
		//LogBinary( pmq->data + pmq->Bottom, 32 );
#endif
		while( msg )
		{
			int nWaiting;
			PMSGDATA pStoreMsg;
			EnterCriticalSec( &pmq->cs  );
			pStoreMsg = (PMSGDATA)(pmq->data + pmq->Top);
			SetPosI( tmp, pmq->Top + realsize );
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
			lprintf( "pStoreMsg = %p, %d %d", pStoreMsg, pmq->Top, tmp );
#endif
			if( tmp == (pmq->Size) )
			{
				// space is exactly what we need.
				pStoreMsg->msg.ttl = timeGetTime() + pmh->default_ttl;
				pStoreMsg->msg.real_length = (uint32_t)size;
				pStoreMsg->msg.length = realsize | MARK_END_OF_QUE | (( opts & MSGQUE_WAIT_ID )?MARK_THREAD_WAITING:0 );
#ifndef DISABLE_MSGQUE_LOGGING
				lprintf( WIDE("New tmp will be 0.") );
#endif
				SetPos( tmp, 0 );
			}
			else
			{
				if( tmp >= ( pmq->Size - sizeof( MSGDATA ) ) )
				{
					// okay - this message is too big to fit here...
					// going to have to store at start, or I suppose whenever the
					// queue has enough space...
#ifndef DISABLE_MSGQUE_LOGGING
					lprintf( WIDE("space left is not big enough for the message... %") _size_f WIDE(" %") _size_f WIDE(" %") _size_f WIDE(" %") _size_f WIDE("")
							 , pmq->Top, pmq->Bottom, pmq->Bottom-pmq->Top, pmq->Size-pmq->Top + pmq->Bottom );
#endif
					if( ( pmq->Bottom == 0 ) ||
						( pmq->Bottom <= size ) )
					{
						// Need to wait for some space...
						LeaveCriticalSec( &pmq->cs );
						if( opts & MSGQUE_NOWAIT )
						{
							//errno = EAGAIN;
							return -1;
						}
#ifndef DISABLE_MSGQUE_LOGGING
						lprintf( WIDE("bottom isn't far enough away either. Waiting for space") );
#endif
 // someone's gotta run and take their message.
						Relinquish();
						continue;
					}
#ifndef DISABLE_MSGQUE_LOGGING
					lprintf( WIDE("Setting step to origin in length, going to origin, setting data %p"), pStoreMsg );
#endif
					// 0 data length, marked end, just junk...
					// okay there, and it's deleted, so noone can read it
					// even if they want a zero byte message :)
					pStoreMsg->msg.length = MARK_END_OF_QUE|MARK_MESSAGE_ALREADY_READ;
					// tmp needs to point to the next top.
					SetPos( tmp, realsize );
					pStoreMsg = (PMSGDATA)pmq->data;
					lprintf( WIDE("pStoreMsg = %p, %") _size_f, pStoreMsg, pmq->Top );
				}
				else
				{
					// this is the size of this msg... we can store
					// and there IS room for another message header of
					// at least 0 bytes at the end.
					if( tmp > pmq->Bottom && pmq->Top < pmq->Bottom )
					{
						lprintf( WIDE("No room left in queue...") );
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
						DumpMessageQueue( pmq );
#endif
						LeaveCriticalSec( &pmq->cs );
						Relinquish();
 // try again from the top...
						continue;
					}
				}
				pStoreMsg->msg.ttl = timeGetTime() + pmh->default_ttl;
				lprintf( WIDE( "Send Message TTL Expired in queue... %d %d %d" ), pStoreMsg->msg.ttl, pmh->default_ttl );
				pStoreMsg->msg.real_length = (uint32_t)size;
				pStoreMsg->msg.length = realsize | (( opts & MSGQUE_WAIT_ID )?MARK_THREAD_WAITING:0 );
			}
			if( tmp == pmq->Bottom )
			{
#ifndef DISABLE_MSGQUE_LOGGING
				bNoSpace = 1;
				lprintf( WIDE("Head would collide with tail...") );
#endif
				LeaveCriticalSec( &pmq->cs );
				if( opts & MSGQUE_NOWAIT )
				{
					//errno = EAGAIN;
					return -1;
				}
#ifndef DISABLE_MSGQUE_LOGGING
				lprintf( WIDE("Waiting for space") );
#endif
 // someone's gotta run and take their message.
				Relinquish();
				continue;
			}
			else
			{
#ifndef DISABLE_MSGQUE_LOGGING
				if( bNoSpace )
					lprintf( WIDE("Okay there's space now...") );
#endif
			}
			MemCpy( &pStoreMsg->MsgID, msg, size + sizeof( pStoreMsg->MsgID ) );
#ifndef DISABLE_MSGQUE_LOGGING
			lprintf( WIDE("[%s] Stored message data..... at %") _size_f WIDE(" %") _size_f WIDE(""), pmq->name, pmq->Top ,size );
#  ifndef DISABLE_MSGQUE_LOGBINARY
			LogBinary( (uint8_t*)pStoreMsg, size + sizeof( pStoreMsg->MsgID ) + offsetof( MSGDATA, MsgID ) );
#  endif
#endif
			msg = NULL;
#ifndef DISABLE_MSGQUE_LOGGING
			lprintf( WIDE("Update top to %") _size_f,tmp );
#endif
			pmq->Top = tmp;
			if( !(opts & MSGQUE_WAIT_ID) )
			{
				// look for, and wake anyone waiting for this
				// type of message... or anyone waiting on any message
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				lprintf( WIDE("not sending a wait, therefore scan for messages...") );
#endif
				nWaiting = ScanForWaiting( pmq, pStoreMsg->MsgID );
				LeaveCriticalSec( &pmq->cs );
				if( nWaiting )
					Relinquish();
			}
			else
			{
				//lprintf( WIDE("Okay then we leave here?") );
				LeaveCriticalSec( &pmq->cs );
			}
		}
		// return success
		return 0;
	}
	// errno = EINVAL;
 // fail if no pmh
	return -1;
}
	//--------------------------------------------------------------------------
int IsMsgQueueEmpty ( PMSGHANDLE pmh )
{
	PMSGQUEUE pmq = pmh->pmq;
	if( !pmq || ( pmq->Bottom == pmq->Top ) )
		return TRUE;
	return FALSE;
}
//--------------------------------------------------------------------------
// if this thread id known, you may change the MsgID
// being waited for, which will result in this waking up
// and reading for the new ID...
int DequeMsgEx ( PMSGHANDLE pmh, long *MsgID, POINTER result, size_t size, uint32_t options DBG_PASS )
{
	PMSGQUEUE pmq = pmh->pmq;
	int p;
	int slept = 0;
	INDEX tmp
		, _tmp
	;
	uint32_t now = timeGetTime();
	INDEX _Bottom, _Top;
	//uint64_t tick, tick2;
	if( !pmq )
		return 0;
	// if there's a read routine, this should not be called.
	// instead the routine to handle
	p = 0;
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	_xlprintf(3 DBG_RELAY)( WIDE("[%s] Enter dequeue... for %") _32f WIDE(""), pmq->name, MsgID?*MsgID:0 );
#endif
	EnterCriticalSec( &pmq->cs );
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
	_xlprintf(3 DBG_RELAY)( WIDE("Deque space left... Top:%d Bottom:%d Avail: %d %d used: %d %d")
			 , pmq->Top, pmq->Bottom
			 , pmq->Bottom-pmq->Top, pmq->Size-pmq->Top + pmq->Bottom
			 , pmq->Top-pmq->Bottom, pmq->Size-pmq->Bottom + pmq->Top );
#endif
	_Bottom = INVALID_INDEX;
	_Top = INVALID_INDEX;
	while( !p && !slept )
	{
		PTHREADMSGDATA pThreadMsg = NULL;
		PMSGDATA pReadMsg;
		PMSGDATA pLastReadMsg;
		_tmp = tmp = pmq->Bottom;
		//lprintf( WIDE("tmp = %d"), tmp );
		if( !(options & MSGQUE_NOWAIT) )
		{
			long LastMsgID = *MsgID;
			// then here we must wait...
			// if the queue is empty, or we've already
			// checked the queue, go to sleep.
			while( ( ((_tmp = tmp),(tmp=pmq->Bottom)) == pmq->Top ||
					(pmq->Bottom == _Bottom &&
					pmq->Top == _Top )) && !slept )
			{
				//lprintf( WIDE("no message, waiting...") );
				{
					uint32_t tmp_top = pmq->waiter_top + 1;
					if( tmp_top >= 1024 )
						tmp_top = 0;
#if 0
					// do a scan to see if already waiting...
					// but since we're single process... there may be multipel threads
					// interacting here?  one on the server side reading, one on the client
					// but still only one ID for that queue should be waiting for
					// any specific message....
					// not sure why this doesn't work to avoid redundant wakeups
					tmp_top = pmq->waiter_bottom;
					while( tmp_top != pmq->waiter_top )
					{
						//lprintf( WIDE("Checking %d msg:%d"), tmp_top, pmq->waiters[tmp_top].msg );
						if( pmq->waiters[tmp_top].msg == *MsgID )
						{
							//lprintf( WIDE("waiting... leave...") );
							break;
						}
						tmp_top++;
						if( tmp_top >= 1024 )
							tmp_top = 0;
					}
#else
					tmp_top = pmq->waiter_top;
#endif
					// if waiter for message is already registered...
					// do not mark him.
					if( tmp_top == pmq->waiter_top )
					{
						tmp_top++;
						if( tmp_top >= 1024 )
							tmp_top = 0;
						if( tmp_top != pmq->waiter_bottom )
						{
							pmq->waiters[pmq->waiter_top].me = GetMyThreadID();
							pmq->waiters[pmq->waiter_top].msg = *MsgID;
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
							lprintf( WIDE("New waiter - waiting for %016") _64fX WIDE(" %") _32f WIDE("")
									 , pmq->waiters[pmq->waiter_top].me
									 , pmq->waiters[pmq->waiter_top].msg );
#endif
							pmq->waiter_top = tmp_top;
						}
						else
						{
							lprintf( WIDE("CRITICAL ERROR - No space to mark this process to wait.") );
							Relinquish();
							continue;
						}
					}
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
					else
						lprintf( WIDE("Already waiting...") );
					DumpWaiterQueue( pmq );
#endif
				}
				LeaveCriticalSec( &pmq->cs );
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				lprintf( WIDE("(left section) sleeping until message (%016Lx)")
						 , GetMyThreadID() );
#endif
				// if someone wakes wakeable sleep - either a> there's a new message
				// or b> someone wants to wakeup a process from Idle()... and we need to return
				slept = 1;
				WakeableSleep( SLEEP_FOREVER );
				// remove wait message...
#ifndef DISABLE_MSGQUE_LOGGING_DETAILED
				lprintf( WIDE("Re-enter critical section here...(%016Lx)")
						 , GetMyThreadID() );
#endif
				EnterCriticalSec( &pmq->cs );
				CollapseWaiting( pmq, LastMsgID );
				if( (*MsgID) == 0xFFFFFFFF )
				{
					lprintf( WIDE( "Aborting waiting read..." ) );
					SetLastError( MSGQUE_ERROR_EABORT );
					break;
				}
				//pmq->waiting = prior;
			}
#ifndef DISABLE_MSGQUE_LOGGING
			//lprintf( WIDE("Fetching a message...") );
#endif
			now = timeGetTime();
		}
		else
		{
			// if the queue is empty, then result now with no message.
			if( tmp == pmq->Top )
			{
#ifndef DISABLE_MSGQUE_LOGGING
				lprintf( WIDE("[%s] NOWAIT option selected... resulting NOMSG."), pmq->name );
#endif
				SetLastError( MSGQUE_ERROR_NOMSG );
				LeaveCriticalSec( &pmq->cs );
				return -1;
			}
		}
#ifndef DISABLE_MSGQUE_LOGGING
		_xlprintf( 1 DBG_RELAY )( WIDE("------- tmp = %") _size_f WIDE(" bottom=%") _size_f WIDE(" top = %") _size_f WIDE(" ------"), tmp, pmq->Bottom, pmq->Top );
#endif
		pLastReadMsg = NULL;
		while( tmp != pmq->Top )
		{
			// after returning a message, the next should be checked
			// 2 conditions - if the length == MARK_END_OF_QUE or
			// length & 0x40000000 then the next message needs to
			// be consumed until said condition is not set.
			pReadMsg = (PMSGDATA)(pmq->data + tmp);
#ifndef DISABLE_MSGQUE_LOGGING
			//lprintf( WIDE("Check for a message at %d (%08lx)"), tmp, pReadMsg->msg.length );
			//LogBinary( (POINTER)pReadMsg, pReadMsg->msg.real_length + sizeof( pReadMsg->MsgID ) + sizeof( MSGDATA ));
#endif
			if( pReadMsg->msg.ttl < now )
			{
				lprintf( WIDE("Message TTL Expired in queue... %d %d %d"), pReadMsg->msg.ttl, now, now - pReadMsg->msg.ttl );
				LogBinary( (uint8_t*)pReadMsg, pReadMsg->msg.length & ACTUAL_LEN_MASK );
				pReadMsg->msg.length |= MARK_MESSAGE_ALREADY_READ;
			}
			if( pReadMsg->msg.length & MARK_MESSAGE_ALREADY_READ )
			{
#ifndef DISABLE_MSGQUE_LOGGING
				//lprintf( WIDE("Message has already been read...") );
#endif
				if( tmp == pmq->Bottom )
				{
					if( pReadMsg->msg.length & MARK_END_OF_QUE )
					{
						SetPos( tmp, 0 );
						pmq->Bottom = tmp;
					}
					else
					{
						UpdatePos( tmp, pReadMsg->msg.length & ACTUAL_LEN_MASK );
						pmq->Bottom = tmp;
					}
				}
				else
				{
					// next is start.
					if( pReadMsg->msg.length & MARK_END_OF_QUE )
					{
#ifndef DISABLE_MSGQUE_LOGGING
						lprintf( WIDE("Looking for a message %") _size_f WIDE("...at %") _size_f WIDE(" haven't found one yet. (%") _size_f WIDE(")"), *MsgID, tmp, (pReadMsg->msg.length + sizeof( MSGCORE )) & ACTUAL_LEN_MASK );
#endif
						SetPos( tmp, 0 );
					}
					else
					{
#ifndef DISABLE_MSGQUE_LOGGING
						lprintf( WIDE("Looking for a message %") _size_f WIDE("...at %") _size_f WIDE(" haven't found one yet. (%") _size_f WIDE(")"), *MsgID, tmp, (pReadMsg->msg.length + sizeof( MSGCORE )) & ACTUAL_LEN_MASK );
#  ifndef DISABLE_MSGQUE_LOGBINARY
						LogBinary( (uint8_t*)pReadMsg, (pReadMsg->msg.length + sizeof( MSGCORE )) & ACTUAL_LEN_MASK );
#  endif
#endif
						UpdatePos( tmp, pReadMsg->msg.length & ACTUAL_LEN_MASK );
					}
				}
				// skip messages already read. (and/or throw them out
				// by updating bottom, we remove them from the queue
				// with no further consideration.
				if( pLastReadMsg && ( pLastReadMsg->msg.length & MARK_MESSAGE_ALREADY_READ ) )
				{
					lprintf( WIDE("Collapsing two already read messages prior length was %") _32f WIDE("(%") _size_f WIDE(") and %")_32f WIDE("(%") _size_f WIDE(") (%s)")
							 , pLastReadMsg->msg.length& ACTUAL_LEN_MASK
							 , (uintptr_t)pLastReadMsg-(uintptr_t)pmq->data
							 , pReadMsg->msg.length& ACTUAL_LEN_MASK
							 , (uintptr_t)pReadMsg-(uintptr_t)pmq->data
							 , (pReadMsg->msg.length&MARK_END_OF_QUE)?WIDE("end"):WIDE("") );
						// prior message was read; collapse this one into it.
					pLastReadMsg->msg.length |= (pReadMsg->msg.length & MARK_END_OF_QUE);
					pLastReadMsg->msg.length += (pReadMsg->msg.length & ACTUAL_LEN_MASK);
					lprintf( WIDE("Result in %")_32f WIDE(" %p   (tmp is %") _size_f WIDE(",t:%") _size_f WIDE(",b:%") _size_f WIDE(")"), pLastReadMsg->msg.length & ACTUAL_LEN_MASK
						, (POINTER)((uintptr_t)pmq->data + (pLastReadMsg->msg.length & ACTUAL_LEN_MASK))
						, tmp
						, pmq->Top
						, pmq->Bottom
						);
				}
				else
					pLastReadMsg = pReadMsg;
				continue;
			}
			// just looped around to kill deleted messages.
			if( p )
				break;
			if( pReadMsg->msg.length & MARK_THREAD_WAITING )
			{
#ifndef DISABLE_MSGQUE_LOGGING
				lprintf( WIDE("A thread is waiting message...") );
#endif
				// skip these... don't care on read?
				// well maybe we care if this is the
				// wait message of me, in which case I can
				// clean it up. It's likely the first message
				// in the queue when I get awoke, it may be
				// early - but all other near messages will
				// likely also be thread wakes...
				if( ((PTHREADMSGDATA)pReadMsg)->thread == GetMyThreadID() )
				{
					// retest this current message as already read.
#ifndef DISABLE_MSGQUE_LOGGING
					lprintf( WIDE("And it's the message that denoted *I* was waiting... delete please") );
#endif
					if( tmp != pmq->Bottom )
					{
						PTHREADMSGDATA pTmpMsg = (PTHREADMSGDATA)(pmq->data + pmq->Bottom);
						if( pTmpMsg->msgdata.msg.length & MARK_THREAD_WAITING )
						{
							((PTHREADMSGDATA)pReadMsg)->thread = pTmpMsg->thread;
							((PTHREADMSGDATA)pReadMsg)->msgdata.MsgID = pTmpMsg->msgdata.MsgID;
							lprintf( WIDE("Mark message as having been read( should be a temporary wait message...") );
							pTmpMsg->msgdata.msg.length |= MARK_MESSAGE_ALREADY_READ;
						}
						else
						{
							lprintf( WIDE("First message in queue is not a thread wait?!") );
							pReadMsg->msg.length |= MARK_MESSAGE_ALREADY_READ;
						}
					}
					else
					{
						lprintf( WIDE("Mark message as having been read( should be a temporary wait message...") );
						pReadMsg->msg.length |= MARK_MESSAGE_ALREADY_READ;
					}
					// and now move forward still...
					UpdatePos( tmp, pReadMsg->msg.length & ACTUAL_LEN_MASK );
					pLastReadMsg = pReadMsg;
					continue;
				}
				if( !pThreadMsg )
				{
					pThreadMsg = (PTHREADMSGDATA)pReadMsg;
				}
				else
				{
					// concatentate this new one in the old one.
					// assuming there's space...
				}
				UpdatePos( tmp, pReadMsg->msg.length & ACTUAL_LEN_MASK );
				pLastReadMsg = pReadMsg;
				continue;
			}
			if( !(*MsgID) || ( pReadMsg->MsgID == (*MsgID) ) )
			{
				if( size > ( pReadMsg->msg.length & ACTUAL_LEN_MASK ) )
				{
					MemCpy( result
							, &pReadMsg->MsgID
							, pReadMsg->msg.real_length + sizeof( pReadMsg->MsgID ) );
					p = pReadMsg->msg.real_length;
#ifndef DISABLE_MSGQUE_LOGGING
					lprintf( WIDE("DequeMessage [%p] %")_MsgID_f WIDE(" len %") _size_f , result, *(MSGIDTYPE*)result, p+sizeof( pReadMsg->MsgID ) );
#  ifndef DISABLE_MSGQUE_LOGBINARY
					LogBinary( (uint8_t*)result, p+sizeof( pReadMsg->MsgID ) );
#  endif
#endif
					pReadMsg->msg.length |= MARK_MESSAGE_ALREADY_READ;
				}
				else
				{
#ifdef __LINUX__
					errno = E2BIG;
#endif
					return -1;
				}
				//lprintf( WIDE("...") );
 // reprocess this mesage...
				continue;
			}
			else if( *MsgID )
			{
#ifndef DISABLE_MSGQUE_LOGGING
				lprintf( WIDE("Looking for a message %")_MsgID_f WIDE("...at %") _size_f WIDE(" haven't found one yet."), *MsgID, tmp );
#  ifndef DISABLE_MSGQUE_LOGBINARY
				LogBinary( (uint8_t*)pReadMsg, (pReadMsg->msg.length + sizeof( MSGCORE )) & ACTUAL_LEN_MASK );
#  endif
#endif
				pLastReadMsg = pReadMsg;
				if( pReadMsg->msg.length & MARK_END_OF_QUE )
				{
					SetPos( tmp, 0 );
					pLastReadMsg = NULL;
				}
				else
					UpdatePos( tmp, ( pReadMsg->msg.length & ACTUAL_LEN_MASK ) );
				continue;
			}
		}
		if( !p )
		{
#ifndef DISABLE_MSGQUE_LOGGING
			lprintf( WIDE("No message found... looping...") );
#endif
			if( options & MSGQUE_NOWAIT )
			{
				lprintf( WIDE("Retunign - not looping...err uhh...") );
				SetLastError( MSGQUE_ERROR_NOMSG );
				LeaveCriticalSec( &pmq->cs );
				return -1;
			}
			_Bottom = pmq->Bottom;
			_Top = pmq->Top;
		}
	}
	LeaveCriticalSec( &pmq->cs );
	if( !p )
	{
		SetLastError( MSGQUE_ERROR_NOMSG );
		return -1;
	}
	return p;
}
#ifdef __cplusplus
 //	namespace message {
};
 // namespace containers {
};
 //namespace sack {
};
#endif
#define DEFINE_MESSAGE_SERVER_GLOBAL
#ifdef __QNX__
#define USE_SACK_MSGQ
#endif
#define ENABLE_GENERAL_USEFUL_DEBUGGING
#ifdef ENABLE_GENERAL_USEFUL_DEBUGGING
//#define DEBUG_THREAD
#define LOG_LOCAL_EVENT
//#define DEBUG_RU_ALIVE_CHECK
//#define DEBUG_HANDLER_LOCATE
#define LOG_SENT_MESSAGES
// event messages need to be enabled to log event message data...
#define DEBUG_DATA_XFER
#define DEBUG_SERVICE_INPUT
//#define NO_LOGGING
/// show event messages...
#define DEBUG_EVENTS
#define DEBUG_OUTEVENTS
/// attempt to show the friendly name for messages handled
#define LOG_HANDLED_MESSAGES
#define DEBUG_MESSAGE_BASE_ID
#define _DEBUG_RECEIVE_DISPATCH_
//#define DEBUG_THREADS
//#define DEBUG_MSGQ_OPEN
#endif
#ifdef __LINUX__
// ipc sysv msgque (msgget,msgsnd,msgrcv)
#ifdef __ANDROID__
#  include <linux/ipc.h>
#  include <linux/msg.h>
#else
#  ifndef USE_SACK_MSGQ
#    include <sys/ipc.h>
#    include <sys/msg.h>
#  endif
#endif
#define MSGTYPE (struct msgbuf*)
#else
#define MSGTYPE
#endif
#ifndef SERVER_MESSAGE_INTERFACE
#define SERVER_MESSAGE_INTERFACE
#ifdef BCC16
# ifdef SERVERMSG_SOURCE
# define SERVERMSG_PROC(type,name) type STDPROC _export name
# else
# define SERVERMSG_PROC(type,name) type STDPROC name
# endif
#else
# ifdef SERVERMSG_SOURCE
# define SERVERMSG_PROC(type,name) EXPORT_METHOD type CPROC name
# else
# define SERVERMSG_PROC(type,name) IMPORT_METHOD type CPROC name
# endif
#endif
#ifdef __cplusplus
#define _SERVER_NAMESPACE namespace server {
#define MSGSERVER_NAMESPACE namespace sack { namespace msg { namespace server {
#define MSGSERVER_NAMESPACE_END }} }
#else
#define _SERVER_NAMESPACE
#define MSGSERVER_NAMESPACE
#define MSGSERVER_NAMESPACE_END
#endif
SACK_NAMESPACE
   _MSG_NAMESPACE
/* Defines methods and events that the service side might want
   to use.                                                     */
	_SERVER_NAMESPACE
#ifdef _DEBUG
 // 2 seconds
#define CLIENT_TIMEOUT   120000
#else
#define CLIENT_TIMEOUT   2000
#endif
/* User callback signature to return the function callback table
   to the server for event dispatch to a service (?) (INTERNAL?) */
typedef int (CPROC *GetServiceFunctionTable)(server_function_table *ppTable
												  ,uint32_t *nEntries
												  ,uint32_t MsgBase);
#ifndef CLIENT_MESSAGE_INTERFACE
#ifndef CLIENTMSG_SOURCE
// now - is there some magic to allow libraries to link to
// the core application?? - this is in the server's core
// and is access by the services it loads.
SERVERMSG_PROC(int, SendMultiServiceEvent)( uint32_t pid, uint32_t event
								 , uint32_t parts
								 , ... );
/* <combine sack::msg::client::SendMultiServiceEvent@uint32_t@uint32_t@uint32_t@...>
   \ \                                                                */
#define SendServiceEvent(pid,event,data,len) SendMultiServiceEvent(pid,event,1,data,len)
//void SendServiceEvent( uint32_t pid, uint32_t event, uint32_t *data, uint32_t len );
#endif
#endif
MSGSERVER_NAMESPACE_END
#ifdef __cplusplus
using namespace sack::msg::server;
#endif
#endif
// $Log: msgserver.h,v $
// Revision 1.11  2005/05/12 21:12:50  jim
// Merge process_service_branch into trunk development.
//
// Revision 1.10.2.1  2005/05/02 17:01:08  jim
// Nearly works... time to move over to linux... still need some cleanup on exits... and dead clients.
//
// Revision 1.10  2003/10/28 01:14:34  panther
// many changes to implement msgsvr on windows.  Even to get displaylib service to build, there's all sorts of errors in inconsistant definitions...
//
// Revision 1.9  2003/09/21 11:49:04  panther
// Fix service refernce counting for unload.  Fix Making sub images hidden.
// Fix Linking of services on server side....
// cleanup some comments...
//
// Revision 1.8  2003/03/25 08:38:11  panther
// Add logging
//
MSGCLIENT_NAMESPACE
#define MSG_DEFAULT_RESULT_BUFFER_MAX (sizeof( uint32_t ) * 16384)
#ifdef  _DEBUG
 // standard transaction timout
#define DEFAULT_TIMEOUT 300000
#else
 // standard transaction timout
#define DEFAULT_TIMEOUT 500
#endif
#if defined( _WIN32 ) || defined(USE_SACK_MSGQ)
#ifdef _MSC_VER
#undef errno
#define errno GetLastError()
#endif
#define MSGQ_TYPE PMSGHANDLE
#else
#define MSGQ_TYPE int
#endif
typedef PREFIX_PACKED struct message_header_tag
{
// internal message information
	// transportable across messsage queues or networks
   SERVICE_ENDPOINT source;
	uint32_t msgid;
// #define MSGDATA( msghdr ) ( (&msghdr.sourceid)+1 )
} PACKED MSGHDR;
typedef PREFIX_PACKED struct full_message_header_tag
{
	SERVICE_ENDPOINT dest;
	MSGHDR hdr;
#define QMSGDATA( qmsghdr ) ((uint32_t*)( (qmsghdr)+1 ))
	//uint32_t data[];
} PACKED QMSG;
// these are client structures
// services which are loaded result in the creation
// of a handler device.
typedef struct ServiceEventHandler_tag EVENTHANDLER, *PEVENTHANDLER;
struct ServiceEventHandler_tag
{
	DeclareLink( EVENTHANDLER );
	struct {
		BIT_FIELD dispatched : 1;
		BIT_FIELD notify_if_dispatched : 1;
		BIT_FIELD destroyed : 1;
		BIT_FIELD local_service : 1;
	} flags;
	// when receiving messages from the application...
	// this is the event base which it will give me...
	// it is also the unique routing ID
	// my list will be built from the sum of all services
	// connected to, and the number of MsgCount they claim to have..
	SERVICE_ROUTE RouteID;
	THREAD_ID EventID;
	// destination address of this service's
	// messages...
	EventHandlerFunction Handler;
	EventHandlerFunctionEx HandlerEx;
	EventHandlerFunctionExx HandlerExx;
	uintptr_t psv;
	// this handler's events come from this queue.
	MSGQ_TYPE msgq_events;
	////CRITICALSECTION csMsgTransact;
	// timeout on this local handler's reception of a responce.
	TEXTSTR servicename;
};
typedef struct ServiceTransactionHandler_tag TRANSACTIONHANDLER, *PTRANSACTIONHANDLER;
struct ServiceTransactionHandler_tag
{
	DeclareLink( TRANSACTIONHANDLER );
	struct {
		BIT_FIELD waiting_for_responce : 1;
		BIT_FIELD responce_received : 1;
		BIT_FIELD bCheckedResponce : 1;
	} flags;
  // the handler this transaction belongs to.
	PEVENTHANDLER transaction_for_handler;
	PSERVICE_ROUTE route;
	CRITICALSECTION csMsgTransact;
	// timeout on this local handler's reception of a responce.
	uint32_t wait_for_responce;
 // last outbound resquest - which is waiting for a responce
	MSGIDTYPE LastMsgID;
 // address of the reply message ID
	MSGIDTYPE *MessageID;
	POINTER msg;
	size_t *len;
	uint32_t last_check_tick;
	PQMSG MessageIn;
	size_t MessageLen;
};
// registration of a service results in a new
// CLIENT_SERVICE structure.  Messages are received
// from clients, and dispatched.. ..
// Just like clients, services also support events...
typedef struct service_tag
{
	struct {
		BIT_FIELD bRegistered : 1;
		BIT_FIELD bFailed : 1;
		BIT_FIELD connected : 1;
		BIT_FIELD bMasterServer : 1;
		BIT_FIELD bWaitingInReceive : 1;
		BIT_FIELD bClosed : 1;
	} flags;
	GetServiceFunctionTable GetFunctionTable;
	server_function_table functions;
	server_message_handler handler;
	server_message_handler_ex handler_ex;
	uintptr_t psv;
	uint32_t entries;
	uint32_t references;
  // this is a static route that goes to the message server.
	SERVICE_ROUTE route;
  // when registered this is our ID for later message handler resolution
	MSGIDTYPE ServiceID;
	TEXTCHAR *name;
	PTHREAD thread;
	//uint32_t pid_me; // these pids should be phased out, and given an ID from msgsvr.
 // these are clients that are connected to this service
	PLIST service_routes;
	PQMSG recv;
	PQMSG result;
	DeclareLink( struct service_tag );
} CLIENT_SERVICE, *PCLIENT_SERVICE;
// PEVENTHANDLER creation also results in the creation of one of these...
// this allows the ProbeClientAlive to work correctly...
// then on the server side, when the service is loaded, one of these is
// created... allowing the server to monitor client connectivity.
typedef struct service_client_tag
{
   SERVICE_ROUTE route;
	//uint32_t pid; // process only? no thread?
	uint32_t last_time_received;
	struct {
		BIT_FIELD valid : 1;
 // uhmm - something like got a message from this but it wasn't known
		BIT_FIELD error : 1;
		BIT_FIELD status_queried : 1;
 // created to track connection from client to service...
		BIT_FIELD is_service : 1;
	} flags;
	PLIST services;
	PEVENTHANDLER handler;
	DeclareLink( struct service_client_tag );
} SERVICE_CLIENT, *PSERVICE_CLIENT;
typedef  struct sleeper_tag
{
	PTHREAD thread;
   PTRANSACTIONHANDLER handler;
} SLEEPER, *PSLEEPER;
#define MAXBUFFER_LENGTH_PAIRSPERSET 256
/* use a small local pool of these instead of allocate/release */
/* this high-reuse area just causes fragmentation */
DeclareSet( BUFFER_LENGTH_PAIR );
#if defined( _WIN32 ) || defined( USE_SACK_MSGQ )
#define IPC_NOWAIT MSGQUE_NOWAIT
#ifndef ENOMSG
#define ENOMSG MSGQUE_ERROR_NOMSG
#endif
#ifndef EINTR
#define EINTR -1
#endif
#ifndef EIDRM
#define EIDRM -2
#endif
#ifndef EINVAL
#define EINVAL -3
#endif
#ifndef E2BIG
#define E2BIG -4
#endif
#ifndef EABORT
#define EABORT MSGQUE_ERROR_EABORT
#endif
#define DEBUG_DATA_XFER
#ifdef DEBUG_DATA_XFER
#  define msgsnd( q,msg,len,opt) ( _lprintf(DBG_RELAY)( WIDE("Send Message...%d %d"), len, len+4 ), LogBinary( (uint8_t*)msg, (len)+4  ), EnqueMsg( q,(msg),(len),(opt)) )
#else
#  define msgsnd(a,b,c,d) EnqueMsg((PMSGHANDLE)a,b,c,d)
#endif
	#define msgrcv(q,m,sz,id,o) DequeMsg((PMSGHANDLE)q,&id,m,sz,o)
	#define MSGQSIZE 32768
	#define IPC_CREAT  1
	#define IPC_EXCL	2
#define msgget(name,n,opts) ( (opts) & IPC_CREAT )			? ( ( (opts) & IPC_EXCL)										    ? ( SackOpenMsgQueue( name, NULL, 0 )								 ? (MSGQ_TYPE)MSGFAIL															  : SackCreateMsgQueue( name, MSGQSIZE, NULL, 0 ))		    : SackCreateMsgQueue( name, MSGQSIZE, NULL, 0 ))			 : SackOpenMsgQueue( name, NULL, 0 )
	//#define msgget(name,n,opts ) CreateMsgQueue( name, MSGQSIZE, NULL, 0 )
	#define msgctl(n,o,f)
	#define MSGFAIL NULL
#else
#ifdef DEBUG_DATA_XFER
	//#define msgsnd( q,msg,len,opt) ( _xlprintf(1 DBG_RELAY)( WIDE("Send Message...") ), LogBinary( (POINTER)msg, (len)+4  ), msgsnd( q,(msg),(len),(opt)) )
	#define msgsnd( q,msg,len,opt) ( lprintf( WIDE("Send Message...") ), LogBinary( (uint8_t*)msg, (len)+4  ), msgsnd( q,(msg),(len),(opt)) )
#endif
	#define msgget( name,n,opts) msgget( n,opts )
	#define MSGFAIL -1
#endif
typedef struct global_message_service_tag
{
	struct {
		BIT_FIELD message_responce_handler_ready : 1;
		BIT_FIELD message_handler_ready : 1;
		BIT_FIELD failed : 1;
		BIT_FIELD events_ready : 1;
		BIT_FIELD local_events_ready : 1;
		BIT_FIELD disconnected : 1;
		//BIT_FIELD connected : 1;
		BIT_FIELD handling_client_message : 1;
		BIT_FIELD bAliveThreadStarted : 1;
		// enabled when my_message_id is resolved...
		BIT_FIELD connected : 1;
		BIT_FIELD bMasterServer : 1;
 // thread for service handling...
		BIT_FIELD bServiceHandlerStarted : 1;
 // thread for service handling...
		BIT_FIELD bCoreServiceHandlerStarted : 1;
 // set this when a valid server was found - dont' reset master id
		BIT_FIELD found_server : 1;
 // receive is waiting to get service input messages
		BIT_FIELD bWaitingInReceive : 1;
		BIT_FIELD bCoreServiceInputHandlerStarted : 1;
	} flags;
   // idenfitier for this process.  Messages from me, and to me reference this ID.
	MSGIDTYPE my_message_id;
	PLIST pSleepers;
			// handles messages on msgq_in (responce from service)
	PTHREAD pThread;
  // handles messages on msgq_out (request for service)
	PTHREAD pMessageThread;
	 // handles messages to msgq_event (client side events)
	PTHREAD pEventThread;
 // handles messages on msgq_local_event (client only internal events)
	PTHREAD pLocalEventThread;
	// these are client side connection managers.
   // for each service connected to, there is a handler.
	PEVENTHANDLER pHandlers;
	// these are for handling send/receive matched response things
   // maybe these are temporary based on PEVENTHANDLERs
   PTRANSACTIONHANDLER pTransactions;
	// this list is only populated in the master server.  This is all registered servers
   // Actually, this service list is also maintained in the registerant of the service.
	PCLIENT_SERVICE services;
	// these are tracked from...
   // clients have a pHandler in them.
	PSERVICE_CLIENT clients;
 // a static handler to cover communication with this library itself.
	EVENTHANDLER _handler;
	// this is the one waiting for a register service ack...
	// I won't have the ServiceID
	CRITICALSECTION csLoading;
	CRITICALSECTION csMsgTransact;
  // this is a static route that goes to the message server.
	SERVICE_ROUTE master_service_route;
	// id + 1 (thread 0)
	MSGQ_TYPE msgq_in;
  // id + 0 (thread 0)
	MSGQ_TYPE msgq_out;
// id + 2 (thread 1)
	MSGQ_TYPE msgq_event;
// id + 3 (thread 2 (or 1 if only local)
	MSGQ_TYPE msgq_local;
	PLINKQUEUE Messages;
	int pending;
} GLOBAL;
#ifdef g
#   undef g
#endif
#define g (*global_msgclient)
#ifndef DEFINE_MESSAGE_SERVER_GLOBAL
extern
#endif
GLOBAL *global_msgclient;
//-----  client_common.c -------
// register with amster is called as part of _InitMessageService...
void RegisterWithMasterService( void );
int _InitMessageService( int local );
void CPROC MonitorClientActive( uintptr_t psv );
void CloseMessageQueues( void );
void DropMessageBuffer( PQMSG msg );
PQMSG GetMessageBuffer( void );
//------ client_input.c -------
PTRANSACTIONHANDLER GetTransactionHandler( PSERVICE_ROUTE route );
//int GetAMessageEx( MSGQ_TYPE msgq, CTEXTSTR q, int flags DBG_PASS );
uintptr_t CPROC HandleMessages( PTHREAD thread );
int WaitReceiveServerMsg ( PSLEEPER sleeper
				, uint32_t MsgOut
					DBG_PASS );
int QueueWaitReceiveServerMsg ( PSLEEPER sleeper, PTRANSACTIONHANDLER handler
										  , MSGIDTYPE *MsgIn
										  , POINTER BufferIn
										  , size_t *LengthIn
											DBG_PASS );
//------ client_client.c ------
PSERVICE_CLIENT FindClient( PSERVICE_ROUTE pid );
//-----  client_event.c ---------
uintptr_t CPROC HandleEventMessages( PTHREAD thread );
int HandleEvents( MSGQ_TYPE msgq, PQMSG MessageEvent, int initial_flags );
//----- client_local.c -------
uintptr_t CPROC HandleLocalEventMessages( PTHREAD thread );
//----- client_service.c --------
int ReceiveServerMessageEx( PTRANSACTIONHANDLER handler, PQMSG MessageIn, size_t MessageLen DBG_PASS );
uintptr_t CPROC HandleServiceMessages( PTHREAD thread );
LOGICAL HandleCoreMessage( PQMSG msg, size_t msglen DBG_PASS );
MSGCLIENT_NAMESPACE_END
MSGCLIENT_NAMESPACE
//--------------------------------------------------------------------
PRIORITY_PRELOAD( LoadMsgClientGlobal, MESSAGE_CLIENT_PRELOAD_PRIORITY )
{
	SimpleRegisterAndCreateGlobal( global_msgclient );
	InitializeCriticalSec( &g.csMsgTransact );
	InitializeCriticalSec( &g.csLoading );
	//InitializeCriticalSec( &g._handler.csMsgTransact );
}
//--------------------------------------------------------------------
static void EndClient( PSERVICE_CLIENT client )
{
	// call the service termination function.
	PCLIENT_SERVICE service;
	INDEX idx;
	// for all services inform it that the client is defunct.
	Log( WIDE("Ending client (from death)") );
	if( client->flags.is_service )
	{
		lprintf( WIDE("Service is gone! please tell client...") );
		if( client->handler->Handler )
			client->handler->Handler( MSG_MateEnded, NULL, 0 );
		if( client->handler->HandlerEx )
			client->handler->HandlerEx( &client->handler->RouteID, MSG_MateEnded, NULL, 0 );
		if( client->handler->HandlerExx )
			client->handler->HandlerExx( client->handler->psv, &client->handler->RouteID, MSG_MateEnded, NULL, 0 );
		UnlinkThing( client->handler );
		Release( client->handler );
	}
	else
	{
		LIST_FORALL( client->services, idx, PCLIENT_SERVICE, service )
		{
			//lprintf( WIDE("Client had service... %p"), service );
			if( service->handler )
			{
				service->handler( &client->route, MSG_ServiceUnload
									 , NULL, 0
									 , NULL, NULL );
			}
			else if( service->handler_ex )
			{
				service->handler_ex( service->psv
										 , &client->route, MSG_ServiceUnload
										 , NULL, 0
										 , NULL, NULL );
			}
			else if( service->functions && service->functions[MSG_ServiceUnload].function )
			{
				uint32_t resultbuf[1];
				size_t resultlen = 4;
				service->functions[MSG_ServiceUnload].function( &client->route, NULL, 0
																			 , resultbuf, &resultlen );
			}
			//Log( WIDE("Ending service on client...") );
			// Use ungloadservice to signal server services of client loss...
			//if( !UnloadService( service->first_message_index, client->pid ) )
			//	Log( WIDE("Somehow unloading a known service failed...") );
		}
		DeleteList( &client->services );
		{
			static uint32_t msg[2048];
			int32_t len;
			//lprintf( "vvv" );
			while( (len=msgrcv( g.msgq_out, MSGTYPE msg, 8192, client->route.source.process_id, IPC_NOWAIT )) >= 0 )
				//	errno != ENOMSG )
				lprintf( WIDE("Flushed a message to dead client(%") _MsgID_f WIDE(",%") _32f WIDE(") from output (%08") _32fx WIDE(":%") _32fs WIDE(" bytes)")
						 , client->route.source.process_id
						 , msg[0]
						 , msg[1]
						 , len );
			//lprintf( "^^^" );
			//lprintf( "vvv" );
			while( msgrcv( g.msgq_event, MSGTYPE msg, 8192, client->route.source.process_id, IPC_NOWAIT ) >= 0 ||
					GetLastError() != ENOMSG )
				Log( WIDE("Flushed a message to dead client from event") );
			//lprintf( "^^^" );
		}
	}
	// delete the client.
	Log( WIDE("Finally unlinking the client...") );
	UnlinkThing( client );
	Release( client );
}
//--------------------------------------------------------------------
void CPROC MonitorClientActive( uintptr_t psv )
{
	// for all clients connected send an alive probe to see
	// if we can free their resources.
	PSERVICE_CLIENT client, next = g.clients;
	//const char *pFile = __FILE__;
	//int nLine = __LINE__;
#ifdef DEBUG_RU_ALIVE_CHECK
	Log( WIDE("Checking client alive") );
#endif
	// if am handling a message don't check alivenmess..
	if( !g.flags.handling_client_message )
	{
		while( ( client = next ) )
		{
			next = client->next;
#ifdef DEBUG_RU_ALIVE_CHECK
			lprintf( WIDE("Client %d(%p) last received %d ms ago"), client->pid, client, timeGetTime() - client->last_time_received );
#endif
			if( ( client->last_time_received + CLIENT_TIMEOUT ) < timeGetTime() )
			{
				Log( WIDE("Client has been silent +") STRSYM(CLIENT_TIMEOUT) WIDE("ms - he's dead. (maybe he unloaded and we forgot to forget him?!)") );
				EndClient( client );
			}
			else if( ( client->last_time_received + (CLIENT_TIMEOUT/2) ) <  timeGetTime() )
			{
				if( !client->flags.status_queried )
				{
					QMSG msg;
					//uint32_t msg[3];
#ifdef DEBUG_DATA_XFER
					DBG_VARSRC;
#endif
					//Log1( WIDE("Asking if client %d is alive"), client->pid );
					msg.dest.process_id            = client->route.dest.process_id;
					msg.dest.service_id            = client->route.dest.service_id;
					msg.hdr.source.process_id = client->route.source.process_id;
					msg.hdr.source.service_id = client->route.source.service_id;
					msg.hdr.msgid             = RU_ALIVE;
					client->flags.status_queried = 1;
#ifdef DEBUG_RU_ALIVE_CHECK
					lprintf( "Ask RU_ALIVE..." );
#endif
					msgsnd( g.msgq_in, MSGTYPE &msg, sizeof( msg ) - sizeof( MSGIDTYPE ), 0 );
				}
				else
				{
#ifdef DEBUG_RU_ALIVE_CHECK
					lprintf( "client has been queried for alivness..." );
#endif
				}
			}
			else
			{
				// hmm maybe a shorter timeout can happen...
			}
		}
	}
#if 0
	{
		PTRANSACTIONHANDLER pHandler, pNextHandler = g.pTransactions;
		while( pHandler = pNextHandler )
		{
			lprintf( "Check event handler (Service) %p", pHandler );
			pNextHandler = pHandler->next;
			{
				uint32_t tick;
				if( ( pHandler->last_check_tick + (CLIENT_TIMEOUT) ) < ( tick = timeGetTime() ) )
				{
					pHandler->last_check_tick = tick;
					if( !ProbeClientAlive( pHandler->ServiceID ) )
					{
						lprintf( "Service is gone! please tell client..." );
						if( pHandler->Handler )
							pHandler->Handler( MSG_MateEnded, NULL, 0 );
						if( pHandler->HandlerEx )
							pHandler->HandlerEx( pHandler->ServiceID, MSG_MateEnded, NULL, 0 );
						if( pHandler->HandlerExx )
							pHandler->HandlerExx( pHandler->psv, pHandler->ServiceID, MSG_MateEnded, NULL, 0 );
						UnlinkThing( pHandler );
						Release( pHandler );
						// generate disconnect message to client(myself)
						continue;
					}
					else
						lprintf( "Service is okay..." );
				}
			}
		}
	}
#endif
}
//--------------------------------------------------------------------
void ResumeThreads( void )
{
#ifndef _WIN32
	uint32_t tick;
	if( g.pThread )
	{
#ifdef DEBUG_SERVICE_INPUT
		lprintf( WIDE("Resume Service") );
#endif
		tick = timeGetTime();
		g.pending = 1;
		pthread_kill( ( GetThreadHandle( g.pThread ) ), SIGUSR2 );
		while( ((tick+10)>timeGetTime()) && g.pending ) Relinquish();
	}
	if( g.pMessageThread )
	{
#ifdef DEBUG_SERVICE_INPUT
		lprintf( WIDE("Resume Responce") );
#endif
		tick = timeGetTime();
		g.pending = 1;
		pthread_kill( ( GetThreadHandle( g.pMessageThread ) ), SIGUSR2 );
		while( ((tick+10)>timeGetTime()) && g.pending ) Relinquish();
	}
	if( g.pEventThread )
	{
#ifdef DEBUG_SERVICE_INPUT
		lprintf( WIDE("Resume event") );
#endif
		tick = timeGetTime();
		g.pending = 1;
		pthread_kill( ( GetThreadHandle( g.pEventThread ) ), SIGUSR2 );
		while( ((tick+10)>timeGetTime()) && g.pending ) Relinquish();
	}
	if( g.pLocalEventThread )
	{
#ifdef DEBUG_SERVICE_INPUT
		lprintf( WIDE("Resume local event") );
#endif
		tick = timeGetTime();
		g.pending = 1;
		pthread_kill( ( GetThreadHandle( g.pLocalEventThread ) ), SIGUSR2 );
		while( ((tick+10)>timeGetTime()) && g.pending ) Relinquish();
	}
#else
	if( g.pThread )
		WakeThread( g.pThread );
	if( g.pMessageThread )
		WakeThread( g.pMessageThread );
	if( g.pEventThread )
		WakeThread( g.pEventThread );
	if( g.pLocalEventThread )
		WakeThread( g.pLocalEventThread );
#endif
}
//--------------------------------------------------------------------
void RegisterWithMasterService( void )
{
	MSGIDTYPE ServiceID;
	if( g.flags.bMasterServer )
	{
		// I'm already done here....
		// I am what I am, and that's it.
		g.flags.connected = 1;
		g.flags.found_server = 1;
	}
	if( !g.flags.connected )
	{
		MSGIDTYPE Result;
		// result is a message ID that will be my SourceID
		size_t msglen = sizeof( ServiceID );
		/*
		{
			// create service 0 if it doesn't exist.
			PCLIENT_SERVICE service;
			for( service = g.services; service; service = service->next )
			{
				// process_id is already matched at this point, or we wouln't have the message
				// just have to give it to the local service.
				if( service->ServiceID == 0 )
				{
					//lprintf( WIDE("Found the service...%s"), service->name );
					break;
				}
			}
			if( !service )
			{
				service = New( CLIENT_SERVICE );
				service->entries = 0;
				service->name = WIDE( "Core Service" );
				//service->
			}
		}
		*/
		//lprintf( WIDE("Connecting first time to service server...%")_MsgID_f WIDE(",%") _MsgID_f, g.master_service_route.dest.process_id, g.master_service_route.dest.service_id );
		if( !TransactServerMultiMessageExEx(DBG_VOIDSRC)( &g.master_service_route, CLIENT_CONNECT, 0
													, &Result, &ServiceID, &msglen
													, 100
													)
		  || Result != (CLIENT_CONNECT|SERVER_SUCCESS) )
		{
			Log( WIDE("Failed CLIENT_CONNECT") );
			//g.flags.failed = TRUE;
			// I see no purpose for this other than troubleshooting
			// RegisterWithMaster is called well after this should
			// have been set...
			//g.flags.message_responce_handler_ready = TRUE;
			return;
		}
		else
		{
			// result and pid in message received from server are trashed...
			//g.master_server_pid = msg[0];
			// modify my_message_id - this is now the
			// ID of messages which will be sent
			// and where repsonces will be returned
		// this therefore means that
#ifdef DEBUG_SERVICE_INPUT
			lprintf( WIDE("Initial service contact success") );
#endif
			g.flags.found_server = 1;
			g.flags.connected = 1;
			//g.my_message_id = msg[0];
			//lprintf( WIDE("Have changed my_message_id and now we need to wake all receivers...") );
			// this causes them to re-queue their requests with the new
			// flag... although the windows implementation passes the address
			// of this variable, so next message will wake this thread, however,
			// if the message was already posted, still will have to wake them
			// so they can scan for new-ready.
			ResumeThreads();
		}
	}
}
//--------------------------------------------------------------------
static MSGQ_TYPE OpenQueueEx( CTEXTSTR name, int key, int flags DBG_PASS )
#ifdef _WIN32
#define OpenQueue(n,k,f) OpenQueueEx(n,0,f DBG_SRC)
#else
#define OpenQueue(n,k,f)  OpenQueueEx( n,k,f DBG_SRC )
#endif
{
	static TEXTCHAR errbuf[256];
	MSGQ_TYPE queue;
	if( g.flags.bMasterServer )
	{
		queue = msgget( name, key, IPC_CREAT|IPC_EXCL|0666 );
		if( queue == MSGFAIL )
		{
			//strerror_s(errbuf, sizeof( errbuf ), errno);
         errbuf[0] = 0;
			lprintf( WIDE("Failed to create message Q for \"%s\":%s for") DBG_FILELINEFMT, name
				, errbuf
				DBG_RELAY );
			queue = msgget( name, key, 0 );
			if( queue == MSGFAIL )
			{
				//perror( WIDE("Failed to open message Q") );
			}
			else
			{
				lprintf( WIDE("Removing message queue id for %s"), name );
				msgctl( queue, IPC_RMID, NULL );
				queue = msgget( name, key, IPC_CREAT|IPC_EXCL|0666 );
				if( queue == MSGFAIL )
				{
					//strerror_s(errbuf, sizeof( errbuf ), errno);
					errbuf[0] = 0;
					lprintf( WIDE("Failed to open message Q for \"%s\":%s"), name
						, errbuf
						);
				}
			}
		}
	}
	else
	{
		queue = msgget( name, key, flags|0666 );
		if( queue == MSGFAIL )
		{
#ifdef DEBUG_MSGQ_OPEN
			//strerror_s(errbuf, sizeof( errbuf ), errno);
         errbuf[0] = 0;
			lprintf( WIDE("Failed to create message Q for \"%s\":%s for ") DBG_FILELINEFMT, name
				, errbuf
				DBG_RELAY );
#endif
			//lprintf( WIDE("Failed to open message Q for \")%s\":%s", name, strerror(errno) );
		}
	}
	return queue;
}
//--------------------------------------------------------------------
#ifndef WIN32
static void ResumeSignal( int signal )
{
	//lprintf( WIDE("Got a resume signal.... resuming uhmm some thread.") );
	//lprintf( WIDE("Uhmm and then pending should be 0?") );
	g.pending = 0;
}
#endif
int _InitMessageService( int local )
{
#ifdef __LINUX__
	key_t key, key2, key3, key4;
 // ignore this ...
	signal( SIGUSR2, ResumeSignal );
#endif
	// key and key2 are reversed from the server - so my out is his in
	// and his inis my out.
	// we do funny things here since we switch in/out vs server.
#ifdef __LINUX__
 // server input, client output
	key = *(long*)MSGQ_ID_BASE;
  // server output, client input
	key2 = key + 1;
  // pid-addressed events (all ways)
	key3 = key + 2;
  // pid-addressed events (all ways)
	key4 = key + 3;
#endif
	// until connected, our message handler ID
	// is my pid.  Then, once connected, we listen
	// for messages with the ID which was granted by the message
	// service.
	// maybe this could be declared to be '2'
	// and then before the client-connect is done, attempt
	// to send to process 2... if a responce is given, someone
	// else is currently registering with the message server
	// and we need to wait.
	// not failed... attempting to re-connect
	g.flags.failed = 0;
	if( !local )
	{
		if( g.flags.disconnected )
		{
			lprintf( WIDE("Previously we had closed all communication... allowing re-open.") );
			g.flags.disconnected = 0;
 // reset this... so we re-request for new path...
			g.my_message_id = 0;
		}
	}
	if( !g.flags.bAliveThreadStarted )
	{
		// this timer monitors ALL clients for inactivity
		// it will probe them with RU_ALIVE messages
		// to which they must respond otherwise be termintated.
		g.flags.bAliveThreadStarted = 1;
		AddTimer( CLIENT_TIMEOUT/4, MonitorClientActive, 0 );
		// each service gets 1 thread to handle their own
		// messages... services do not have 'events' generated
		// to them.
	}
	if( !g.my_message_id )
	{
#ifdef __LINUX__
 //pService->thread->ThreadID & 0x7FFFFFFFUL; /*(uint32_t)getpid()*/;
		g.my_message_id = getpid();
#else
		g.my_message_id = GetCurrentProcessId();
#endif
	}
	g.master_service_route.dest.process_id = 1;
	g.master_service_route.dest.service_id = 0;
	g.master_service_route.source.process_id = g.my_message_id;
	g.master_service_route.source.service_id = 0;
	if( !local && !g.msgq_in && !g.flags.message_responce_handler_ready )
	{
#ifdef DEBUG_MSGQ_OPEN
		lprintf( WIDE("opening message queue? %d %d %d")
				 , local, g.msgq_in, g.flags.message_responce_handler_ready );
#endif
		g.msgq_in = OpenQueue( MSGQ_ID_BASE WIDE("1"), key2, 0 );
#ifdef DEBUG_MSGQ_OPEN
		lprintf( WIDE("Result msgq_in = %ld"), g.msgq_in );
#endif
		if( g.msgq_in == MSGFAIL )
		{
			g.msgq_in = 0;
			return FALSE;
		}
#ifdef DEBUG_THREADS
		lprintf( WIDE("Creating thread to handle responces...") );
#endif
		AddIdleProc( ProcessClientMessages, 0 );
		ThreadTo( HandleMessages, g.my_message_id );
		while( !g.flags.message_responce_handler_ready )
			Relinquish();
	}
	if( !local && !g.msgq_out && !g.flags.message_handler_ready )
	{
		g.msgq_out = OpenQueue( MSGQ_ID_BASE WIDE("0"), key, 0 );
		if( g.msgq_out == MSGFAIL )
		{
			g.msgq_out = 0;
			return FALSE;
		}
		// just allow this thread to be created later...
		// need to open the Queue... but that's about it.
#ifdef DEBUG_THREADS
		//lprintf( WIDE("Creating thread to handle messages...") );
		// thread is now created in RegisterService portion
#endif
	}
	if( !local && !g.msgq_event && !g.flags.events_ready )
	{
		g.msgq_event = OpenQueue( MSGQ_ID_BASE WIDE("2"), key3, 0 );
		if( g.msgq_event == MSGFAIL )
		{
			g.msgq_event = 0;
			return FALSE;
		}
#ifdef DEBUG_THREADS
		lprintf( WIDE("Creating thread to handle events...") );
#endif
		ThreadTo( HandleEventMessages, 0 );
		while( !g.flags.events_ready )
			Relinquish();
	}
	if( local && !g.msgq_local && !g.flags.local_events_ready )
	{
	// huh - how can I open this shm under linux?
		g.msgq_local = OpenQueue( NULL, key4, IPC_CREAT );
		if( g.msgq_local == MSGFAIL )
		{
			g.msgq_local = 0;
			return FALSE;
		}
#ifdef DEBUG_THREADS
		lprintf( WIDE("Creating thread to handle local events...") );
#endif
		AddIdleProc( ProcessClientMessages, 0 );
		ThreadTo( HandleLocalEventMessages, 0 );
		while( !g.flags.local_events_ready )
			Relinquish();
	}
	// right now our PID is the message ID
	// and after this we will have our correct message ID...
	g._handler.RouteID.dest.process_id = 1;
	g._handler.RouteID.dest.service_id = 0;
	if( g.flags.failed )
	{
		//g.flags.initialized = FALSE;
		return -1;
	}
	return 1;
}
//--------------------------------------------------------------------
void CloseMessageQueues( void )
{
	g.flags.disconnected = TRUE;
	if( g.flags.bMasterServer )
	{
		// master server closing, removes all id's
		// removing the message queue should be enough
		// to wake each of these threads...
		if( g.msgq_in != MSGFAIL )
		{
			msgctl( g.msgq_in, IPC_RMID, NULL );
			g.msgq_in = 0;
		}
		if( g.msgq_out != MSGFAIL )
		{
			msgctl( g.msgq_out, IPC_RMID, NULL );
			g.msgq_out = 0;
		}
		if( g.msgq_event != MSGFAIL )
		{
			msgctl( g.msgq_event, IPC_RMID, NULL );
			g.msgq_event = 0;
		}
		if( g.msgq_local != MSGFAIL )
		{
			msgctl( g.msgq_local, IPC_RMID, NULL );
			g.msgq_local = 0;
		}
	}
	else
	{
		// we have to wake up everyone, so they can realize we're disconnected
		// and leave...
		// then we wait some short time for everyone to exit...
		ResumeThreads();
	}
	{
		uint32_t attempts = 0;
		uint32_t time;
		g.msgq_in = 0;
		g.msgq_out = 0;
		g.msgq_event = 0;
		g.msgq_local = 0;
		g.my_message_id = 0;
		do
		{
			time = timeGetTime();
			while( ((time+100)>timeGetTime()) && g.pThread ) Relinquish();
			time = timeGetTime();
			while( ((time+100)>timeGetTime()) && g.pMessageThread ) Relinquish();
			time = timeGetTime();
			while( ((time+100)>timeGetTime()) && g.pEventThread ) Relinquish();
			time = timeGetTime();
			while( ((time+100)>timeGetTime()) && g.pLocalEventThread ) Relinquish();
			if( g.pThread || g.pMessageThread || g.pEventThread || g.pLocalEventThread )
			{
				attempts++;
				lprintf( WIDE("Threads are not exiting... %") _32f WIDE(" times"), attempts );
				if( attempts < 10 )
 // skips
					continue;
			}
		} while( 0 );
	}
	// re-establish our communication ID if we
	// end up with more work to do...
	g.flags.connected = 0;
}
//--------------------------------------------------------------------
static void DisconnectClient(void)
{
	static int bDone;
	PEVENTHANDLER pHandler;
	if( !global_msgclient || bDone )
		return;
	bDone = 1;
	//lprintf( WIDE("Disconnect all clients... %Lx"), GetMyThreadID() );
	while( ( pHandler = g.pHandlers ) )
	{
		//lprintf( WIDE("Unloading a service...") );
		UnloadService( pHandler->servicename );
	}
	//lprintf( WIDE("Okay all registered services are gone.") );
	// no real purpose in this....
	// well perhaps... but eh...
	// if( !master server )
	//SendServerMessage( CLIENT_DISCONNECT, NULL, 0 );
	CloseMessageQueues();
}
ATEXIT_PRIORITY( _DisconnectClient, ATEXIT_PRIORITY_MSGCLIENT )
{
	DisconnectClient();
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( int, ProbeClientAlive )( PSERVICE_ENDPOINT RouteID )
{
	MSGIDTYPE Responce;
	SERVICE_ROUTE ping_route;
	if( RouteID->process_id == g.my_message_id )
	{
		lprintf( WIDE("Yes, I, myself, am alive...") );
		return TRUE;
	}
	//lprintf( WIDE("Hmm is client %p") WIDE(" alive?"), RouteID );
	{
		PEVENTHANDLER handler;
		for( handler = g.pHandlers; handler; handler = handler->next )
			if( ( handler->RouteID.dest.process_id == RouteID->process_id )
			  && ( handler->RouteID.dest.service_id == RouteID->service_id ) )
				break;
		if( !handler )
		{
			// has a nul name.
			handler = New( EVENTHANDLER );
			MemSet( handler, 0, sizeof( EVENTHANDLER ) );
			//InitializeCriticalSec( &handler->csMsgTransact );
			handler->RouteID.dest = RouteID[0];
			LinkThing( g.pHandlers, handler );
			//lprintf( WIDE("Created a HANDLER to coordinate probe alive request..") );
		}
	}
	ping_route.dest.process_id = RouteID->process_id;
 // PING goes to service 0 (internals)
	ping_route.dest.service_id = 0;
	ping_route.source.process_id = g.my_message_id;
	ping_route.source.service_id = 0;
	if( TransactRoutedServerMultiMessageEx( &ping_route, RU_ALIVE, 0
													  , &Responce, NULL, NULL
#ifdef DEBUG_DATA_XFER
														// if logging data xfer - we need more time
													  , 250
#else
 // 10 millisecond timeout... should be more than generous.
													  , 250
#endif
													  , NULL, NULL ) &&
		Responce == ( IM_ALIVE ) )
	{
		//lprintf( WIDE("Ping Success.") );
		return TRUE;
	}
	//lprintf( WIDE("Ping Failure.") );
	return FALSE;
}
//-------------------------------------------------------------
CLIENTMSG_PROC( int, SendOutMessageEx )( PQMSG buffer, size_t len DBG_PASS )
{
#ifdef DEBUG_MESSAGE_BASE_ID
	//DBG_VARSRC;
#endif
	int stat;
	if( ( stat = msgsnd( g.msgq_out, MSGTYPE (buffer), len, 0 ) ) < 0 )
	{
		TEXTCHAR msg[256];
		//strerror_s(errbuf, sizeof( errbuf ), errno);
		msg[0] = 0;
		lprintf( WIDE("Error sending message: %s")
			, msg );
	}
	return stat;
}
CLIENTMSG_PROC( int, SendOutMessage )( PQMSG buffer, size_t len )
{
	return SendOutMessageEx(buffer,len DBG_SRC);
}
//-------------------------------------------------------------
CLIENTMSG_PROC( void, SetMasterServer )( void )
{
	g.flags.bMasterServer = 1;
}
//-------------------------------------------------------------
CLIENTMSG_PROC( void, DumpServiceList )(void )
{
	PLIST list = NULL;
	int bDone = 0;
	PREFIX_PACKED struct {
		PLIST *ppList;
		int *pbDone;
		PTHREAD me;
	} PACKED mydata;
	mydata.ppList = &list;
	mydata.pbDone = &bDone;
	if( !_InitMessageService( FALSE ) )
	{
		lprintf( WIDE("Initization of public message participation failed, cannot query service master") );
		return;
	}
	RegisterWithMasterService();
	mydata.me = MakeThread();
	lprintf( WIDE("Sending message to server ... list services...") );
	LogBinary( (uint8_t*)&mydata, sizeof(mydata) );
	SendServerMessage( &g.master_service_route, CLIENT_LIST_SERVICES, &mydata, sizeof(mydata) );
	// wait for end of list...
	while( !bDone )
	{
		WakeableSleep( 5000 );
		if( !bDone )
		{
			lprintf( WIDE("Treading water, but I think I'm stuck here forever...") );
		}
	}
	{
		INDEX idx;
		char *service;
		LIST_FORALL( list, idx, char *, service )
		{
			// ID of service MAY be available... but is not yet through
			// thsi interface...
			lprintf( WIDE("Available Service: %s"), service );
			Release( service );
		}
		lprintf( WIDE("End of service list.") );
		DeleteList( &list );
	}
}
//-------------------------------------------------------------
CLIENTMSG_PROC( void, GetServiceList )( PLIST *list )
{
	int bDone = 0;
	PREFIX_PACKED struct {
		PLIST *ppList;
		int *pbDone;
		PTHREAD me;
	} PACKED mydata;
	mydata.ppList = list;
	mydata.pbDone = &bDone;
	if( !_InitMessageService( FALSE ) )
	{
		lprintf( WIDE("Initization of public message participation failed, cannot query service master") );
		return;
	}
	RegisterWithMasterService();
	mydata.me = MakeThread();
	lprintf( WIDE("Sending message to server ... list services...") );
	SendServerMessage( &g.master_service_route, CLIENT_LIST_SERVICES, &mydata, sizeof(mydata) );
	// wait for end of list...
	while( !bDone )
	{
		WakeableSleep( 5000 );
		if( !bDone )
		{
			lprintf( WIDE("Treading water, but I think I'm stuck here forever...") );
		}
	}
	/*
	{
		INDEX idx;
		char *service;
		LIST_FORALL( list, idx, char *, service )
		{
			// ID of service MAY be available... but is not yet through
			// thsi interface...
			lprintf( WIDE("Available Service: %s"), service );
		}
		lprintf( WIDE("End of service list.") );
		}
		*/
}
CLIENTMSG_PROC( LOGICAL, IsSameMsgEndPoint )( PSERVICE_ENDPOINT a, PSERVICE_ENDPOINT b )
{
   return ( a->process_id == b->process_id ) && ( a->service_id == b->service_id );
}
CLIENTMSG_PROC( LOGICAL, IsSameMsgSource )( PSERVICE_ROUTE a, PSERVICE_ROUTE b )
{
	return IsSameMsgEndPoint( &a->source, &b->source );
}
CLIENTMSG_PROC( LOGICAL, IsSameMsgDest )( PSERVICE_ROUTE a, PSERVICE_ROUTE b )
{
	return IsSameMsgEndPoint( &a->dest, &b->dest );
}
CLIENTMSG_PROC( LOGICAL, IsMsgSourceSameAsMsgDest )( PSERVICE_ROUTE a, PSERVICE_ROUTE b )
{
	return IsSameMsgEndPoint( &a->source, &b->dest );
}
void DropMessageBuffer( PQMSG msg )
{
	EnqueLink( &g.Messages, msg );
}
PQMSG GetMessageBuffer( void )
{
	PQMSG msg = (PQMSG)DequeLink( &g.Messages );
	if( !msg )
	{
		msg = NewPlus( QMSG, 8192 );
		return msg;
	}
	return msg;
}
MSGCLIENT_NAMESPACE_END
//-------------------------------------------------------------
MSGCLIENT_NAMESPACE
//--------------------------------------------------------------------
PSERVICE_CLIENT FindClient( PSERVICE_ROUTE pid )
{
	PSERVICE_CLIENT client = g.clients;
	while( client )
	{
		if( ( client->route.dest.process_id == pid->dest.process_id )
         && ( client->route.dest.service_id == pid->dest.service_id ) )
		{
			break;
		}
		client = client->next;
	}
	return client;
}
//--------------------------------------------------------------------
static PSERVICE_CLIENT AddClient( PSERVICE_ROUTE pid )
{
	{
		PSERVICE_CLIENT client = FindClient( pid );
		if( client )
		{
			//Log( WIDE("Client has reconnected?!?!?!") );
			// reconnect is done when requesting a service from
			// a server that supplies one or more services itself...
			// suppose we can just let him continue...
			return client;
		}
	}
	{
		PSERVICE_CLIENT client = New( SERVICE_CLIENT );
		MemSet( client, 0, sizeof( SERVICE_CLIENT ) );
		client->route = pid[0];
		client->last_time_received = timeGetTime();
		client->flags.valid = 1;
		LinkThing( g.clients, client );
		g.clients = client;
		//Log( WIDE("Added client...") );
		return client;
	}
}
//--------------------------------------------------------------------
static PSERVICE_ROUTE _LoadService( CTEXTSTR service
							  , EventHandlerFunction EventHandler
							  , EventHandlerFunctionEx EventHandlerEx
							  , EventHandlerFunctionExx EventHandlerExx
							  , server_message_handler handler
                       , server_message_handler_ex handler_ex
							  , uintptr_t psv
							  )
{
	MSGIDTYPE MsgID;
	MsgSrv_ReplyServiceLoad msg;
 // expect MsgBase = 0, EventMessgaeCount = 1
	size_t MsgLen = sizeof( msg );
	PEVENTHANDLER pHandler;
	// can check now if some other part of this has loaded
	// this service.
	// reset this status...
	if( !_InitMessageService( service?FALSE:TRUE ) )
	{
#ifdef DEBUG_MSGQ_OPEN
		lprintf( WIDE("Load of %s message service failed."), service );
#endif
		return NULL;
	}
	if( service )
	{
		RegisterWithMasterService();
		if( !g.flags.bAliveThreadStarted )
		{
			// this timer monitors ALL clients for inactivity
			// it will probe them with RU_ALIVE messages
			// to which they must respond otherwise be termintated.
			g.flags.bAliveThreadStarted = 1;
			AddTimer( CLIENT_TIMEOUT/4, MonitorClientActive, 0 );
			// each service gets 1 thread to handle their own
			// messages... services do not have 'events' generated
			// to them.
		}
#if 0
		// always query for service, don't short cut... ?
		while( pHandler )
		{
			// only one connection to any given service name
			// may be maintained.  The service itself is resulted...
			if( !strcmp( pHandler->servicename, service ) )
				return &pHandler->RouteID;
			pHandler = pHandler->next;
		}
#endif
		EnterCriticalSec( &g.csLoading );
		pHandler = New( EVENTHANDLER );
		MemSet( pHandler, 0, sizeof( EVENTHANDLER ) );
		//InitializeCriticalSec( &pHandler->csMsgTransact );
		pHandler->servicename = StrDup( service );
		pHandler->RouteID.dest.process_id = 1;
		pHandler->RouteID.dest.service_id = 0;
		pHandler->RouteID.source.process_id = g.my_message_id;
		pHandler->RouteID.source.service_id = 0;
		//lprintf( WIDE("Allocating local structure which manages our connection to this service...") );
		// MsgInfo is used both on the send and receives the
		// responce from the service...
		// LoadService goes to the msgsvr and requests the
		// location of the service.
		if( !TransactRoutedServerMultiMessageEx( &pHandler->RouteID
															, MSG_ServiceLoad, 1
															, &MsgID, &msg, &MsgLen
															, 250
 // include NUL
															, service, (StrLen( service ) + 1) *sizeof(TEXTCHAR)
															) )
		{
			Log( WIDE("Transact message timeout.") );
			Release( pHandler );
			LeaveCriticalSec( &g.csLoading );
			return NULL;
		}
		if( MsgID != (MSG_ServiceLoad|SERVER_SUCCESS) )
		{
			lprintf( WIDE("Server reports it failed to load [%s] (%08") _MsgID_f WIDE("!=%08" ) _MsgID_f WIDE(")")
					 , service
					 , MsgID
					 , (MSGIDTYPE)(MSG_ServiceLoad|SERVER_SUCCESS) );
			Release( pHandler );
			LeaveCriticalSec( &g.csLoading );
			return NULL;
		}
		// uncorrectable anymore.
		//if( MsgLen == 16 )
		//{
		//	lprintf( WIDE("Old server load service responce... lacks the PID of the event handler.") );
		//}
		if( MsgLen != sizeof( msg ) )
		{
			lprintf( WIDE("Server responce was the wrong length!!! %") _size_f WIDE(" expecting %")_size_f, MsgLen, sizeof( msg ) );
			Release( pHandler );
			LeaveCriticalSec( &g.csLoading );
			return NULL;
		}
	}
	else
	{
		// loading special NULL service.
		// the NULL service looks like a queue available
      // for events only?  fakes a server response in msg.
		pHandler = New( EVENTHANDLER );
		MemSet( pHandler, 0, sizeof( EVENTHANDLER ) );
		//InitializeCriticalSec( &pHandler->csMsgTransact );
		pHandler->RouteID.dest.process_id = g.my_message_id;
		pHandler->RouteID.dest.service_id = 0;
		pHandler->servicename = StrDup( WIDE("local_events") );
 // this is a special event channel to myself.
		msg.ServiceID = 0;
		//lprintf( WIDE("opening local only service... we're making up numbers here.") );
		if( g.pLocalEventThread )
		{
			msg.thread = GetThreadID( g.pLocalEventThread );
		}
		else
		{
			lprintf( WIDE("Event message system has not started correctly...") );
			Release( pHandler );
			LeaveCriticalSec( &g.csLoading );
			return NULL;
		}
	}
	// EVENTHANDLER is the outbound structure to idenfity
	// the service information which messages go where...
	{
		//pHandler = Allocate( sizeof( EVENTHANDLER ) + strlen( service?service:"local_events" ) );
		//strcpy( pHandler->servicename, service?service:"local_events" );
		//lprintf( WIDE("Allocating local structure which manages our connection to this service...") );
		pHandler->flags.destroyed = 0;
		pHandler->flags.dispatched = 0;
		//pHandler->MsgCountEvents = msg.events;
		//pHandler->MsgCount = msg.functions;
		pHandler->Handler = EventHandler;
		pHandler->HandlerEx = EventHandlerEx;
		pHandler->HandlerExx = EventHandlerExx;
      pHandler->psv = psv;
		// thread ID to wake for events? or to probe?
		// thread ID unused.
		pHandler->EventID = msg.thread;
		if( service )
		{
			pHandler->flags.local_service = 0;
			//pHandler->RouteID.dest = msg.ServiceID; // magic place where source ID is..
			pHandler->msgq_events = g.msgq_event;
		}
		else
		{
			pHandler->flags.local_service = 1;
			pHandler->RouteID.dest.process_id = g.my_message_id;
			pHandler->RouteID.dest.service_id = 0;
			pHandler->msgq_events = g.msgq_local;
		}
		LinkThing( g.pHandlers, pHandler );
		if( service )
		{
 // hang this on the list of services to check...
			PSERVICE_CLIENT pClient = AddClient( &pHandler->RouteID );
			pClient->flags.is_service = 1;
			pClient->handler = pHandler;
		}
		LeaveCriticalSec( &g.csLoading );
	}
	return &pHandler->RouteID;
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadService)( CTEXTSTR service, EventHandlerFunction EventHandler )
{
	return _LoadService( service, EventHandler, NULL, NULL, NULL, NULL, 0 );
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceEx)( CTEXTSTR service, EventHandlerFunctionEx EventHandlerEx )
{
	return _LoadService( service, NULL, EventHandlerEx, NULL, NULL, NULL, 0 );
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( PSERVICE_ROUTE, LoadServiceExx)( CTEXTSTR service, EventHandlerFunctionExx EventHandlerEx, uintptr_t psv )
{
	return _LoadService( service, NULL, NULL, EventHandlerEx, NULL, NULL, psv );
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( void, UnloadService )( CTEXTSTR name )
{
	PEVENTHANDLER pHandler;
	pHandler = g.pHandlers;
	while( pHandler )
	{
		if( StrCaseCmp( pHandler->servicename, name ) == 0 )
			break;
		pHandler = pHandler->next;
	}
	if( pHandler )
	{
		MSGIDTYPE Responce;
		//lprintf( WIDE("Unload service: %s"), pHandler->servicename );
		if( pHandler->flags.local_service )
		{
			//lprintf( WIDE("Local service... resulting quick success...") );
			Responce = (MSG_ServiceUnload)|SERVER_SUCCESS;
		}
		else
		{
			//lprintf( WIDE("Requesting message %d from %d "), MSG_ServiceUnload , pHandler->MsgBase );
			Responce = ((MSG_ServiceUnload)|SERVER_SUCCESS);
			if( !TransactServerMessage( &pHandler->RouteID
											  , MSG_ServiceUnload, NULL, 0
/*NULL*/
											  , &Responce, NULL, 0 ) )
			{
				lprintf( WIDE("Transaction to ServiceUnload failed...") );
			}
			else if( Responce != ((MSG_ServiceUnload)|SERVER_SUCCESS) )
			{
				lprintf( WIDE("Server reports it failed to unload the service %08") _MsgID_f WIDE(" %08") _MsgID_f WIDE("")
						 , Responce, (MSGIDTYPE)((MSG_ServiceUnload)|SERVER_SUCCESS) );
			// no matter what the result, this must still release this
			// resource....
			//return;
			}
			while( pHandler->flags.dispatched )
			{
				Relinquish();
			}
		}
		UnlinkThing( pHandler );
		//lprintf( WIDE("Release? wow release hangs forever?") );
		//Release( pHandler );
		if( 0 && !g.pHandlers )
		{
			Log( WIDE("No more services loaded - killing threads, disconnecting") );
			if( g.pLocalEventThread )
			{
				EndThread( g.pLocalEventThread );
				// wake up the thread...
			}
			if( g.pEventThread )
				EndThread( g.pEventThread );
			if( g.pThread )
				EndThread( g.pThread );
			CloseMessageQueues();
			g.flags.events_ready = 0;
			g.flags.local_events_ready = 0;
			g.flags.failed = 0;
			g.flags.message_handler_ready = 0;
			g.flags.message_responce_handler_ready = 0;
		}
		//Log( WIDE("Done unloading services...") );
		return;
	}
	Log( WIDE("Service was already Unloaded!?!?!?!?!?") );
}
MSGCLIENT_NAMESPACE_END
//-------------------------------------------------------------
MSGCLIENT_NAMESPACE
//--------------------------------------------------------------------
// this expects route to be destination-correct
CLIENTMSG_PROC(int, SendMultiServiceEventPairsEx)( PSERVICE_ROUTE RouteID, uint32_t event
															  , uint32_t parts
															  , BUFFER_LENGTH_PAIR *pairs
															  DBG_PASS
															  )
#define SendMultiServiceEventPairs(p,ev,par,pair) SendMultiServiceEventPairsEx(p,ev,par,pair DBG_SRC)
{
	static struct {
		QMSG msg;
		uint32_t data[2048-sizeof(QMSG)];
	}msg;
	static LOGICAL initialized;
	static CRITICALSECTION cs;
	uint8_t* msgbuf;
	size_t sendlen = 0;
	if( !initialized )
	{
		InitializeCriticalSec( &cs );
		initialized = 1;
	}
#ifdef DEBUG_MESSAGE_BASE_ID
	//DBG_VARSRC;
#endif
	EnterCriticalSec( &cs );
	if( RouteID )
	{
		msg.msg.dest = RouteID->dest;
		msg.msg.hdr.source = RouteID->source;
	}
	else
	{
		// local event message, should be hard coded?
		msg.msg.dest.process_id = g.my_message_id;
		msg.msg.dest.service_id = 0;
		msg.msg.hdr.source.process_id = g.my_message_id;
		msg.msg.hdr.source.service_id = 0;
	}
	msg.msg.hdr.msgid = event;
	msgbuf = (uint8_t*)msg.data;
	while( parts )
	{
		if( pairs->buffer && pairs->len )
		{
			MemCpy( msgbuf + sendlen, pairs->buffer, pairs->len );
			sendlen += pairs->len;
			pairs++;
		}
		parts--;
	}
						// outgoing que for this handler.
#if defined( DEBUG_EVENTS )
	_lprintf(DBG_RELAY)( WIDE("Send Event...") );
#if !defined( DEBUG_DATA_XFER )
	LogBinary( (uint8_t*)&msg, sendlen + sizeof( MSGHDR ) + sizeof( MSGIDTYPE ) );
#endif
#endif
	if( !msg.msg.dest.process_id )
		msg.msg.dest.process_id = g.my_message_id;
	{
		int status;
		status = msgsnd( RouteID?g.msgq_event:g.msgq_local, MSGTYPE &msg
							, sendlen + ( sizeof( QMSG ) - sizeof( MSGIDTYPE ) ), 0 );
		LeaveCriticalSec( &cs );
		return !status;
	}
}
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
static struct {
	CTEXTSTR pFile;
	int nLine;
}nextsmmse;
#endif
#undef SendMultiServiceEvent
CLIENTMSG_PROC(int, SendMultiServiceEvent)( PSERVICE_ROUTE RouteID, uint32_t event
								 , uint32_t parts
								 , ... )
{
	int status;
	BUFFER_LENGTH_PAIR *pairs = NewArray( BUFFER_LENGTH_PAIR, parts );
	uint32_t n;
	va_list args;
	va_start( args, parts );
	for( n = 0; n < parts; n++ )
	{
		pairs[n].buffer = va_arg( args, POINTER );
		pairs[n].len = va_arg( args, uint32_t );
	}
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	status = SendMultiServiceEventPairsEx( RouteID, event, parts, pairs, nextsmmse.pFile, nextsmmse.nLine );
#else
	status = SendMultiServiceEventPairsEx( RouteID, event, parts, pairs );
#endif
	Release( pairs );
	return status;
}
CLIENTMSG_PROC(SendMultiServiceEventProto, SendMultiServiceEventEx)( DBG_VOIDPASS )
{
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	nextsmmse.pFile = pFile;
	nextsmmse.nLine = nLine;
#endif
	return SendMultiServiceEvent;
}
//--------------------------------------------------------------------
uintptr_t CPROC HandleEventMessages( PTHREAD thread )
{
	g.pEventThread = thread;
	g.flags.events_ready = TRUE;
#ifdef DEBUG_THREADS
	lprintf( WIDE("threadID: %Lx %lx"), GetThreadID( thread ), (unsigned long)(GetThreadID( thread ) & 0xFFFFFFFF) );
#endif
	//g.my_message_id = g.my_message_id; //(uint32_t)( thread->ThreadID & 0xFFFFFFFF );
	while( !g.flags.disconnected )
	{
		int r;
		if( thread == g.pEventThread )
		{
 // 8192 bytes
			static uint32_t MessageEvent[2048];
#ifdef DEBUG_EVENTS
			lprintf( WIDE("Reading event...") );
#endif
			if( ( r = HandleEvents( g.msgq_event, (PQMSG)MessageEvent, 0 ) ) < 0 )
			{
				Log( WIDE("EventHandler has reported a fatal error condition.") );
				break;
			}
#ifdef DEBUG_EVENTS
			lprintf( WIDE("Read event...") );
#endif
		}
		else if( r == 2 )
		{
			Log( WIDE("Thread has been restarted.") );
			// don't clear ready or main event flag
			// things.
			return 0;
		}
	}
	lprintf( WIDE("Done with this event thread - BAD! ") );
	g.flags.events_ready = FALSE;
	g.pEventThread = NULL;
	return 0;
}
//--------------------------------------------------------------------
int HandleEvents( MSGQ_TYPE msgq, PQMSG MessageEvent, int initial_flags )
{
	int receive_flags = initial_flags;
	int receive_count = 0;
	while( 1 )
	{
		int32_t MessageLen;
#ifdef DEBUG_EVENTS
		lprintf( WIDE("Reading eventqueue... my_message_id = %d"), g.my_message_id );
#endif
			//lprintf( "vvv" );
		MessageLen = msgrcv( msgq
								 , MSGTYPE MessageEvent, 8192
								 , g.my_message_id
								 , receive_flags );
		//lprintf( "^^^" );
#ifdef DEBUG_DATA_XFER
      if( MessageLen >= 0 )
			LogBinary( (uint8_t*)MessageEvent, MessageLen + sizeof( MSGIDTYPE ) );
#endif
		if( (MessageLen+ sizeof( MSGIDTYPE )) == 0 )
		{
			lprintf( WIDE("Recieved -4 message (no data?!) no message, should have been -1, ENOMSG") );
		}
		else if( MessageLen == -1 )
		{
#ifdef _WIN32
			int my_errno = GetLastError();
#  ifdef errno
#    undef errno
#  endif
#  define errno my_errno
#endif
			//Log( WIDE("Failed a message...") );
			if( errno == ENOMSG )
			{
				//Log( WIDE("No message...") );
				if( receive_count )
				{
					PEVENTHANDLER pLastHandler;
					PEVENTHANDLER pHandler = g.pHandlers;
#ifdef DEBUG_EVENTS
					lprintf( WIDE("Dispatch dispatch_pending..") );
#endif
					while( pHandler )
					{
						pHandler->flags.dispatched = 1;
						if( pHandler->flags.notify_if_dispatched )
						{
							//lprintf( WIDE("Okay one had something pending...") );
							if( pHandler->Handler )
								pHandler->Handler( MSG_EventDispatchPending, NULL, 0 );
							else if( pHandler->HandlerEx )
								pHandler->HandlerEx( 0, MSG_EventDispatchPending, NULL, 0 );
							else if( pHandler->HandlerExx )
								pHandler->HandlerExx( pHandler->psv, 0, MSG_EventDispatchPending, NULL, 0 );
							// okay did that... now clear status.
							pHandler->flags.notify_if_dispatched = 0;
						}
						pLastHandler = pHandler;
						pHandler = pHandler->next;
						pLastHandler->flags.dispatched = 0;
						//lprintf( WIDE("next handler please...") );
					}
				}
 // re-enable pause.
				receive_flags = 0;
				//lprintf( WIDE("Done reading...") );
 // done;
				break;
			}
			else if( errno == EIDRM )
			{
				Log( WIDE("Queue was removed.") );
				g.flags.events_ready = 0;
				return -1;
			}
			else
			{
				if( errno != EINTR )
					xlprintf( LOG_ALWAYS )( WIDE("msgrcv resulted in error: %d"), errno );
				//else
				//	Log( WIDE("EINTR received.") );
				break;
			}
		}
		else
		{
			PEVENTHANDLER pHandler = g.pHandlers;
			receive_flags = IPC_NOWAIT;
			receive_count++;
#ifdef DEBUG_EVENTS
			lprintf( WIDE("Got an event message...") );
#endif
			if( MessageEvent->hdr.msgid < MSG_EventUser )
			{
				// core server events...
				// MessageEvent->hdr.sourceid == client_id (client_route_id)
				switch( MessageEvent->hdr.msgid )
				{
				case MSG_SERVICE_DATA:
					{
						PREFIX_PACKED struct msg_service_name {
							PLIST *list;
							// so what i there's no reference to this?! OMG!
							// I still need to have it defined!
							SERVICE_ENDPOINT service_id;
 // actually is the first element of an array of characters with nul terminator.
							TEXTCHAR newname;
						} PACKED *data_msg = (struct msg_service_name*)(MessageEvent+1);
						// ahh - someone requested the list of services...
						// client-application API...
						// add to the list... what list?
						PLIST *list = data_msg->list;
						// MessageEvent[3] for this message is client_id
						// which may be used to directly contact the client.
						//lprintf( WIDE("Adding service %ld called %s to list.."), MessageEvent[4], MessageEvent + 5 );
						// SetLink( data_msg->list, data_msg->dest.service_id, data_msg->newname );
						AddLink( list
								 , StrDup( &data_msg->newname ) );
					}
					break;
				case MSG_SERVICE_NOMORE:
					{
						// ahh - someone requested the list of services...
						// client-application API...
						// this is the END of the list
						PREFIX_PACKED struct msg_service_nomore {
							int *bDone;
							PTHREAD pThread;
						} PACKED *data_msg = (struct msg_service_nomore*)(MessageEvent+1);
						//int *bDone = *(int**)((&MessageEvent->hdr)+1);
						//PTHREAD pThread = *(PTHREAD*)((int*)((&MessageEvent->hdr)+1)+1);
						(*data_msg->bDone) = 1;
						WakeThread( data_msg->pThread );
					}
					break;
				}
			}
			else for( ; pHandler; pHandler = pHandler->next )
			{
				uint32_t Msg;
#ifdef DEBUG_EVENTS
				lprintf( WIDE("Finding handler for %ld-%d %p (from %lx to %lx)")
						 , MessageEvent->hdr.msgid
//pHandler->MsgCountEvents
						 , 0
						 , pHandler->Handler
						 , (uint32_t*)((&MessageEvent->hdr)+1)
 /*pHandler->ServiceID*/
						 , 0 );
#endif
				//if( !pHandler->ServiceID )
				//	pHandler->ServiceID = g.my_message_id;
				if( ( pHandler->RouteID.source.process_id != MessageEvent->dest.process_id )
               || ( pHandler->RouteID.source.service_id != MessageEvent->dest.service_id ) )
				{
					// if it's not from this handler's server... try the next.
					continue;
				}
				Msg = MessageEvent->hdr.msgid;
				//lprintf( WIDE("Msg now %d base %d %d"), Msg, pHandler->MsgBase, pHandler->MsgCountEvents );
 // have a handler
				if(( pHandler->Handler
 // have a fancier handler....
					 || pHandler->HandlerEx
 // or an even fancier handler...
                || pHandler->HandlerExx )
 // not negative result (msg IS 32 bits)
				  && !( Msg & 0x80000000 )
				  /*&& ( Msg < pHandler->MsgCountEvents )*/
 // in range of handler
 )
				{
					int result_yesno;
#ifdef DEBUG_EVENTS
					lprintf( WIDE("Dispatch event message to handler...") );
#endif
					pHandler->flags.dispatched = 1;
					if( pHandler->Handler )
					{
						//lprintf( WIDE("small handler") );
						result_yesno = pHandler->Handler( Msg, (uint32_t*)((&MessageEvent->hdr)+1), MessageLen - sizeof( MSGHDR ) );
					}
					else if( pHandler->HandlerEx )
					{
						//lprintf( WIDE("ex handler...%d"), Msg );
						result_yesno = pHandler->HandlerEx( (PSERVICE_ROUTE)MessageEvent
																	 , Msg
																	 , (uint32_t*)((&MessageEvent->hdr)+1)
																	 , MessageLen - sizeof( MSGHDR ) );
					}
					else if( pHandler->HandlerExx )
					{
						//lprintf( WIDE("ex handler...%d"), Msg );
						result_yesno = pHandler->HandlerExx( pHandler->psv
																	  , (PSERVICE_ROUTE)(uintptr_t)MessageEvent->hdr.source.process_id
																	  , Msg
																	  , (uint32_t*)((&MessageEvent->hdr)+1)
																	  , MessageLen - sizeof( MSGHDR ) );
					}
					if( result_yesno & EVENT_WAIT_DISPATCH )
					{
						//lprintf( WIDE("Setting status to send dispatch_events...") );
						pHandler->flags.notify_if_dispatched = 1;
					}
					pHandler->flags.dispatched = 0;
					break;
				}
			}
		}
	}
	if( receive_count )
		return 1;
	return 0;
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( int, ProcessClientMessages )( uintptr_t unused )
{
	static uint32_t MessageBuffer[2048];
	if( IsThisThread( g.pEventThread ) )
	{
		lprintf( WIDE("External handle event messages...") );
/*IPC_NOWAIT*/
		return HandleEvents( g.msgq_event, (PQMSG)MessageBuffer, 0 );
	}
	if( g.pLocalEventThread && IsThisThread( g.pLocalEventThread ) )
	{
#ifdef LOG_LOCAL_EVENT
		lprintf( WIDE("External handle local event messages...") );
#endif
		// if this is thE thread... chances are someone can wake it up
		// and it is allowed to go to sleep.  This thread is indeed wakable
		// by normal measures.
/*IPC_NOWAIT*/
		return HandleEvents( g.msgq_local, (PQMSG)MessageBuffer, 0 );
	}
	return -1;
}
MSGCLIENT_NAMESPACE_END
//-------------------------------------------------------------
MSGCLIENT_NAMESPACE
PTRANSACTIONHANDLER GetTransactionHandler( PSERVICE_ROUTE route )
{
	PTRANSACTIONHANDLER handler = g.pTransactions;
	while( handler )
	{
		if( handler->route == route )
			break;
		handler = NextThing( handler );
	}
	if( !handler )
	{
		handler = New( TRANSACTIONHANDLER );
		MemSet( handler, 0, sizeof( TRANSACTIONHANDLER ) );
		InitializeCriticalSec( &handler->csMsgTransact );
		handler->route = route;
		LinkThing( g.pTransactions, handler );
	}
	return handler;
}
//--------------------------------------------------------------------
static int GetAMessageEx( MSGQ_TYPE msgq, MSGIDTYPE MsgFilter, CTEXTSTR q, int flags DBG_PASS )
#define GetAMessage(m,x,f) GetAMessageEx(m,x,_WIDE(#m),f DBG_SRC)
{
	//int bLog = 0;
	if( IsThisThread( g.pThread ) )
	{
		int logged = 0;
		PQMSG MessageIn = GetMessageBuffer();
		int MessageLen;
		do
		{
			//if( bLog )
#ifdef DEBUG_THREADS
			lprintf( WIDE("Attempt to recieve for %08lx %p"), MsgFilter, msgq );
#endif
			//lprintf( "vvv" );
			MessageLen = msgrcv( msgq, MSGTYPE MessageIn, 8192, MsgFilter, flags );
#ifdef DEBUG_DATA_XFER
			LogBinary( (uint8_t*)MessageIn, MessageLen + sizeof( MSGIDTYPE ) );
#endif
			//lprintf( "^^^" );
			//lprintf( WIDE("Got a receive...") );
 // retry
			if( ( MessageLen == (-((int32_t)sizeof(MSGIDTYPE))) ) )
			{
				lprintf( WIDE("Recieved -4 message (no data?!) no message, should have been -1, ENOMSG") );
				MessageIn->hdr.msgid = RU_ALIVE;
 // continue on do-while checks while condition - gofigure.
				continue;
			}
			if( MessageLen == -1 )
			{
#ifdef _WIN32
				int my_errno = GetLastError();
#  ifdef errno
#    undef errno
#  endif
#  define errno my_errno
#endif
				if( errno == ENOMSG )
				{
					lprintf( WIDE("No message... nowait was set?") );
					return 0;
				}
				else if( errno == EIDRM )
				{
					lprintf( WIDE("No message... Message queue removed") );
					return -1;
				}
				else
				{
					if( errno == EINTR ){
						//bLog = 1;
						//lprintf( WIDE("Error Interrupt - that's okay...") );
					}
					else if( errno == EINVAL )
					{
						lprintf( WIDE("msgrecv on q %d is invalid! open it. or what is %") _MsgID_f WIDE("(%08") _MsgID_f WIDE(") or %08d")
								 , msgq, g.my_message_id, g.my_message_id, flags );
					}
					else
					{
						xlprintf( LOG_ALWAYS )( WIDE("msgrcv resulted in error: %d"), errno );
					}
 // loop back around.
					MessageIn->hdr.msgid = RU_ALIVE;
				}
			}
			else
			{
				if( MessageIn->dest.process_id == 0 )
				{
					lprintf( WIDE("---------- DO NOT BE HERE ----------------") );
					HandleCoreMessage( MessageIn, (MessageLen-(sizeof(QMSG)-sizeof(MSGIDTYPE))) DBG_SRC );
				}
			}
		}
		while( !g.flags.disconnected
  // RU_ALIVE receives are no receive.
				&& MessageIn->hdr.msgid == RU_ALIVE );
#ifdef DEBUG_THREADS
		lprintf( WIDE("Responce received...%08lX"), MessageIn->hdr.msgid );
#endif
		if( !g.flags.disconnected )
		{
			int cnt = 0;
			INDEX idx;
			PSLEEPER sleeper;
#ifdef DEBUG_THREADS
			lprintf( WIDE("waking sleepers.") );
#endif
			LIST_FORALL( g.pSleepers, idx, PSLEEPER, sleeper )
			{
				if( (MessageIn->dest.process_id == sleeper->handler->route->source.process_id )
					&& ( ( ( MessageIn->hdr.msgid & 0xFFFFFFF ) == MSG_ServiceLoad )
					    || (MessageIn->dest.service_id == sleeper->handler->route->source.service_id ) ) )
				{
 // set to enable application to get it's message...
					sleeper->handler->flags.responce_received = 1;
					sleeper->handler->MessageIn = MessageIn;
					sleeper->handler->MessageLen = MessageLen;
					cnt++;
#ifdef DEBUG_THREADS
					lprintf( WIDE("Wake thread waiting for responces...%p"), sleeper->thread  );
#endif
					WakeThread( sleeper->thread );
				}
			}
			if( !cnt )
			{
			//lprintf( WIDE("FATALITY - received responce from service, and noone was waiting for it!") );
			//lprintf( WIDE("No Sleepers woken - maybe - they haven't gotten around to sleeping yet?") );
			}
		}
	}
	else
	{
		//lprintf( WIDE("Not the message thread... exiting quietly... %d %p %d %Ld")
		//	, g.my_message_id
		//	 , g.pThread
		//	 , getpid()
		//		, g.pThread->ThreadID
		//	);
		return 2;
	}
	return 1;
}
//--------------------------------------------------------------------
// the work in this routine is basically to
// find a handler to receive into?
int WaitReceiveServerMsg ( PSLEEPER sleeper
					, uint32_t MsgOut
					DBG_PASS )
{
	PTRANSACTIONHANDLER handler = sleeper->handler;
	if( sleeper->thread )
	{
		int received;
		int IsThread = IsThisThread( g.pThread );
		//lprintf( WIDE("waiting for cmd result") );
#ifdef DEBUG_THREAD
		lprintf( WIDE("This thread? %s"), IsThread?"Yes":"No" );
#endif
		do
		{
			// this library is totally serialized for one transaction
			// at a time, from multiple threads.
			received = 0;
			while( ( handler->flags.bCheckedResponce ||
					  !handler->flags.responce_received ) &&
					(
#ifdef DEBUG_DATA_XFER
#ifdef _DEBUG
					 (lprintf( WIDE("Compare %") _32f WIDE(" vs %") _32f WIDE(" (=%") _32fs WIDE(") (positive keep waiting)")
								, handler->wait_for_responce
								, timeGetTime()
								, handler->wait_for_responce - timeGetTime()  ) ),
#endif
#endif
 // wait for a responce
					( handler->wait_for_responce > timeGetTime() )) )
			{
				received = 1;
				// check for responces...
				// will return immediate if is not this thread which
				// is supposed to be there...
#ifdef DEBUG_DATA_XFER
				_lprintf(DBG_RELAY)( WIDE("getting or waiting for... a message...") );
#endif
				if( IsThread )
				{
					lprintf( WIDE("Get message (might be my thread") );
					if( GetAMessage( g.msgq_in, g.my_message_id, IPC_NOWAIT ) == 2 )
					{
						Log( WIDE("Okay - won't check for messages anymore - just wait...") );
						IsThread = 0;
					}
				}
				// seperate test, can decide to not be the thread...
				if( !IsThread )
				{
					if( handler->flags.responce_received && !handler->flags.bCheckedResponce )
					{
						DeleteLink( &g.pSleepers, sleeper );
						goto dont_sleep;
					}
					handler->flags.bCheckedResponce = 0;
					//lprintf( WIDE("Going to sleep for %")_32fs
					//		 , handler->wait_for_responce - timeGetTime()
					//		 );
					WakeableSleep( handler->wait_for_responce - timeGetTime() );
					//lprintf( WIDE("AWAKE! %d"), handler->flags.responce_received );
					DeleteLink( &g.pSleepers, sleeper );
				}
				else
				{
					Relinquish();
				}
			}
		       // timeout...?
			if( !handler->flags.bCheckedResponce )
				received = 1;
			//lprintf( WIDE("When we finished this loop still was waiting %")_32fs, handler->wait_for_responce - timeGetTime() );
			//else
			{
				//lprintf( WIDE("Excellent... the responce is back before I could sleep!") );
			}
			if( !handler->flags.responce_received )
			{
				Log( WIDE("Responce timeout!") );
				handler->flags.waiting_for_responce = 0;
				LeaveCriticalSec( &handler->csMsgTransact );
 // DONE - fail! abort!
				return FALSE;
			}
			else
			{
				//Log( WIDE("Result to application... ") );
			}
		dont_sleep: ;
			handler->flags.bCheckedResponce = 1;
			//lprintf( WIDE("Read message...") );
			// if the message is a response to me.....
		}
		while( received && ReceiveServerMessageEx( handler, handler->MessageIn, handler->MessageLen DBG_RELAY ) );
		if( received )
		{
			handler->flags.waiting_for_responce = 0;
			//Log2( WIDE("Got responce: %08x %d long"), *MsgIn, LengthIn?*LengthIn:-1 );
			if( ( *handler->MessageID & 0x0FFFFFFF ) != ( (handler->LastMsgID) & 0x0FFFFFFF ) )
			{
				lprintf( WIDE("Mismatched server responce to client message: %")_MsgID_f WIDE(" to %")_MsgID_f
						 , *handler->MessageID & 0x0FFFFFFF
						 , handler->LastMsgID & 0x0FFFFFFF
						  );
			}
			else
			{
				if( handler->route->dest.process_id == 1
				  && handler->route->dest.service_id == 0
				  && MsgOut == MSG_ServiceLoad
				  && ( (*handler->MessageID) & SERVER_SUCCESS ) )
				{
					handler->route->dest = handler->MessageIn->hdr.source;
				}
			}
			//lprintf( WIDE( "Clear received response" ) );
			//handler->flags.responce_received = 0; // allow more responces to be received.
		}
	}
	if( handler )
	{
		//lprintf( WIDE("cleanup...%p"), handler );
		handler->flags.waiting_for_responce = 0;
		//LeaveCriticalSec( &handler->csMsgTransact );
	}
	//lprintf( WIDE("done waiting...") );
	return TRUE;
}
// the work in this routine is basically to
// find a handler to receive into?
int QueueWaitReceiveServerMsg ( PSLEEPER sleeper, PTRANSACTIONHANDLER handler
										  , MSGIDTYPE *MsgIn
										  , POINTER BufferIn
										  , size_t *LengthIn
											DBG_PASS )
{
	if( MsgIn )
	{
		//lprintf( WIDE("waiting for cmd result") );
#ifdef DEBUG_THREAD
		lprintf( WIDE("This thread? %s"), IsThread?"Yes":"No" );
#endif
		handler->MessageID = MsgIn;
		handler->msg = BufferIn;
		handler->len = LengthIn;
		handler->flags.bCheckedResponce = 0;
		sleeper->thread = MakeThread();
		sleeper->handler = handler;
		AddLink( &g.pSleepers, sleeper );
	}
	else
	{
		sleeper->handler = handler;
		sleeper->thread = NULL;
	}
	//lprintf( WIDE("done waiting...") );
	return TRUE;
}
uintptr_t CPROC HandleMessages( PTHREAD thread )
{
	MSGIDTYPE MsgFilter = (MSGIDTYPE)GetThreadParam( thread );
	g.pThread = thread;
#ifdef DEBUG_THREADS
	lprintf( WIDE("threadID: %lx"), g.my_message_id );
#endif
	g.flags.message_responce_handler_ready = TRUE;
	while( !g.flags.disconnected )
	{
		int r;
		//Log( WIDE("enter read a message...") );
		if( ( r = GetAMessage( g.msgq_in, MsgFilter, 0 ) ) < 0 )
		{
			Log( WIDE("thread is exiting...") );
			g.flags.message_responce_handler_ready = FALSE;
			break;
		}
		if( r == 2 )
		{
			Log( WIDE("THIS thread is no longer THE thread!?!?!?!?!?!") );
			break;
		}
	}
	g.pThread = NULL;
	return 0;
}
MSGCLIENT_NAMESPACE_END
//-------------------------------------------------------------
MSGCLIENT_NAMESPACE
//--------------------------------------------------------------------
uintptr_t CPROC HandleLocalEventMessages( PTHREAD thread )
{
	g.pLocalEventThread = thread;
	g.flags.local_events_ready = TRUE;
	//g.my_message_id = getpid(); //(uint32_t)( thread->ThreadID & 0xFFFFFFFF );
	while( !g.flags.disconnected )
	{
		int r;
		if( thread == g.pLocalEventThread )
		{
			// thread local storage :)
			static int levels;
			static uint32_t *pBuffer;
 // 8192 bytes
			static uint32_t MessageEvent[2048];
			if( !levels )
				pBuffer = MessageEvent;
			else
				pBuffer = (uint32_t*)Allocate( sizeof( MessageEvent ) );
			levels++;
			//lprintf( WIDE("---- GET A LOCAL EVENT!") );
			if( ( r = HandleEvents( g.msgq_local, (PQMSG)pBuffer, 0 ) ) < 0 )
			{
				Log( WIDE("EventHandler has reported a fatal error condition.") );
				break;
			}
			levels--;
			if( levels )
				Release( pBuffer );
		}
		else if( r == 2 )
		{
			Log( WIDE("Thread has been restarted.") );
			// don't clear ready or main event flag
			// things.
			return 0;
		}
	}
	g.flags.local_events_ready = FALSE;
	g.pLocalEventThread = NULL;
	return 0;
}
MSGCLIENT_NAMESPACE_END
MSGCLIENT_NAMESPACE
//--------------------------------------------------------------------
int SendInMultiMessageEx( PSERVICE_ROUTE routeID, uint32_t MsgID, uint32_t parts, BUFFER_LENGTH_PAIR *pairs DBG_PASS)
{
	CPOINTER msg;
	size_t len;
	size_t ofs;
	uint32_t param;
	PQMSG MessageOut;
	// shouldn't use MessageOut probably.. ..
	// protect msgout against multiple people.. ..
	EnterCriticalSec( &g.csMsgTransact );
	MessageOut = GetMessageBuffer();
	MessageOut->dest.process_id              = routeID->dest.process_id;
	MessageOut->dest.service_id     = routeID->dest.service_id;
	MessageOut->hdr.source.process_id = routeID->source.process_id;
	MessageOut->hdr.source.service_id = routeID->source.service_id;
	MessageOut->hdr.msgid = MsgID;
	ofs = 0;
	for( param = 0; param < parts; param++ )
	{
		msg = pairs[param].buffer;
		len = pairs[param].len;
		if( len + ofs > 8192 )
		{
		// wow - this is a BIG message - lets see - what can we do?
#ifdef WIN32
#undef SetLastError
			SetLastError( E2BIG );
#else
			errno = E2BIG;
#endif
			_lprintf(DBG_RELAY)( WIDE("Length of message is too big to transport...%") _size_f WIDE(" (len %") _size_f WIDE(" ofs %") _size_f WIDE(")"), len + ofs, len, ofs );
			LeaveCriticalSec( &g.csMsgTransact );
			return FALSE;
		}
		if( msg && len )
		{
			//Log3( WIDE("Adding %d bytes at %d: %08x "), len, ofs, ((uint32_t*)msg)[0] );
			MemCpy( ((char*)QMSGDATA(MessageOut)) + ofs, msg, len );
			ofs += len;
		}
	}
	{
		int stat;
	// send to application inbound queue..
#ifdef DEBUG_OUTEVENTS
		lprintf( WIDE("Sending result to application...") );
		LogBinary( (uint8_t*)MessageOut, ofs );
#endif
		stat = msgsnd( g.msgq_in, MSGTYPE MessageOut, ofs + sizeof(QMSG) - sizeof( MSGIDTYPE ), 0 );
		DropMessageBuffer( MessageOut );
		LeaveCriticalSec( &g.csMsgTransact );
		return !stat;
	}
}
int SendInMultiMessage( PSERVICE_ROUTE routeID, uint32_t MsgID, uint32_t parts, BUFFER_LENGTH_PAIR *pairs )
#define SendInMultiMessage(r,m,parts,pairs) SendInMultiMessageEx(r,m,parts,pairs DBG_SRC )
{
	return SendInMultiMessage( routeID, MsgID, parts, pairs);
}
//--------------------------------------------------------------------
int SendInMessage( PSERVICE_ROUTE routeID, uint32_t MsgID, POINTER buffer, size_t len )
{
	BUFFER_LENGTH_PAIR pair;
	pair.buffer = buffer;
	pair.len = len;
	return SendInMultiMessage( routeID, MsgID, 1, &pair );
}
//--------------------------------------------------------------------
#ifdef _DEBUG_RECEIVE_DISPATCH_
int metamsgrcv( MSGQ_TYPE q, POINTER p, int len, long id, int opt DBG_PASS )
{
	int stat;
	_xlprintf(1 DBG_RELAY)( WIDE("*** Read Message %d"), id);
	stat = msgrcv( q,MSGTYPE p,len,id,opt );
#undef msgrcv
	#define msgrcv(q,p,l,i,o) metamsgrcv(q,p,l,i,o DBG_SRC)
	_xlprintf(1 DBG_RELAY)( WIDE("*** Got message %d"), stat );
	return stat;
}
#endif
static int PrivateSendTransactionResponseMultiMessageEx( PSERVICE_ROUTE DestID
																, uint32_t MessageID, uint32_t buffers
																, BUFFER_LENGTH_PAIR *pairs
																 DBG_PASS )
#define PrivateSendTransactionResponseMultiMessage(d,m,bu,p) PrivateSendTransactionResponseMultiMessageEx(d,m,bu,p DBG_SRC )
{
	CPOINTER msg;
	size_t len, ofs;
	uint32_t param;
	int status;
	PQMSG MessageOut;
	if( g.flags.disconnected )
	{
		_lprintf(DBG_RELAY)( WIDE("Have already disconnected from server... no further communication possible.") );
		return TRUE;
	}
	MessageOut = GetMessageBuffer();
	MessageOut->dest.process_id       = DestID->dest.process_id;
	MessageOut->dest.service_id		  = DestID->dest.service_id;
	MessageOut->hdr.source.process_id = DestID->source.process_id;
	MessageOut->hdr.source.service_id = DestID->source.service_id;
	MessageOut->hdr.msgid             = MessageID;
	// don't know len at this point.. .. ..
	//if( len > 8188 )
	//{
		// wow - this is a BIG message - lets see - what can we do?
		//SetLastError( E2BIG );
		//lprintf( WIDE("Lenght of message is too big to transport...") );
		//return FALSE;
	//}
	ofs = 0;
	//Log1( WIDE("Adding %d params"), buffers );
	for( param = 0; param < buffers; param++ )
	{
		msg = pairs[param].buffer;
		len = pairs[param].len;
		if( len + ofs > 8192 )
		{
		// wow - this is a BIG message - lets see - what can we do?
#ifdef WIN32
			SetLastError( E2BIG );
#else
			errno = E2BIG;
#endif
			_lprintf(DBG_RELAY)( WIDE("Length of message is too big to transport...%") _size_f WIDE(" (len %") _size_f WIDE(" ofs %") _size_f WIDE(")"), len + ofs, len, ofs );
			return FALSE;
		}
		if( msg && len )
		{
			//Log3( WIDE("Adding %d bytes at %d: %08x "), len, ofs, ((uint32_t*)msg)[0] );
			MemCpy( ((char*)QMSGDATA( MessageOut )) + ofs, msg, len );
			ofs += len;
		}
	}
	// subtract 4 from the offset (the msg_id is not counted)
	//Log2( WIDE("Sent %d  (%d) bytes"), g.MessageOut[0], ofs - sizeof( MSGIDTYPE ) );
	// 0 success, non zero failure - return notted state
				  //lprintf( WIDE("Send Message. %08lX"), *(uint32_t*)g.MessageOut );
	//_xlprintf( 1 DBG_RELAY )( "blah." );
#ifdef LOG_SENT_MESSAGES
	_lprintf(DBG_RELAY)( "Send is %d", ofs );
#endif
	status = !msgsnd( g.msgq_out, MSGTYPE MessageOut, ofs + sizeof( QMSG )- sizeof( MSGIDTYPE ), 0 );
	DropMessageBuffer( MessageOut );
	return status;
}
CLIENTMSG_PROC( int, SendServerMultiMessage )( PSERVICE_ROUTE RouteID, uint32_t MessageID, uint32_t buffers, ... )
{
	BUFFER_LENGTH_PAIR *pairs = (BUFFER_LENGTH_PAIR*)Allocate( sizeof( BUFFER_LENGTH_PAIR ) * buffers );
	uint32_t n;
	va_list args;
	int status;
	va_start( args, buffers );
	for( n = 0; n < buffers; n++ )
	{
		pairs[n].buffer = va_arg( args, POINTER );
		pairs[n].len = va_arg( args, uint32_t );
	}
	status = PrivateSendTransactionResponseMultiMessage( RouteID, MessageID, buffers, pairs );
	Release( pairs );
	return status;
}
CLIENTMSG_PROC( int, SendRoutedServerMultiMessage )( PSERVICE_ROUTE RouteID, uint32_t MessageID, uint32_t buffers, ... )
{
	int status;
	BUFFER_LENGTH_PAIR *pairs = (BUFFER_LENGTH_PAIR*)Allocate( sizeof( BUFFER_LENGTH_PAIR ) * buffers );
	uint32_t n;
	va_list args;
	va_start( args, buffers );
	for( n = 0; n < buffers; n++ )
	{
		pairs[n].buffer = va_arg( args, POINTER );
		pairs[n].len = va_arg( args, uint32_t );
	}
	status = PrivateSendTransactionResponseMultiMessage( RouteID, MessageID, buffers, pairs );
	Release( pairs );
	return status;
}
CLIENTMSG_PROC( int, SendRoutedServerMessage )( PSERVICE_ROUTE RouteID, uint32_t MessageID, POINTER buffer, size_t len )
{
	int status;
	BUFFER_LENGTH_PAIR pair;
	pair.buffer = buffer;
	pair.len = len;
	status = PrivateSendTransactionResponseMultiMessage( RouteID, MessageID, 1, &pair );
	return status;
}
CLIENTMSG_PROC( int, SendServerMessage )( PSERVICE_ROUTE RouteID, uint32_t MessageID, POINTER msg, size_t len )
{
	BUFFER_LENGTH_PAIR pair;
	int status;
	pair.buffer = msg;
	pair.len = len;
	status = PrivateSendTransactionResponseMultiMessage( RouteID, MessageID, 1, &pair );
	return status;
}
// returns FALSE on timeout, else success.
// this is used by msg.core.dll - used for forwarding messages
// to real handlers...
CLIENTMSG_PROC( int, TransactRoutedServerMultiMessageEx )( PSERVICE_ROUTE RouteID
																			, MSGIDTYPE MsgOut, uint32_t buffers
																			, MSGIDTYPE *MsgIn
																			, POINTER BufferIn, size_t *LengthIn
																			, uint32_t timeout
																			// buffer starts arg list, length is
																			// not used, but is here for demonstration
																			, ... )
{
	BUFFER_LENGTH_PAIR *pairs = (BUFFER_LENGTH_PAIR*)Allocate( sizeof( BUFFER_LENGTH_PAIR ) * buffers );
	uint32_t n;
	va_list args;
	SLEEPER sleeper;
	int status;
	PTRANSACTIONHANDLER handler = GetTransactionHandler( RouteID );
	// can send the message, but may not get another responce
	// until the first is done...
	if( MsgIn || BufferIn )
	{
		if( !handler )
		{
			lprintf( WIDE("We have no business being here... no loadservice has been made to this service!") );
			return 0;
		}
		//lprintf( WIDE("Enter %p"), handler );
		EnterCriticalSec( &handler->csMsgTransact );
		switch( MsgOut )
		{
		case RU_ALIVE:
			//lprintf( WIDE("Lying about message to expect") );
			handler->LastMsgID = IM_ALIVE;
			break;
		default:
			//lprintf( WIDE("set last msgID %") _MsgID_f, MsgOut );
			handler->LastMsgID = MsgOut;
			break;
		}
		if( ( handler->MessageID = MsgIn ) )
			(*MsgIn) = handler->LastMsgID;
		handler->wait_for_responce = timeGetTime() + (timeout?timeout:DEFAULT_TIMEOUT);
	}
	//lprintf( WIDE("transact message...") );
	va_start( args, timeout );
	for( n = 0; n < buffers; n++ )
	{
		pairs[n].buffer = va_arg( args, POINTER );
		pairs[n].len = va_arg( args, uint32_t );
	}
	QueueWaitReceiveServerMsg( &sleeper, handler
											, MsgIn
											, BufferIn
											, LengthIn
											 DBG_SRC );
	if( !( PrivateSendTransactionResponseMultiMessage( RouteID, MsgOut, buffers
															  , pairs ) ) )
	{
		DeleteLink( &g.pSleepers, &sleeper );
		Release( pairs );
		if( handler )
		{
			handler->flags.waiting_for_responce = 0;
			LeaveCriticalSec( &handler->csMsgTransact );
		}
		 return FALSE;
	}
	Release( pairs );
	//lprintf( WIDE("Entering wait after serving a message...") );
	if( MsgIn || (BufferIn && LengthIn) )
	{
		status = WaitReceiveServerMsg( &sleeper, MsgOut DBG_SRC );
	}
	else
	{
		handler->flags.waiting_for_responce = 0;
		LeaveCriticalSec( &handler->csMsgTransact );
		status = TRUE;
	}
	DeleteLink( &g.pSleepers, &sleeper );
	return status;
}
struct debug_transact {
	CTEXTSTR pFile;
	int nLine;
}next_transact;
#undef TransactServerMultiMessage
CLIENTMSG_PROC( int, TransactServerMultiMessage )( PSERVICE_ROUTE RouteID, MSGIDTYPE MsgOut, uint32_t buffers
										, MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn
										 // buffer starts arg list, length is
										 // not used, but is here for demonstration
										, ... )
{
	SLEEPER sleeper;
	BUFFER_LENGTH_PAIR *pairs = (BUFFER_LENGTH_PAIR*)Allocate( sizeof( BUFFER_LENGTH_PAIR ) * buffers );
	PTRANSACTIONHANDLER handler = GetTransactionHandler( RouteID );
	uint32_t n;
	va_list args;
	int stat;
	va_start( args, LengthIn );
	for( n = 0; n < buffers; n++ )
	{
		pairs[n].buffer = va_arg( args, CPOINTER );
		pairs[n].len = va_arg( args, uint32_t );
	}
	//if( MsgOut == 0x23f )
	//	DebugBreak();
	QueueWaitReceiveServerMsg( &sleeper, handler
											, MsgIn
											, BufferIn
											, LengthIn
											 DBG_SRC );
#ifdef LOG_SENT_MESSAGES
	lprintf( WIDE( "%s(%d):Sending message..." ), next_transact.pFile, next_transact.nLine );
#endif
	switch( MsgOut )
	{
	case RU_ALIVE:
		lprintf( WIDE("Lying about message to expect") );
		handler->LastMsgID = IM_ALIVE;
		break;
	default:
		//lprintf( WIDE("set last msgID %ld"), MsgOut );
		handler->LastMsgID = MsgOut;
		break;
	}
#if defined( _DEBUG ) || defined( _DEBUG_INFO )
	if( !( PrivateSendTransactionResponseMultiMessageEx( RouteID, MsgOut, buffers
																	, pairs
																	, next_transact.pFile, next_transact.nLine
																	) ) )
#else
	if( !( PrivateSendTransactionResponseMultiMessageEx( RouteID, MsgOut, buffers
																	, pairs
																	) ) )
#endif
	{
		//lprintf( WIDE("Leaving...") );
		//handler->flags.wait_for_responce = 0;
		//LeaveCriticalSec( &handler->csMsgTransact );
		DeleteLink( &g.pSleepers, &sleeper );
		Release( pairs );
		return FALSE;
	}
	Release( pairs );
	handler->wait_for_responce = timeGetTime() + (DEFAULT_TIMEOUT);
	//lprintf( WIDE("waiting... %p"), handler );
	if( MsgIn || (BufferIn && LengthIn) )
		stat = WaitReceiveServerMsg( &sleeper, MsgOut DBG_SRC );
	else
	{
		handler->flags.waiting_for_responce = 0;
		LeaveCriticalSec( &handler->csMsgTransact );
		stat = TRUE;
	}
	DeleteLink( &g.pSleepers, &sleeper );
	//lprintf( WIDE("Done %p %d"),handler, stat );
	return stat;
}
// buffer starts arg list, length is
// not used, but is here for demonstration
CLIENTMSG_PROC( TSMMProto, TransactServerMultiMessageExEx )( DBG_VOIDPASS )
{
#ifdef LOG_SENT_MESSAGES
#  ifdef _DEBUG
	next_transact.pFile = pFile;
	next_transact.nLine = nLine;
#  endif
#endif
	return TransactServerMultiMessage;
}
CLIENTMSG_PROC( int, TransactServerMultiMessageEx )( PSERVICE_ROUTE RouteID, MSGIDTYPE MsgOut, uint32_t buffers
																	, MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn
																	, uint32_t timeout
																	 // buffer starts arg list, length is
																	 // not used, but is here for demonstration
																	, ... )
{
	SLEEPER sleeper;
	BUFFER_LENGTH_PAIR *pairs = (BUFFER_LENGTH_PAIR*)Allocate( sizeof( BUFFER_LENGTH_PAIR ) * buffers );
	PTRANSACTIONHANDLER handler = GetTransactionHandler( RouteID );
	uint32_t n;
	va_list args;
	int stat;
	va_start( args, timeout );
	for( n = 0; n < buffers; n++ )
	{
		pairs[n].buffer = va_arg( args, POINTER );
		pairs[n].len = va_arg( args, uint32_t );
	}
	QueueWaitReceiveServerMsg( &sleeper, handler
											, MsgIn
											, BufferIn
											, LengthIn
											 DBG_SRC );
	if( !(PrivateSendTransactionResponseMultiMessage( RouteID, MsgOut, buffers
															 , pairs ) ) )
	{
		DeleteLink( &g.pSleepers, &sleeper );
		Release( pairs );
		handler->flags.waiting_for_responce = 0;
		LeaveCriticalSec( &handler->csMsgTransact );
		return FALSE;
	}
	Release( pairs );
	handler->wait_for_responce = timeGetTime() + (timeout?timeout:DEFAULT_TIMEOUT);
	if( MsgIn || (BufferIn && LengthIn) )
		stat = WaitReceiveServerMsg( &sleeper, MsgOut DBG_SRC );
	else
	{
		handler->flags.waiting_for_responce = 0;
		LeaveCriticalSec( &handler->csMsgTransact );
		stat = TRUE;
	}
	DeleteLink( &g.pSleepers, &sleeper );
	return stat;
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( int, TransactServerMessageEx)( PSERVICE_ROUTE RouteID, MSGIDTYPE MsgOut, CPOINTER BufferOut, size_t LengthOut
						  , MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn DBG_PASS )
{
	return TransactServerMultiMessageExEx(DBG_VOIDRELAY)( RouteID, MsgOut, 1, MsgIn, BufferIn, LengthIn
												, BufferOut, LengthOut );
}
//--------------------------------------------------------------------
CLIENTMSG_PROC( int, TransactServerMessageExx)( PSERVICE_ROUTE RouteID, MSGIDTYPE MsgOut, CPOINTER BufferOut, size_t LengthOut
															 , MSGIDTYPE *MsgIn, POINTER BufferIn, size_t *LengthIn
															  , uint32_t timeout DBG_PASS )
{
#ifdef LOG_SENT_MESSAGES
#  ifdef _DEBUG
	next_transact.pFile = pFile;
	next_transact.nLine = nLine;
#  endif
#endif
	return TransactServerMultiMessageEx( RouteID, MsgOut, 1, MsgIn, BufferIn, LengthIn, timeout
												  , BufferOut, LengthOut );
}
MSGCLIENT_NAMESPACE_END
MSGCLIENT_NAMESPACE
//--------------------------------------------------------------------
LOGICAL HandleCoreMessage( PQMSG msg, size_t msglen DBG_PASS )
{
#ifdef DEBUG_SERVICE_INPUT
	lprintf( WIDE("Read message to %d (%08x)"), msglen, msg->hdr.msgid );
#endif
	if( msg->hdr.msgid == IM_TARDY )
	{
		PTRANSACTIONHANDLER handler;
		lprintf( WIDE("Server wants to extend timout to %") _32f WIDE(""), QMSGDATA( msg )[0] );
		for( handler = g.pTransactions; handler; handler = handler->next )
			if( ( handler->route->dest.process_id == msg->dest.process_id )
				&& ( handler->route->dest.service_id == msg->dest.service_id ) )
			{
			// result of IM_TARDY, add an amount of time to the message...
				handler->wait_for_responce = msg->hdr.msgid + timeGetTime();
				break;
			}
		if( !handler )
		{
			lprintf( WIDE("A service announced it was going to be tardy to someone who was not talking to it!") );
			DebugBreak();
		}
		// okay continue in a do_while will execute the while condition
		// also, much like while(){} will...
		msg->hdr.msgid = RU_ALIVE;
 // handled.
		return TRUE;
	}
	else if( msg->hdr.msgid == RU_ALIVE )
	{
		QMSG Msg;
#ifdef DEBUG_MESSAGE_BASE_ID
		DBG_VARSRC;
#endif
		//Log( WIDE("Got RU_ALIVE am responding  AM ALIVE!!") );
		Msg.dest.process_id              = msg->hdr.source.process_id;
		Msg.dest.service_id     = msg->hdr.source.service_id;
		Msg.hdr.source.process_id = msg->dest.process_id;
		Msg.hdr.source.service_id = msg->dest.service_id;
		Msg.hdr.msgid = IM_ALIVE;
		// by using the input message queue, it makes sure that
		// both sides are processing input messages... otherwise
		// previously queued messages would be received first.
		msgsnd( g.msgq_in, MSGTYPE &Msg, sizeof(QMSG) - sizeof( MSGIDTYPE ), 0 );
 // handled.
		return TRUE;
	}
	else if( msg->hdr.msgid == IM_ALIVE )
	{
		PSERVICE_CLIENT client = FindClient( (PSERVICE_ROUTE)&msg );
#ifdef DEBUG_RU_ALIVE_CHECK
		lprintf( WIDE("Got message IM_ALIVE from client... %") _32f WIDE(""), msg->hdr.source.process_id );
#endif
		if( client )
		{
			//lprintf( WIDE("Updating client %p with current time...allowing him to requery.."), client );
			if( client->flags.status_queried )
			{
				client->flags.status_queried = 0;
				// fake a get-next-message... if status_queried is NOT set
				// then, this is a request of ProbeClientAlive.
				msg->hdr.msgid = RU_ALIVE;
			}
			client->last_time_received = timeGetTime();
		}
		// go back to top and get another message...
		// application can care about this...
		// maybe should check...
		//msg->hdr.msgid = RU_ALIVE;
 // handled.
		return TRUE;
	}
	return FALSE;
}
uintptr_t CPROC HandleServiceMessages( PTHREAD thread )
//#define DoHandleServiceMessages(p) DoHandleServiceMessagesEx(p DBG_SRC)
{
	static uint32_t one = 1;
	LOGICAL master_service = (LOGICAL)GetThreadParam( thread );
	int32_t length;
	MSGIDTYPE msgid;
 // default to ...
	size_t result_length = INVALID_INDEX;
	// can't use getpid cause we really want the threadID
	// also this value may NOT be negative.
	PQMSG recv = (PQMSG)Allocate( MSG_DEFAULT_RESULT_BUFFER_MAX );
	PQMSG result = (PQMSG)Allocate( MSG_DEFAULT_RESULT_BUFFER_MAX );
	// consume any outstanding messages... so we don't get confused
	// someone may have requested things for this service...
	//lprintf( "vvv" );
	(msgid=master_service?one:g.my_message_id);
#ifdef DEBUG_DATA_XFER
	lprintf( "Recieving on %ld", msgid );
#endif
	while( msgrcv( g.msgq_out
					 , MSGTYPE recv
					 , 8192
					 , msgid
					 , IPC_NOWAIT ) > 0 )
	{
		//lprintf( WIDE("Dropping a message...") );
	}
			//lprintf( "^^^" );
	while( !g.flags.disconnected )
	{
		//lprintf( WIDE("service is waiting for messages to %08lx"), g.my_message_id );
		// receiving from the 'out' queue which is commands TO a service.
			//lprintf( "vvv" );
		g.flags.bWaitingInReceive = 1;
#ifdef DEBUG_DATA_XFER
		lprintf( "Recieving on %ld", msgid );
#endif
		length = msgrcv( g.msgq_out
							, MSGTYPE recv
							, 8192
							, msgid
							, 0 );
		g.flags.bWaitingInReceive = 0;
#ifdef DEBUG_DATA_XFER
		lprintf( "^^^ %d", length );
#endif
		length -= ( sizeof( QMSG ) - sizeof( MSGIDTYPE ) );
		if( length < 0 )
		{
#ifdef _WIN32
				int my_errno = GetLastError();
#  ifdef errno
#    undef errno
#  endif
#  define errno my_errno
#endif
 // got a signal - ignore and try again.
			if( errno == EINTR )
				continue;
			if( errno == EIDRM )
			{
				Log( WIDE("Server ended.") );
				break;
			}
			if( errno == EINVAL )
			{
				Log( WIDE("Queues Closed?") );
				g.flags.disconnected = 1;
				break;
			}
#if defined( _WIN32 ) || defined( USE_SACK_MSGQ )
			if( errno == EABORT )
			{
				Log( WIDE( "Server Read Abort." ) );
				break;
			}
#endif
			Log1( WIDE("msgrecv error: %d"), errno );
			continue;
		}
#ifdef DEBUG_DATA_XFER
		else
		{
			lprintf( WIDE("Received Message.... g.msgq_out %d"), length );
			LogBinary( (uint8_t*)recv, length + sizeof( QMSG ) );
		}
#endif
		// setup the result message to be a reply to the incoming message.
		result->dest.process_id            = recv->hdr.source.process_id;
		result->dest.service_id            = recv->hdr.source.service_id;
		result->hdr.source.process_id = recv->dest.process_id;
		result->hdr.source.service_id = recv->dest.service_id;
		result->hdr.msgid             = recv->hdr.msgid | SERVER_UNHANDLED;
		if( recv->hdr.msgid & 0xF0000000 )
		{
			// message is a responce from someone else...
		}
		else
		{
			if( recv->dest.service_id == 0 )
			{
				if( HandleCoreMessage( recv, length DBG_SRC ) )
					continue;
			}
			{
				int handled = FALSE;
				PCLIENT_SERVICE service;
				for( service = g.services; service; service = service->next )
				{
					// process_id is already matched at this point, or we wouln't have the message
					// just have to give it to the local service.
#ifdef DEBUG_DATA_XFER
					lprintf( "is %d == %d", service->ServiceID, recv->dest.service_id );
#endif
					if( service->ServiceID == recv->dest.service_id )
					{
						//lprintf( WIDE("Found the service...%s"), service->name );
						break;
					}
				}
				if( service )
				{
					uint32_t msgid = recv->hdr.msgid;
#ifdef DEBUG_MESSAGE_BASE_ID
					lprintf( WIDE("service base %ld(+%ld) and this is from %s")
							 , msgid
                       , service->entries
							 , ( g.my_message_id == recv->hdr.source.process_id )?"myself":"someone else" );
#endif
					if( msgid < service->entries )
					{
						int result_okay = 0;
						g.flags.handling_client_message = 1;
						if( service->handler_ex )
						{
#if defined( LOG_HANDLED_MESSAGES )
							lprintf( WIDE("Got a service message to handler: %08lx length %ld")
									 , recv->hdr.source.process_id
									 , length + sizeof(QMSG) );
#endif
							result_length = MSG_DEFAULT_RESULT_BUFFER_MAX;
							handled = TRUE;
							result_okay = service->handler_ex( service->psv
																		, (PSERVICE_ROUTE)result
																		, msgid
																		, QMSGDATA(recv), length
																		, QMSGDATA(result), &result_length ) ;
                     lprintf( "Output result is %d", result_length );
						}
						if( !handled && service->handler )
						{
#if defined( LOG_HANDLED_MESSAGES )
							lprintf( WIDE("Got a service message to handler: %08lx length %ld")
									 , recv->hdr.source.process_id
									 , length + sizeof(QMSG) );
#endif
							result_length = MSG_DEFAULT_RESULT_BUFFER_MAX;
							handled = TRUE;
							result_okay = service->handler( (PSERVICE_ROUTE)result
																	, msgid
																	, QMSGDATA(recv), length
																			, QMSGDATA(result), &result_length ) ;
#if defined( LOG_HANDLED_MESSAGES )
							lprintf( "result length to send:%d", result_length );
#endif
						}
						if( !handled )
						{
							if( service->functions
								&& service->functions[msgid].function )
							{
								//result_length = 4096; // maximum responce buffer...
#if defined( LOG_HANDLED_MESSAGES )
								lprintf( WIDE("Got a service : (%d)%s from %08lx length %ld")
										 , msgid
#ifdef _DEBUG
										 , service->functions[msgid].name
#else
										 , WIDE("noname")
#endif
										 , recv->hdr.source.process_id
										 , length + sizeof(QMSG) );
#endif
 // safer default. although uninformative.
								result_length = 0;
								handled = TRUE;
								result_okay = service->functions[msgid].function( (PSERVICE_ROUTE)result
																								, QMSGDATA( recv )
																								, length
																								, QMSGDATA(result)
																								, &result_length );
								lprintf( "result length to send:%d", result_length );
								switch( msgid )
								{
								case MSG_ServiceLoad:
									if( result_okay && ( result_length == 0 ) )
									{
#if defined( LOG_HANDLED_MESSAGES )
										lprintf( "Using default handler for service load" );
#endif
										((MsgSrv_ReplyServiceLoad*)QMSGDATA(result))->ServiceID = result->hdr.source.service_id;
										((MsgSrv_ReplyServiceLoad*)QMSGDATA(result))->thread = 0;
										result_length = sizeof( MsgSrv_ReplyServiceLoad );
									}
									break;
								}
							}
							else if( service->functions )
							{
								switch( msgid )
								{
								case MSG_ServiceUnload:
//#if defined( LOG_HANDLED_MESSAGES )
									lprintf( "Using default handler for service unload" );
//#endif
									result_okay = 1;
									break;
								case MSG_ServiceLoad:
#if defined( LOG_HANDLED_MESSAGES )
									lprintf( "Using default handler for service load" );
#endif
									((MsgSrv_ReplyServiceLoad*)QMSGDATA(result))->ServiceID = result->dest.service_id;
									((MsgSrv_ReplyServiceLoad*)QMSGDATA(result))->thread = 0;
									result_length = sizeof( MsgSrv_ReplyServiceLoad );
									result_okay = 1;
									break;
								default:
#if defined( LOG_HANDLED_MESSAGES )
									DebugBreak();
									lprintf( WIDE("didn't have a function for 0x%lx (%ld) or %s")
											 , msgid
											 , msgid
#ifdef _DEBUG
											 , service->functions[msgid].name
#else
											 , WIDE("noname")
#endif
										 );
#endif
									result_okay = 0;
									result_length = INVALID_INDEX;
									break;
								}
							}
							else
							{
								DebugBreak();
								result_okay = 0;
								result_length = 0;
							}
						}
						if( result_okay )
							result->hdr.msgid = recv->hdr.msgid | SERVER_SUCCESS;
						else
							result->hdr.msgid = recv->hdr.msgid | SERVER_FAILURE;
						// a key result value to indicate there is
						// no responce to be sent to the client.
						if( result_length != INVALID_INDEX )
						{
#ifdef DEBUG_DATA_XFER
							DBG_VARSRC;
							lprintf( "length:%d %d", result_length, sizeof( QMSG ) );
#endif
							msgsnd( g.msgq_in, MSGTYPE result, result_length + (sizeof(QMSG) - sizeof( MSGIDTYPE )), 0 );
						}
						else
						{
							//Log( WIDE("No responce sent") );
						}
					}
				}
				else
				{
					lprintf( WIDE("Failed to find target service for message.") );
				}
			}
#if defined(_DEBUG) && defined( LOG_HANDLED_MESSAGES )
			Log( WIDE("Message complete...") );
#endif
			g.flags.handling_client_message = 0;
		}
	}
	Release( recv );
	Release( result );
	return 0;
}
//--------------------------------------------------------------------
void DoRegisterService( PCLIENT_SERVICE pService )
{
	MSGIDTYPE MsgID;
	// if I'm the master service, I don't very well have to
	// register with myself do I?
	if( !pService->flags.bFailed )
	{
		//lprintf( WIDE("Transacting a message....") );
		size_t result_len = sizeof( pService->ServiceID );
		//lprintf( WIDE("Transacting a message....") );
		if( !TransactServerMultiMessage( &g.master_service_route, CLIENT_REGISTER_SERVICE, 1
												 , &MsgID, &pService->ServiceID, &result_len
 // include NUL
												 , pService->name, (StrLen( pService->name ) + 1) * sizeof(TEXTCHAR)
												 ) )
		{
			pService->flags.bFailed = 1;
			lprintf( WIDE("registration failed.") );
		}
		else
		{
			//lprintf( WIDE("MsgID is %lx and should be %lx? "),MsgID , ( CLIENT_REGISTER_SERVICE | SERVER_SUCCESS ) );
			if( MsgID != ( CLIENT_REGISTER_SERVICE | SERVER_SUCCESS ) )
			{
				pService->flags.bFailed = 1;
				lprintf( WIDE("registration failed.") );
			}
		}
		pService->flags.bRegistered = 1;
	}
}
//--------------------------------------------------------------------
int ReceiveServerMessageEx( PTRANSACTIONHANDLER handler, PQMSG MessageIn, size_t MessageLen DBG_PASS )
{
	/*
	 first check... LoadService() response.
    LoadService() will have been called in another thread,
    */
	if( (MessageIn->hdr.msgid&0xFFFFFFF) == (MSG_ServiceLoad) )
	{
		//lprintf( WIDE("Loading service responce... setup the service ID for future com") );
		handler->route->dest.process_id = MessageIn->hdr.source.process_id;
		handler->route->dest.service_id = MessageIn->hdr.source.service_id;
		handler->route->source.process_id = MessageIn->dest.process_id;
		handler->route->source.service_id = MessageIn->dest.service_id;
		if( handler->MessageID )
			(*handler->MessageID) = MessageIn->hdr.msgid;
	}
	if( MessageIn->hdr.source.process_id == 1
		&& MessageIn->hdr.source.service_id == 0
	  )
	{
		//if( handler != &g._handler )
		{
			// result received from some other handler (probably something like
			//lprintf( WIDE("message from core service ... wrong handler?") );
			if( MessageIn->hdr.msgid & SERVER_FAILURE )
			{
				// eat this message...
				//return 0;
			}
			//else
			//	return 1;
			//DebugBreak();
		}
		if( handler->MessageID )
			(*handler->MessageID) = MessageIn->hdr.msgid;
  //	  handler = &g._handler;
	}
	if( ( handler->route->dest.process_id != MessageIn->hdr.source.process_id )
		|| ( handler->route->dest.service_id != MessageIn->hdr.source.service_id ) )
	{
		//lprintf( WIDE("%ld and %ld "), handler->ServiceID, MessageIn->hdr.source.process_id );
		// this handler is not for this message responce...
		//DebugBreak();
		//lprintf( WIDE("this handler is not THE handler!") );
		return 1;
	}
	else
	{
		//lprintf( WIDE("All is well, check message ID %p"), handler );
		if( handler->MessageID )
			(*handler->MessageID) = MessageIn->hdr.msgid;
		if( handler->LastMsgID != ( (MessageIn->hdr.msgid)& 0xFFFFFFF ) )
		{
			LogBinary( (uint8_t*)MessageIn, MessageLen );
			lprintf( WIDE("len was %") _size_f, MessageLen );
			lprintf( WIDE("Message is for this guy - but isn't the right ID! %") _MsgID_f WIDE(" %") _32f WIDE(" %") _32f WIDE("")
					 , handler->LastMsgID, (MessageIn->hdr.msgid) & 0xFFFFFFF, 0 );
			//DebugBreak();
			return 1;
		}
	}
	if( handler->msg && handler->len )
	{
  // subtract message ID and message source from it.
		MessageLen -= sizeof(QMSG) - sizeof( MSGIDTYPE );
		if( MessageLen > 0 )
		{
			if( (int32_t)(*handler->len) < MessageLen )
			{
				_lprintf( DBG_RELAY )( WIDE("Cutting out possible data to the application - should provide a failure! %") _size_f WIDE(" expected %") _size_f WIDE(" returned"), (*handler->len), MessageLen );
				MessageLen = (*handler->len);
			}
			MemCpy( handler->msg, QMSGDATA( MessageIn ), MessageLen );
		}
		(*handler->len) = MessageLen;
	}
	else
	{
		// maybe it was just interested in the header...
		// which will be the source ID and the message ID
		if( MessageLen - ( sizeof( QMSG ) - sizeof( MSGIDTYPE ) ) )
		{
			LogBinary( (uint8_t*)MessageIn, MessageLen + sizeof( QMSG ) );
			SystemLogEx( WIDE("Server returned result data which the client did not get") DBG_RELAY );
		}
	}
	// we now have to wait for another response.
	// this one has been consumed.
	handler->flags.responce_received = 0;
	return 0;
}
//--------------------------------------------------------------------
#undef RegisterServiceEx
CLIENTMSG_PROC( LOGICAL, RegisterServiceEx )( CTEXTSTR name
														  , server_function_table functions
														  , int entries
														  , server_message_handler handler
														)
{
   return RegisterServiceExx( name, functions, entries, handler, NULL, 0 );
}
// don't really get a route from this...
// service_routes will become available as clients connect.
CLIENTMSG_PROC( LOGICAL, RegisterServiceExx )( CTEXTSTR name
															, server_function_table functions
															, int entries
															, server_message_handler handler
															, server_message_handler_ex handler_ex
															, uintptr_t psv
															)
{
	int status;
	if( !name )
	{
		g.flags.bMasterServer = 1;
	}
	if( ( status = _InitMessageService( FALSE ) ) < 1 )
	{
		if( status == -1 )
			lprintf( WIDE("Initization of %s message service failed (service already exists? communication)."), name );
		//if( status == 0 )
		//	; //lprintf( WIDE("Initization of %s message service failed to initialize?)."), name );
		return FALSE;
	}
	else
	{
		//static int nBaseMsg;
		PCLIENT_SERVICE pService = New( CLIENT_SERVICE );
		pService->service_routes = NULL;
		pService->flags.bRegistered = 0;
		pService->flags.bFailed = 0;
		pService->flags.connected = 0;
		pService->flags.bClosed = 0;
		pService->flags.bWaitingInReceive = 0;
		// setup service message base.
		if( !name )
		{
			pService->flags.bMasterServer = 1;
			pService->name = StrDup( WIDE("Master Server") );
		}
		else
		{
			pService->flags.bMasterServer = 0;
			pService->name = StrDup( name );
		}
		pService->handler_ex = handler_ex;
		pService->handler = handler;
		pService->functions = functions;
		pService->entries = entries?entries:256;
		pService->references = 0;
		if( !g.flags.bAliveThreadStarted )
		{
			// this timer monitors ALL clients for inactivity
			// it will probe them with RU_ALIVE messages
			// to which they must respond otherwise be termintated.
			g.flags.bAliveThreadStarted = 1;
			AddTimer( CLIENT_TIMEOUT/4, MonitorClientActive, 0 );
			// each service gets 1 thread to handle their own
			// messages... services do not have 'events' generated
			// to them.
		}
		if( !pService->flags.bMasterServer && !g.flags.bServiceHandlerStarted )
		{
			// pass FALSE (not master service, begin receiving on my_message_id)
			ThreadTo( HandleServiceMessages, (uintptr_t)0 );
			g.flags.bServiceHandlerStarted = 1;
		}
		if( pService->flags.bMasterServer && !g.flags.bCoreServiceHandlerStarted )
		{
			// pass FALSE (IS master service, begin receiving on 1)
			ThreadTo( HandleServiceMessages, (uintptr_t)1 );
			g.flags.bCoreServiceHandlerStarted = 1;
		}
		if( pService->flags.bMasterServer && !g.flags.bCoreServiceHandlerStarted )
		{
			// pass 1 as message filter ID, begin receiving message 1 on input queue.
			ThreadTo( HandleMessages, 1 );
			g.flags.bCoreServiceInputHandlerStarted = 1;
		}
		if( !pService->flags.bMasterServer )
		{
			RegisterWithMasterService();
			DoRegisterService( pService );
		}
		else
		{
			// should attempt some sort of ping before assuming it's good.
			pService->ServiceID = 0;
			pService->GetFunctionTable = NULL;
			pService->flags.bRegistered = 1;
		}
		while( !pService->flags.bRegistered )
			Relinquish();
		if( pService->flags.bFailed )
		{
			pService->flags.bClosed = 1;
			while( pService->flags.bWaitingInReceive )
			{
				pService->recv->dest.process_id = INVALID_MESSAGE;
				if( pService->thread )
					WakeThread( pService->thread );
				else
					break;
				//Relinquish();
			}
			while( pService->thread )
			{
				Relinquish();
				WakeThread( pService->thread );
			}
			Release( pService->name );
			Release( pService );
			return FALSE;
		}
		if( pService )
		{
			LinkThing( g.services, pService );
			return TRUE;
		}
	}
	return FALSE;
}
	//--------------------------------------------------------------------
#undef RegisterService
CLIENTMSG_PROC( LOGICAL, RegisterService )( TEXTCHAR *name
														  , server_function_table functions
														  , int entries
														)
{
	return RegisterServiceEx( name, functions, entries, NULL );
}
MSGCLIENT_NAMESPACE_END
//-------------------------------------------------------------
#define SUMMONER_NAME WIDE("Master Summoner")
enum {
	MSG_RU_ALIVE = MSG_EventUser
      , MSG_WHOAMI
		, MSG_IM_STARTING
		, MSG_IM_ALIVE
		, MSG_IM_READY
		, MSG_DIE
     //, MSG_BREAK
};
#ifdef __cplusplus
namespace sack { namespace task { namespace construct {
using namespace sack::msg::client;
#endif
#define l summonser_construct_local
typedef struct local_tag
{
	int init_ran;
	PSERVICE_ROUTE MsgBase;
	TEXTCHAR my_name[256];
	// handle a registry of external functions to call
	// for alive checks... otherwise be simple and claim
   // alive (at least the message services are alive)
} LOCAL;
static LOCAL l;
static int CPROC HandleSummonerEvents( PSERVICE_ROUTE SourceID, MSGIDTYPE MsgID, uint32_t *data, size_t len )
{
	switch( MsgID )
	{
	case MSG_RU_ALIVE:
		// echo the data back to the server..
		// this helps mate requests and responces...
		SendRoutedServerMessage( SourceID, MSG_IM_ALIVE, data, len );
		break;
	case MSG_DIE:
		lprintf( WIDE("Command to die, therefore I shall...") );
		exit(0);
		break;
	default:
		lprintf( WIDE("Received unknown message %") _MsgID_f WIDE(" from %p"), MsgID, SourceID );
		break;
	}
   return TRUE;
}
//#if 0
PRELOAD( Started )
{
#ifndef __NO_OPTIONS__
	if( SACK_GetProfileIntEx( WIDE( "SACK/Summoner" ), WIDE( "Auto register with summoner?" ), 0, TRUE ) )
#else
   if( 0 )
#endif
	{
		l.init_ran = 1;
		l.MsgBase = LoadServiceEx( SUMMONER_NAME, HandleSummonerEvents );
		lprintf( WIDE("Message base for service is %d"), l.MsgBase );
		if( l.MsgBase )
		{
			MSGIDTYPE result;
			size_t result_length;
			result_length = sizeof( l.my_name );
			if( !TransactServerMessage( l.MsgBase, MSG_WHOAMI, NULL, 0
											  , &result, l.my_name, &result_length ) )
			{
				// since we JUST loaded it, this shold be nearly impossible to hit.
				lprintf( WIDE("Failed to find out who I am from summoner.") );
				UnloadService( SUMMONER_NAME );
				l.MsgBase = NULL;
				return;
			}
			else if( result != ((MSG_WHOAMI)|SERVER_SUCCESS ) )
			{
				lprintf( WIDE("Server responce was in error... disable support") );
				UnloadService( SUMMONER_NAME );
				l.MsgBase = NULL;
				return;
			}
			else if( !result_length )
			{
				lprintf( WIDE("Summoner is not responsible for us, and requires no notifications." ) );
				//UnloadService( SUMMONER_NAME );
				l.MsgBase = NULL;
				return;
			}
							 //else l.my_name is my task name from sommoner.config
         lprintf( "SAY I AM STARTING with %s", l.my_name );
			if( !TransactServerMessage( l.MsgBase, MSG_IM_STARTING, l.my_name, (uint32_t)strlen( l.my_name ) + 1
											  , NULL, NULL, 0 ) )
			{
				// this should almost be guaranteed to work...
				lprintf( WIDE("Failed to send starting to summoner... disable support") );
				UnloadService( SUMMONER_NAME );
				l.MsgBase = NULL;
				return;
			}
			//lprintf( WIDE("We're starting, go ahead.") );
		}
	}
	else
		l.MsgBase = NULL;
}
//#endif
 void  LoadComplete ( void )
{
	uint32_t result;
   // if we registered with the summoner...
	if( l.MsgBase )
	{
		lprintf( WIDE("Sending IM_READY to summoner...\n") );
		result = ((MSG_IM_READY) | SERVER_SUCCESS);
		if( TransactServerMessage( l.MsgBase, MSG_IM_READY, l.my_name, (uint32_t)strlen( l.my_name ) + 1
 /*&result*/
										 , NULL, NULL, 0 )
		  )
		{
			lprintf( "should be wait on true false: %d", result );
			if( result == ((MSG_IM_READY) | SERVER_SUCCESS) )
			{
			}
			else
			{
				lprintf( WIDE("Summoner has somehow complained that we're started?!") );
				DebugBreak();
			}
		}
		else
		{
			lprintf( WIDE("Summoner has dissappeared.  Disabling support.") );
			l.MsgBase = NULL;
		}
	}
	//else
   //   lprintf( WIDE("Service has been disabled.") );
}
ATEXIT( Ended )
{
	if( l.init_ran && l.MsgBase )
	{
		lprintf( WIDE("mark ready in summoner (dispatch as ended?)") );
		LoadComplete();
		UnloadService( SUMMONER_NAME );
	}
}
#undef l
#ifdef __cplusplus
 //namespace sack namespace
}}}
#endif
